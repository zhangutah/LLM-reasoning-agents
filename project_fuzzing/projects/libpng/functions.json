{
  "project": "libpng",
  "statistics": {
    "total_functions": 401,
    "covered_functions": 174,
    "uncovered_functions": 227,
    "coverage_rate": 43.39,
    "average_coverage": 27.23
  },
  "functions": [
    {
      "name": "png_info_init_3",
      "clean_name": "png_info_init_3",
      "source_file": "/src/libpng/png.c",
      "source_code": " * NOTE: it is almost inconceivable that this API is used because it bypasses\n * the user-memory mechanism and the user error handling/warning mechanisms in\n * those cases where it does anything other than a memset.\n */\nPNG_FUNCTION(void,PNGAPI\npng_info_init_3,(png_infopp ptr_ptr, size_t png_info_struct_size),\n    PNG_DEPRECATED)\n{\n   png_inforp info_ptr = *ptr_ptr;\n\n   png_debug(1, \"in png_info_init_3\");\n\n   if (info_ptr == NULL)\n      return;\n\n   if ((sizeof (png_info)) > png_info_struct_size)\n   {\n      *ptr_ptr = NULL;\n      /* The following line is why this API should not be used: */\n      free(info_ptr);\n      info_ptr = png_voidcast(png_inforp, png_malloc_base(NULL,\n          (sizeof *info_ptr)));\n      if (info_ptr == NULL)\n         return;\n      *ptr_ptr = info_ptr;\n   }\n\n   /* Set everything to 0 */\n   memset(info_ptr, 0, (sizeof *info_ptr));\n}\n",
      "line_start": 433,
      "line_end": 458,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_data_freer",
      "clean_name": "png_data_freer",
      "source_file": "/src/libpng/png.c",
      "source_code": "   /* Set everything to 0 */\n   memset(info_ptr, 0, (sizeof *info_ptr));\n}\n\nvoid PNGAPI\npng_data_freer(png_const_structrp png_ptr, png_inforp info_ptr,\n    int freer, png_uint_32 mask)\n{\n   png_debug(1, \"in png_data_freer\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (freer == PNG_DESTROY_WILL_FREE_DATA)\n      info_ptr->free_me |= mask;\n\n   else if (freer == PNG_USER_WILL_FREE_DATA)\n      info_ptr->free_me &= ~mask;\n\n   else\n      png_error(png_ptr, \"Unknown freer parameter in png_data_freer\");\n}\n",
      "line_start": 460,
      "line_end": 477,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_convert_to_rfc1123_buffer",
      "clean_name": "png_convert_to_rfc1123_buffer",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  ifdef PNG_TIME_RFC1123_SUPPORTED\n/* Convert the supplied time into an RFC 1123 string suitable for use in\n * a \"Creation Time\" or other text-based time string.\n */\nint PNGAPI\npng_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)\n{\n   static const char short_months[12][4] =\n        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\n   if (out == NULL)\n      return 0;\n\n   if (ptime->year > 9999 /* RFC1123 limitation */ ||\n       ptime->month == 0    ||  ptime->month > 12  ||\n       ptime->day   == 0    ||  ptime->day   > 31  ||\n       ptime->hour  > 23    ||  ptime->minute > 59 ||\n       ptime->second > 60)\n      return 0;\n\n   {\n      size_t pos = 0;\n      char number_buf[5] = {0, 0, 0, 0, 0}; /* enough for a four-digit year */\n\n#     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))\n#     define APPEND_NUMBER(format, value)\\\n         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))\n#     define APPEND(ch) if (pos < 28) out[pos++] = (ch)\n\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);\n      APPEND(' ');\n      APPEND_STRING(short_months[(ptime->month - 1)]);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);\n      APPEND_STRING(\" +0000\"); /* This reliably terminates the buffer */\n      PNG_UNUSED (pos)\n\n#     undef APPEND\n#     undef APPEND_NUMBER\n#     undef APPEND_STRING\n   }\n\n   return 1;\n}\n",
      "line_start": 738,
      "line_end": 784,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 100,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_convert_to_rfc1123",
      "clean_name": "png_convert_to_rfc1123",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* Original API that uses a private buffer in png_struct.\n * Deprecated because it causes png_struct to carry a spurious temporary\n * buffer (png_struct::time_buffer), better to have the caller pass this in.\n */\npng_const_charp PNGAPI\npng_convert_to_rfc1123(png_structrp png_ptr, png_const_timep ptime)\n{\n   if (png_ptr != NULL)\n   {\n      /* The only failure above if png_ptr != NULL is from an invalid ptime */\n      if (png_convert_to_rfc1123_buffer(png_ptr->time_buffer, ptime) == 0)\n         png_warning(png_ptr, \"Ignoring invalid time value\");\n\n      else\n         return png_ptr->time_buffer;\n   }\n\n   return NULL;\n}\n",
      "line_start": 792,
      "line_end": 806,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_copyright",
      "clean_name": "png_get_copyright",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  endif /* TIME_RFC1123 */\n\n#endif /* READ || WRITE */\n\npng_const_charp PNGAPI\npng_get_copyright(png_const_structrp png_ptr)\n{\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n#ifdef PNG_STRING_COPYRIGHT\n   return PNG_STRING_COPYRIGHT\n#else\n   return PNG_STRING_NEWLINE \\\n      \"libpng version 1.6.52.git\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 2018-2025 Cosmin Truta\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\" \\\n      PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1996-1997 Andreas Dilger\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\" \\\n      PNG_STRING_NEWLINE;\n#endif\n}\n",
      "line_start": 812,
      "line_end": 828,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_libpng_ver",
      "clean_name": "png_get_libpng_ver",
      "source_file": "/src/libpng/png.c",
      "source_code": " * Note: now there is no difference between png_get_libpng_ver() and\n * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,\n * it is guaranteed that png.c uses the correct version of png.h.\n */\npng_const_charp PNGAPI\npng_get_libpng_ver(png_const_structrp png_ptr)\n{\n   /* Version of *.c files used when building libpng */\n   return png_get_header_ver(png_ptr);\n}\n",
      "line_start": 838,
      "line_end": 843,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_header_ver",
      "clean_name": "png_get_header_ver",
      "source_file": "/src/libpng/png.c",
      "source_code": "   /* Version of *.c files used when building libpng */\n   return png_get_header_ver(png_ptr);\n}\n\npng_const_charp PNGAPI\npng_get_header_ver(png_const_structrp png_ptr)\n{\n   /* Version of *.h files used when building libpng */\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n   return PNG_LIBPNG_VER_STRING;\n}\n",
      "line_start": 845,
      "line_end": 851,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_header_version",
      "clean_name": "png_get_header_version",
      "source_file": "/src/libpng/png.c",
      "source_code": "   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n   return PNG_LIBPNG_VER_STRING;\n}\n\npng_const_charp PNGAPI\npng_get_header_version(png_const_structrp png_ptr)\n{\n   /* Returns longer string containing both version and date */\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n#ifdef __STDC__\n   return PNG_HEADER_VERSION_STRING\n#  ifndef PNG_READ_SUPPORTED\n      \" (NO READ SUPPORT)\"\n#  endif\n      PNG_STRING_NEWLINE;\n#else\n   return PNG_HEADER_VERSION_STRING;\n#endif\n}\n",
      "line_start": 853,
      "line_end": 867,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_build_grayscale_palette",
      "clean_name": "png_build_grayscale_palette",
      "source_file": "/src/libpng/png.c",
      "source_code": " * large of png_color.  This lets grayscale images be treated as\n * paletted.  Most useful for gamma correction and simplification\n * of code.  This API is not used internally.\n */\nvoid PNGAPI\npng_build_grayscale_palette(int bit_depth, png_colorp palette)\n{\n   int num_palette;\n   int color_inc;\n   int i;\n   int v;\n\n   png_debug(1, \"in png_do_build_grayscale_palette\");\n\n   if (palette == NULL)\n      return;\n\n   switch (bit_depth)\n   {\n      case 1:\n         num_palette = 2;\n         color_inc = 0xff;\n         break;\n\n      case 2:\n         num_palette = 4;\n         color_inc = 0x55;\n         break;\n\n      case 4:\n         num_palette = 16;\n         color_inc = 0x11;\n         break;\n\n      case 8:\n         num_palette = 256;\n         color_inc = 1;\n         break;\n\n      default:\n         num_palette = 0;\n         color_inc = 0;\n         break;\n   }\n\n   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)\n   {\n      palette[i].red = (png_byte)(v & 0xff);\n      palette[i].green = (png_byte)(v & 0xff);\n      palette[i].blue = (png_byte)(v & 0xff);\n   }\n}\n",
      "line_start": 876,
      "line_end": 923,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_reset_zstream",
      "clean_name": "png_reset_zstream",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* SET_UNKNOWN_CHUNKS */\n\n#ifdef PNG_READ_SUPPORTED\n/* This function, added to libpng-1.0.6g, is untested. */\nint PNGAPI\npng_reset_zstream(png_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return Z_STREAM_ERROR;\n\n   /* WARNING: this resets the window bits to the maximum! */\n   return inflateReset(&png_ptr->zstream);\n}\n",
      "line_start": 975,
      "line_end": 983,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_access_version_number",
      "clean_name": "png_access_version_number",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n#endif /* READ */\n\n/* This function was added to libpng-1.0.7 */\npng_uint_32 PNGAPI\npng_access_version_number(void)\n{\n   /* Version of *.c files used when building libpng */\n   return (png_uint_32)PNG_LIBPNG_VER;\n}\n",
      "line_start": 987,
      "line_end": 992,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_xy_from_XYZ",
      "clean_name": "png_xy_from_XYZ",
      "source_file": "/src/libpng/png.c",
      "source_code": " * cHRM, as opposed to using chromaticities.  These internal APIs return\n * non-zero on a parameter error.  The X, Y and Z values are required to be\n * positive and less than 1.0.\n */\nint /* PRIVATE */\npng_xy_from_XYZ(png_xy *xy, const png_XYZ *XYZ)\n{\n   /* NOTE: returns 0 on success, 1 means error. */\n   png_int_32 d, dred, dgreen, dblue, dwhite, whiteX, whiteY;\n\n   /* 'd' in each of the blocks below is just X+Y+Z for each component,\n    * x, y and z are X,Y,Z/(X+Y+Z).\n    */\n   d = XYZ->red_X;\n   if (png_safe_add(&d, XYZ->red_Y, XYZ->red_Z))\n      return 1;\n   dred = d;\n   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, dred) == 0)\n      return 1;\n   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, dred) == 0)\n      return 1;\n\n   d = XYZ->green_X;\n   if (png_safe_add(&d, XYZ->green_Y, XYZ->green_Z))\n      return 1;\n   dgreen = d;\n   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, dgreen) == 0)\n      return 1;\n   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, dgreen) == 0)\n      return 1;\n\n   d = XYZ->blue_X;\n   if (png_safe_add(&d, XYZ->blue_Y, XYZ->blue_Z))\n      return 1;\n   dblue = d;\n   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, dblue) == 0)\n      return 1;\n   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, dblue) == 0)\n      return 1;\n\n   /* The reference white is simply the sum of the end-point (X,Y,Z) vectors so\n    * the fillowing calculates (X+Y+Z) of the reference white (media white,\n    * encoding white) itself:\n    */\n   d = dblue;\n   if (png_safe_add(&d, dred, dgreen))\n      return 1;\n   dwhite = d;\n\n   /* Find the white X,Y values from the sum of the red, green and blue X,Y\n    * values.\n    */\n   d = XYZ->red_X;\n   if (png_safe_add(&d, XYZ->green_X, XYZ->blue_X))\n      return 1;\n   whiteX = d;\n\n   d = XYZ->red_Y;\n   if (png_safe_add(&d, XYZ->green_Y, XYZ->blue_Y))\n      return 1;\n   whiteY = d;\n\n   if (png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite) == 0)\n      return 1;\n   if (png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite) == 0)\n      return 1;\n\n   return 0;\n}\n",
      "line_start": 1133,
      "line_end": 1197,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 112,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_XYZ_from_xy",
      "clean_name": "png_XYZ_from_xy",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 0;\n}\n\nint /* PRIVATE */\npng_XYZ_from_xy(png_XYZ *XYZ, const png_xy *xy)\n{\n   /* NOTE: returns 0 on success, 1 means error. */\n   png_fixed_point red_inverse, green_inverse, blue_scale;\n   png_fixed_point left, right, denominator;\n\n   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically\n    * have end points with 0 tristimulus values (these are impossible end\n    * points, but they are used to cover the possible colors).  We check\n    * xy->whitey against 5, not 0, to avoid a possible integer overflow.\n    *\n    * The limits here will *not* accept ACES AP0, where bluey is -7700\n    * (-0.0770) because the PNG spec itself requires the xy values to be\n    * unsigned.  whitey is also required to be 5 or more to avoid overflow.\n    *\n    * Instead the upper limits have been relaxed to accomodate ACES AP1 where\n    * redz ends up as -600 (-0.006).  ProPhotoRGB was already \"in range.\"\n    * The new limit accomodates the AP0 and AP1 ranges for z but not AP0 redy.\n    */\n   const png_fixed_point fpLimit = PNG_FP_1+(PNG_FP_1/10);\n   if (xy->redx   < 0 || xy->redx > fpLimit) return 1;\n   if (xy->redy   < 0 || xy->redy > fpLimit-xy->redx) return 1;\n   if (xy->greenx < 0 || xy->greenx > fpLimit) return 1;\n   if (xy->greeny < 0 || xy->greeny > fpLimit-xy->greenx) return 1;\n   if (xy->bluex  < 0 || xy->bluex > fpLimit) return 1;\n   if (xy->bluey  < 0 || xy->bluey > fpLimit-xy->bluex) return 1;\n   if (xy->whitex < 0 || xy->whitex > fpLimit) return 1;\n   if (xy->whitey < 5 || xy->whitey > fpLimit-xy->whitex) return 1;\n\n   /* The reverse calculation is more difficult because the original tristimulus\n    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8\n    * derived values were recorded in the cHRM chunk;\n    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and\n    * therefore an arbitrary ninth value has to be introduced to undo the\n    * original transformations.\n    *\n    * Think of the original end-points as points in (X,Y,Z) space.  The\n    * chromaticity values (c) have the property:\n    *\n    *           C\n    *   c = ---------\n    *       X + Y + Z\n    *\n    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the\n    * three chromaticity values (x,y,z) for each end-point obey the\n    * relationship:\n    *\n    *   x + y + z = 1\n    *\n    * This describes the plane in (X,Y,Z) space that intersects each axis at the\n    * value 1.0; call this the chromaticity plane.  Thus the chromaticity\n    * calculation has scaled each end-point so that it is on the x+y+z=1 plane\n    * and chromaticity is the intersection of the vector from the origin to the\n    * (X,Y,Z) value with the chromaticity plane.\n    *\n    * To fully invert the chromaticity calculation we would need the three\n    * end-point scale factors, (red-scale, green-scale, blue-scale), but these\n    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and\n    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have\n    * given all three of the scale factors since:\n    *\n    *    color-C = color-c * color-scale\n    *    white-C = red-C + green-C + blue-C\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\n    *\n    * But cHRM records only white-x and white-y, so we have lost the white scale\n    * factor:\n    *\n    *    white-C = white-c*white-scale\n    *\n    * To handle this the inverse transformation makes an arbitrary assumption\n    * about white-scale:\n    *\n    *    Assume: white-Y = 1.0\n    *    Hence:  white-scale = 1/white-y\n    *    Or:     red-Y + green-Y + blue-Y = 1.0\n    *\n    * Notice the last statement of the assumption gives an equation in three of\n    * the nine values we want to calculate.  8 more equations come from the\n    * above routine as summarised at the top above (the chromaticity\n    * calculation):\n    *\n    *    Given: color-x = color-X / (color-X + color-Y + color-Z)\n    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0\n    *\n    * This is 9 simultaneous equations in the 9 variables \"color-C\" and can be\n    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix\n    * determinants, however this is not as bad as it seems because only 28 of\n    * the total of 90 terms in the various matrices are non-zero.  Nevertheless\n    * Cramer's rule is notoriously numerically unstable because the determinant\n    * calculation involves the difference of large, but similar, numbers.  It is\n    * difficult to be sure that the calculation is stable for real world values\n    * and it is certain that it becomes unstable where the end points are close\n    * together.\n    *\n    * So this code uses the perhaps slightly less optimal but more\n    * understandable and totally obvious approach of calculating color-scale.\n    *\n    * This algorithm depends on the precision in white-scale and that is\n    * (1/white-y), so we can immediately see that as white-y approaches 0 the\n    * accuracy inherent in the cHRM chunk drops off substantially.\n    *\n    * libpng arithmetic: a simple inversion of the above equations\n    * ------------------------------------------------------------\n    *\n    *    white_scale = 1/white-y\n    *    white-X = white-x * white-scale\n    *    white-Y = 1.0\n    *    white-Z = (1 - white-x - white-y) * white_scale\n    *\n    *    white-C = red-C + green-C + blue-C\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\n    *\n    * This gives us three equations in (red-scale,green-scale,blue-scale) where\n    * all the coefficients are now known:\n    *\n    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale\n    *       = white-x/white-y\n    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1\n    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale\n    *       = (1 - white-x - white-y)/white-y\n    *\n    * In the last equation color-z is (1 - color-x - color-y) so we can add all\n    * three equations together to get an alternative third:\n    *\n    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale\n    *\n    * So now we have a Cramer's rule solution where the determinants are just\n    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve\n    * multiplication of three coefficients so we can't guarantee to avoid\n    * overflow in the libpng fixed point representation.  Using Cramer's rule in\n    * floating point is probably a good choice here, but it's not an option for\n    * fixed point.  Instead proceed to simplify the first two equations by\n    * eliminating what is likely to be the largest value, blue-scale:\n    *\n    *    blue-scale = white-scale - red-scale - green-scale\n    *\n    * Hence:\n    *\n    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =\n    *                (white-x - blue-x)*white-scale\n    *\n    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =\n    *                1 - blue-y*white-scale\n    *\n    * And now we can trivially solve for (red-scale,green-scale):\n    *\n    *    green-scale =\n    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale\n    *                -----------------------------------------------------------\n    *                                  green-x - blue-x\n    *\n    *    red-scale =\n    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale\n    *                ---------------------------------------------------------\n    *                                  red-y - blue-y\n    *\n    * Hence:\n    *\n    *    red-scale =\n    *          ( (green-x - blue-x) * (white-y - blue-y) -\n    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y\n    * -------------------------------------------------------------------------\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\n    *\n    *    green-scale =\n    *          ( (red-y - blue-y) * (white-x - blue-x) -\n    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y\n    * -------------------------------------------------------------------------\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\n    *\n    * Accuracy:\n    * The input values have 5 decimal digits of accuracy.\n    *\n    * In the previous implementation the values were all in the range 0 < value\n    * < 1, so simple products are in the same range but may need up to 10\n    * decimal digits to preserve the original precision and avoid underflow.\n    * Because we are using a 32-bit signed representation we cannot match this;\n    * the best is a little over 9 decimal digits, less than 10.\n    *\n    * This range has now been extended to allow values up to 1.1, or 110,000 in\n    * fixed point.\n    *\n    * The approach used here is to preserve the maximum precision within the\n    * signed representation.  Because the red-scale calculation above uses the\n    * difference between two products of values that must be in the range\n    * -1.1..+1.1 it is sufficient to divide the product by 8;\n    * ceil(121,000/32767*2).  The factor is irrelevant in the calculation\n    * because it is applied to both numerator and denominator.\n    *\n    * Note that the values of the differences of the products of the\n    * chromaticities in the above equations tend to be small, for example for\n    * the sRGB chromaticities they are:\n    *\n    * red numerator:    -0.04751\n    * green numerator:  -0.08788\n    * denominator:      -0.2241 (without white-y multiplication)\n    *\n    *  The resultant Y coefficients from the chromaticities of some widely used\n    *  color space definitions are (to 15 decimal places):\n    *\n    *  sRGB\n    *    0.212639005871510 0.715168678767756 0.072192315360734\n    *  Kodak ProPhoto\n    *    0.288071128229293 0.711843217810102 0.000085653960605\n    *  Adobe RGB\n    *    0.297344975250536 0.627363566255466 0.075291458493998\n    *  Adobe Wide Gamut RGB\n    *    0.258728243040113 0.724682314948566 0.016589442011321\n    */\n   {\n      int error = 0;\n\n      /* By the argument above overflow should be impossible here, however the\n       * code now simply returns a failure code.  The xy subtracts in the\n       * arguments to png_muldiv are *not* checked for overflow because the\n       * checks at the start guarantee they are in the range 0..110000 and\n       * png_fixed_point is a 32-bit signed number.\n       */\n      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 8) ==\n            0)\n         return 1;\n      denominator = png_fp_sub(left, right, &error);\n      if (error) return 1;\n\n      /* Now find the red numerator. */\n      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 8) ==\n            0)\n         return 1;\n\n      /* Overflow is possible here and it indicates an extreme set of PNG cHRM\n       * chunk values.  This calculation actually returns the reciprocal of the\n       * scale value because this allows us to delay the multiplication of\n       * white-y into the denominator, which tends to produce a small number.\n       */\n      if (png_muldiv(&red_inverse, xy->whitey, denominator,\n                     png_fp_sub(left, right, &error)) == 0 || error ||\n          red_inverse <= xy->whitey /* r+g+b scales = white scale */)\n         return 1;\n\n      /* Similarly for green_inverse: */\n      if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&green_inverse, xy->whitey, denominator,\n                     png_fp_sub(left, right, &error)) == 0 || error ||\n          green_inverse <= xy->whitey)\n         return 1;\n\n      /* And the blue scale, the checks above guarantee this can't overflow but\n       * it can still produce 0 for extreme cHRM values.\n       */\n      blue_scale = png_fp_sub(png_fp_sub(png_reciprocal(xy->whitey),\n                                         png_reciprocal(red_inverse), &error),\n                              png_reciprocal(green_inverse), &error);\n      if (error || blue_scale <= 0)\n         return 1;\n   }\n\n   /* And fill in the png_XYZ.  Again the subtracts are safe because of the\n    * checks on the xy values at the start (the subtracts just calculate the\n    * corresponding z values.)\n    */\n   if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,\n       red_inverse) == 0)\n      return 1;\n\n   if (png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->green_Z, PNG_FP_1 - xy->greenx - xy->greeny, PNG_FP_1,\n       green_inverse) == 0)\n      return 1;\n\n   if (png_muldiv(&XYZ->blue_X, xy->bluex, blue_scale, PNG_FP_1) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->blue_Y, xy->bluey, blue_scale, PNG_FP_1) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->blue_Z, PNG_FP_1 - xy->bluex - xy->bluey, blue_scale,\n       PNG_FP_1) == 0)\n      return 1;\n\n   return 0; /*success*/\n}\n",
      "line_start": 1199,
      "line_end": 1493,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 255,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_icc_check_length",
      "clean_name": "png_icc_check_length",
      "source_file": "/src/libpng/png.c",
      "source_code": "      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length)\n{\n   if (!icc_check_length(png_ptr, name, profile_length))\n      return 0;\n\n   /* This needs to be here because the 'normal' check is in\n    * png_decompress_chunk, yet this happens after the attempt to\n    * png_malloc_base the required data.  We only need this on read; on write\n    * the caller supplies the profile buffer so libpng doesn't allocate it.  See\n    * the call to icc_check_length below (the write case).\n    */\n   if (profile_length > png_chunk_max(png_ptr))\n      return png_icc_profile_error(png_ptr, name, profile_length,\n            \"profile too long\");\n\n   return 1;\n}\n",
      "line_start": 1590,
      "line_end": 1608,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_icc_check_header",
      "clean_name": "png_icc_check_header",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_header(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length,\n   png_const_bytep profile/* first 132 bytes only */, int color_type)\n{\n   png_uint_32 temp;\n\n   /* Length check; this cannot be ignored in this code because profile_length\n    * is used later to check the tag table, so even if the profile seems over\n    * long profile_length from the caller must be correct.  The caller can fix\n    * this up on read or write by just passing in the profile header length.\n    */\n   temp = png_get_uint_32(profile);\n   if (temp != profile_length)\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"length does not match profile\");\n\n   temp = (png_uint_32) (*(profile+8));\n   if (temp > 3 && (profile_length & 3))\n      return png_icc_profile_error(png_ptr, name, profile_length,\n          \"invalid length\");\n\n   temp = png_get_uint_32(profile+128); /* tag count: 12 bytes/tag */\n   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */\n      profile_length < 132+12*temp) /* truncated tag table */\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"tag count too large\");\n\n   /* The 'intent' must be valid or we can't store it, ICC limits the intent to\n    * 16 bits.\n    */\n   temp = png_get_uint_32(profile+64);\n   if (temp >= 0xffff) /* The ICC limit */\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"invalid rendering intent\");\n\n   /* This is just a warning because the profile may be valid in future\n    * versions.\n    */\n   if (temp >= PNG_sRGB_INTENT_LAST)\n      (void)png_icc_profile_error(png_ptr, name, temp,\n          \"intent outside defined range\");\n\n   /* At this point the tag table can't be checked because it hasn't necessarily\n    * been loaded; however, various header fields can be checked.  These checks\n    * are for values permitted by the PNG spec in an ICC profile; the PNG spec\n    * restricts the profiles that can be passed in an iCCP chunk (they must be\n    * appropriate to processing PNG data!)\n    */\n\n   /* Data checks (could be skipped).  These checks must be independent of the\n    * version number; however, the version number doesn't accommodate changes in\n    * the header fields (just the known tags and the interpretation of the\n    * data.)\n    */\n   temp = png_get_uint_32(profile+36); /* signature 'ascp' */\n   if (temp != 0x61637370)\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"invalid signature\");\n\n   /* Currently the PCS illuminant/adopted white point (the computational\n    * white point) are required to be D50,\n    * however the profile contains a record of the illuminant so perhaps ICC\n    * expects to be able to change this in the future (despite the rationale in\n    * the introduction for using a fixed PCS adopted white.)  Consequently the\n    * following is just a warning.\n    */\n   if (memcmp(profile+68, D50_nCIEXYZ, 12) != 0)\n      (void)png_icc_profile_error(png_ptr, name, 0/*no tag value*/,\n          \"PCS illuminant is not D50\");\n\n   /* The PNG spec requires this:\n    * \"If the iCCP chunk is present, the image samples conform to the colour\n    * space represented by the embedded ICC profile as defined by the\n    * International Color Consortium [ICC]. The colour space of the ICC profile\n    * shall be an RGB colour space for colour images (PNG colour types 2, 3, and\n    * 6), or a greyscale colour space for greyscale images (PNG colour types 0\n    * and 4).\"\n    *\n    * This checking code ensures the embedded profile (on either read or write)\n    * conforms to the specification requirements.  Notice that an ICC 'gray'\n    * color-space profile contains the information to transform the monochrome\n    * data to XYZ or L*a*b (according to which PCS the profile uses) and this\n    * should be used in preference to the standard libpng K channel replication\n    * into R, G and B channels.\n    *\n    * Previously it was suggested that an RGB profile on grayscale data could be\n    * handled.  However it it is clear that using an RGB profile in this context\n    * must be an error - there is no specification of what it means.  Thus it is\n    * almost certainly more correct to ignore the profile.\n    */\n   temp = png_get_uint_32(profile+16); /* data colour space field */\n   switch (temp)\n   {\n      case 0x52474220: /* 'RGB ' */\n         if ((color_type & PNG_COLOR_MASK_COLOR) == 0)\n            return png_icc_profile_error(png_ptr, name, temp,\n                \"RGB color space not permitted on grayscale PNG\");\n         break;\n\n      case 0x47524159: /* 'GRAY' */\n         if ((color_type & PNG_COLOR_MASK_COLOR) != 0)\n            return png_icc_profile_error(png_ptr, name, temp,\n                \"Gray color space not permitted on RGB PNG\");\n         break;\n\n      default:\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"invalid ICC profile color space\");\n   }\n\n   /* It is up to the application to check that the profile class matches the\n    * application requirements; the spec provides no guidance, but it's pretty\n    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer\n    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these\n    * cases.  Issue an error for device link or abstract profiles - these don't\n    * contain the records necessary to transform the color-space to anything\n    * other than the target device (and not even that for an abstract profile).\n    * Profiles of these classes may not be embedded in images.\n    */\n   temp = png_get_uint_32(profile+12); /* profile/device class */\n   switch (temp)\n   {\n      case 0x73636e72: /* 'scnr' */\n      case 0x6d6e7472: /* 'mntr' */\n      case 0x70727472: /* 'prtr' */\n      case 0x73706163: /* 'spac' */\n         /* All supported */\n         break;\n\n      case 0x61627374: /* 'abst' */\n         /* May not be embedded in an image */\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"invalid embedded Abstract ICC profile\");\n\n      case 0x6c696e6b: /* 'link' */\n         /* DeviceLink profiles cannot be interpreted in a non-device specific\n          * fashion, if an app uses the AToB0Tag in the profile the results are\n          * undefined unless the result is sent to the intended device,\n          * therefore a DeviceLink profile should not be found embedded in a\n          * PNG.\n          */\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected DeviceLink ICC profile class\");\n\n      case 0x6e6d636c: /* 'nmcl' */\n         /* A NamedColor profile is also device specific, however it doesn't\n          * contain an AToB0 tag that is open to misinterpretation.  Almost\n          * certainly it will fail the tests below.\n          */\n         (void)png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected NamedColor ICC profile class\");\n         break;\n\n      default:\n         /* To allow for future enhancements to the profile accept unrecognized\n          * profile classes with a warning, these then hit the test below on the\n          * tag content to ensure they are backward compatible with one of the\n          * understood profiles.\n          */\n         (void)png_icc_profile_error(png_ptr, name, temp,\n             \"unrecognized ICC profile class\");\n         break;\n   }\n\n   /* For any profile other than a device link one the PCS must be encoded\n    * either in XYZ or Lab.\n    */\n   temp = png_get_uint_32(profile+20);\n   switch (temp)\n   {\n      case 0x58595a20: /* 'XYZ ' */\n      case 0x4c616220: /* 'Lab ' */\n         break;\n\n      default:\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected ICC PCS encoding\");\n   }\n\n   return 1;\n}\n",
      "line_start": 1610,
      "line_end": 1791,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 142,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_icc_check_tag_table",
      "clean_name": "png_icc_check_tag_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_tag_table(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length,\n   png_const_bytep profile /* header plus whole tag table */)\n{\n   png_uint_32 tag_count = png_get_uint_32(profile+128);\n   png_uint_32 itag;\n   png_const_bytep tag = profile+132; /* The first tag */\n\n   /* First scan all the tags in the table and add bits to the icc_info value\n    * (temporarily in 'tags').\n    */\n   for (itag=0; itag < tag_count; ++itag, tag += 12)\n   {\n      png_uint_32 tag_id = png_get_uint_32(tag+0);\n      png_uint_32 tag_start = png_get_uint_32(tag+4); /* must be aligned */\n      png_uint_32 tag_length = png_get_uint_32(tag+8);/* not padded */\n\n      /* The ICC specification does not exclude zero length tags, therefore the\n       * start might actually be anywhere if there is no data, but this would be\n       * a clear abuse of the intent of the standard so the start is checked for\n       * being in range.  All defined tag types have an 8 byte header - a 4 byte\n       * type signature then 0.\n       */\n\n      /* This is a hard error; potentially it can cause read outside the\n       * profile.\n       */\n      if (tag_start > profile_length || tag_length > profile_length - tag_start)\n         return png_icc_profile_error(png_ptr, name, tag_id,\n             \"ICC profile tag outside profile\");\n\n      if ((tag_start & 3) != 0)\n      {\n         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this; it is\n          * only a warning here because libpng does not care about the\n          * alignment.\n          */\n         (void)png_icc_profile_error(png_ptr, name, tag_id,\n             \"ICC profile tag start not a multiple of 4\");\n      }\n   }\n\n   return 1; /* success, maybe with warnings */\n}\n",
      "line_start": 1793,
      "line_end": 1837,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_rgb_coefficients",
      "clean_name": "png_set_rgb_coefficients",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return 0; /* sRGB defaults */\n}\n#endif /* READ_mDCV || READ_cHRM */\n\nvoid /* PRIVATE */\npng_set_rgb_coefficients(png_structrp png_ptr)\n{\n   /* Set the rgb_to_gray coefficients from the colorspace if available.  Note\n    * that '_set' means that png_rgb_to_gray was called **and** it successfully\n    * set up the coefficients.\n    */\n   if (png_ptr->rgb_to_gray_coefficients_set == 0)\n   {\n#  if check_chromaticities\n      png_XYZ xyz;\n\n      if (have_chromaticities(png_ptr) &&\n          png_XYZ_from_xy(&xyz, &png_ptr->chromaticities) == 0)\n      {\n         /* png_set_rgb_to_gray has not set the coefficients, get them from the\n          * Y * values of the colorspace colorants.\n          */\n         png_fixed_point r = xyz.red_Y;\n         png_fixed_point g = xyz.green_Y;\n         png_fixed_point b = xyz.blue_Y;\n         png_fixed_point total = r+g+b;\n\n         if (total > 0 &&\n            r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n            g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n            b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n            r+g+b <= 32769)\n         {\n            /* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n             * all of the coefficients were rounded up.  Handle this by\n             * reducing the *largest* coefficient by 1; this matches the\n             * approach used for the default coefficients in pngrtran.c\n             */\n            int add = 0;\n\n            if (r+g+b > 32768)\n               add = -1;\n            else if (r+g+b < 32768)\n               add = 1;\n\n            if (add != 0)\n            {\n               if (g >= r && g >= b)\n                  g += add;\n               else if (r >= g && r >= b)\n                  r += add;\n               else\n                  b += add;\n            }\n\n            /* Check for an internal error. */\n            if (r+g+b != 32768)\n               png_error(png_ptr,\n                   \"internal error handling cHRM coefficients\");\n\n            else\n            {\n               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n            }\n         }\n      }\n      else\n#  endif /* check_chromaticities */\n      {\n         /* Use the historical REC 709 (etc) values: */\n         png_ptr->rgb_to_gray_red_coeff   = 6968;\n         png_ptr->rgb_to_gray_green_coeff = 23434;\n         /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */\n      }\n   }\n}\n",
      "line_start": 1882,
      "line_end": 1954,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 107,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_ascii_from_fp",
      "clean_name": "png_ascii_from_fp",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Function to format a floating point value in ASCII with a given\n * precision.\n */\nvoid /* PRIVATE */\npng_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, size_t size,\n    double fp, unsigned int precision)\n{\n   /* We use standard functions from math.h, but not printf because\n    * that would require stdio.  The caller must supply a buffer of\n    * sufficient size or we will png_error.  The tests on size and\n    * the space in ascii[] consumed are indicated below.\n    */\n   if (precision < 1)\n      precision = DBL_DIG;\n\n   /* Enforce the limit of the implementation precision too. */\n   if (precision > DBL_DIG+1)\n      precision = DBL_DIG+1;\n\n   /* Basic sanity checks */\n   if (size >= precision+5) /* See the requirements below. */\n   {\n      if (fp < 0)\n      {\n         fp = -fp;\n         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */\n         --size;\n      }\n\n      if (fp >= DBL_MIN && fp <= DBL_MAX)\n      {\n         int exp_b10;   /* A base 10 exponent */\n         double base;   /* 10^exp_b10 */\n\n         /* First extract a base 10 exponent of the number,\n          * the calculation below rounds down when converting\n          * from base 2 to base 10 (multiply by log10(2) -\n          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to\n          * be increased.  Note that the arithmetic shift\n          * performs a floor() unlike C arithmetic - using a\n          * C multiply would break the following for negative\n          * exponents.\n          */\n         (void)frexp(fp, &exp_b10); /* exponent to base 2 */\n\n         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */\n\n         /* Avoid underflow here. */\n         base = png_pow10(exp_b10); /* May underflow */\n\n         while (base < DBL_MIN || base < fp)\n         {\n            /* And this may overflow. */\n            double test = png_pow10(exp_b10+1);\n\n            if (test <= DBL_MAX)\n            {\n               ++exp_b10; base = test;\n            }\n\n            else\n               break;\n         }\n\n         /* Normalize fp and correct exp_b10, after this fp is in the\n          * range [.1,1) and exp_b10 is both the exponent and the digit\n          * *before* which the decimal point should be inserted\n          * (starting with 0 for the first digit).  Note that this\n          * works even if 10^exp_b10 is out of range because of the\n          * test on DBL_MAX above.\n          */\n         fp /= base;\n         while (fp >= 1)\n         {\n            fp /= 10; ++exp_b10;\n         }\n\n         /* Because of the code above fp may, at this point, be\n          * less than .1, this is ok because the code below can\n          * handle the leading zeros this generates, so no attempt\n          * is made to correct that here.\n          */\n\n         {\n            unsigned int czero, clead, cdigits;\n            char exponent[10];\n\n            /* Allow up to two leading zeros - this will not lengthen\n             * the number compared to using E-n.\n             */\n            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */\n            {\n               czero = 0U-exp_b10; /* PLUS 2 digits: TOTAL 3 */\n               exp_b10 = 0;      /* Dot added below before first output. */\n            }\n            else\n               czero = 0;    /* No zeros to add */\n\n            /* Generate the digit list, stripping trailing zeros and\n             * inserting a '.' before a digit if the exponent is 0.\n             */\n            clead = czero; /* Count of leading zeros */\n            cdigits = 0;   /* Count of digits in list. */\n\n            do\n            {\n               double d;\n\n               fp *= 10;\n               /* Use modf here, not floor and subtract, so that\n                * the separation is done in one step.  At the end\n                * of the loop don't break the number into parts so\n                * that the final digit is rounded.\n                */\n               if (cdigits+czero+1 < precision+clead)\n                  fp = modf(fp, &d);\n\n               else\n               {\n                  d = floor(fp + .5);\n\n                  if (d > 9)\n                  {\n                     /* Rounding up to 10, handle that here. */\n                     if (czero > 0)\n                     {\n                        --czero; d = 1;\n                        if (cdigits == 0) --clead;\n                     }\n                     else\n                     {\n                        while (cdigits > 0 && d > 9)\n                        {\n                           int ch = *--ascii;\n\n                           if (exp_b10 != (-1))\n                              ++exp_b10;\n\n                           else if (ch == 46)\n                           {\n                              ch = *--ascii; ++size;\n                              /* Advance exp_b10 to '1', so that the\n                               * decimal point happens after the\n                               * previous digit.\n                               */\n                              exp_b10 = 1;\n                           }\n\n                           --cdigits;\n                           d = ch - 47;  /* I.e. 1+(ch-48) */\n                        }\n\n                        /* Did we reach the beginning? If so adjust the\n                         * exponent but take into account the leading\n                         * decimal point.\n                         */\n                        if (d > 9)  /* cdigits == 0 */\n                        {\n                           if (exp_b10 == (-1))\n                           {\n                              /* Leading decimal point (plus zeros?), if\n                               * we lose the decimal point here it must\n                               * be reentered below.\n                               */\n                              int ch = *--ascii;\n\n                              if (ch == 46)\n                              {\n                                 ++size; exp_b10 = 1;\n                              }\n\n                              /* Else lost a leading zero, so 'exp_b10' is\n                               * still ok at (-1)\n                               */\n                           }\n                           else\n                              ++exp_b10;\n\n                           /* In all cases we output a '1' */\n                           d = 1;\n                        }\n                     }\n                  }\n                  fp = 0; /* Guarantees termination below. */\n               }\n\n               if (d == 0)\n               {\n                  ++czero;\n                  if (cdigits == 0) ++clead;\n               }\n               else\n               {\n                  /* Included embedded zeros in the digit count. */\n                  cdigits += czero - clead;\n                  clead = 0;\n\n                  while (czero > 0)\n                  {\n                     /* exp_b10 == (-1) means we just output the decimal\n                      * place - after the DP don't adjust 'exp_b10' any\n                      * more!\n                      */\n                     if (exp_b10 != (-1))\n                     {\n                        if (exp_b10 == 0)\n                        {\n                           *ascii++ = 46; --size;\n                        }\n                        /* PLUS 1: TOTAL 4 */\n                        --exp_b10;\n                     }\n                     *ascii++ = 48; --czero;\n                  }\n\n                  if (exp_b10 != (-1))\n                  {\n                     if (exp_b10 == 0)\n                     {\n                        *ascii++ = 46; --size; /* counted above */\n                     }\n\n                     --exp_b10;\n                  }\n                  *ascii++ = (char)(48 + (int)d); ++cdigits;\n               }\n            }\n            while (cdigits+czero < precision+clead && fp > DBL_MIN);\n\n            /* The total output count (max) is now 4+precision */\n\n            /* Check for an exponent, if we don't need one we are\n             * done and just need to terminate the string.  At this\n             * point, exp_b10==(-1) is effectively a flag: it got\n             * to '-1' because of the decrement, after outputting\n             * the decimal point above. (The exponent required is\n             * *not* -1.)\n             */\n            if (exp_b10 >= (-1) && exp_b10 <= 2)\n            {\n               /* The following only happens if we didn't output the\n                * leading zeros above for negative exponent, so this\n                * doesn't add to the digit requirement.  Note that the\n                * two zeros here can only be output if the two leading\n                * zeros were *not* output, so this doesn't increase\n                * the output count.\n                */\n               while (exp_b10-- > 0) *ascii++ = 48;\n\n               *ascii = 0;\n\n               /* Total buffer requirement (including the '\\0') is\n                * 5+precision - see check at the start.\n                */\n               return;\n            }\n\n            /* Here if an exponent is required, adjust size for\n             * the digits we output but did not count.  The total\n             * digit output here so far is at most 1+precision - no\n             * decimal point and no leading or trailing zeros have\n             * been output.\n             */\n            size -= cdigits;\n\n            *ascii++ = 69; --size;    /* 'E': PLUS 1 TOTAL 2+precision */\n\n            /* The following use of an unsigned temporary avoids ambiguities in\n             * the signed arithmetic on exp_b10 and permits GCC at least to do\n             * better optimization.\n             */\n            {\n               unsigned int uexp_b10;\n\n               if (exp_b10 < 0)\n               {\n                  *ascii++ = 45; --size; /* '-': PLUS 1 TOTAL 3+precision */\n                  uexp_b10 = 0U-exp_b10;\n               }\n\n               else\n                  uexp_b10 = 0U+exp_b10;\n\n               cdigits = 0;\n\n               while (uexp_b10 > 0)\n               {\n                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);\n                  uexp_b10 /= 10;\n               }\n            }\n\n            /* Need another size check here for the exponent digits, so\n             * this need not be considered above.\n             */\n            if (size > cdigits)\n            {\n               while (cdigits > 0) *ascii++ = exponent[--cdigits];\n\n               *ascii = 0;\n\n               return;\n            }\n         }\n      }\n      else if (!(fp >= DBL_MIN))\n      {\n         *ascii++ = 48; /* '0' */\n         *ascii = 0;\n         return;\n      }\n      else\n      {\n         *ascii++ = 105; /* 'i' */\n         *ascii++ = 110; /* 'n' */\n         *ascii++ = 102; /* 'f' */\n         *ascii = 0;\n         return;\n      }\n   }\n\n   /* Here on buffer too small. */\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\n}\n",
      "line_start": 2313,
      "line_end": 2633,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 210,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_ascii_from_fixed",
      "clean_name": "png_ascii_from_fixed",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n#  ifdef PNG_FIXED_POINT_SUPPORTED\n/* Function to format a fixed point value in ASCII.\n */\nvoid /* PRIVATE */\npng_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,\n    size_t size, png_fixed_point fp)\n{\n   /* Require space for 10 decimal digits, a decimal point, a minus sign and a\n    * trailing \\0, 13 characters:\n    */\n   if (size > 12)\n   {\n      png_uint_32 num;\n\n      /* Avoid overflow here on the minimum integer. */\n      if (fp < 0)\n      {\n         *ascii++ = 45; num = (png_uint_32)(-fp);\n      }\n      else\n         num = (png_uint_32)fp;\n\n      if (num <= 0x80000000) /* else overflowed */\n      {\n         unsigned int ndigits = 0, first = 16 /* flag value */;\n         char digits[10] = {0};\n\n         while (num)\n         {\n            /* Split the low digit off num: */\n            unsigned int tmp = num/10;\n            num -= tmp*10;\n            digits[ndigits++] = (char)(48 + num);\n            /* Record the first non-zero digit, note that this is a number\n             * starting at 1, it's not actually the array index.\n             */\n            if (first == 16 && num > 0)\n               first = ndigits;\n            num = tmp;\n         }\n\n         if (ndigits > 0)\n         {\n            while (ndigits > 5) *ascii++ = digits[--ndigits];\n            /* The remaining digits are fractional digits, ndigits is '5' or\n             * smaller at this point.  It is certainly not zero.  Check for a\n             * non-zero fractional digit:\n             */\n            if (first <= 5)\n            {\n               unsigned int i;\n               *ascii++ = 46; /* decimal point */\n               /* ndigits may be <5 for small numbers, output leading zeros\n                * then ndigits digits to first:\n                */\n               i = 5;\n               while (ndigits < i)\n               {\n                  *ascii++ = 48; --i;\n               }\n               while (ndigits >= first) *ascii++ = digits[--ndigits];\n               /* Don't output the trailing zeros! */\n            }\n         }\n         else\n            *ascii++ = 48;\n\n         /* And null terminate the string: */\n         *ascii = 0;\n         return;\n      }\n   }\n\n   /* Here on buffer too small. */\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\n}\n",
      "line_start": 2639,
      "line_end": 2711,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_fixed",
      "clean_name": "png_fixed",
      "source_file": "/src/libpng/png.c",
      "source_code": "   defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \\\n   (defined(PNG_sCAL_SUPPORTED) && \\\n   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))\npng_fixed_point\npng_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(100000 * fp + .5);\n\n   if (r > 2147483647. || r < -2147483648.)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_fixed_point)r;\n}\n",
      "line_start": 2722,
      "line_end": 2735,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_fixed_ITU",
      "clean_name": "png_fixed_ITU",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\npng_uint_32\npng_fixed_ITU(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(10000 * fp + .5);\n\n   if (r > 2147483647. || r < 0)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_uint_32)r;\n}\n",
      "line_start": 2741,
      "line_end": 2754,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_gamma_correct",
      "clean_name": "png_gamma_correct",
      "source_file": "/src/libpng/png.c",
      "source_code": " * png_struct, interpreting values as 8-bit or 16-bit.  While the result\n * is nominally a 16-bit value if bit depth is 8 then the result is\n * 8-bit (as are the arguments.)\n */\npng_uint_16 /* PRIVATE */\npng_gamma_correct(png_structrp png_ptr, unsigned int value,\n    png_fixed_point gamma_val)\n{\n   if (png_ptr->bit_depth == 8)\n      return png_gamma_8bit_correct(value, gamma_val);\n\n#ifdef PNG_16BIT_SUPPORTED\n   else\n      return png_gamma_16bit_correct(value, gamma_val);\n#else\n      /* should not reach this */\n      return 0;\n#endif /* 16BIT */\n}\n",
      "line_start": 3352,
      "line_end": 3366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_option",
      "clean_name": "png_set_option",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* READ_GAMMA */\n\n/* HARDWARE OR SOFTWARE OPTION SUPPORT */\n#ifdef PNG_SET_OPTION_SUPPORTED\nint PNGAPI\npng_set_option(png_structrp png_ptr, int option, int onoff)\n{\n   if (png_ptr != NULL && option >= 0 && option < PNG_OPTION_NEXT &&\n      (option & 1) == 0)\n   {\n      png_uint_32 mask = 3U << option;\n      png_uint_32 setting = (2U + (onoff != 0)) << option;\n      png_uint_32 current = png_ptr->options;\n\n      png_ptr->options = (png_uint_32)((current & ~mask) | setting);\n\n      return (int)(current & mask) >> option;\n   }\n\n   return PNG_OPTION_INVALID;\n}\n",
      "line_start": 3765,
      "line_end": 3781,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_image_error",
      "clean_name": "png_image_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "      image->opaque = NULL;\n   }\n}\n\nint /* PRIVATE */\npng_image_error(png_imagep image, png_const_charp error_message)\n{\n   /* Utility to log an error. */\n   png_safecat(image->message, (sizeof image->message), 0, error_message);\n   image->warning_or_error |= PNG_IMAGE_ERROR;\n   png_image_free(image);\n   return 0;\n}\n",
      "line_start": 4030,
      "line_end": 4038,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png.c:png_safe_add",
      "clean_name": "png_safe_add",
      "source_file": "/src/libpng/png.c",
      "source_code": "   *error = 1;\n   return PNG_FP_1/2;\n}\n\nstatic int\npng_safe_add(png_int_32 *addend0_and_result, png_int_32 addend1,\n      png_int_32 addend2)\n{\n   /* Safely add three integers.  Returns 0 on success, 1 on overflow.  Does not\n    * set the result on overflow.\n    */\n   int error = 0;\n   int result = png_fp_add(*addend0_and_result,\n                           png_fp_add(addend1, addend2, &error),\n                           &error);\n   if (!error) *addend0_and_result = result;\n   return error;\n}\n",
      "line_start": 1113,
      "line_end": 1126,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_fp_add",
      "clean_name": "png_fp_add",
      "source_file": "/src/libpng/png.c",
      "source_code": "   }\n}\n\n#ifdef PNG_COLORSPACE_SUPPORTED\nstatic png_int_32\npng_fp_add(png_int_32 addend0, png_int_32 addend1, int *error)\n{\n   /* Safely add two fixed point values setting an error flag and returning 0.5\n    * on overflow.\n    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n    * relying on addition of two positive values producing a negative one is not\n    * safe.\n    */\n   if (addend0 > 0)\n   {\n      if (0x7fffffff - addend0 >= addend1)\n         return addend0+addend1;\n   }\n   else if (addend0 < 0)\n   {\n      if (-0x7fffffff - addend0 <= addend1)\n         return addend0+addend1;\n   }\n   else\n      return addend1;\n\n   *error = 1;\n   return PNG_FP_1/2;\n}\n",
      "line_start": 1066,
      "line_end": 1090,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_fp_sub",
      "clean_name": "png_fp_sub",
      "source_file": "/src/libpng/png.c",
      "source_code": "   *error = 1;\n   return PNG_FP_1/2;\n}\n\nstatic png_int_32\npng_fp_sub(png_int_32 addend0, png_int_32 addend1, int *error)\n{\n   /* As above but calculate addend0-addend1. */\n   if (addend1 > 0)\n   {\n      if (-0x7fffffff + addend1 <= addend0)\n         return addend0-addend1;\n   }\n   else if (addend1 < 0)\n   {\n      if (0x7fffffff + addend1 >= addend0)\n         return addend0-addend1;\n   }\n   else\n      return addend0;\n\n   *error = 1;\n   return PNG_FP_1/2;\n}\n",
      "line_start": 1092,
      "line_end": 1111,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:icc_check_length",
      "clean_name": "icc_check_length",
      "source_file": "/src/libpng/png.c",
      "source_code": " */\nstatic const png_byte D50_nCIEXYZ[12] =\n   { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };\n\nstatic int /* bool */\nicc_check_length(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length)\n{\n   if (profile_length < 132)\n      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n   return 1;\n}\n",
      "line_start": 1581,
      "line_end": 1588,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_icc_profile_error",
      "clean_name": "png_icc_profile_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "      is_ICC_signature_char((it >> 8) & 0xff) &&\n      is_ICC_signature_char(it & 0xff);\n}\n\nstatic int\npng_icc_profile_error(png_const_structrp png_ptr, png_const_charp name,\n   png_alloc_size_t value, png_const_charp reason)\n{\n   size_t pos;\n   char message[196]; /* see below for calculation */\n\n   pos = png_safecat(message, (sizeof message), 0, \"profile '\"); /* 9 chars */\n   pos = png_safecat(message, pos+79, pos, name); /* Truncate to 79 chars */\n   pos = png_safecat(message, (sizeof message), pos, \"': \"); /* +2 = 90 */\n   if (is_ICC_signature(value) != 0)\n   {\n      /* So 'value' is at most 4 bytes and the following cast is safe */\n      png_icc_tag_name(message+pos, (png_uint_32)value);\n      pos += 6; /* total +8; less than the else clause */\n      message[pos++] = ':';\n      message[pos++] = ' ';\n   }\n#  ifdef PNG_WARNINGS_SUPPORTED\n   else\n   {\n      char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114 */\n\n      pos = png_safecat(message, (sizeof message), pos,\n          png_format_number(number, number+(sizeof number),\n          PNG_NUMBER_FORMAT_x, value));\n      pos = png_safecat(message, (sizeof message), pos, \"h: \"); /* +2 = 116 */\n   }\n#  endif\n   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */\n   pos = png_safecat(message, (sizeof message), pos, reason);\n   PNG_UNUSED(pos)\n\n   png_chunk_benign_error(png_ptr, message);\n\n   return 0;\n}\n",
      "line_start": 1535,
      "line_end": 1571,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:is_ICC_signature",
      "clean_name": "is_ICC_signature",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||\n      (it >= 97 && it <= 122);\n}\n\nstatic int\nis_ICC_signature(png_alloc_size_t it)\n{\n   return is_ICC_signature_char(it >> 24) /* checks all the top bits */ &&\n      is_ICC_signature_char((it >> 16) & 0xff) &&\n      is_ICC_signature_char((it >> 8) & 0xff) &&\n      is_ICC_signature_char(it & 0xff);\n}\n",
      "line_start": 1526,
      "line_end": 1533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:is_ICC_signature_char",
      "clean_name": "is_ICC_signature_char",
      "source_file": "/src/libpng/png.c",
      "source_code": "   name[4] = png_icc_tag_char(tag      );\n   name[5] = '\\'';\n}\n\nstatic int\nis_ICC_signature_char(png_alloc_size_t it)\n{\n   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||\n      (it >= 97 && it <= 122);\n}\n",
      "line_start": 1519,
      "line_end": 1524,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_icc_tag_name",
      "clean_name": "png_icc_tag_name",
      "source_file": "/src/libpng/png.c",
      "source_code": "   else\n      return '?';\n}\n\nstatic void\npng_icc_tag_name(char *name, png_uint_32 tag)\n{\n   name[0] = '\\'';\n   name[1] = png_icc_tag_char(tag >> 24);\n   name[2] = png_icc_tag_char(tag >> 16);\n   name[3] = png_icc_tag_char(tag >>  8);\n   name[4] = png_icc_tag_char(tag      );\n   name[5] = '\\'';\n}\n",
      "line_start": 1508,
      "line_end": 1517,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_icc_tag_char",
      "clean_name": "png_icc_tag_char",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* COLORSPACE */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n/* Error message generation */\nstatic char\npng_icc_tag_char(png_uint_32 byte)\n{\n   byte &= 0xff;\n   if (byte >= 32 && byte <= 126)\n      return (char)byte;\n   else\n      return '?';\n}\n",
      "line_start": 1498,
      "line_end": 1506,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:have_chromaticities",
      "clean_name": "have_chromaticities",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* READ_iCCP */\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n#if (defined PNG_READ_mDCV_SUPPORTED) || (defined PNG_READ_cHRM_SUPPORTED)\nstatic int\nhave_chromaticities(png_const_structrp png_ptr)\n{\n   /* Handle new PNGv3 chunks and the precedence rules to determine whether\n    * png_struct::chromaticities must be processed.  Only required for RGB to\n    * gray.\n    *\n    * mDCV: this is the mastering colour space and it is independent of the\n    *       encoding so it needs to be used regardless of the encoded space.\n    *\n    * cICP: first in priority but not yet implemented - the chromaticities come\n    *       from the 'primaries'.\n    *\n    * iCCP: not supported by libpng (so ignored)\n    *\n    * sRGB: the defaults match sRGB\n    *\n    * cHRM: calculate the coefficients\n    */\n#  ifdef PNG_READ_mDCV_SUPPORTED\n      if (png_has_chunk(png_ptr, mDCV))\n         return 1;\n#     define check_chromaticities 1\n#  endif /*mDCV*/\n\n#  ifdef PNG_READ_sRGB_SUPPORTED\n      if (png_has_chunk(png_ptr, sRGB))\n         return 0;\n#  endif /*sRGB*/\n\n#  ifdef PNG_READ_cHRM_SUPPORTED\n      if (png_has_chunk(png_ptr, cHRM))\n         return 1;\n#     define check_chromaticities 1\n#  endif /*cHRM*/\n\n   return 0; /* sRGB defaults */\n}\n",
      "line_start": 1842,
      "line_end": 1879,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_pow10",
      "clean_name": "png_pow10",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  ifdef PNG_FLOATING_POINT_SUPPORTED\n/* Utility used below - a simple accurate power of ten from an integral\n * exponent.\n */\nstatic double\npng_pow10(int power)\n{\n   int recip = 0;\n   double d = 1;\n\n   /* Handle negative exponent with a reciprocal at the end because\n    * 10 is exact whereas .1 is inexact in base 2\n    */\n   if (power < 0)\n   {\n      if (power < DBL_MIN_10_EXP) return 0;\n      recip = 1; power = -power;\n   }\n\n   if (power > 0)\n   {\n      /* Decompose power bitwise. */\n      double mult = 10;\n      do\n      {\n         if (power & 1) d *= mult;\n         mult *= mult;\n         power >>= 1;\n      }\n      while (power > 0);\n\n      if (recip != 0) d = 1/d;\n   }\n   /* else power is 0 and d is 1 */\n\n   return d;\n}\n",
      "line_start": 2276,
      "line_end": 2308,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png.c:png_build_16bit_table",
      "clean_name": "png_build_16bit_table",
      "source_file": "/src/libpng/png.c",
      "source_code": " * The caller is responsible for ensuring that the table gets cleaned up on\n * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument\n * should be somewhere that will be cleaned.\n */\nstatic void\npng_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,\n    unsigned int shift, png_fixed_point gamma_val)\n{\n   /* Various values derived from 'shift': */\n   unsigned int num = 1U << (8U - shift);\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   /* CSE the division and work round wacky GCC warnings (see the comments\n    * in png_gamma_8bit_correct for where these come from.)\n    */\n   double fmax = 1.0 / (((png_int_32)1 << (16U - shift)) - 1);\n#endif\n   unsigned int max = (1U << (16U - shift)) - 1U;\n   unsigned int max_by_2 = 1U << (15U - shift);\n   unsigned int i;\n\n   png_uint_16pp table = *ptable =\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\n\n   for (i = 0; i < num; i++)\n   {\n      png_uint_16p sub_table = table[i] =\n          (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));\n\n      /* The 'threshold' test is repeated here because it can arise for one of\n       * the 16-bit tables even if the others don't hit it.\n       */\n      if (png_gamma_significant(gamma_val) != 0)\n      {\n         /* The old code would overflow at the end and this would cause the\n          * 'pow' function to return a result >1, resulting in an\n          * arithmetic error.  This code follows the spec exactly; ig is\n          * the recovered input sample, it always has 8-16 bits.\n          *\n          * We want input * 65535/max, rounded, the arithmetic fits in 32\n          * bits (unsigned) so long as max <= 32767.\n          */\n         unsigned int j;\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n               /* Inline the 'max' scaling operation: */\n               /* See png_gamma_8bit_correct for why the cast to (int) is\n                * required here.\n                */\n               double d = floor(65535.*pow(ig*fmax, gamma_val*.00001)+.5);\n               sub_table[j] = (png_uint_16)d;\n#           else\n               if (shift != 0)\n                  ig = (ig * 65535U + max_by_2)/max;\n\n               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);\n#           endif\n         }\n      }\n      else\n      {\n         /* We must still build a table, but do it the fast way. */\n         unsigned int j;\n\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n\n            if (shift != 0)\n               ig = (ig * 65535U + max_by_2)/max;\n\n            sub_table[j] = (png_uint_16)ig;\n         }\n      }\n   }\n}\n",
      "line_start": 3377,
      "line_end": 3449,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_error",
      "clean_name": "png_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * you should supply a replacement error function and use png_set_error_fn()\n * to replace the error function at run-time.\n */\n#ifdef PNG_ERROR_TEXT_SUPPORTED\nPNG_FUNCTION(void,PNGAPI\npng_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   if (png_ptr != NULL && png_ptr->error_fn != NULL)\n      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),\n          error_message);\n\n   /* If the custom handler doesn't exist, or if it returns,\n      use the default handler, which will not return. */\n   png_default_error(png_ptr, error_message);\n}\n",
      "line_start": 38,
      "line_end": 49,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_safecat",
      "clean_name": "png_safecat",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "\n/* Utility to safely appends strings to a buffer.  This never errors out so\n * error checking is not required in the caller.\n */\nsize_t\npng_safecat(png_charp buffer, size_t bufsize, size_t pos,\n    png_const_charp string)\n{\n   if (buffer != NULL && pos < bufsize)\n   {\n      if (string != NULL)\n         while (*string != '\\0' && pos < bufsize-1)\n           buffer[pos++] = *string++;\n\n      buffer[pos] = '\\0';\n   }\n\n   return pos;\n}\n",
      "line_start": 71,
      "line_end": 85,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_format_number",
      "clean_name": "png_format_number",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "/* Utility to dump an unsigned value into a buffer, given a start pointer and\n * and end pointer (which should point just *beyond* the end of the buffer!)\n * Returns the pointer to the start of the formatted string.\n */\npng_charp\npng_format_number(png_const_charp start, png_charp end, int format,\n    png_alloc_size_t number)\n{\n   int count = 0;    /* number of digits output */\n   int mincount = 1; /* minimum number required */\n   int output = 0;   /* digit output (for the fixed point format) */\n\n   *--end = '\\0';\n\n   /* This is written so that the loop always runs at least once, even with\n    * number zero.\n    */\n   while (end > start && (number != 0 || count < mincount))\n   {\n\n      static const char digits[] = \"0123456789ABCDEF\";\n\n      switch (format)\n      {\n         case PNG_NUMBER_FORMAT_fixed:\n            /* Needs five digits (the fraction) */\n            mincount = 5;\n            if (output != 0 || number % 10 != 0)\n            {\n               *--end = digits[number % 10];\n               output = 1;\n            }\n            number /= 10;\n            break;\n\n         case PNG_NUMBER_FORMAT_02u:\n            /* Expects at least 2 digits. */\n            mincount = 2;\n            /* FALLTHROUGH */\n\n         case PNG_NUMBER_FORMAT_u:\n            *--end = digits[number % 10];\n            number /= 10;\n            break;\n\n         case PNG_NUMBER_FORMAT_02x:\n            /* This format expects at least two digits */\n            mincount = 2;\n            /* FALLTHROUGH */\n\n         case PNG_NUMBER_FORMAT_x:\n            *--end = digits[number & 0xf];\n            number >>= 4;\n            break;\n\n         default: /* an error */\n            number = 0;\n            break;\n      }\n\n      /* Keep track of the number of digits added */\n      ++count;\n\n      /* Float a fixed number here: */\n      if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))\n      {\n         /* End of the fraction, but maybe nothing was output?  In that case\n          * drop the decimal point.  If the number is a true zero handle that\n          * here.\n          */\n         if (output != 0)\n            *--end = '.';\n         else if (number == 0) /* and !output */\n            *--end = '0';\n      }\n   }\n\n   return end;\n}\n",
      "line_start": 92,
      "line_end": 166,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_warning",
      "clean_name": "png_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * should not be changed.  If there is a need to handle warnings differently,\n * you should supply a replacement warning function and use\n * png_set_error_fn() to replace the warning function at run-time.\n */\nvoid PNGAPI\npng_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n   int offset = 0;\n   if (png_ptr != NULL && png_ptr->warning_fn != NULL)\n      (*(png_ptr->warning_fn))(png_constcast(png_structrp,png_ptr),\n          warning_message + offset);\n   else\n      png_default_warning(png_ptr, warning_message + offset);\n}\n",
      "line_start": 175,
      "line_end": 184,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_warning_parameter",
      "clean_name": "png_warning_parameter",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter\n * is introduced by @<number>, where 'number' starts at 1.  This follows the\n * standard established by X/Open for internationalizable error messages.\n */\nvoid\npng_warning_parameter(png_warning_parameters p, int number,\n    png_const_charp string)\n{\n   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)\n      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);\n}\n",
      "line_start": 191,
      "line_end": 197,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_warning_parameter_unsigned",
      "clean_name": "png_warning_parameter_unsigned",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)\n      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);\n}\n\nvoid\npng_warning_parameter_unsigned(png_warning_parameters p, int number, int format,\n    png_alloc_size_t value)\n{\n   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));\n}\n",
      "line_start": 199,
      "line_end": 205,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_warning_parameter_signed",
      "clean_name": "png_warning_parameter_signed",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));\n}\n\nvoid\npng_warning_parameter_signed(png_warning_parameters p, int number, int format,\n    png_int_32 value)\n{\n   png_alloc_size_t u;\n   png_charp str;\n   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n\n   /* Avoid overflow by doing the negate in a png_alloc_size_t: */\n   u = (png_alloc_size_t)value;\n   if (value < 0)\n      u = ~u + 1;\n\n   str = PNG_FORMAT_NUMBER(buffer, format, u);\n\n   if (value < 0 && str > buffer)\n      *--str = '-';\n\n   png_warning_parameter(p, number, str);\n}\n",
      "line_start": 207,
      "line_end": 226,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_formatted_warning",
      "clean_name": "png_formatted_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "\n   png_warning_parameter(p, number, str);\n}\n\nvoid\npng_formatted_warning(png_const_structrp png_ptr, png_warning_parameters p,\n    png_const_charp message)\n{\n   /* The internal buffer is just 192 bytes - enough for all our messages,\n    * overflow doesn't happen because this code checks!  If someone figures\n    * out how to send us a message longer than 192 bytes, all that will\n    * happen is that the message will be truncated appropriately.\n    */\n   size_t i = 0; /* Index in the msg[] buffer: */\n   char msg[192];\n\n   /* Each iteration through the following loop writes at most one character\n    * to msg[i++] then returns here to validate that there is still space for\n    * the trailing '\\0'.  It may (in the case of a parameter) read more than\n    * one character from message[]; it must check for '\\0' and continue to the\n    * test if it finds the end of string.\n    */\n   while (i<(sizeof msg)-1 && *message != '\\0')\n   {\n      /* '@' at end of string is now just printed (previously it was skipped);\n       * it is an error in the calling code to terminate the string with @.\n       */\n      if (p != NULL && *message == '@' && message[1] != '\\0')\n      {\n         int parameter_char = *++message; /* Consume the '@' */\n         static const char valid_parameters[] = \"123456789\";\n         int parameter = 0;\n\n         /* Search for the parameter digit, the index in the string is the\n          * parameter to use.\n          */\n         while (valid_parameters[parameter] != parameter_char &&\n            valid_parameters[parameter] != '\\0')\n            ++parameter;\n\n         /* If the parameter digit is out of range it will just get printed. */\n         if (parameter < PNG_WARNING_PARAMETER_COUNT)\n         {\n            /* Append this parameter */\n            png_const_charp parm = p[parameter];\n            png_const_charp pend = p[parameter] + (sizeof p[parameter]);\n\n            /* No need to copy the trailing '\\0' here, but there is no guarantee\n             * that parm[] has been initialized, so there is no guarantee of a\n             * trailing '\\0':\n             */\n            while (i<(sizeof msg)-1 && *parm != '\\0' && parm < pend)\n               msg[i++] = *parm++;\n\n            /* Consume the parameter digit too: */\n            ++message;\n            continue;\n         }\n\n         /* else not a parameter and there is a character after the @ sign; just\n          * copy that.  This is known not to be '\\0' because of the test above.\n          */\n      }\n\n      /* At this point *message can't be '\\0', even in the bad parameter case\n       * above where there is a lone '@' at the end of the message string.\n       */\n      msg[i++] = *message++;\n   }\n\n   /* i is always less than (sizeof msg), so: */\n   msg[i] = '\\0';\n\n   /* And this is the formatted message. It may be larger than\n    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these\n    * are not (currently) formatted.\n    */\n   png_warning(png_ptr, msg);\n}\n",
      "line_start": 228,
      "line_end": 302,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 54,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_benign_error",
      "clean_name": "png_benign_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* WARNINGS */\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\nvoid PNGAPI\npng_benign_error(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)\n   {\n#     ifdef PNG_READ_SUPPORTED\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n            png_ptr->chunk_name != 0)\n            png_chunk_warning(png_ptr, error_message);\n         else\n#     endif\n      png_warning(png_ptr, error_message);\n   }\n\n   else\n   {\n#     ifdef PNG_READ_SUPPORTED\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n            png_ptr->chunk_name != 0)\n            png_chunk_error(png_ptr, error_message);\n         else\n#     endif\n      png_error(png_ptr, error_message);\n   }\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 306,
      "line_end": 334,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 39,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_app_warning",
      "clean_name": "png_app_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "      PNG_UNUSED(error_message)\n#  endif\n}\n\nvoid /* PRIVATE */\npng_app_warning(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_APP_WARNINGS_WARN) != 0)\n      png_warning(png_ptr, error_message);\n   else\n      png_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 336,
      "line_end": 347,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_app_error",
      "clean_name": "png_app_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "      PNG_UNUSED(error_message)\n#  endif\n}\n\nvoid /* PRIVATE */\npng_app_error(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN) != 0)\n      png_warning(png_ptr, error_message);\n   else\n      png_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 349,
      "line_end": 360,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_chunk_error",
      "clean_name": "png_chunk_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* WARNINGS || ERROR_TEXT */\n\n#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)\nPNG_FUNCTION(void,PNGAPI\npng_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   char msg[18+PNG_MAX_ERROR_TEXT];\n   if (png_ptr == NULL)\n      png_error(png_ptr, error_message);\n\n   else\n   {\n      png_format_buffer(png_ptr, msg, error_message);\n      png_error(png_ptr, msg);\n   }\n}\n",
      "line_start": 424,
      "line_end": 437,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_chunk_warning",
      "clean_name": "png_chunk_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* READ && ERROR_TEXT */\n\n#ifdef PNG_WARNINGS_SUPPORTED\nvoid PNGAPI\npng_chunk_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n   char msg[18+PNG_MAX_ERROR_TEXT];\n   if (png_ptr == NULL)\n      png_warning(png_ptr, warning_message);\n\n   else\n   {\n      png_format_buffer(png_ptr, msg, warning_message);\n      png_warning(png_ptr, msg);\n   }\n}\n",
      "line_start": 441,
      "line_end": 453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_chunk_benign_error",
      "clean_name": "png_chunk_benign_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "#endif /* WARNINGS */\n\n#ifdef PNG_READ_SUPPORTED\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\nvoid PNGAPI\npng_chunk_benign_error(png_const_structrp png_ptr, png_const_charp\n    error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)\n      png_chunk_warning(png_ptr, error_message);\n\n   else\n      png_chunk_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 458,
      "line_end": 471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_chunk_report",
      "clean_name": "png_chunk_report",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif\n#endif /* READ */\n\nvoid /* PRIVATE */\npng_chunk_report(png_const_structrp png_ptr, png_const_charp message, int error)\n{\n#  ifndef PNG_WARNINGS_SUPPORTED\n      PNG_UNUSED(message)\n#  endif\n\n   /* This is always supported, but for just read or just write it\n    * unconditionally does the right thing.\n    */\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n#  endif\n\n#  ifdef PNG_READ_SUPPORTED\n      {\n         if (error < PNG_CHUNK_ERROR)\n            png_chunk_warning(png_ptr, message);\n\n         else\n            png_chunk_benign_error(png_ptr, message);\n      }\n#  endif\n\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\n      else if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n#  endif\n\n#  ifdef PNG_WRITE_SUPPORTED\n      {\n         if (error < PNG_CHUNK_WRITE_ERROR)\n            png_app_warning(png_ptr, message);\n\n         else\n            png_app_error(png_ptr, message);\n      }\n#  endif\n}\n",
      "line_start": 475,
      "line_end": 512,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_fixed_error",
      "clean_name": "png_fixed_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n\n#ifdef PNG_ERROR_TEXT_SUPPORTED\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nPNG_FUNCTION(void,\npng_fixed_error,(png_const_structrp png_ptr, png_const_charp name),PNG_NORETURN)\n{\n#  define fixed_message \"fixed point overflow in \"\n#  define fixed_message_ln ((sizeof fixed_message)-1)\n   unsigned int  iin;\n   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];\n   memcpy(msg, fixed_message, fixed_message_ln);\n   iin = 0;\n   if (name != NULL)\n      while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)\n      {\n         msg[fixed_message_ln + iin] = name[iin];\n         ++iin;\n      }\n   msg[fixed_message_ln + iin] = 0;\n   png_error(png_ptr, msg);\n}\n",
      "line_start": 516,
      "line_end": 533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_longjmp",
      "clean_name": "png_longjmp",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "#endif\n   png_longjmp(png_ptr, 1);\n}\n\nPNG_FUNCTION(void,PNGAPI\npng_longjmp,(png_const_structrp png_ptr, int val),PNG_NORETURN)\n{\n#ifdef PNG_SETJMP_SUPPORTED\n   if (png_ptr != NULL && png_ptr->longjmp_fn != NULL &&\n       png_ptr->jmp_buf_ptr != NULL)\n      png_ptr->longjmp_fn(*png_ptr->jmp_buf_ptr, val);\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(val)\n#endif\n\n   /* If control reaches this point, png_longjmp() must not return. The only\n    * choice is to terminate the whole process (or maybe the thread); to do\n    * this the ANSI-C abort() function is used unless a different method is\n    * implemented by overriding the default configuration setting for\n    * PNG_ABORT().\n    */\n   PNG_ABORT();\n}\n",
      "line_start": 669,
      "line_end": 688,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_error_ptr",
      "clean_name": "png_get_error_ptr",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "/* This function returns a pointer to the error_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\npng_voidp PNGAPI\npng_get_error_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return (png_voidp)png_ptr->error_ptr;\n}\n",
      "line_start": 735,
      "line_end": 742,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_safe_error",
      "clean_name": "png_safe_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   /* Currently the above both depend on SETJMP_SUPPORTED, however it would be\n    * possible to implement without setjmp support just so long as there is some\n    * way to handle the error return here:\n    */\nPNG_FUNCTION(void /* PRIVATE */, (PNGCBAPI\npng_safe_error),(png_structp png_nonconst_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   png_const_structrp png_ptr = png_nonconst_ptr;\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\n\n   /* An error is always logged here, overwriting anything (typically a warning)\n    * that is already there:\n    */\n   if (image != NULL)\n   {\n      png_safecat(image->message, (sizeof image->message), 0, error_message);\n      image->warning_or_error |= PNG_IMAGE_ERROR;\n\n      /* Retrieve the jmp_buf from within the png_control, making this work for\n       * C++ compilation too is pretty tricky: C++ wants a pointer to the first\n       * element of a jmp_buf, but C doesn't tell us the type of that.\n       */\n      if (image->opaque != NULL && image->opaque->error_buf != NULL)\n         longjmp(png_control_jmp_buf(image->opaque), 1);\n\n      /* Missing longjmp buffer, the following is to help debugging: */\n      {\n         size_t pos = png_safecat(image->message, (sizeof image->message), 0,\n             \"bad longjmp: \");\n         png_safecat(image->message, (sizeof image->message), pos,\n             error_message);\n      }\n   }\n\n   /* Here on an internal programming error. */\n   abort();\n}\n",
      "line_start": 760,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_safe_warning",
      "clean_name": "png_safe_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   abort();\n}\n\n#ifdef PNG_WARNINGS_SUPPORTED\nvoid /* PRIVATE */ PNGCBAPI\npng_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)\n{\n   png_const_structrp png_ptr = png_nonconst_ptr;\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\n\n   /* A warning is only logged if there is no prior warning or error. */\n   if (image->warning_or_error == 0)\n   {\n      png_safecat(image->message, (sizeof image->message), 0, warning_message);\n      image->warning_or_error |= PNG_IMAGE_WARNING;\n   }\n}\n",
      "line_start": 796,
      "line_end": 808,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngerror.c:png_format_buffer",
      "clean_name": "png_format_buffer",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n   'A', 'B', 'C', 'D', 'E', 'F'\n};\n\nstatic void /* PRIVATE */\npng_format_buffer(png_const_structrp png_ptr, png_charp buffer, png_const_charp\n    error_message)\n{\n   png_uint_32 chunk_name = png_ptr->chunk_name;\n   int iout = 0, ishift = 24;\n\n   while (ishift >= 0)\n   {\n      int c = (int)(chunk_name >> ishift) & 0xff;\n\n      ishift -= 8;\n      if (isnonalpha(c) != 0)\n      {\n         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;\n         buffer[iout++] = png_digit[(c & 0xf0) >> 4];\n         buffer[iout++] = png_digit[c & 0x0f];\n         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;\n      }\n\n      else\n      {\n         buffer[iout++] = (char)c;\n      }\n   }\n\n   if (error_message == NULL)\n      buffer[iout] = '\\0';\n\n   else\n   {\n      int iin = 0;\n\n      buffer[iout++] = ':';\n      buffer[iout++] = ' ';\n\n      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\\0')\n         buffer[iout++] = error_message[iin++];\n\n      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */\n      buffer[iout] = '\\0';\n   }\n}\n",
      "line_start": 378,
      "line_end": 420,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngerror.c:png_default_error",
      "clean_name": "png_default_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * this function MUST NOT RETURN, or the program will likely crash.  This\n * function is used by default, or if the program supplies NULL for the\n * error function pointer in png_set_error_fn().\n */\nstatic PNG_FUNCTION(void /* PRIVATE */,\npng_default_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n   fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n      \"undefined\");\n   fprintf(stderr, PNG_STRING_NEWLINE);\n#else\n   PNG_UNUSED(error_message) /* Make compiler happy */\n#endif\n   png_longjmp(png_ptr, 1);\n}\n",
      "line_start": 655,
      "line_end": 667,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngerror.c:png_default_warning",
      "clean_name": "png_default_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * it can continue anyway.  Replacement functions don't have to do anything\n * here if you don't want them to.  In the default configuration, png_ptr is\n * not used, but it is passed in case it may be useful.\n */\nstatic void /* PRIVATE */\npng_default_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n   fprintf(stderr, \"libpng warning: %s\", warning_message);\n   fprintf(stderr, PNG_STRING_NEWLINE);\n#else\n   PNG_UNUSED(warning_message) /* Make compiler happy */\n#endif\n   PNG_UNUSED(png_ptr) /* Make compiler happy */\n}\n",
      "line_start": 696,
      "line_end": 706,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_get_valid",
      "clean_name": "png_get_valid",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#include \"pngpriv.h\"\n\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n\npng_uint_32 PNGAPI\npng_get_valid(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 flag)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n   {\n#ifdef PNG_READ_tRNS_SUPPORTED\n      /* png_handle_PLTE() may have canceled a valid tRNS chunk but left the\n       * 'valid' flag for the detection of duplicate chunks. Do not report a\n       * valid tRNS chunk in this case.\n       */\n      if (flag == PNG_INFO_tRNS && png_ptr->num_trans == 0)\n         return 0;\n#endif\n\n      return info_ptr->valid & flag;\n   }\n\n   return 0;\n}\n",
      "line_start": 18,
      "line_end": 37,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_rows",
      "clean_name": "png_get_rows",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\npng_bytepp PNGAPI\npng_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->row_pointers;\n\n   return 0;\n}\n",
      "line_start": 49,
      "line_end": 56,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_image_width",
      "clean_name": "png_get_image_width",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_EASY_ACCESS_SUPPORTED\n/* Easy access to info, added in libpng-0.99 */\npng_uint_32 PNGAPI\npng_get_image_width(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->width;\n\n   return 0;\n}\n",
      "line_start": 61,
      "line_end": 68,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_image_height",
      "clean_name": "png_get_image_height",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_image_height(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->height;\n\n   return 0;\n}\n",
      "line_start": 70,
      "line_end": 77,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_bit_depth",
      "clean_name": "png_get_bit_depth",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_bit_depth(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->bit_depth;\n\n   return 0;\n}\n",
      "line_start": 79,
      "line_end": 86,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_color_type",
      "clean_name": "png_get_color_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_color_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->color_type;\n\n   return 0;\n}\n",
      "line_start": 88,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_filter_type",
      "clean_name": "png_get_filter_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_filter_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->filter_type;\n\n   return 0;\n}\n",
      "line_start": 97,
      "line_end": 104,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_interlace_type",
      "clean_name": "png_get_interlace_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_interlace_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->interlace_type;\n\n   return 0;\n}\n",
      "line_start": 106,
      "line_end": 113,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_compression_type",
      "clean_name": "png_get_compression_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->compression_type;\n\n   return 0;\n}\n",
      "line_start": 115,
      "line_end": 122,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_pixels_per_meter",
      "clean_name": "png_get_x_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\n   info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_x_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n         return info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 124,
      "line_end": 143,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_pixels_per_meter",
      "clean_name": "png_get_y_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_y_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\n    info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_y_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n         return info_ptr->y_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 145,
      "line_end": 164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pixels_per_meter",
      "clean_name": "png_get_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER &&\n          info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit)\n         return info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 166,
      "line_end": 185,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pixel_aspect_ratio",
      "clean_name": "png_get_pixel_aspect_ratio",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_pixel_aspect_ratio(png_const_structrp png_ptr, png_const_inforp\n   info_ptr)\n{\n#ifdef PNG_READ_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixel_aspect_ratio\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->x_pixels_per_unit != 0)\n         return (float)info_ptr->y_pixels_per_unit\n              / (float)info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return (float)0.0;\n}\n",
      "line_start": 188,
      "line_end": 208,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pixel_aspect_ratio_fixed",
      "clean_name": "png_get_pixel_aspect_ratio_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\npng_fixed_point PNGAPI\npng_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n#ifdef PNG_READ_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixel_aspect_ratio_fixed\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0 &&\n       info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&\n       info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX &&\n       info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)\n   {\n      png_fixed_point res;\n\n      /* The following casts work because a PNG 4 byte integer only has a valid\n       * range of 0..2^31-1; otherwise the cast might overflow.\n       */\n      if (png_muldiv(&res, (png_int_32)info_ptr->y_pixels_per_unit, PNG_FP_1,\n          (png_int_32)info_ptr->x_pixels_per_unit) != 0)\n         return res;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 212,
      "line_end": 240,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_offset_microns",
      "clean_name": "png_get_x_offset_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n#endif\n\npng_int_32 PNGAPI\npng_get_x_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_x_offset_microns\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\n         return info_ptr->x_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 243,
      "line_end": 261,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_offset_microns",
      "clean_name": "png_get_y_offset_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_y_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_y_offset_microns\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\n         return info_ptr->y_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 263,
      "line_end": 281,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_offset_pixels",
      "clean_name": "png_get_x_offset_pixels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_x_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_x_offset_pixels\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\n         return info_ptr->x_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 283,
      "line_end": 301,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_offset_pixels",
      "clean_name": "png_get_y_offset_pixels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_y_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_y_offset_pixels\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\n         return info_ptr->y_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 303,
      "line_end": 321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pixels_per_inch",
      "clean_name": "png_get_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n#endif\n}\n\npng_uint_32 PNGAPI\npng_get_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 356,
      "line_end": 360,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_pixels_per_inch",
      "clean_name": "png_get_x_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));\n}\n\npng_uint_32 PNGAPI\npng_get_x_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 362,
      "line_end": 366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_pixels_per_inch",
      "clean_name": "png_get_y_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));\n}\n\npng_uint_32 PNGAPI\npng_get_y_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 368,
      "line_end": 372,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_offset_inches_fixed",
      "clean_name": "png_get_x_offset_inches_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   png_warning(png_ptr, \"fixed point overflow ignored\");\n   return 0;\n}\n\npng_fixed_point PNGAPI\npng_get_x_offset_inches_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n   return png_fixed_inches_from_microns(png_ptr,\n       png_get_x_offset_microns(png_ptr, info_ptr));\n}\n",
      "line_start": 392,
      "line_end": 398,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_offset_inches_fixed",
      "clean_name": "png_get_y_offset_inches_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif /* FIXED_POINT */\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\npng_fixed_point PNGAPI\npng_get_y_offset_inches_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n   return png_fixed_inches_from_microns(png_ptr,\n       png_get_y_offset_microns(png_ptr, info_ptr));\n}\n",
      "line_start": 402,
      "line_end": 408,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_x_offset_inches",
      "clean_name": "png_get_x_offset_inches",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_x_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   /* To avoid the overflow do the conversion directly in floating\n    * point.\n    */\n   return (float)(png_get_x_offset_microns(png_ptr, info_ptr) * .00003937);\n}\n",
      "line_start": 412,
      "line_end": 419,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_y_offset_inches",
      "clean_name": "png_get_y_offset_inches",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_y_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   /* To avoid the overflow do the conversion directly in floating\n    * point.\n    */\n   return (float)(png_get_y_offset_microns(png_ptr, info_ptr) * .00003937);\n}\n",
      "line_start": 423,
      "line_end": 430,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pHYs_dpi",
      "clean_name": "png_get_pHYs_dpi",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_pHYs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pHYs_dpi(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (res_x != NULL)\n      {\n         *res_x = info_ptr->x_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (res_y != NULL)\n      {\n         *res_y = info_ptr->y_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (unit_type != NULL)\n      {\n         *unit_type = (int)info_ptr->phys_unit_type;\n         retval |= PNG_INFO_pHYs;\n\n         if (*unit_type == 1)\n         {\n            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);\n            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);\n         }\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 434,
      "line_end": 471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_channels",
      "clean_name": "png_get_channels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n#endif /* EASY_ACCESS */\n\n\npng_byte PNGAPI\npng_get_channels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->channels;\n\n   return 0;\n}\n",
      "line_start": 480,
      "line_end": 487,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_signature",
      "clean_name": "png_get_signature",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_READ_SUPPORTED\npng_const_bytep PNGAPI\npng_get_signature(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->signature;\n\n   return NULL;\n}\n",
      "line_start": 490,
      "line_end": 497,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_bKGD",
      "clean_name": "png_get_bKGD",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_bKGD_SUPPORTED\npng_uint_32 PNGAPI\npng_get_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_color_16p *background)\n{\n   png_debug1(1, \"in %s retrieval function\", \"bKGD\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_bKGD) != 0 &&\n       background != NULL)\n   {\n      *background = &(info_ptr->background);\n      return PNG_INFO_bKGD;\n   }\n\n   return 0;\n}\n",
      "line_start": 501,
      "line_end": 516,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cHRM",
      "clean_name": "png_get_cHRM",
      "source_file": "/src/libpng/pngget.c",
      "source_code": " * same time to correct the rgb grayscale coefficient defaults obtained from the\n * cHRM chunk in 1.5.4\n */\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cHRM(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *whitex, double *whitey, double *redx, double *redy,\n    double *greenx, double *greeny, double *bluex, double *bluey)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n\n   /* PNGv3: this just returns the values store from the cHRM, if any. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n   {\n      if (whitex != NULL)\n         *whitex = png_float(png_ptr, info_ptr->cHRM.whitex, \"cHRM wx\");\n      if (whitey != NULL)\n         *whitey = png_float(png_ptr, info_ptr->cHRM.whitey, \"cHRM wy\");\n      if (redx   != NULL)\n         *redx   = png_float(png_ptr, info_ptr->cHRM.redx,   \"cHRM rx\");\n      if (redy   != NULL)\n         *redy   = png_float(png_ptr, info_ptr->cHRM.redy,   \"cHRM ry\");\n      if (greenx != NULL)\n         *greenx = png_float(png_ptr, info_ptr->cHRM.greenx, \"cHRM gx\");\n      if (greeny != NULL)\n         *greeny = png_float(png_ptr, info_ptr->cHRM.greeny, \"cHRM gy\");\n      if (bluex  != NULL)\n         *bluex  = png_float(png_ptr, info_ptr->cHRM.bluex,  \"cHRM bx\");\n      if (bluey  != NULL)\n         *bluey  = png_float(png_ptr, info_ptr->cHRM.bluey,  \"cHRM by\");\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 525,
      "line_end": 556,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cHRM_XYZ",
      "clean_name": "png_get_cHRM_XYZ",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_cHRM_XYZ(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *red_X, double *red_Y, double *red_Z, double *green_X,\n    double *green_Y, double *green_Z, double *blue_X, double *blue_Y,\n    double *blue_Z)\n{\n   png_XYZ XYZ;\n   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0 &&\n       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n   {\n      if (red_X != NULL)\n         *red_X = png_float(png_ptr, XYZ.red_X, \"cHRM red X\");\n      if (red_Y != NULL)\n         *red_Y = png_float(png_ptr, XYZ.red_Y, \"cHRM red Y\");\n      if (red_Z != NULL)\n         *red_Z = png_float(png_ptr, XYZ.red_Z, \"cHRM red Z\");\n      if (green_X != NULL)\n         *green_X = png_float(png_ptr, XYZ.green_X, \"cHRM green X\");\n      if (green_Y != NULL)\n         *green_Y = png_float(png_ptr, XYZ.green_Y, \"cHRM green Y\");\n      if (green_Z != NULL)\n         *green_Z = png_float(png_ptr, XYZ.green_Z, \"cHRM green Z\");\n      if (blue_X != NULL)\n         *blue_X = png_float(png_ptr, XYZ.blue_X, \"cHRM blue X\");\n      if (blue_Y != NULL)\n         *blue_Y = png_float(png_ptr, XYZ.blue_Y, \"cHRM blue Y\");\n      if (blue_Z != NULL)\n         *blue_Z = png_float(png_ptr, XYZ.blue_Z, \"cHRM blue Z\");\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 558,
      "line_end": 593,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cHRM_XYZ_fixed",
      "clean_name": "png_get_cHRM_XYZ_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,\n    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,\n    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,\n    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,\n    png_fixed_point *int_blue_Z)\n{\n   png_XYZ XYZ;\n   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0U &&\n       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n   {\n      if (int_red_X != NULL) *int_red_X = XYZ.red_X;\n      if (int_red_Y != NULL) *int_red_Y = XYZ.red_Y;\n      if (int_red_Z != NULL) *int_red_Z = XYZ.red_Z;\n      if (int_green_X != NULL) *int_green_X = XYZ.green_X;\n      if (int_green_Y != NULL) *int_green_Y = XYZ.green_Y;\n      if (int_green_Z != NULL) *int_green_Z = XYZ.green_Z;\n      if (int_blue_X != NULL) *int_blue_X = XYZ.blue_X;\n      if (int_blue_Y != NULL) *int_blue_Y = XYZ.blue_Y;\n      if (int_blue_Z != NULL) *int_blue_Z = XYZ.blue_Z;\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 597,
      "line_end": 625,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 65,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cHRM_fixed",
      "clean_name": "png_get_cHRM_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_cHRM_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *whitex, png_fixed_point *whitey, png_fixed_point *redx,\n    png_fixed_point *redy, png_fixed_point *greenx, png_fixed_point *greeny,\n    png_fixed_point *bluex, png_fixed_point *bluey)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n\n   /* PNGv3: this just returns the values store from the cHRM, if any. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n   {\n      if (whitex != NULL) *whitex = info_ptr->cHRM.whitex;\n      if (whitey != NULL) *whitey = info_ptr->cHRM.whitey;\n      if (redx   != NULL) *redx   = info_ptr->cHRM.redx;\n      if (redy   != NULL) *redy   = info_ptr->cHRM.redy;\n      if (greenx != NULL) *greenx = info_ptr->cHRM.greenx;\n      if (greeny != NULL) *greeny = info_ptr->cHRM.greeny;\n      if (bluex  != NULL) *bluex  = info_ptr->cHRM.bluex;\n      if (bluey  != NULL) *bluey  = info_ptr->cHRM.bluey;\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 627,
      "line_end": 651,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_gAMA_fixed",
      "clean_name": "png_get_gAMA_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_gAMA_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_gAMA_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *file_gamma)\n{\n   png_debug1(1, \"in %s retrieval function\", \"gAMA\");\n\n   /* PNGv3 compatibility: only report gAMA if it is really present. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n   {\n      if (file_gamma != NULL) *file_gamma = info_ptr->gamma;\n      return PNG_INFO_gAMA;\n   }\n\n   return 0;\n}\n",
      "line_start": 657,
      "line_end": 672,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_gAMA",
      "clean_name": "png_get_gAMA",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_gAMA(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *file_gamma)\n{\n   png_debug1(1, \"in %s retrieval function\", \"gAMA(float)\");\n\n   /* PNGv3 compatibility: only report gAMA if it is really present. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n   {\n      if (file_gamma != NULL)\n         *file_gamma = png_float(png_ptr, info_ptr->gamma, \"gAMA\");\n\n      return PNG_INFO_gAMA;\n   }\n\n   return 0;\n}\n",
      "line_start": 676,
      "line_end": 693,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sRGB",
      "clean_name": "png_get_sRGB",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#  endif\n#endif\n\n#ifdef PNG_sRGB_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sRGB(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *file_srgb_intent)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sRGB\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n      (info_ptr->valid & PNG_INFO_sRGB) != 0)\n   {\n      if (file_srgb_intent != NULL)\n         *file_srgb_intent = info_ptr->rendering_intent;\n      return PNG_INFO_sRGB;\n   }\n\n   return 0;\n}\n",
      "line_start": 698,
      "line_end": 713,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_iCCP",
      "clean_name": "png_get_iCCP",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\npng_uint_32 PNGAPI\npng_get_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_charpp name, int *compression_type,\n    png_bytepp profile, png_uint_32 *proflen)\n{\n   png_debug1(1, \"in %s retrieval function\", \"iCCP\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_iCCP) != 0 &&\n       name != NULL && profile != NULL && proflen != NULL)\n   {\n      *name = info_ptr->iccp_name;\n      *profile = info_ptr->iccp_profile;\n      *proflen = png_get_uint_32(info_ptr->iccp_profile);\n      /* This is somewhat irrelevant since the profile data returned has\n       * actually been uncompressed.\n       */\n      if (compression_type != NULL)\n         *compression_type = PNG_COMPRESSION_TYPE_BASE;\n      return PNG_INFO_iCCP;\n   }\n\n   return 0;\n\n}\n",
      "line_start": 717,
      "line_end": 741,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sPLT",
      "clean_name": "png_get_sPLT",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\nint PNGAPI\npng_get_sPLT(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_sPLT_tpp spalettes)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sPLT\");\n\n   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)\n   {\n      *spalettes = info_ptr->splt_palettes;\n      return info_ptr->splt_palettes_num;\n   }\n\n   return 0;\n}\n",
      "line_start": 745,
      "line_end": 758,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cICP",
      "clean_name": "png_get_cICP",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_cICP_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cICP(png_const_structrp png_ptr,\n             png_const_inforp info_ptr, png_bytep colour_primaries,\n             png_bytep transfer_function, png_bytep matrix_coefficients,\n             png_bytep video_full_range_flag)\n{\n    png_debug1(1, \"in %s retrieval function\", \"cICP\");\n\n    if (png_ptr != NULL && info_ptr != NULL &&\n        (info_ptr->valid & PNG_INFO_cICP) != 0 &&\n        colour_primaries != NULL && transfer_function != NULL &&\n        matrix_coefficients != NULL && video_full_range_flag != NULL)\n    {\n        *colour_primaries = info_ptr->cicp_colour_primaries;\n        *transfer_function = info_ptr->cicp_transfer_function;\n        *matrix_coefficients = info_ptr->cicp_matrix_coefficients;\n        *video_full_range_flag = info_ptr->cicp_video_full_range_flag;\n        return (PNG_INFO_cICP);\n    }\n\n    return 0;\n}\n",
      "line_start": 762,
      "line_end": 783,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cLLI_fixed",
      "clean_name": "png_get_cLLI_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_cLLI_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cLLI_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32p maxCLL,\n    png_uint_32p maxFALL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cLLI\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n   {\n      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL;\n      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL;\n      return PNG_INFO_cLLI;\n   }\n\n   return 0;\n}\n",
      "line_start": 788,
      "line_end": 804,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_cLLI",
      "clean_name": "png_get_cLLI",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cLLI(png_const_structrp png_ptr, png_const_inforp info_ptr,\n      double *maxCLL, double *maxFALL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cLLI(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n   {\n      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL * .0001;\n      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL * .0001;\n      return PNG_INFO_cLLI;\n   }\n\n   return 0;\n}\n",
      "line_start": 808,
      "line_end": 823,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_mDCV_fixed",
      "clean_name": "png_get_mDCV_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* cLLI */\n\n#ifdef PNG_mDCV_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_mDCV_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *white_x, png_fixed_point *white_y,\n    png_fixed_point *red_x, png_fixed_point *red_y,\n    png_fixed_point *green_x, png_fixed_point *green_y,\n    png_fixed_point *blue_x, png_fixed_point *blue_y,\n    png_uint_32p mastering_maxDL, png_uint_32p mastering_minDL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"mDCV\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n   {\n      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * 2;\n      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * 2;\n      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * 2;\n      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * 2;\n      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * 2;\n      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * 2;\n      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * 2;\n      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * 2;\n      if (mastering_maxDL != NULL) *mastering_maxDL = info_ptr->mastering_maxDL;\n      if (mastering_minDL != NULL) *mastering_minDL = info_ptr->mastering_minDL;\n      return PNG_INFO_mDCV;\n   }\n\n   return 0;\n}\n",
      "line_start": 829,
      "line_end": 856,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_mDCV",
      "clean_name": "png_get_mDCV",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_mDCV(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *white_x, double *white_y, double *red_x, double *red_y,\n    double *green_x, double *green_y, double *blue_x, double *blue_y,\n    double *mastering_maxDL, double *mastering_minDL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"mDCV(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n   {\n      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * .00002;\n      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * .00002;\n      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * .00002;\n      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * .00002;\n      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * .00002;\n      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * .00002;\n      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * .00002;\n      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * .00002;\n      if (mastering_maxDL != NULL)\n         *mastering_maxDL = info_ptr->mastering_maxDL * .0001;\n      if (mastering_minDL != NULL)\n         *mastering_minDL = info_ptr->mastering_minDL * .0001;\n      return PNG_INFO_mDCV;\n   }\n\n   return 0;\n}\n",
      "line_start": 860,
      "line_end": 887,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_eXIf",
      "clean_name": "png_get_eXIf",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#  endif /* FLOATING_POINT */\n#endif /* mDCV */\n\n#ifdef PNG_eXIf_SUPPORTED\npng_uint_32 PNGAPI\npng_get_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep *exif)\n{\n  png_warning(png_ptr, \"png_get_eXIf does not work; use png_get_eXIf_1\");\n  PNG_UNUSED(info_ptr)\n  PNG_UNUSED(exif)\n  return 0;\n}\n",
      "line_start": 892,
      "line_end": 900,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_eXIf_1",
      "clean_name": "png_get_eXIf_1",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "  PNG_UNUSED(exif)\n  return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_eXIf_1(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *num_exif, png_bytep *exif)\n{\n   png_debug1(1, \"in %s retrieval function\", \"eXIf\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_eXIf) != 0 && exif != NULL)\n   {\n      *num_exif = info_ptr->num_exif;\n      *exif = info_ptr->exif;\n      return PNG_INFO_eXIf;\n   }\n\n   return 0;\n}\n",
      "line_start": 902,
      "line_end": 917,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_hIST",
      "clean_name": "png_get_hIST",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\npng_uint_32 PNGAPI\npng_get_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_uint_16p *hist)\n{\n   png_debug1(1, \"in %s retrieval function\", \"hIST\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_hIST) != 0 && hist != NULL)\n   {\n      *hist = info_ptr->hist;\n      return PNG_INFO_hIST;\n   }\n\n   return 0;\n}\n",
      "line_start": 921,
      "line_end": 935,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_oFFs",
      "clean_name": "png_get_oFFs",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 1;\n}\n\n#ifdef PNG_oFFs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_oFFs(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)\n{\n   png_debug1(1, \"in %s retrieval function\", \"oFFs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0 &&\n       offset_x != NULL && offset_y != NULL && unit_type != NULL)\n   {\n      *offset_x = info_ptr->x_offset;\n      *offset_y = info_ptr->y_offset;\n      *unit_type = (int)info_ptr->offset_unit_type;\n      return PNG_INFO_oFFs;\n   }\n\n   return 0;\n}\n",
      "line_start": 983,
      "line_end": 1000,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pCAL",
      "clean_name": "png_get_pCAL",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,\n    png_charp *units, png_charpp *params)\n{\n   png_debug1(1, \"in %s retrieval function\", \"pCAL\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pCAL) != 0 &&\n       purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&\n       nparams != NULL && units != NULL && params != NULL)\n   {\n      *purpose = info_ptr->pcal_purpose;\n      *X0 = info_ptr->pcal_X0;\n      *X1 = info_ptr->pcal_X1;\n      *type = (int)info_ptr->pcal_type;\n      *nparams = (int)info_ptr->pcal_nparams;\n      *units = info_ptr->pcal_units;\n      *params = info_ptr->pcal_params;\n      return PNG_INFO_pCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1004,
      "line_end": 1027,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sCAL_fixed",
      "clean_name": "png_get_sCAL_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#ifdef PNG_sCAL_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\n#    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \\\n         defined(PNG_FLOATING_POINT_SUPPORTED)\npng_uint_32 PNGAPI\npng_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, png_fixed_point *width, png_fixed_point *height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      /*TODO: make this work without FP support; the API is currently eliminated\n       * if neither floating point APIs nor internal floating point arithmetic\n       * are enabled.\n       */\n      *width = png_fixed(png_ptr, atof(info_ptr->scal_s_width), \"sCAL width\");\n      *height = png_fixed(png_ptr, atof(info_ptr->scal_s_height),\n          \"sCAL height\");\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1034,
      "line_end": 1055,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sCAL",
      "clean_name": "png_get_sCAL",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#    endif /* FLOATING_ARITHMETIC */\n#  endif /* FIXED_POINT */\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sCAL(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, double *width, double *height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      *width = atof(info_ptr->scal_s_width);\n      *height = atof(info_ptr->scal_s_height);\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1059,
      "line_end": 1075,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sCAL_s",
      "clean_name": "png_get_sCAL_s",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n#  endif /* FLOATING POINT */\npng_uint_32 PNGAPI\npng_get_sCAL_s(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, png_charpp width, png_charpp height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL(str)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      *width = info_ptr->scal_s_width;\n      *height = info_ptr->scal_s_height;\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1077,
      "line_end": 1093,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_pHYs",
      "clean_name": "png_get_pHYs",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif /* sCAL */\n\n#ifdef PNG_pHYs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pHYs(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (res_x != NULL)\n      {\n         *res_x = info_ptr->x_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (res_y != NULL)\n      {\n         *res_y = info_ptr->y_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (unit_type != NULL)\n      {\n         *unit_type = (int)info_ptr->phys_unit_type;\n         retval |= PNG_INFO_pHYs;\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 1097,
      "line_end": 1128,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_PLTE",
      "clean_name": "png_get_PLTE",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return retval;\n}\n#endif /* pHYs */\n\npng_uint_32 PNGAPI\npng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_colorp *palette, int *num_palette)\n{\n   png_debug1(1, \"in %s retrieval function\", \"PLTE\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_PLTE) != 0 && palette != NULL)\n   {\n      *palette = info_ptr->palette;\n      *num_palette = info_ptr->num_palette;\n      png_debug1(3, \"num_palette = %d\", *num_palette);\n      return PNG_INFO_PLTE;\n   }\n\n   return 0;\n}\n",
      "line_start": 1131,
      "line_end": 1147,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_sBIT",
      "clean_name": "png_get_sBIT",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_sBIT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_color_8p *sig_bit)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sBIT\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sBIT) != 0 && sig_bit != NULL)\n   {\n      *sig_bit = &(info_ptr->sig_bit);\n      return PNG_INFO_sBIT;\n   }\n\n   return 0;\n}\n",
      "line_start": 1150,
      "line_end": 1164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_text",
      "clean_name": "png_get_text",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_TEXT_SUPPORTED\nint PNGAPI\npng_get_text(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_textp *text_ptr, int *num_text)\n{\n   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)\n   {\n      png_debug1(1, \"in text retrieval function, chunk typeid = 0x%lx\",\n         (unsigned long)png_ptr->chunk_name);\n\n      if (text_ptr != NULL)\n         *text_ptr = info_ptr->text;\n\n      if (num_text != NULL)\n         *num_text = info_ptr->num_text;\n\n      return info_ptr->num_text;\n   }\n\n   if (num_text != NULL)\n      *num_text = 0;\n\n   return 0;\n}\n",
      "line_start": 1168,
      "line_end": 1190,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_tIME",
      "clean_name": "png_get_tIME",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tIME_SUPPORTED\npng_uint_32 PNGAPI\npng_get_tIME(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_timep *mod_time)\n{\n   png_debug1(1, \"in %s retrieval function\", \"tIME\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_tIME) != 0 && mod_time != NULL)\n   {\n      *mod_time = &(info_ptr->mod_time);\n      return PNG_INFO_tIME;\n   }\n\n   return 0;\n}\n",
      "line_start": 1194,
      "line_end": 1208,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_tRNS",
      "clean_name": "png_get_tRNS",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\npng_uint_32 PNGAPI\npng_get_tRNS(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"tRNS\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_tRNS) != 0)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (trans_alpha != NULL)\n         {\n            *trans_alpha = info_ptr->trans_alpha;\n            retval |= PNG_INFO_tRNS;\n         }\n\n         if (trans_color != NULL)\n            *trans_color = &(info_ptr->trans_color);\n      }\n\n      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */\n      {\n         if (trans_color != NULL)\n         {\n            *trans_color = &(info_ptr->trans_color);\n            retval |= PNG_INFO_tRNS;\n         }\n\n         if (trans_alpha != NULL)\n            *trans_alpha = NULL;\n      }\n\n      if (num_trans != NULL)\n      {\n         *num_trans = info_ptr->num_trans;\n         retval |= PNG_INFO_tRNS;\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 1212,
      "line_end": 1255,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_unknown_chunks",
      "clean_name": "png_get_unknown_chunks",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\nint PNGAPI\npng_get_unknown_chunks(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_unknown_chunkpp unknowns)\n{\n   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)\n   {\n      *unknowns = info_ptr->unknown_chunks;\n      return info_ptr->unknown_chunks_num;\n   }\n\n   return 0;\n}\n",
      "line_start": 1259,
      "line_end": 1270,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_rgb_to_gray_status",
      "clean_name": "png_get_rgb_to_gray_status",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\npng_byte PNGAPI\npng_get_rgb_to_gray_status(png_const_structrp png_ptr)\n{\n   return (png_byte)(png_ptr ? png_ptr->rgb_to_gray_status : 0);\n}\n",
      "line_start": 1274,
      "line_end": 1278,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_user_chunk_ptr",
      "clean_name": "png_get_user_chunk_ptr",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_USER_CHUNKS_SUPPORTED\npng_voidp PNGAPI\npng_get_user_chunk_ptr(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);\n}\n",
      "line_start": 1282,
      "line_end": 1286,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_compression_buffer_size",
      "clean_name": "png_get_compression_buffer_size",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);\n}\n#endif\n\nsize_t PNGAPI\npng_get_compression_buffer_size(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return 0;\n\n#ifdef PNG_WRITE_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n#endif\n   {\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n      return png_ptr->IDAT_read_size;\n#else\n      return PNG_IDAT_READ_SIZE;\n#endif\n   }\n\n#ifdef PNG_WRITE_SUPPORTED\n   else\n      return png_ptr->zbuffer_size;\n#endif\n}\n",
      "line_start": 1289,
      "line_end": 1310,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_user_width_max",
      "clean_name": "png_get_user_width_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n/* These functions were added to libpng 1.2.6 and were enabled\n * by default in libpng-1.4.0 */\npng_uint_32 PNGAPI\npng_get_user_width_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_width_max : 0);\n}\n",
      "line_start": 1315,
      "line_end": 1319,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_user_height_max",
      "clean_name": "png_get_user_height_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return (png_ptr ? png_ptr->user_width_max : 0);\n}\n\npng_uint_32 PNGAPI\npng_get_user_height_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_height_max : 0);\n}\n",
      "line_start": 1321,
      "line_end": 1325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_chunk_cache_max",
      "clean_name": "png_get_chunk_cache_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_height_max : 0);\n}\n\n/* This function was added to libpng 1.4.0 */\npng_uint_32 PNGAPI\npng_get_chunk_cache_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);\n}\n",
      "line_start": 1328,
      "line_end": 1332,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_chunk_malloc_max",
      "clean_name": "png_get_chunk_malloc_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);\n}\n\n/* This function was added to libpng 1.4.1 */\npng_alloc_size_t PNGAPI\npng_get_chunk_malloc_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);\n}\n",
      "line_start": 1335,
      "line_end": 1339,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_io_state",
      "clean_name": "png_get_io_state",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* SET_USER_LIMITS */\n\n/* These functions were added to libpng 1.4.0 */\n#ifdef PNG_IO_STATE_SUPPORTED\npng_uint_32 PNGAPI\npng_get_io_state(png_const_structrp png_ptr)\n{\n   return png_ptr->io_state;\n}\n",
      "line_start": 1344,
      "line_end": 1348,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_io_chunk_type",
      "clean_name": "png_get_io_chunk_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return png_ptr->io_state;\n}\n\npng_uint_32 PNGAPI\npng_get_io_chunk_type(png_const_structrp png_ptr)\n{\n   return png_ptr->chunk_name;\n}\n",
      "line_start": 1350,
      "line_end": 1354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_palette_max",
      "clean_name": "png_get_palette_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* IO_STATE */\n\n#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\n#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED\nint PNGAPI\npng_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return png_ptr->num_palette_max;\n\n   return -1;\n}\n",
      "line_start": 1359,
      "line_end": 1366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngget.c:ppi_from_ppm",
      "clean_name": "ppi_from_ppm",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_INCH_CONVERSIONS_SUPPORTED\nstatic png_uint_32\nppi_from_ppm(png_uint_32 ppm)\n{\n#if 0\n   /* The conversion is *(2.54/100), in binary (32 digits):\n    * .00000110100000001001110101001001\n    */\n   png_uint_32 t1001, t1101;\n   ppm >>= 1;                  /* .1 */\n   t1001 = ppm + (ppm >> 3);   /* .1001 */\n   t1101 = t1001 + (ppm >> 1); /* .1101 */\n   ppm >>= 20;                 /* .000000000000000000001 */\n   t1101 += t1101 >> 15;       /* .1101000000000001101 */\n   t1001 >>= 11;               /* .000000000001001 */\n   t1001 += t1001 >> 12;       /* .000000000001001000000001001 */\n   ppm += t1001;               /* .000000000001001000001001001 */\n   ppm += t1101;               /* .110100000001001110101001001 */\n   return (ppm + 16) >> 5;/* .00000110100000001001110101001001 */\n#else\n   /* The argument is a PNG unsigned integer, so it is not permitted\n    * to be bigger than 2^31.\n    */\n   png_fixed_point result;\n   if (ppm <= PNG_UINT_31_MAX && png_muldiv(&result, (png_int_32)ppm, 127,\n       5000) != 0)\n      return (png_uint_32)result;\n\n   /* Overflow. */\n   return 0;\n#endif\n}\n",
      "line_start": 324,
      "line_end": 354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngget.c:png_fixed_inches_from_microns",
      "clean_name": "png_fixed_inches_from_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));\n}\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\nstatic png_fixed_point\npng_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)\n{\n   /* Convert from meters * 1,000,000 to inches * 100,000, meters to\n    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.\n    * Notice that this can overflow - a warning is output and 0 is\n    * returned.\n    */\n   png_fixed_point result;\n\n   if (png_muldiv(&result, microns, 500, 127) != 0)\n      return result;\n\n   png_warning(png_ptr, \"fixed point overflow ignored\");\n   return 0;\n}\n",
      "line_start": 375,
      "line_end": 390,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_malloc_array",
      "clean_name": "png_malloc_array",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "   /* The failure case when the request is too large */\n   return NULL;\n}\n\nPNG_FUNCTION(png_voidp /* PRIVATE */,\npng_malloc_array,(png_const_structrp png_ptr, int nelements,\n    size_t element_size),PNG_ALLOCATED)\n{\n   if (nelements <= 0 || element_size == 0)\n      png_error(png_ptr, \"internal error: array alloc\");\n\n   return png_malloc_array_checked(png_ptr, nelements, element_size);\n}\n",
      "line_start": 119,
      "line_end": 127,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_malloc_default",
      "clean_name": "png_malloc_default",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "   return ret;\n}\n\n#ifdef PNG_USER_MEM_SUPPORTED\nPNG_FUNCTION(png_voidp,PNGAPI\npng_malloc_default,(png_const_structrp png_ptr, png_alloc_size_t size),\n    PNG_ALLOCATED PNG_DEPRECATED)\n{\n   png_voidp ret;\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   /* Passing 'NULL' here bypasses the application provided memory handler. */\n   ret = png_malloc_base(NULL/*use malloc*/, size);\n\n   if (ret == NULL)\n      png_error(png_ptr, \"Out of Memory\"); /* 'M' means png_malloc_default */\n\n   return ret;\n}\n",
      "line_start": 186,
      "line_end": 202,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_mem_ptr",
      "clean_name": "png_get_mem_ptr",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "/* This function returns a pointer to the mem_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\npng_voidp PNGAPI\npng_get_mem_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return png_ptr->mem_ptr;\n}\n",
      "line_start": 273,
      "line_end": 280,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_start_read_image",
      "clean_name": "png_start_read_image",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * are set, but before any reading takes place.  This allows\n * the user to obtain a gamma-corrected palette, for example.\n * If the user doesn't call this, we will do it ourselves.\n */\nvoid PNGAPI\npng_start_read_image(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_start_read_image\");\n\n   if (png_ptr != NULL)\n   {\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n         png_read_start_row(png_ptr);\n\n      /* New in 1.6.0 this avoids the bug of doing the initializations twice */\n      else\n         png_app_error(png_ptr,\n             \"png_start_read_image/png_read_update_info: duplicate call\");\n   }\n}\n",
      "line_start": 200,
      "line_end": 215,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_read_rows",
      "clean_name": "png_read_rows",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " *\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\n */\n\nvoid PNGAPI\npng_read_rows(png_structrp png_ptr, png_bytepp row,\n    png_bytepp display_row, png_uint_32 num_rows)\n{\n   png_uint_32 i;\n   png_bytepp rp;\n   png_bytepp dp;\n\n   png_debug(1, \"in png_read_rows\");\n\n   if (png_ptr == NULL)\n      return;\n\n   rp = row;\n   dp = display_row;\n   if (rp != NULL && dp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep rptr = *rp++;\n         png_bytep dptr = *dp++;\n\n         png_read_row(png_ptr, rptr, dptr);\n      }\n\n   else if (rp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep rptr = *rp;\n         png_read_row(png_ptr, rptr, NULL);\n         rp++;\n      }\n\n   else if (dp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep dptr = *dp;\n         png_read_row(png_ptr, NULL, dptr);\n         dp++;\n      }\n}\n",
      "line_start": 551,
      "line_end": 590,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_read_image",
      "clean_name": "png_read_image",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * each pass of a interlaced image, use png_read_rows() instead.\n *\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\n */\nvoid PNGAPI\npng_read_image(png_structrp png_ptr, png_bytepp image)\n{\n   png_uint_32 i, image_height;\n   int pass, j;\n   png_bytepp rp;\n\n   png_debug(1, \"in png_read_image\");\n\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n   {\n      pass = png_set_interlace_handling(png_ptr);\n      /* And make sure transforms are initialized. */\n      png_start_read_image(png_ptr);\n   }\n   else\n   {\n      if (png_ptr->interlaced != 0 &&\n          (png_ptr->transformations & PNG_INTERLACE) == 0)\n      {\n         /* Caller called png_start_read_image or png_read_update_info without\n          * first turning on the PNG_INTERLACE transform.  We can fix this here,\n          * but the caller should do it!\n          */\n         png_warning(png_ptr, \"Interlace handling should be turned on when \"\n             \"using png_read_image\");\n         /* Make sure this is set correctly */\n         png_ptr->num_rows = png_ptr->height;\n      }\n\n      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in\n       * the above error case.\n       */\n      pass = png_set_interlace_handling(png_ptr);\n   }\n#else\n   if (png_ptr->interlaced)\n      png_error(png_ptr,\n          \"Cannot read interlaced image -- interlace handler disabled\");\n\n   pass = 1;\n#endif\n\n   image_height=png_ptr->height;\n\n   for (j = 0; j < pass; j++)\n   {\n      rp = image;\n      for (i = 0; i < image_height; i++)\n      {\n         png_read_row(png_ptr, *rp, NULL);\n         rp++;\n      }\n   }\n}\n",
      "line_start": 606,
      "line_end": 664,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_read_status_fn",
      "clean_name": "png_set_read_status_fn",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   png_read_destroy(png_ptr);\n   png_destroy_png_struct(png_ptr);\n}\n\nvoid PNGAPI\npng_set_read_status_fn(png_structrp png_ptr, png_read_status_ptr read_row_fn)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->read_row_fn = read_row_fn;\n}\n",
      "line_start": 856,
      "line_end": 863,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_read_png",
      "clean_name": "png_read_png",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n#ifdef PNG_INFO_IMAGE_SUPPORTED\nvoid PNGAPI\npng_read_png(png_structrp png_ptr, png_inforp info_ptr,\n    int transforms, voidp params)\n{\n   png_debug(1, \"in png_read_png\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* png_read_info() gives us all of the information from the\n    * PNG file before the first IDAT (image data chunk).\n    */\n   png_read_info(png_ptr, info_ptr);\n   if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))\n      png_error(png_ptr, \"Image is too high to process with png_read_png()\");\n\n   /* -------------- image transformations start here ------------------- */\n   /* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM\n    * is not implemented.  This will only happen in de-configured (non-default)\n    * libpng builds.  The results can be unexpected - png_read_png may return\n    * short or mal-formed rows because the transform is skipped.\n    */\n\n   /* Tell libpng to strip 16-bit/color files down to 8 bits per color.\n    */\n   if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)\n      /* Added at libpng-1.5.4. \"strip_16\" produces the same result that it\n       * did in earlier versions, while \"scale_16\" is now more accurate.\n       */\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n      png_set_scale_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SCALE_16 not supported\");\n#endif\n\n   /* If both SCALE and STRIP are required pngrtran will effectively cancel the\n    * latter by doing SCALE first.  This is ok and allows apps not to check for\n    * which is supported to get the right answer.\n    */\n   if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n      png_set_strip_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_16 not supported\");\n#endif\n\n   /* Strip alpha bytes from the input data without combining with\n    * the background (not recommended).\n    */\n   if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n      png_set_strip_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_ALPHA not supported\");\n#endif\n\n   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single\n    * byte into separate bytes (useful for paletted and grayscale images).\n    */\n   if ((transforms & PNG_TRANSFORM_PACKING) != 0)\n#ifdef PNG_READ_PACK_SUPPORTED\n      png_set_packing(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKING not supported\");\n#endif\n\n   /* Change the order of packed pixels to least significant bit first\n    * (not useful if you are using png_set_packing).\n    */\n   if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n      png_set_packswap(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKSWAP not supported\");\n#endif\n\n   /* Expand paletted colors into true RGB triplets\n    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel\n    * Expand paletted or RGB images with transparency to full alpha\n    * channels so the data will be available as RGBA quartets.\n    */\n   if ((transforms & PNG_TRANSFORM_EXPAND) != 0)\n#ifdef PNG_READ_EXPAND_SUPPORTED\n      png_set_expand(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND not supported\");\n#endif\n\n   /* We don't handle background color or gamma transformation or quantizing.\n    */\n\n   /* Invert monochrome files to have 0 as white and 1 as black\n    */\n   if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)\n#ifdef PNG_READ_INVERT_SUPPORTED\n      png_set_invert_mono(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_MONO not supported\");\n#endif\n\n   /* If you want to shift the pixel values from the range [0,255] or\n    * [0,65535] to the original [0,7] or [0,31], or whatever range the\n    * colors were originally in:\n    */\n   if ((transforms & PNG_TRANSFORM_SHIFT) != 0)\n#ifdef PNG_READ_SHIFT_SUPPORTED\n      if ((info_ptr->valid & PNG_INFO_sBIT) != 0)\n         png_set_shift(png_ptr, &info_ptr->sig_bit);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SHIFT not supported\");\n#endif\n\n   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */\n   if ((transforms & PNG_TRANSFORM_BGR) != 0)\n#ifdef PNG_READ_BGR_SUPPORTED\n      png_set_bgr(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_BGR not supported\");\n#endif\n\n   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */\n   if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\n      png_set_swap_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ALPHA not supported\");\n#endif\n\n   /* Swap bytes of 16-bit files to least significant byte first */\n   if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)\n#ifdef PNG_READ_SWAP_SUPPORTED\n      png_set_swap(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ENDIAN not supported\");\n#endif\n\n/* Added at libpng-1.2.41 */\n   /* Invert the alpha channel from opacity to transparency */\n   if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\n      png_set_invert_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_ALPHA not supported\");\n#endif\n\n/* Added at libpng-1.2.41 */\n   /* Expand grayscale image to RGB */\n   if ((transforms & PNG_TRANSFORM_GRAY_TO_RGB) != 0)\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n      png_set_gray_to_rgb(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_GRAY_TO_RGB not supported\");\n#endif\n\n/* Added at libpng-1.5.4 */\n   if ((transforms & PNG_TRANSFORM_EXPAND_16) != 0)\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n      png_set_expand_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND_16 not supported\");\n#endif\n\n   /* We don't handle adding filler bytes */\n\n   /* We use png_read_image and rely on that for interlace handling, but we also\n    * call png_read_update_info therefore must turn on interlace handling now:\n    */\n   (void)png_set_interlace_handling(png_ptr);\n\n   /* Optional call to gamma correct and add the background to the palette\n    * and update info structure.  REQUIRED if you are expecting libpng to\n    * update the palette for you (i.e., you selected such a transform above).\n    */\n   png_read_update_info(png_ptr, info_ptr);\n\n   /* -------------- image transformations end here ------------------- */\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n   if (info_ptr->row_pointers == NULL)\n   {\n      png_uint_32 iptr;\n\n      info_ptr->row_pointers = png_voidcast(png_bytepp, png_malloc(png_ptr,\n          info_ptr->height * (sizeof (png_bytep))));\n\n      for (iptr=0; iptr<info_ptr->height; iptr++)\n         info_ptr->row_pointers[iptr] = NULL;\n\n      info_ptr->free_me |= PNG_FREE_ROWS;\n\n      for (iptr = 0; iptr < info_ptr->height; iptr++)\n         info_ptr->row_pointers[iptr] = png_voidcast(png_bytep,\n             png_malloc(png_ptr, info_ptr->rowbytes));\n   }\n\n   png_read_image(png_ptr, info_ptr->row_pointers);\n   info_ptr->valid |= PNG_INFO_IDAT;\n\n   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */\n   png_read_end(png_ptr, info_ptr);\n\n   PNG_UNUSED(params)\n}\n",
      "line_start": 868,
      "line_end": 1070,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 190,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngread.c:png_do_read_intrapixel",
      "clean_name": "png_do_read_intrapixel",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "#ifdef PNG_MNG_FEATURES_SUPPORTED\n/* Undoes intrapixel differencing,\n * NOTE: this is apparently only supported in the 'sequential' reader.\n */\nstatic void\npng_do_read_intrapixel(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_read_intrapixel\");\n\n   if (\n       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      int bytes_per_pixel;\n      png_uint_32 row_width = row_info->width;\n\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep rp;\n         png_uint_32 i;\n\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n            bytes_per_pixel = 3;\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            bytes_per_pixel = 4;\n\n         else\n            return;\n\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\n         {\n            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);\n            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);\n         }\n      }\n      else if (row_info->bit_depth == 16)\n      {\n         png_bytep rp;\n         png_uint_32 i;\n\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n            bytes_per_pixel = 6;\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            bytes_per_pixel = 8;\n\n         else\n            return;\n\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\n         {\n            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);\n            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);\n            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);\n            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;\n            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;\n            *(rp    ) = (png_byte)((red >> 8) & 0xff);\n            *(rp + 1) = (png_byte)(red & 0xff);\n            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);\n            *(rp + 5) = (png_byte)(blue & 0xff);\n         }\n      }\n   }\n}\n",
      "line_start": 223,
      "line_end": 282,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 78,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_colormap",
      "clean_name": "png_image_read_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "/* Return a palette index to the above palette given three 8-bit sRGB values. */\n#define PNG_RGB_INDEX(r,g,b) \\\n   ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))\n\nstatic int\npng_image_read_colormap(png_voidp argument)\n{\n   png_image_read_control *display =\n      png_voidcast(png_image_read_control*, argument);\n   png_imagep image = display->image;\n\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_uint_32 output_format = image->format;\n   int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) != 0 ?\n      P_LINEAR : P_sRGB;\n\n   unsigned int cmap_entries;\n   unsigned int output_processing;        /* Output processing option */\n   unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */\n\n   /* Background information; the background color and the index of this color\n    * in the color-map if it exists (else 256).\n    */\n   unsigned int background_index = 256;\n   png_uint_32 back_r, back_g, back_b;\n\n   /* Flags to accumulate things that need to be done to the input. */\n   int expand_tRNS = 0;\n\n   /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is\n    * very difficult to do, the results look awful, and it is difficult to see\n    * what possible use it is because the application can't control the\n    * color-map.\n    */\n   if (((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0 ||\n         png_ptr->num_trans > 0) /* alpha in input */ &&\n      ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0) /* no alpha in output */)\n   {\n      if (output_encoding == P_LINEAR) /* compose on black */\n         back_b = back_g = back_r = 0;\n\n      else if (display->background == NULL /* no way to remove it */)\n         png_error(png_ptr,\n             \"background color must be supplied to remove alpha/transparency\");\n\n      /* Get a copy of the background color (this avoids repeating the checks\n       * below.)  The encoding is 8-bit sRGB or 16-bit linear, depending on the\n       * output format.\n       */\n      else\n      {\n         back_g = display->background->green;\n         if ((output_format & PNG_FORMAT_FLAG_COLOR) != 0)\n         {\n            back_r = display->background->red;\n            back_b = display->background->blue;\n         }\n         else\n            back_b = back_r = back_g;\n      }\n   }\n\n   else if (output_encoding == P_LINEAR)\n      back_b = back_r = back_g = 65535;\n\n   else\n      back_b = back_r = back_g = 255;\n\n   /* Default the input file gamma if required - this is necessary because\n    * libpng assumes that if no gamma information is present the data is in the\n    * output format, but the simplified API deduces the gamma from the input\n    * format.  The 'default' gamma value is also set by png_set_alpha_mode, but\n    * this is happening before any such call, so:\n    *\n    * TODO: should be an internal API and all this code should be copied into a\n    * single common gamma+colorspace file.\n    */\n   if (png_ptr->bit_depth == 16 &&\n      (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n      png_ptr->default_gamma = PNG_GAMMA_LINEAR;\n\n   else\n      png_ptr->default_gamma = PNG_GAMMA_sRGB_INVERSE;\n\n   /* Decide what to do based on the PNG color type of the input data.  The\n    * utility function png_create_colormap_entry deals with most aspects of the\n    * output transformations; this code works out how to produce bytes of\n    * color-map entries from the original format.\n    */\n   switch (png_ptr->color_type)\n   {\n      case PNG_COLOR_TYPE_GRAY:\n         if (png_ptr->bit_depth <= 8)\n         {\n            /* There at most 256 colors in the output, regardless of\n             * transparency.\n             */\n            unsigned int step, i, val, trans = 256/*ignore*/, back_alpha = 0;\n\n            cmap_entries = 1U << png_ptr->bit_depth;\n            if (cmap_entries > image->colormap_entries)\n               png_error(png_ptr, \"gray[8] color-map: too few entries\");\n\n            step = 255 / (cmap_entries - 1);\n            output_processing = PNG_CMAP_NONE;\n\n            /* If there is a tRNS chunk then this either selects a transparent\n             * value or, if the output has no alpha, the background color.\n             */\n            if (png_ptr->num_trans > 0)\n            {\n               trans = png_ptr->trans_color.gray;\n\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0)\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\n            }\n\n            /* png_create_colormap_entry just takes an RGBA and writes the\n             * corresponding color-map entry using the format from 'image',\n             * including the required conversion to sRGB or linear as\n             * appropriate.  The input values are always either sRGB (if the\n             * gamma correction flag is 0) or 0..255 scaled file encoded values\n             * (if the function must gamma correct them).\n             */\n            for (i=val=0; i<cmap_entries; ++i, val += step)\n            {\n               /* 'i' is a file value.  While this will result in duplicated\n                * entries for 8-bit non-sRGB encoded files it is necessary to\n                * have non-gamma corrected values to do tRNS handling.\n                */\n               if (i != trans)\n                  png_create_colormap_entry(display, i, val, val, val, 255,\n                      P_FILE/*8-bit with file gamma*/);\n\n               /* Else this entry is transparent.  The colors don't matter if\n                * there is an alpha channel (back_alpha == 0), but it does no\n                * harm to pass them in; the values are not set above so this\n                * passes in white.\n                *\n                * NOTE: this preserves the full precision of the application\n                * supplied background color when it is used.\n                */\n               else\n                  png_create_colormap_entry(display, i, back_r, back_g, back_b,\n                      back_alpha, output_encoding);\n            }\n\n            /* We need libpng to preserve the original encoding. */\n            data_encoding = P_FILE;\n\n            /* The rows from libpng, while technically gray values, are now also\n             * color-map indices; however, they may need to be expanded to 1\n             * byte per pixel.  This is what png_set_packing does (i.e., it\n             * unpacks the bit values into bytes.)\n             */\n            if (png_ptr->bit_depth < 8)\n               png_set_packing(png_ptr);\n         }\n\n         else /* bit depth is 16 */\n         {\n            /* The 16-bit input values can be converted directly to 8-bit gamma\n             * encoded values; however, if a tRNS chunk is present 257 color-map\n             * entries are required.  This means that the extra entry requires\n             * special processing; add an alpha channel, sacrifice gray level\n             * 254 and convert transparent (alpha==0) entries to that.\n             *\n             * Use libpng to chop the data to 8 bits.  Convert it to sRGB at the\n             * same time to minimize quality loss.  If a tRNS chunk is present\n             * this means libpng must handle it too; otherwise it is impossible\n             * to do the exact match on the 16-bit value.\n             *\n             * If the output has no alpha channel *and* the background color is\n             * gray then it is possible to let libpng handle the substitution by\n             * ensuring that the corresponding gray level matches the background\n             * color exactly.\n             */\n            data_encoding = P_sRGB;\n\n            if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n               png_error(png_ptr, \"gray[16] color-map: too few entries\");\n\n            cmap_entries = (unsigned int)make_gray_colormap(display);\n\n            if (png_ptr->num_trans > 0)\n            {\n               unsigned int back_alpha;\n\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n                  back_alpha = 0;\n\n               else\n               {\n                  if (back_r == back_g && back_g == back_b)\n                  {\n                     /* Background is gray; no special processing will be\n                      * required.\n                      */\n                     png_color_16 c;\n                     png_uint_32 gray = back_g;\n\n                     if (output_encoding == P_LINEAR)\n                     {\n                        gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                        /* And make sure the corresponding palette entry\n                         * matches.\n                         */\n                        png_create_colormap_entry(display, gray, back_g, back_g,\n                            back_g, 65535, P_LINEAR);\n                     }\n\n                     /* The background passed to libpng, however, must be the\n                      * sRGB value.\n                      */\n                     c.index = 0; /*unused*/\n                     c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n                     /* NOTE: does this work without expanding tRNS to alpha?\n                      * It should be the color->gray case below apparently\n                      * doesn't.\n                      */\n                     png_set_background_fixed(png_ptr, &c,\n                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                         0/*gamma: not used*/);\n\n                     output_processing = PNG_CMAP_NONE;\n                     break;\n                  }\n#ifdef __COVERITY__\n                 /* Coverity claims that output_encoding cannot be 2 (P_LINEAR)\n                  * here.\n                  */\n                  back_alpha = 255;\n#else\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\n#endif\n               }\n\n               /* output_processing means that the libpng-processed row will be\n                * 8-bit GA and it has to be processing to single byte color-map\n                * values.  Entry 254 is replaced by either a completely\n                * transparent entry or by the background color at full\n                * precision (and the background color is not a simple gray\n                * level in this case.)\n                */\n               expand_tRNS = 1;\n               output_processing = PNG_CMAP_TRANS;\n               background_index = 254;\n\n               /* And set (overwrite) color-map entry 254 to the actual\n                * background color at full precision.\n                */\n               png_create_colormap_entry(display, 254, back_r, back_g, back_b,\n                   back_alpha, output_encoding);\n            }\n\n            else\n               output_processing = PNG_CMAP_NONE;\n         }\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         /* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum\n          * of 65536 combinations.  If, however, the alpha channel is to be\n          * removed there are only 256 possibilities if the background is gray.\n          * (Otherwise there is a subset of the 65536 possibilities defined by\n          * the triangle between black, white and the background color.)\n          *\n          * Reduce 16-bit files to 8-bit and sRGB encode the result.  No need to\n          * worry about tRNS matching - tRNS is ignored if there is an alpha\n          * channel.\n          */\n         data_encoding = P_sRGB;\n\n         if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n         {\n            if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n               png_error(png_ptr, \"gray+alpha color-map: too few entries\");\n\n            cmap_entries = (unsigned int)make_ga_colormap(display);\n\n            background_index = PNG_CMAP_GA_BACKGROUND;\n            output_processing = PNG_CMAP_GA;\n         }\n\n         else /* alpha is removed */\n         {\n            /* Alpha must be removed as the PNG data is processed when the\n             * background is a color because the G and A channels are\n             * independent and the vector addition (non-parallel vectors) is a\n             * 2-D problem.\n             *\n             * This can be reduced to the same algorithm as above by making a\n             * colormap containing gray levels (for the opaque grays), a\n             * background entry (for a transparent pixel) and a set of four six\n             * level color values, one set for each intermediate alpha value.\n             * See the comments in make_ga_colormap for how this works in the\n             * per-pixel processing.\n             *\n             * If the background is gray, however, we only need a 256 entry gray\n             * level color map.  It is sufficient to make the entry generated\n             * for the background color be exactly the color specified.\n             */\n            if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0 ||\n               (back_r == back_g && back_g == back_b))\n            {\n               /* Background is gray; no special processing will be required. */\n               png_color_16 c;\n               png_uint_32 gray = back_g;\n\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"gray-alpha color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_gray_colormap(display);\n\n               if (output_encoding == P_LINEAR)\n               {\n                  gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                  /* And make sure the corresponding palette entry matches. */\n                  png_create_colormap_entry(display, gray, back_g, back_g,\n                      back_g, 65535, P_LINEAR);\n               }\n\n               /* The background passed to libpng, however, must be the sRGB\n                * value.\n                */\n               c.index = 0; /*unused*/\n               c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n               png_set_background_fixed(png_ptr, &c,\n                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                   0/*gamma: not used*/);\n\n               output_processing = PNG_CMAP_NONE;\n            }\n\n            else\n            {\n               png_uint_32 i, a;\n\n               /* This is the same as png_make_ga_colormap, above, except that\n                * the entries are all opaque.\n                */\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"ga-alpha color-map: too few entries\");\n\n               i = 0;\n               while (i < 231)\n               {\n                  png_uint_32 gray = (i * 256 + 115) / 231;\n                  png_create_colormap_entry(display, i++, gray, gray, gray,\n                      255, P_sRGB);\n               }\n\n               /* NOTE: this preserves the full precision of the application\n                * background color.\n                */\n               background_index = i;\n               png_create_colormap_entry(display, i++, back_r, back_g, back_b,\n#ifdef __COVERITY__\n                   /* Coverity claims that output_encoding\n                    * cannot be 2 (P_LINEAR) here.\n                    */ 255U,\n#else\n                    output_encoding == P_LINEAR ? 65535U : 255U,\n#endif\n                    output_encoding);\n\n               /* For non-opaque input composite on the sRGB background - this\n                * requires inverting the encoding for each component.  The input\n                * is still converted to the sRGB encoding because this is a\n                * reasonable approximate to the logarithmic curve of human\n                * visual sensitivity, at least over the narrow range which PNG\n                * represents.  Consequently 'G' is always sRGB encoded, while\n                * 'A' is linear.  We need the linear background colors.\n                */\n               if (output_encoding == P_sRGB) /* else already linear */\n               {\n                  /* This may produce a value not exactly matching the\n                   * background, but that's ok because these numbers are only\n                   * used when alpha != 0\n                   */\n                  back_r = png_sRGB_table[back_r];\n                  back_g = png_sRGB_table[back_g];\n                  back_b = png_sRGB_table[back_b];\n               }\n\n               for (a=1; a<5; ++a)\n               {\n                  unsigned int g;\n\n                  /* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled\n                   * by an 8-bit alpha value (0..255).\n                   */\n                  png_uint_32 alpha = 51 * a;\n                  png_uint_32 back_rx = (255-alpha) * back_r;\n                  png_uint_32 back_gx = (255-alpha) * back_g;\n                  png_uint_32 back_bx = (255-alpha) * back_b;\n\n                  for (g=0; g<6; ++g)\n                  {\n                     png_uint_32 gray = png_sRGB_table[g*51] * alpha;\n\n                     png_create_colormap_entry(display, i++,\n                         PNG_sRGB_FROM_LINEAR(gray + back_rx),\n                         PNG_sRGB_FROM_LINEAR(gray + back_gx),\n                         PNG_sRGB_FROM_LINEAR(gray + back_bx), 255, P_sRGB);\n                  }\n               }\n\n               cmap_entries = i;\n               output_processing = PNG_CMAP_GA;\n            }\n         }\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         /* Exclude the case where the output is gray; we can always handle this\n          * with the cases above.\n          */\n         if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0)\n         {\n            /* The color-map will be grayscale, so we may as well convert the\n             * input RGB values to a simple grayscale and use the grayscale\n             * code above.\n             *\n             * NOTE: calling this apparently damages the recognition of the\n             * transparent color in background color handling; call\n             * png_set_tRNS_to_alpha before png_set_background_fixed.\n             */\n            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE, -1,\n                -1);\n            data_encoding = P_sRGB;\n\n            /* The output will now be one or two 8-bit gray or gray+alpha\n             * channels.  The more complex case arises when the input has alpha.\n             */\n            if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n               png_ptr->num_trans > 0) &&\n               (output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n            {\n               /* Both input and output have an alpha channel, so no background\n                * processing is required; just map the GA bytes to the right\n                * color-map entry.\n                */\n               expand_tRNS = 1;\n\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb[ga] color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_ga_colormap(display);\n               background_index = PNG_CMAP_GA_BACKGROUND;\n               output_processing = PNG_CMAP_GA;\n            }\n\n            else\n            {\n               const png_fixed_point gamma = png_resolve_file_gamma(png_ptr);\n\n               /* Either the input or the output has no alpha channel, so there\n                * will be no non-opaque pixels in the color-map; it will just be\n                * grayscale.\n                */\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb[gray] color-map: too few entries\");\n\n               /* Ideally this code would use libpng to do the gamma correction,\n                * but if an input alpha channel is to be removed we will hit the\n                * libpng bug in gamma+compose+rgb-to-gray (the double gamma\n                * correction bug).  Fix this by dropping the gamma correction in\n                * this case and doing it in the palette; this will result in\n                * duplicate palette entries, but that's better than the\n                * alternative of double gamma correction.\n                *\n                * NOTE: PNGv3: check the resolved result of all the potentially\n                * different colour space chunks.\n                */\n               if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n                  png_ptr->num_trans > 0) &&\n                  png_gamma_not_sRGB(gamma) != 0)\n               {\n                  cmap_entries = (unsigned int)make_gray_file_colormap(display);\n                  data_encoding = P_FILE;\n               }\n\n               else\n                  cmap_entries = (unsigned int)make_gray_colormap(display);\n\n               /* But if the input has alpha or transparency it must be removed\n                */\n               if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n                  png_ptr->num_trans > 0)\n               {\n                  png_color_16 c;\n                  png_uint_32 gray = back_g;\n\n                  /* We need to ensure that the application background exists in\n                   * the colormap and that completely transparent pixels map to\n                   * it.  Achieve this simply by ensuring that the entry\n                   * selected for the background really is the background color.\n                   */\n                  if (data_encoding == P_FILE) /* from the fixup above */\n                  {\n                     /* The app supplied a gray which is in output_encoding, we\n                      * need to convert it to a value of the input (P_FILE)\n                      * encoding then set this palette entry to the required\n                      * output encoding.\n                      */\n                     if (output_encoding == P_sRGB)\n                        gray = png_sRGB_table[gray]; /* now P_LINEAR */\n\n                     gray = PNG_DIV257(png_gamma_16bit_correct(gray, gamma));\n                        /* now P_FILE */\n\n                     /* And make sure the corresponding palette entry contains\n                      * exactly the required sRGB value.\n                      */\n                     png_create_colormap_entry(display, gray, back_g, back_g,\n                         back_g, 0/*unused*/, output_encoding);\n                  }\n\n                  else if (output_encoding == P_LINEAR)\n                  {\n                     gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                     /* And make sure the corresponding palette entry matches.\n                      */\n                     png_create_colormap_entry(display, gray, back_g, back_g,\n                        back_g, 0/*unused*/, P_LINEAR);\n                  }\n\n                  /* The background passed to libpng, however, must be the\n                   * output (normally sRGB) value.\n                   */\n                  c.index = 0; /*unused*/\n                  c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n                  /* NOTE: the following is apparently a bug in libpng. Without\n                   * it the transparent color recognition in\n                   * png_set_background_fixed seems to go wrong.\n                   */\n                  expand_tRNS = 1;\n                  png_set_background_fixed(png_ptr, &c,\n                      PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                      0/*gamma: not used*/);\n               }\n\n               output_processing = PNG_CMAP_NONE;\n            }\n         }\n\n         else /* output is color */\n         {\n            /* We could use png_quantize here so long as there is no transparent\n             * color or alpha; png_quantize ignores alpha.  Easier overall just\n             * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.\n             * Consequently we always want libpng to produce sRGB data.\n             */\n            data_encoding = P_sRGB;\n\n            /* Is there any transparency or alpha? */\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n               png_ptr->num_trans > 0)\n            {\n               /* Is there alpha in the output too?  If so all four channels are\n                * processed into a special RGB cube with alpha support.\n                */\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n               {\n                  png_uint_32 r;\n\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\n                     png_error(png_ptr, \"rgb+alpha color-map: too few entries\");\n\n                  cmap_entries = (unsigned int)make_rgb_colormap(display);\n\n                  /* Add a transparent entry. */\n                  png_create_colormap_entry(display, cmap_entries, 255, 255,\n                      255, 0, P_sRGB);\n\n                  /* This is stored as the background index for the processing\n                   * algorithm.\n                   */\n                  background_index = cmap_entries++;\n\n                  /* Add 27 r,g,b entries each with alpha 0.5. */\n                  for (r=0; r<256; r = (r << 1) | 0x7f)\n                  {\n                     png_uint_32 g;\n\n                     for (g=0; g<256; g = (g << 1) | 0x7f)\n                     {\n                        png_uint_32 b;\n\n                        /* This generates components with the values 0, 127 and\n                         * 255\n                         */\n                        for (b=0; b<256; b = (b << 1) | 0x7f)\n                           png_create_colormap_entry(display, cmap_entries++,\n                               r, g, b, 128, P_sRGB);\n                     }\n                  }\n\n                  expand_tRNS = 1;\n                  output_processing = PNG_CMAP_RGB_ALPHA;\n               }\n\n               else\n               {\n                  /* Alpha/transparency must be removed.  The background must\n                   * exist in the color map (achieved by setting adding it after\n                   * the 666 color-map).  If the standard processing code will\n                   * pick up this entry automatically that's all that is\n                   * required; libpng can be called to do the background\n                   * processing.\n                   */\n                  unsigned int sample_size =\n                     PNG_IMAGE_SAMPLE_SIZE(output_format);\n                  png_uint_32 r, g, b; /* sRGB background */\n\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\n                     png_error(png_ptr, \"rgb-alpha color-map: too few entries\");\n\n                  cmap_entries = (unsigned int)make_rgb_colormap(display);\n\n                  png_create_colormap_entry(display, cmap_entries, back_r,\n                      back_g, back_b, 0/*unused*/, output_encoding);\n\n                  if (output_encoding == P_LINEAR)\n                  {\n                     r = PNG_sRGB_FROM_LINEAR(back_r * 255);\n                     g = PNG_sRGB_FROM_LINEAR(back_g * 255);\n                     b = PNG_sRGB_FROM_LINEAR(back_b * 255);\n                  }\n\n                  else\n                  {\n                     r = back_r;\n                     g = back_g;\n                     b = back_g;\n                  }\n\n                  /* Compare the newly-created color-map entry with the one the\n                   * PNG_CMAP_RGB algorithm will use.  If the two entries don't\n                   * match, add the new one and set this as the background\n                   * index.\n                   */\n                  if (memcmp((png_const_bytep)display->colormap +\n                      sample_size * cmap_entries,\n                      (png_const_bytep)display->colormap +\n                          sample_size * PNG_RGB_INDEX(r,g,b),\n                     sample_size) != 0)\n                  {\n                     /* The background color must be added. */\n                     background_index = cmap_entries++;\n\n                     /* Add 27 r,g,b entries each with created by composing with\n                      * the background at alpha 0.5.\n                      */\n                     for (r=0; r<256; r = (r << 1) | 0x7f)\n                     {\n                        for (g=0; g<256; g = (g << 1) | 0x7f)\n                        {\n                           /* This generates components with the values 0, 127\n                            * and 255\n                            */\n                           for (b=0; b<256; b = (b << 1) | 0x7f)\n                              png_create_colormap_entry(display, cmap_entries++,\n                                  png_colormap_compose(display, r, P_sRGB, 128,\n                                      back_r, output_encoding),\n                                  png_colormap_compose(display, g, P_sRGB, 128,\n                                      back_g, output_encoding),\n                                  png_colormap_compose(display, b, P_sRGB, 128,\n                                      back_b, output_encoding),\n                                  0/*unused*/, output_encoding);\n                        }\n                     }\n\n                     expand_tRNS = 1;\n                     output_processing = PNG_CMAP_RGB_ALPHA;\n                  }\n\n                  else /* background color is in the standard color-map */\n                  {\n                     png_color_16 c;\n\n                     c.index = 0; /*unused*/\n                     c.red = (png_uint_16)back_r;\n                     c.gray = c.green = (png_uint_16)back_g;\n                     c.blue = (png_uint_16)back_b;\n\n                     png_set_background_fixed(png_ptr, &c,\n                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                         0/*gamma: not used*/);\n\n                     output_processing = PNG_CMAP_RGB;\n                  }\n               }\n            }\n\n            else /* no alpha or transparency in the input */\n            {\n               /* Alpha in the output is irrelevant, simply map the opaque input\n                * pixels to the 6x6x6 color-map.\n                */\n               if (PNG_RGB_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_rgb_colormap(display);\n               output_processing = PNG_CMAP_RGB;\n            }\n         }\n         break;\n\n      case PNG_COLOR_TYPE_PALETTE:\n         /* It's already got a color-map.  It may be necessary to eliminate the\n          * tRNS entries though.\n          */\n         {\n            unsigned int num_trans = png_ptr->num_trans;\n            png_const_bytep trans = num_trans > 0 ? png_ptr->trans_alpha : NULL;\n            png_const_colorp colormap = png_ptr->palette;\n            int do_background = trans != NULL &&\n               (output_format & PNG_FORMAT_FLAG_ALPHA) == 0;\n            unsigned int i;\n\n            /* Just in case: */\n            if (trans == NULL)\n               num_trans = 0;\n\n            output_processing = PNG_CMAP_NONE;\n            data_encoding = P_FILE; /* Don't change from color-map indices */\n            cmap_entries = (unsigned int)png_ptr->num_palette;\n            if (cmap_entries > 256)\n               cmap_entries = 256;\n\n            if (cmap_entries > (unsigned int)image->colormap_entries)\n               png_error(png_ptr, \"palette color-map: too few entries\");\n\n            for (i=0; i < cmap_entries; ++i)\n            {\n               if (do_background != 0 && i < num_trans && trans[i] < 255)\n               {\n                  if (trans[i] == 0)\n                     png_create_colormap_entry(display, i, back_r, back_g,\n                         back_b, 0, output_encoding);\n\n                  else\n                  {\n                     /* Must compose the PNG file color in the color-map entry\n                      * on the sRGB color in 'back'.\n                      */\n                     png_create_colormap_entry(display, i,\n                         png_colormap_compose(display, colormap[i].red,\n                             P_FILE, trans[i], back_r, output_encoding),\n                         png_colormap_compose(display, colormap[i].green,\n                             P_FILE, trans[i], back_g, output_encoding),\n                         png_colormap_compose(display, colormap[i].blue,\n                             P_FILE, trans[i], back_b, output_encoding),\n                         output_encoding == P_LINEAR ? trans[i] * 257U :\n                             trans[i],\n                         output_encoding);\n                  }\n               }\n\n               else\n                  png_create_colormap_entry(display, i, colormap[i].red,\n                      colormap[i].green, colormap[i].blue,\n                      i < num_trans ? trans[i] : 255U, P_FILE/*8-bit*/);\n            }\n\n            /* The PNG data may have indices packed in fewer than 8 bits, it\n             * must be expanded if so.\n             */\n            if (png_ptr->bit_depth < 8)\n               png_set_packing(png_ptr);\n         }\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid PNG color type\");\n         /*NOT REACHED*/\n   }\n\n   /* Now deal with the output processing */\n   if (expand_tRNS != 0 && png_ptr->num_trans > 0 &&\n       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) == 0)\n      png_set_tRNS_to_alpha(png_ptr);\n\n   switch (data_encoding)\n   {\n      case P_sRGB:\n         /* Change to 8-bit sRGB */\n         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);\n         /* FALLTHROUGH */\n\n      case P_FILE:\n         if (png_ptr->bit_depth > 8)\n            png_set_scale_16(png_ptr);\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(png_ptr, \"bad data option (internal error)\");\n#endif\n   }\n\n   if (cmap_entries > 256 || cmap_entries > image->colormap_entries)\n      png_error(png_ptr, \"color map overflow (BAD internal error)\");\n\n   image->colormap_entries = cmap_entries;\n\n   /* Double check using the recorded background index */\n   switch (output_processing)\n   {\n      case PNG_CMAP_NONE:\n         if (background_index != PNG_CMAP_NONE_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_GA:\n         if (background_index != PNG_CMAP_GA_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_TRANS:\n         if (background_index >= cmap_entries ||\n            background_index != PNG_CMAP_TRANS_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_RGB:\n         if (background_index != PNG_CMAP_RGB_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_RGB_ALPHA:\n         if (background_index != PNG_CMAP_RGB_ALPHA_BACKGROUND)\n            goto bad_background;\n         break;\n\n      default:\n         png_error(png_ptr, \"bad processing option (internal error)\");\n\n      bad_background:\n         png_error(png_ptr, \"bad background index (internal error)\");\n   }\n\n   display->colormap_processing = (int)output_processing;\n\n   return 1/*ok*/;\n}\n",
      "line_start": 1959,
      "line_end": 2809,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 964,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_create_colormap_entry",
      "clean_name": "png_create_colormap_entry",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must\n * be 8-bit.\n */\nstatic void\npng_create_colormap_entry(png_image_read_control *display,\n    png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,\n    png_uint_32 alpha, int encoding)\n{\n   png_imagep image = display->image;\n   int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) != 0 ?\n       P_LINEAR : P_sRGB;\n   int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&\n       (red != green || green != blue);\n\n   if (ip > 255)\n      png_error(image->opaque->png_ptr, \"color-map index out of range\");\n\n   /* Update the cache with whether the file gamma is significantly different\n    * from sRGB.\n    */\n   if (encoding == P_FILE)\n   {\n      if (display->file_encoding == P_NOTSET)\n         set_file_encoding(display);\n\n      /* Note that the cached value may be P_FILE too, but if it is then the\n       * gamma_to_linear member has been set.\n       */\n      encoding = display->file_encoding;\n   }\n\n   if (encoding == P_FILE)\n   {\n      png_fixed_point g = display->gamma_to_linear;\n\n      red = png_gamma_16bit_correct(red*257, g);\n      green = png_gamma_16bit_correct(green*257, g);\n      blue = png_gamma_16bit_correct(blue*257, g);\n\n      if (convert_to_Y != 0 || output_encoding == P_LINEAR)\n      {\n         alpha *= 257;\n         encoding = P_LINEAR;\n      }\n\n      else\n      {\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\n         encoding = P_sRGB;\n      }\n   }\n\n   else if (encoding == P_LINEAR8)\n   {\n      /* This encoding occurs quite frequently in test cases because PngSuite\n       * includes a gAMA 1.0 chunk with most images.\n       */\n      red *= 257;\n      green *= 257;\n      blue *= 257;\n      alpha *= 257;\n      encoding = P_LINEAR;\n   }\n\n   else if (encoding == P_sRGB &&\n       (convert_to_Y  != 0 || output_encoding == P_LINEAR))\n   {\n      /* The values are 8-bit sRGB values, but must be converted to 16-bit\n       * linear.\n       */\n      red = png_sRGB_table[red];\n      green = png_sRGB_table[green];\n      blue = png_sRGB_table[blue];\n      alpha *= 257;\n      encoding = P_LINEAR;\n   }\n\n   /* This is set if the color isn't gray but the output is. */\n   if (encoding == P_LINEAR)\n   {\n      if (convert_to_Y != 0)\n      {\n         /* NOTE: these values are copied from png_do_rgb_to_gray */\n         png_uint_32 y = (png_uint_32)6968 * red  + (png_uint_32)23434 * green +\n            (png_uint_32)2366 * blue;\n\n         if (output_encoding == P_LINEAR)\n            y = (y + 16384) >> 15;\n\n         else\n         {\n            /* y is scaled by 32768, we need it scaled by 255: */\n            y = (y + 128) >> 8;\n            y *= 255;\n            y = PNG_sRGB_FROM_LINEAR((y + 64) >> 7);\n            alpha = PNG_DIV257(alpha);\n            encoding = P_sRGB;\n         }\n\n         blue = red = green = y;\n      }\n\n      else if (output_encoding == P_sRGB)\n      {\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\n         alpha = PNG_DIV257(alpha);\n         encoding = P_sRGB;\n      }\n   }\n\n   if (encoding != output_encoding)\n      png_error(image->opaque->png_ptr, \"bad encoding (internal error)\");\n\n   /* Store the value. */\n   {\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\n         int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&\n            (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;\n#     else\n#        define afirst 0\n#     endif\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\n         int bgr = (image->format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;\n#     else\n#        define bgr 0\n#     endif\n\n      if (output_encoding == P_LINEAR)\n      {\n         png_uint_16p entry = png_voidcast(png_uint_16p, display->colormap);\n\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\n\n         /* The linear 16-bit values must be pre-multiplied by the alpha channel\n          * value, if less than 65535 (this is, effectively, composite on black\n          * if the alpha channel is removed.)\n          */\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\n         {\n            case 4:\n               entry[afirst ? 0 : 3] = (png_uint_16)alpha;\n               /* FALLTHROUGH */\n\n            case 3:\n               if (alpha < 65535)\n               {\n                  if (alpha > 0)\n                  {\n                     blue = (blue * alpha + 32767U)/65535U;\n                     green = (green * alpha + 32767U)/65535U;\n                     red = (red * alpha + 32767U)/65535U;\n                  }\n\n                  else\n                     red = green = blue = 0;\n               }\n               entry[afirst + (2 ^ bgr)] = (png_uint_16)blue;\n               entry[afirst + 1] = (png_uint_16)green;\n               entry[afirst + bgr] = (png_uint_16)red;\n               break;\n\n            case 2:\n               entry[1 ^ afirst] = (png_uint_16)alpha;\n               /* FALLTHROUGH */\n\n            case 1:\n               if (alpha < 65535)\n               {\n                  if (alpha > 0)\n                     green = (green * alpha + 32767U)/65535U;\n\n                  else\n                     green = 0;\n               }\n               entry[afirst] = (png_uint_16)green;\n               break;\n\n            default:\n               break;\n         }\n      }\n\n      else /* output encoding is P_sRGB */\n      {\n         png_bytep entry = png_voidcast(png_bytep, display->colormap);\n\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\n\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\n         {\n            case 4:\n               entry[afirst ? 0 : 3] = (png_byte)alpha;\n               /* FALLTHROUGH */\n            case 3:\n               entry[afirst + (2 ^ bgr)] = (png_byte)blue;\n               entry[afirst + 1] = (png_byte)green;\n               entry[afirst + bgr] = (png_byte)red;\n               break;\n\n            case 2:\n               entry[1 ^ afirst] = (png_byte)alpha;\n               /* FALLTHROUGH */\n            case 1:\n               entry[afirst] = (png_byte)green;\n               break;\n\n            default:\n               break;\n         }\n      }\n\n#     ifdef afirst\n#        undef afirst\n#     endif\n#     ifdef bgr\n#        undef bgr\n#     endif\n   }\n}\n",
      "line_start": 1631,
      "line_end": 1850,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 303,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:set_file_encoding",
      "clean_name": "set_file_encoding",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " */\n#define PNG_DIV51(v8) (((v8) * 5 + 130) >> 8)\n\n/* Utility functions to make particular color-maps */\nstatic void\nset_file_encoding(png_image_read_control *display)\n{\n   png_structrp png_ptr = display->image->opaque->png_ptr;\n   png_fixed_point g = png_resolve_file_gamma(png_ptr);\n\n   /* PNGv3: the result may be 0 however the 'default_gamma' should have been\n    * set before this is called so zero is an error:\n    */\n   if (g == 0)\n      png_error(png_ptr, \"internal: default gamma not set\");\n\n   if (png_gamma_significant(g) != 0)\n   {\n      if (png_gamma_not_sRGB(g) != 0)\n      {\n         display->file_encoding = P_FILE;\n         display->gamma_to_linear = png_reciprocal(g);\n      }\n\n      else\n         display->file_encoding = P_sRGB;\n   }\n\n   else\n      display->file_encoding = P_LINEAR8;\n}\n",
      "line_start": 1527,
      "line_end": 1553,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:make_gray_colormap",
      "clean_name": "make_gray_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return (int)i;\n}\n\nstatic int\nmake_gray_colormap(png_image_read_control *display)\n{\n   unsigned int i;\n\n   for (i=0; i<256; ++i)\n      png_create_colormap_entry(display, i, i, i, i, 255, P_sRGB);\n\n   return (int)i;\n}\n",
      "line_start": 1863,
      "line_end": 1872,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:make_ga_colormap",
      "clean_name": "make_ga_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return (int)i;\n}\n#define PNG_GRAY_COLORMAP_ENTRIES 256\n\nstatic int\nmake_ga_colormap(png_image_read_control *display)\n{\n   unsigned int i, a;\n\n   /* Alpha is retained, the output will be a color-map with entries\n    * selected by six levels of alpha.  One transparent entry, 6 gray\n    * levels for all the intermediate alpha values, leaving 230 entries\n    * for the opaque grays.  The color-map entries are the six values\n    * [0..5]*51, the GA processing uses PNG_DIV51(value) to find the\n    * relevant entry.\n    *\n    * if (alpha > 229) // opaque\n    * {\n    *    // The 231 entries are selected to make the math below work:\n    *    base = 0;\n    *    entry = (231 * gray + 128) >> 8;\n    * }\n    * else if (alpha < 26) // transparent\n    * {\n    *    base = 231;\n    *    entry = 0;\n    * }\n    * else // partially opaque\n    * {\n    *    base = 226 + 6 * PNG_DIV51(alpha);\n    *    entry = PNG_DIV51(gray);\n    * }\n    */\n   i = 0;\n   while (i < 231)\n   {\n      unsigned int gray = (i * 256 + 115) / 231;\n      png_create_colormap_entry(display, i++, gray, gray, gray, 255, P_sRGB);\n   }\n\n   /* 255 is used here for the component values for consistency with the code\n    * that undoes premultiplication in pngwrite.c.\n    */\n   png_create_colormap_entry(display, i++, 255, 255, 255, 0, P_sRGB);\n\n   for (a=1; a<5; ++a)\n   {\n      unsigned int g;\n\n      for (g=0; g<6; ++g)\n         png_create_colormap_entry(display, i++, g*51, g*51, g*51, a*51,\n             P_sRGB);\n   }\n\n   return (int)i;\n}\n",
      "line_start": 1875,
      "line_end": 1926,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_gamma_not_sRGB",
      "clean_name": "png_gamma_not_sRGB",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * one used in pngrtran.c when deciding whether to do gamma correction.  The\n * arithmetic optimizes the division by using the fact that the inverse of the\n * file sRGB gamma is 2.2\n */\nstatic int\npng_gamma_not_sRGB(png_fixed_point g)\n{\n   /* 1.6.47: use the same sanity checks as used in pngrtran.c */\n   if (g < PNG_LIB_GAMMA_MIN || g > PNG_LIB_GAMMA_MAX)\n      return 0; /* Includes the uninitialized value 0 */\n\n   return png_gamma_significant((g * 11 + 2)/5 /* i.e. *2.2, rounded */);\n}\n",
      "line_start": 1234,
      "line_end": 1242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:make_gray_file_colormap",
      "clean_name": "make_gray_file_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "#     endif\n   }\n}\n\nstatic int\nmake_gray_file_colormap(png_image_read_control *display)\n{\n   unsigned int i;\n\n   for (i=0; i<256; ++i)\n      png_create_colormap_entry(display, i, i, i, i, 255, P_FILE);\n\n   return (int)i;\n}\n",
      "line_start": 1852,
      "line_end": 1861,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:make_rgb_colormap",
      "clean_name": "make_rgb_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "}\n\n#define PNG_GA_COLORMAP_ENTRIES 256\n\nstatic int\nmake_rgb_colormap(png_image_read_control *display)\n{\n   unsigned int i, r;\n\n   /* Build a 6x6x6 opaque RGB cube */\n   for (i=r=0; r<6; ++r)\n   {\n      unsigned int g;\n\n      for (g=0; g<6; ++g)\n      {\n         unsigned int b;\n\n         for (b=0; b<6; ++b)\n            png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,\n                P_sRGB);\n      }\n   }\n\n   return (int)i;\n}\n",
      "line_start": 1930,
      "line_end": 1951,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_colormap_compose",
      "clean_name": "png_colormap_compose",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return value;\n}\n\nstatic png_uint_32\npng_colormap_compose(png_image_read_control *display,\n    png_uint_32 foreground, int foreground_encoding, png_uint_32 alpha,\n    png_uint_32 background, int encoding)\n{\n   /* The file value is composed on the background, the background has the given\n    * encoding and so does the result, the file is encoded with P_FILE and the\n    * file and alpha are 8-bit values.  The (output) encoding will always be\n    * P_LINEAR or P_sRGB.\n    */\n   png_uint_32 f = decode_gamma(display, foreground, foreground_encoding);\n   png_uint_32 b = decode_gamma(display, background, encoding);\n\n   /* The alpha is always an 8-bit value (it comes from the palette), the value\n    * scaled by 255 is what PNG_sRGB_FROM_LINEAR requires.\n    */\n   f = f * alpha + b * (255-alpha);\n\n   if (encoding == P_LINEAR)\n   {\n      /* Scale to 65535; divide by 255, approximately (in fact this is extremely\n       * accurate, it divides by 255.00000005937181414556, with no overflow.)\n       */\n      f *= 257; /* Now scaled by 65535 */\n      f += f >> 16;\n      f = (f+32768) >> 16;\n   }\n\n   else /* P_sRGB */\n      f = PNG_sRGB_FROM_LINEAR(f);\n\n   return f;\n}\n",
      "line_start": 1594,
      "line_end": 1626,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:decode_gamma",
      "clean_name": "decode_gamma",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   else\n      display->file_encoding = P_LINEAR8;\n}\n\nstatic unsigned int\ndecode_gamma(png_image_read_control *display, png_uint_32 value, int encoding)\n{\n   if (encoding == P_FILE) /* double check */\n      encoding = display->file_encoding;\n\n   if (encoding == P_NOTSET) /* must be the file encoding */\n   {\n      set_file_encoding(display);\n      encoding = display->file_encoding;\n   }\n\n   switch (encoding)\n   {\n      case P_FILE:\n         value = png_gamma_16bit_correct(value*257, display->gamma_to_linear);\n         break;\n\n      case P_sRGB:\n         value = png_sRGB_table[value];\n         break;\n\n      case P_LINEAR:\n         break;\n\n      case P_LINEAR8:\n         value *= 257;\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(display->image->opaque->png_ptr,\n             \"unexpected encoding (internal error)\");\n#endif\n   }\n\n   return value;\n}\n",
      "line_start": 1555,
      "line_end": 1592,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 45,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_colormapped",
      "clean_name": "png_image_read_colormapped",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return 1;\n}\n\nstatic int\npng_image_read_colormapped(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_controlp control = image->opaque;\n   png_structrp png_ptr = control->png_ptr;\n   png_inforp info_ptr = control->info_ptr;\n\n   int passes = 0; /* As a flag */\n\n   PNG_SKIP_CHUNKS(png_ptr);\n\n   /* Update the 'info' structure and make sure the result is as required; first\n    * make sure to turn on the interlace handling if it will be required\n    * (because it can't be turned on *after* the call to png_read_update_info!)\n    */\n   if (display->colormap_processing == PNG_CMAP_NONE)\n      passes = png_set_interlace_handling(png_ptr);\n\n   png_read_update_info(png_ptr, info_ptr);\n\n   /* The expected output can be deduced from the colormap_processing option. */\n   switch (display->colormap_processing)\n   {\n      case PNG_CMAP_NONE:\n         /* Output must be one channel and one byte per pixel, the output\n          * encoding can be anything.\n          */\n         if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||\n            info_ptr->color_type == PNG_COLOR_TYPE_GRAY) &&\n            info_ptr->bit_depth == 8)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_TRANS:\n      case PNG_CMAP_GA:\n         /* Output must be two channels and the 'G' one must be sRGB, the latter\n          * can be checked with an exact number because it should have been set\n          * to this number above!\n          */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 256)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_RGB:\n         /* Output must be 8-bit sRGB encoded RGB */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 216)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_RGB_ALPHA:\n         /* Output must be 8-bit sRGB encoded RGBA */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 244 /* 216 + 1 + 27 */)\n            break;\n\n         goto bad_output;\n\n      default:\n      bad_output:\n         png_error(png_ptr, \"bad color-map processing (internal error)\");\n   }\n\n   /* Now read the rows.  Do this here if it is possible to read directly into\n    * the output buffer, otherwise allocate a local row buffer of the maximum\n    * size libpng requires and call the relevant processing routine safely.\n    */\n   {\n      png_voidp first_row = display->buffer;\n      ptrdiff_t row_bytes = display->row_stride;\n\n      /* The following expression is designed to work correctly whether it gives\n       * a signed or an unsigned result.\n       */\n      if (row_bytes < 0)\n      {\n         char *ptr = png_voidcast(char*, first_row);\n         ptr += (image->height-1) * (-row_bytes);\n         first_row = png_voidcast(png_voidp, ptr);\n      }\n\n      display->first_row = first_row;\n      display->row_bytes = row_bytes;\n   }\n\n   if (passes == 0)\n   {\n      int result;\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n\n      display->local_row = row;\n      result = png_safe_execute(image, png_image_read_and_map, display);\n      display->local_row = NULL;\n      png_free(png_ptr, row);\n\n      return result;\n   }\n\n   else\n   {\n      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;\n\n      while (--passes >= 0)\n      {\n         png_uint_32      y = image->height;\n         png_bytep        row = png_voidcast(png_bytep, display->first_row);\n\n         for (; y > 0; --y)\n         {\n            png_read_row(png_ptr, row, NULL);\n            row += row_bytes;\n         }\n      }\n\n      return 1;\n   }\n}\n",
      "line_start": 3001,
      "line_end": 3130,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 189,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_and_map",
      "clean_name": "png_image_read_and_map",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 1/*ok*/;\n}\n\n/* The final part of the color-map read called from png_image_finish_read. */\nstatic int\npng_image_read_and_map(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   int passes;\n\n   /* Called when the libpng data must be transformed into the color-mapped\n    * form.  There is a local row buffer in display->local and this routine must\n    * do the interlace handling.\n    */\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   {\n      png_uint_32  height = image->height;\n      png_uint_32  width = image->width;\n      int          proc = display->colormap_processing;\n      png_bytep    first_row = png_voidcast(png_bytep, display->first_row);\n      ptrdiff_t    step_row = display->row_bytes;\n      int pass;\n\n      for (pass = 0; pass < passes; ++pass)\n      {\n         unsigned int     startx, stepx, stepy;\n         png_uint_32      y;\n\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n         {\n            /* The row may be empty for a short image: */\n            if (PNG_PASS_COLS(width, pass) == 0)\n               continue;\n\n            startx = PNG_PASS_START_COL(pass);\n            stepx = PNG_PASS_COL_OFFSET(pass);\n            y = PNG_PASS_START_ROW(pass);\n            stepy = PNG_PASS_ROW_OFFSET(pass);\n         }\n\n         else\n         {\n            y = 0;\n            startx = 0;\n            stepx = stepy = 1;\n         }\n\n         for (; y<height; y += stepy)\n         {\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\n            png_bytep outrow = first_row + y * step_row;\n            png_const_bytep end_row = outrow + width;\n\n            /* Read read the libpng data into the temporary buffer. */\n            png_read_row(png_ptr, inrow, NULL);\n\n            /* Now process the row according to the processing option, note\n             * that the caller verifies that the format of the libpng output\n             * data is as required.\n             */\n            outrow += startx;\n            switch (proc)\n            {\n               case PNG_CMAP_GA:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     /* The data is always in the PNG order */\n                     unsigned int gray = *inrow++;\n                     unsigned int alpha = *inrow++;\n                     unsigned int entry;\n\n                     /* NOTE: this code is copied as a comment in\n                      * make_ga_colormap above.  Please update the\n                      * comment if you change this code!\n                      */\n                     if (alpha > 229) /* opaque */\n                     {\n                        entry = (231 * gray + 128) >> 8;\n                     }\n                     else if (alpha < 26) /* transparent */\n                     {\n                        entry = 231;\n                     }\n                     else /* partially opaque */\n                     {\n                        entry = 226 + 6 * PNG_DIV51(alpha) + PNG_DIV51(gray);\n                     }\n\n                     *outrow = (png_byte)entry;\n                  }\n                  break;\n\n               case PNG_CMAP_TRANS:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     png_byte gray = *inrow++;\n                     png_byte alpha = *inrow++;\n\n                     if (alpha == 0)\n                        *outrow = PNG_CMAP_TRANS_BACKGROUND;\n\n                     else if (gray != PNG_CMAP_TRANS_BACKGROUND)\n                        *outrow = gray;\n\n                     else\n                        *outrow = (png_byte)(PNG_CMAP_TRANS_BACKGROUND+1);\n                  }\n                  break;\n\n               case PNG_CMAP_RGB:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     *outrow = PNG_RGB_INDEX(inrow[0], inrow[1], inrow[2]);\n                     inrow += 3;\n                  }\n                  break;\n\n               case PNG_CMAP_RGB_ALPHA:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     unsigned int alpha = inrow[3];\n\n                     /* Because the alpha entries only hold alpha==0.5 values\n                      * split the processing at alpha==0.25 (64) and 0.75\n                      * (196).\n                      */\n\n                     if (alpha >= 196)\n                        *outrow = PNG_RGB_INDEX(inrow[0], inrow[1],\n                            inrow[2]);\n\n                     else if (alpha < 64)\n                        *outrow = PNG_CMAP_RGB_ALPHA_BACKGROUND;\n\n                     else\n                     {\n                        /* Likewise there are three entries for each of r, g\n                         * and b.  We could select the entry by popcount on\n                         * the top two bits on those architectures that\n                         * support it, this is what the code below does,\n                         * crudely.\n                         */\n                        unsigned int back_i = PNG_CMAP_RGB_ALPHA_BACKGROUND+1;\n\n                        /* Here are how the values map:\n                         *\n                         * 0x00 .. 0x3f -> 0\n                         * 0x40 .. 0xbf -> 1\n                         * 0xc0 .. 0xff -> 2\n                         *\n                         * So, as above with the explicit alpha checks, the\n                         * breakpoints are at 64 and 196.\n                         */\n                        if (inrow[0] & 0x80) back_i += 9; /* red */\n                        if (inrow[0] & 0x40) back_i += 9;\n                        if (inrow[0] & 0x80) back_i += 3; /* green */\n                        if (inrow[0] & 0x40) back_i += 3;\n                        if (inrow[0] & 0x80) back_i += 1; /* blue */\n                        if (inrow[0] & 0x40) back_i += 1;\n\n                        *outrow = (png_byte)back_i;\n                     }\n\n                     inrow += 4;\n                  }\n                  break;\n\n               default:\n                  break;\n            }\n         }\n      }\n   }\n\n   return 1;\n}\n",
      "line_start": 2812,
      "line_end": 2999,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 218,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_composite",
      "clean_name": "png_image_read_composite",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 1;\n}\n\n/* Just the row reading part of png_image_read. */\nstatic int\npng_image_read_composite(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   int passes;\n\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   {\n      png_uint_32  height = image->height;\n      png_uint_32  width = image->width;\n      ptrdiff_t    step_row = display->row_bytes;\n      unsigned int channels =\n          (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ? 3 : 1;\n      int pass;\n\n      for (pass = 0; pass < passes; ++pass)\n      {\n         unsigned int     startx, stepx, stepy;\n         png_uint_32      y;\n\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n         {\n            /* The row may be empty for a short image: */\n            if (PNG_PASS_COLS(width, pass) == 0)\n               continue;\n\n            startx = PNG_PASS_START_COL(pass) * channels;\n            stepx = PNG_PASS_COL_OFFSET(pass) * channels;\n            y = PNG_PASS_START_ROW(pass);\n            stepy = PNG_PASS_ROW_OFFSET(pass);\n         }\n\n         else\n         {\n            y = 0;\n            startx = 0;\n            stepx = channels;\n            stepy = 1;\n         }\n\n         for (; y<height; y += stepy)\n         {\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\n            png_bytep outrow;\n            png_const_bytep end_row;\n\n            /* Read the row, which is packed: */\n            png_read_row(png_ptr, inrow, NULL);\n\n            outrow = png_voidcast(png_bytep, display->first_row);\n            outrow += y * step_row;\n            end_row = outrow + width * channels;\n\n            /* Now do the composition on each pixel in this row. */\n            outrow += startx;\n            for (; outrow < end_row; outrow += stepx)\n            {\n               png_byte alpha = inrow[channels];\n\n               if (alpha > 0) /* else no change to the output */\n               {\n                  unsigned int c;\n\n                  for (c=0; c<channels; ++c)\n                  {\n                     png_uint_32 component = inrow[c];\n\n                     if (alpha < 255) /* else just use component */\n                     {\n                        /* This is PNG_OPTIMIZED_ALPHA, the component value\n                         * is a linear 8-bit value.  Combine this with the\n                         * current outrow[c] value which is sRGB encoded.\n                         * Arithmetic here is 16-bits to preserve the output\n                         * values correctly.\n                         */\n                        component *= 257*255; /* =65535 */\n                        component += (255-alpha)*png_sRGB_table[outrow[c]];\n\n                        /* So 'component' is scaled by 255*65535 and is\n                         * therefore appropriate for the sRGB to linear\n                         * conversion table.\n                         */\n                        component = PNG_sRGB_FROM_LINEAR(component);\n                     }\n\n                     outrow[c] = (png_byte)component;\n                  }\n               }\n\n               inrow += channels+1; /* components and alpha channel */\n            }\n         }\n      }\n   }\n\n   return 1;\n}\n",
      "line_start": 3181,
      "line_end": 3293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 123,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_background",
      "clean_name": "png_image_read_background",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * correction.  The fix-up is to prevent the PNG_COMPOSITE operation from\n * happening inside libpng, so this routine sees an 8 or 16-bit gray+alpha\n * row and handles the removal or pre-multiplication of the alpha channel.\n */\nstatic int\npng_image_read_background(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_inforp info_ptr = image->opaque->info_ptr;\n   png_uint_32 height = image->height;\n   png_uint_32 width = image->width;\n   int pass, passes;\n\n   /* Double check the convoluted logic below.  We expect to get here with\n    * libpng doing rgb to gray and gamma correction but background processing\n    * left to the png_image_read_background function.  The rows libpng produce\n    * might be 8 or 16-bit but should always have two channels; gray plus alpha.\n    */\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\n      png_error(png_ptr, \"lost rgb to gray\");\n\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      png_error(png_ptr, \"unexpected compose\");\n\n   if (png_get_channels(png_ptr, info_ptr) != 2)\n      png_error(png_ptr, \"lost/gained channels\");\n\n   /* Expect the 8-bit case to always remove the alpha channel */\n   if ((image->format & PNG_FORMAT_FLAG_LINEAR) == 0 &&\n      (image->format & PNG_FORMAT_FLAG_ALPHA) != 0)\n      png_error(png_ptr, \"unexpected 8-bit transformation\");\n\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   /* Use direct access to info_ptr here because otherwise the simplified API\n    * would require PNG_EASY_ACCESS_SUPPORTED (just for this.)  Note this is\n    * checking the value after libpng expansions, not the original value in the\n    * PNG.\n    */\n   switch (info_ptr->bit_depth)\n   {\n      case 8:\n         /* 8-bit sRGB gray values with an alpha channel; the alpha channel is\n          * to be removed by composing on a background: either the row if\n          * display->background is NULL or display->background->green if not.\n          * Unlike the code above ALPHA_OPTIMIZED has *not* been done.\n          */\n         {\n            png_bytep first_row = png_voidcast(png_bytep, display->first_row);\n            ptrdiff_t step_row = display->row_bytes;\n\n            for (pass = 0; pass < passes; ++pass)\n            {\n               unsigned int     startx, stepx, stepy;\n               png_uint_32      y;\n\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n               {\n                  /* The row may be empty for a short image: */\n                  if (PNG_PASS_COLS(width, pass) == 0)\n                     continue;\n\n                  startx = PNG_PASS_START_COL(pass);\n                  stepx = PNG_PASS_COL_OFFSET(pass);\n                  y = PNG_PASS_START_ROW(pass);\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\n               }\n\n               else\n               {\n                  y = 0;\n                  startx = 0;\n                  stepx = stepy = 1;\n               }\n\n               if (display->background == NULL)\n               {\n                  for (; y<height; y += stepy)\n                  {\n                     png_bytep inrow = png_voidcast(png_bytep,\n                         display->local_row);\n                     png_bytep outrow = first_row + y * step_row;\n                     png_const_bytep end_row = outrow + width;\n\n                     /* Read the row, which is packed: */\n                     png_read_row(png_ptr, inrow, NULL);\n\n                     /* Now do the composition on each pixel in this row. */\n                     outrow += startx;\n                     for (; outrow < end_row; outrow += stepx)\n                     {\n                        png_byte alpha = inrow[1];\n\n                        if (alpha > 0) /* else no change to the output */\n                        {\n                           png_uint_32 component = inrow[0];\n\n                           if (alpha < 255) /* else just use component */\n                           {\n                              /* Since PNG_OPTIMIZED_ALPHA was not set it is\n                               * necessary to invert the sRGB transfer\n                               * function and multiply the alpha out.\n                               */\n                              component = png_sRGB_table[component] * alpha;\n                              component += png_sRGB_table[outrow[0]] *\n                                 (255-alpha);\n                              component = PNG_sRGB_FROM_LINEAR(component);\n                           }\n\n                           outrow[0] = (png_byte)component;\n                        }\n\n                        inrow += 2; /* gray and alpha channel */\n                     }\n                  }\n               }\n\n               else /* constant background value */\n               {\n                  png_byte background8 = display->background->green;\n                  png_uint_16 background = png_sRGB_table[background8];\n\n                  for (; y<height; y += stepy)\n                  {\n                     png_bytep inrow = png_voidcast(png_bytep,\n                         display->local_row);\n                     png_bytep outrow = first_row + y * step_row;\n                     png_const_bytep end_row = outrow + width;\n\n                     /* Read the row, which is packed: */\n                     png_read_row(png_ptr, inrow, NULL);\n\n                     /* Now do the composition on each pixel in this row. */\n                     outrow += startx;\n                     for (; outrow < end_row; outrow += stepx)\n                     {\n                        png_byte alpha = inrow[1];\n\n                        if (alpha > 0) /* else use background */\n                        {\n                           png_uint_32 component = inrow[0];\n\n                           if (alpha < 255) /* else just use component */\n                           {\n                              component = png_sRGB_table[component] * alpha;\n                              component += background * (255-alpha);\n                              component = PNG_sRGB_FROM_LINEAR(component);\n                           }\n\n                           outrow[0] = (png_byte)component;\n                        }\n\n                        else\n                           outrow[0] = background8;\n\n                        inrow += 2; /* gray and alpha channel */\n                     }\n                  }\n               }\n            }\n         }\n         break;\n\n      case 16:\n         /* 16-bit linear with pre-multiplied alpha; the pre-multiplication must\n          * still be done and, maybe, the alpha channel removed.  This code also\n          * handles the alpha-first option.\n          */\n         {\n            png_uint_16p first_row = png_voidcast(png_uint_16p,\n                display->first_row);\n            /* The division by two is safe because the caller passed in a\n             * stride which was multiplied by 2 (below) to get row_bytes.\n             */\n            ptrdiff_t    step_row = display->row_bytes / 2;\n            unsigned int preserve_alpha = (image->format &\n                PNG_FORMAT_FLAG_ALPHA) != 0;\n            unsigned int outchannels = 1U+preserve_alpha;\n            int swap_alpha = 0;\n\n#           ifdef PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED\n               if (preserve_alpha != 0 &&\n                   (image->format & PNG_FORMAT_FLAG_AFIRST) != 0)\n                  swap_alpha = 1;\n#           endif\n\n            for (pass = 0; pass < passes; ++pass)\n            {\n               unsigned int     startx, stepx, stepy;\n               png_uint_32      y;\n\n               /* The 'x' start and step are adjusted to output components here.\n                */\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n               {\n                  /* The row may be empty for a short image: */\n                  if (PNG_PASS_COLS(width, pass) == 0)\n                     continue;\n\n                  startx = PNG_PASS_START_COL(pass) * outchannels;\n                  stepx = PNG_PASS_COL_OFFSET(pass) * outchannels;\n                  y = PNG_PASS_START_ROW(pass);\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\n               }\n\n               else\n               {\n                  y = 0;\n                  startx = 0;\n                  stepx = outchannels;\n                  stepy = 1;\n               }\n\n               for (; y<height; y += stepy)\n               {\n                  png_const_uint_16p inrow;\n                  png_uint_16p outrow = first_row + y*step_row;\n                  png_uint_16p end_row = outrow + width * outchannels;\n\n                  /* Read the row, which is packed: */\n                  png_read_row(png_ptr, png_voidcast(png_bytep,\n                      display->local_row), NULL);\n                  inrow = png_voidcast(png_const_uint_16p, display->local_row);\n\n                  /* Now do the pre-multiplication on each pixel in this row.\n                   */\n                  outrow += startx;\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     png_uint_32 component = inrow[0];\n                     png_uint_16 alpha = inrow[1];\n\n                     if (alpha > 0) /* else 0 */\n                     {\n                        if (alpha < 65535) /* else just use component */\n                        {\n                           component *= alpha;\n                           component += 32767;\n                           component /= 65535;\n                        }\n                     }\n\n                     else\n                        component = 0;\n\n                     outrow[swap_alpha] = (png_uint_16)component;\n                     if (preserve_alpha != 0)\n                        outrow[1 ^ swap_alpha] = alpha;\n\n                     inrow += 2; /* components and alpha channel */\n                  }\n               }\n            }\n         }\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(png_ptr, \"unexpected bit depth\");\n#endif\n   }\n\n   return 1;\n}\n",
      "line_start": 3308,
      "line_end": 3582,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 313,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_set_background_fixed",
      "clean_name": "png_set_background_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n/* Handle alpha and tRNS via a background color */\nvoid PNGFAPI\npng_set_background_fixed(png_structrp png_ptr,\n    png_const_color_16p background_color, int background_gamma_code,\n    int need_expand, png_fixed_point background_gamma)\n{\n   png_debug(1, \"in png_set_background_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0 || background_color == NULL)\n      return;\n\n   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)\n   {\n      png_warning(png_ptr, \"Application must supply a known background gamma\");\n      return;\n   }\n\n   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;\n   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n\n   png_ptr->background = *background_color;\n   png_ptr->background_gamma = background_gamma;\n   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);\n   if (need_expand != 0)\n      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;\n   else\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n}\n",
      "line_start": 141,
      "line_end": 168,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_background",
      "clean_name": "png_set_background",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_background(png_structrp png_ptr,\n    png_const_color_16p background_color, int background_gamma_code,\n    int need_expand, double background_gamma)\n{\n   png_set_background_fixed(png_ptr, background_color, background_gamma_code,\n      need_expand, png_fixed(png_ptr, background_gamma, \"png_set_background\"));\n}\n",
      "line_start": 171,
      "line_end": 178,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_strip_16",
      "clean_name": "png_set_strip_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n/* Chop 16-bit depth files to 8-bit depth */\nvoid PNGAPI\npng_set_strip_16(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_strip_16\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_16_TO_8;\n}\n",
      "line_start": 201,
      "line_end": 210,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_strip_alpha",
      "clean_name": "png_set_strip_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\nvoid PNGAPI\npng_set_strip_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_strip_alpha\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_STRIP_ALPHA;\n}\n",
      "line_start": 214,
      "line_end": 223,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_alpha_mode",
      "clean_name": "png_set_alpha_mode",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   }\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)\n{\n   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,\n       output_gamma));\n}\n",
      "line_start": 460,
      "line_end": 465,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_quantize",
      "clean_name": "png_set_quantize",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "} png_dsort;\ntypedef png_dsort *   png_dsortp;\ntypedef png_dsort * * png_dsortpp;\n\nvoid PNGAPI\npng_set_quantize(png_structrp png_ptr, png_colorp palette,\n    int num_palette, int maximum_colors, png_const_uint_16p histogram,\n    int full_quantize)\n{\n   png_debug(1, \"in png_set_quantize\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_QUANTIZE;\n\n   if (full_quantize == 0)\n   {\n      int i;\n\n      /* Initialize the array to index colors.\n       *\n       * Ensure quantize_index can fit 256 elements (PNG_MAX_PALETTE_LENGTH)\n       * rather than num_palette elements. This is to prevent buffer overflows\n       * caused by malformed PNG files with out-of-range palette indices.\n       *\n       * Be careful to avoid leaking memory. Applications are allowed to call\n       * this function more than once per png_struct.\n       */\n      png_free(png_ptr, png_ptr->quantize_index);\n      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,\n          PNG_MAX_PALETTE_LENGTH);\n      for (i = 0; i < PNG_MAX_PALETTE_LENGTH; i++)\n         png_ptr->quantize_index[i] = (png_byte)i;\n   }\n\n   if (num_palette > maximum_colors)\n   {\n      if (histogram != NULL)\n      {\n         /* This is easy enough, just throw out the least used colors.\n          * Perhaps not the best solution, but good enough.\n          */\n\n         png_bytep quantize_sort;\n         int i, j;\n\n         /* Initialize the local array to sort colors. */\n         quantize_sort = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n         for (i = 0; i < num_palette; i++)\n            quantize_sort[i] = (png_byte)i;\n\n         /* Find the least used palette entries by starting a\n          * bubble sort, and running it until we have sorted\n          * out enough colors.  Note that we don't care about\n          * sorting all the colors, just finding which are\n          * least used.\n          */\n\n         for (i = num_palette - 1; i >= maximum_colors; i--)\n         {\n            int done; /* To stop early if the list is pre-sorted */\n\n            done = 1;\n            for (j = 0; j < i; j++)\n            {\n               if (histogram[quantize_sort[j]]\n                   < histogram[quantize_sort[j + 1]])\n               {\n                  png_byte t;\n\n                  t = quantize_sort[j];\n                  quantize_sort[j] = quantize_sort[j + 1];\n                  quantize_sort[j + 1] = t;\n                  done = 0;\n               }\n            }\n\n            if (done != 0)\n               break;\n         }\n\n         /* Swap the palette around, and set up a table, if necessary */\n         if (full_quantize != 0)\n         {\n            j = num_palette;\n\n            /* Put all the useful colors within the max, but don't\n             * move the others.\n             */\n            for (i = 0; i < maximum_colors; i++)\n            {\n               if ((int)quantize_sort[i] >= maximum_colors)\n               {\n                  do\n                     j--;\n                  while ((int)quantize_sort[j] >= maximum_colors);\n\n                  palette[i] = palette[j];\n               }\n            }\n         }\n         else\n         {\n            j = num_palette;\n\n            /* Move all the used colors inside the max limit, and\n             * develop a translation table.\n             */\n            for (i = 0; i < maximum_colors; i++)\n            {\n               /* Only move the colors we need to */\n               if ((int)quantize_sort[i] >= maximum_colors)\n               {\n                  png_color tmp_color;\n\n                  do\n                     j--;\n                  while ((int)quantize_sort[j] >= maximum_colors);\n\n                  tmp_color = palette[j];\n                  palette[j] = palette[i];\n                  palette[i] = tmp_color;\n                  /* Indicate where the color went */\n                  png_ptr->quantize_index[j] = (png_byte)i;\n                  png_ptr->quantize_index[i] = (png_byte)j;\n               }\n            }\n\n            /* Find closest color for those colors we are not using */\n            for (i = 0; i < num_palette; i++)\n            {\n               if ((int)png_ptr->quantize_index[i] >= maximum_colors)\n               {\n                  int min_d, k, min_k, d_index;\n\n                  /* Find the closest color to one we threw out */\n                  d_index = png_ptr->quantize_index[i];\n                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);\n                  for (k = 1, min_k = 0; k < maximum_colors; k++)\n                  {\n                     int d;\n\n                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);\n\n                     if (d < min_d)\n                     {\n                        min_d = d;\n                        min_k = k;\n                     }\n                  }\n                  /* Point to closest color */\n                  png_ptr->quantize_index[i] = (png_byte)min_k;\n               }\n            }\n         }\n         png_free(png_ptr, quantize_sort);\n      }\n      else\n      {\n         /* This is much harder to do simply (and quickly).  Perhaps\n          * we need to go through a median cut routine, but those\n          * don't always behave themselves with only a few colors\n          * as input.  So we will just find the closest two colors,\n          * and throw out one of them (chosen somewhat randomly).\n          * [We don't understand this at all, so if someone wants to\n          *  work on improving it, be our guest - AED, GRP]\n          */\n         int i;\n         int max_d;\n         int num_new_palette;\n         png_dsortp t;\n         png_dsortpp hash;\n\n         t = NULL;\n\n         /* Initialize palette index arrays */\n         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n\n         /* Initialize the sort array */\n         for (i = 0; i < num_palette; i++)\n         {\n            png_ptr->index_to_palette[i] = (png_byte)i;\n            png_ptr->palette_to_index[i] = (png_byte)i;\n         }\n\n         hash = (png_dsortpp)png_calloc(png_ptr, (png_alloc_size_t)(769 *\n             (sizeof (png_dsortp))));\n\n         num_new_palette = num_palette;\n\n         /* Initial wild guess at how far apart the farthest pixel\n          * pair we will be eliminating will be.  Larger\n          * numbers mean more areas will be allocated, Smaller\n          * numbers run the risk of not saving enough data, and\n          * having to do this all over again.\n          *\n          * I have not done extensive checking on this number.\n          */\n         max_d = 96;\n\n         while (num_new_palette > maximum_colors)\n         {\n            for (i = 0; i < num_new_palette - 1; i++)\n            {\n               int j;\n\n               for (j = i + 1; j < num_new_palette; j++)\n               {\n                  int d;\n\n                  d = PNG_COLOR_DIST(palette[i], palette[j]);\n\n                  if (d <= max_d)\n                  {\n\n                     t = (png_dsortp)png_malloc_warn(png_ptr,\n                         (png_alloc_size_t)(sizeof (png_dsort)));\n\n                     if (t == NULL)\n                         break;\n\n                     t->next = hash[d];\n                     t->left = (png_byte)i;\n                     t->right = (png_byte)j;\n                     hash[d] = t;\n                  }\n               }\n               if (t == NULL)\n                  break;\n            }\n\n            if (t != NULL)\n            for (i = 0; i <= max_d; i++)\n            {\n               if (hash[i] != NULL)\n               {\n                  png_dsortp p;\n\n                  for (p = hash[i]; p; p = p->next)\n                  {\n                     if ((int)png_ptr->index_to_palette[p->left]\n                         < num_new_palette &&\n                         (int)png_ptr->index_to_palette[p->right]\n                         < num_new_palette)\n                     {\n                        int j, next_j;\n\n                        if (num_new_palette & 0x01)\n                        {\n                           j = p->left;\n                           next_j = p->right;\n                        }\n                        else\n                        {\n                           j = p->right;\n                           next_j = p->left;\n                        }\n\n                        num_new_palette--;\n                        palette[png_ptr->index_to_palette[j]]\n                            = palette[num_new_palette];\n                        if (full_quantize == 0)\n                        {\n                           int k;\n\n                           for (k = 0; k < num_palette; k++)\n                           {\n                              if (png_ptr->quantize_index[k] ==\n                                  png_ptr->index_to_palette[j])\n                                 png_ptr->quantize_index[k] =\n                                     png_ptr->index_to_palette[next_j];\n\n                              if ((int)png_ptr->quantize_index[k] ==\n                                  num_new_palette)\n                                 png_ptr->quantize_index[k] =\n                                     png_ptr->index_to_palette[j];\n                           }\n                        }\n\n                        png_ptr->index_to_palette[png_ptr->palette_to_index\n                            [num_new_palette]] = png_ptr->index_to_palette[j];\n\n                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]\n                            = png_ptr->palette_to_index[num_new_palette];\n\n                        png_ptr->index_to_palette[j] =\n                            (png_byte)num_new_palette;\n\n                        png_ptr->palette_to_index[num_new_palette] =\n                            (png_byte)j;\n                     }\n                     if (num_new_palette <= maximum_colors)\n                        break;\n                  }\n                  if (num_new_palette <= maximum_colors)\n                     break;\n               }\n            }\n\n            for (i = 0; i < 769; i++)\n            {\n               if (hash[i] != NULL)\n               {\n                  png_dsortp p = hash[i];\n                  while (p)\n                  {\n                     t = p->next;\n                     png_free(png_ptr, p);\n                     p = t;\n                  }\n               }\n               hash[i] = 0;\n            }\n            max_d += 96;\n         }\n         png_free(png_ptr, hash);\n         png_free(png_ptr, png_ptr->palette_to_index);\n         png_free(png_ptr, png_ptr->index_to_palette);\n         png_ptr->palette_to_index = NULL;\n         png_ptr->index_to_palette = NULL;\n      }\n      num_palette = maximum_colors;\n   }\n   if (png_ptr->palette == NULL)\n   {\n      png_ptr->palette = palette;\n   }\n   png_ptr->num_palette = (png_uint_16)num_palette;\n\n   if (full_quantize != 0)\n   {\n      int i;\n      png_bytep distance;\n      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +\n          PNG_QUANTIZE_BLUE_BITS;\n      int num_red = (1 << PNG_QUANTIZE_RED_BITS);\n      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);\n      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);\n      size_t num_entries = ((size_t)1 << total_bits);\n\n      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,\n          (png_alloc_size_t)(num_entries));\n\n      distance = (png_bytep)png_malloc(png_ptr, (png_alloc_size_t)num_entries);\n\n      memset(distance, 0xff, num_entries);\n\n      for (i = 0; i < num_palette; i++)\n      {\n         int ir, ig, ib;\n         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));\n         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));\n         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));\n\n         for (ir = 0; ir < num_red; ir++)\n         {\n            /* int dr = abs(ir - r); */\n            int dr = ((ir > r) ? ir - r : r - ir);\n            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +\n                PNG_QUANTIZE_GREEN_BITS));\n\n            for (ig = 0; ig < num_green; ig++)\n            {\n               /* int dg = abs(ig - g); */\n               int dg = ((ig > g) ? ig - g : g - ig);\n               int dt = dr + dg;\n               int dm = ((dr > dg) ? dr : dg);\n               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);\n\n               for (ib = 0; ib < num_blue; ib++)\n               {\n                  int d_index = index_g | ib;\n                  /* int db = abs(ib - b); */\n                  int db = ((ib > b) ? ib - b : b - ib);\n                  int dmax = ((dm > db) ? dm : db);\n                  int d = dmax + dt + db;\n\n                  if (d < (int)distance[d_index])\n                  {\n                     distance[d_index] = (png_byte)d;\n                     png_ptr->palette_lookup[d_index] = (png_byte)i;\n                  }\n               }\n            }\n         }\n      }\n\n      png_free(png_ptr, distance);\n   }\n}\n",
      "line_start": 488,
      "line_end": 878,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 341,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_gamma_fixed",
      "clean_name": "png_set_gamma_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif /* READ_QUANTIZE */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\nvoid PNGFAPI\npng_set_gamma_fixed(png_structrp png_ptr, png_fixed_point scrn_gamma,\n    png_fixed_point file_gamma)\n{\n   png_debug(1, \"in png_set_gamma_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   /* New in libpng-1.5.4 - reserve particular negative values as flags. */\n   scrn_gamma = translate_gamma_flags(scrn_gamma, 1/*screen*/);\n   file_gamma = translate_gamma_flags(file_gamma, 0/*file*/);\n\n   /* Checking the gamma values for being >0 was added in 1.5.4 along with the\n    * premultiplied alpha support; this actually hides an undocumented feature\n    * of the previous implementation which allowed gamma processing to be\n    * disabled in background handling.  There is no evidence (so far) that this\n    * was being used; however, png_set_background itself accepted and must still\n    * accept '0' for the gamma value it takes, because it isn't always used.\n    *\n    * Since this is an API change (albeit a very minor one that removes an\n    * undocumented API feature) the following checks were only enabled in\n    * libpng-1.6.0.\n    */\n   if (file_gamma <= 0)\n      png_app_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n   if (scrn_gamma <= 0)\n      png_app_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n\n   if (unsupported_gamma(png_ptr, file_gamma, 1/*warn*/) ||\n       unsupported_gamma(png_ptr, scrn_gamma, 1/*warn*/))\n      return;\n\n   /* 1.6.47: png_struct::file_gamma and png_struct::screen_gamma are now only\n    * written by this API.  This removes dependencies on the order of API calls\n    * and allows the complex gamma checks to be delayed until needed.\n    */\n   png_ptr->file_gamma = file_gamma;\n   png_ptr->screen_gamma = scrn_gamma;\n}\n",
      "line_start": 882,
      "line_end": 921,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_gamma",
      "clean_name": "png_set_gamma",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   png_ptr->screen_gamma = scrn_gamma;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_gamma(png_structrp png_ptr, double scrn_gamma, double file_gamma)\n{\n   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),\n       convert_gamma_value(png_ptr, file_gamma));\n}\n",
      "line_start": 924,
      "line_end": 929,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_palette_to_rgb",
      "clean_name": "png_set_palette_to_rgb",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " *  and its name was changed to png_set_expand_gray_1_2_4_to_8().\n */\n\n/* Expand paletted images to RGB. */\nvoid PNGAPI\npng_set_palette_to_rgb(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_palette_to_rgb\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 968,
      "line_end": 977,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_expand_16",
      "clean_name": "png_set_expand_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_EXPAND_16_SUPPORTED\n/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise\n * it may not work correctly.)\n */\nvoid PNGAPI\npng_set_expand_16(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_expand_16\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 1008,
      "line_end": 1017,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_rgb_to_gray_fixed",
      "clean_name": "png_set_rgb_to_gray_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\nvoid PNGFAPI\npng_set_rgb_to_gray_fixed(png_structrp png_ptr, int error_action,\n    png_fixed_point red, png_fixed_point green)\n{\n   png_debug(1, \"in png_set_rgb_to_gray_fixed\");\n\n   /* Need the IHDR here because of the check on color_type below. */\n   /* TODO: fix this */\n   if (png_rtran_ok(png_ptr, 1) == 0)\n      return;\n\n   switch (error_action)\n   {\n      case PNG_ERROR_ACTION_NONE:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY;\n         break;\n\n      case PNG_ERROR_ACTION_WARN:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;\n         break;\n\n      case PNG_ERROR_ACTION_ERROR:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid error action to rgb_to_gray\");\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n#ifdef PNG_READ_EXPAND_SUPPORTED\n      png_ptr->transformations |= PNG_EXPAND;\n#else\n   {\n      /* Make this an error in 1.6 because otherwise the application may assume\n       * that it just worked and get a memory overwrite.\n       */\n      png_error(png_ptr,\n          \"Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED\");\n\n      /* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */\n   }\n#endif\n   {\n      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)\n      {\n         png_uint_16 red_int, green_int;\n\n         /* NOTE: this calculation does not round, but this behavior is retained\n          * for consistency; the inaccuracy is very small.  The code here always\n          * overwrites the coefficients, regardless of whether they have been\n          * defaulted or set already.\n          */\n         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);\n         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);\n\n         png_ptr->rgb_to_gray_red_coeff   = red_int;\n         png_ptr->rgb_to_gray_green_coeff = green_int;\n         png_ptr->rgb_to_gray_coefficients_set = 1;\n      }\n\n      else if (red >= 0 && green >= 0)\n         png_app_warning(png_ptr,\n               \"ignoring out of range rgb_to_gray coefficients\");\n   }\n}\n",
      "line_start": 1036,
      "line_end": 1101,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_rgb_to_gray",
      "clean_name": "png_set_rgb_to_gray",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Convert a RGB image to a grayscale of the same width.  This allows us,\n * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.\n */\n\nvoid PNGAPI\npng_set_rgb_to_gray(png_structrp png_ptr, int error_action, double red,\n    double green)\n{\n   png_set_rgb_to_gray_fixed(png_ptr, error_action,\n       png_fixed(png_ptr, red, \"rgb to gray red coefficient\"),\n      png_fixed(png_ptr, green, \"rgb to gray green coefficient\"));\n}\n",
      "line_start": 1108,
      "line_end": 1115,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_read_user_transform_fn",
      "clean_name": "png_set_read_user_transform_fn",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif /* RGB_TO_GRAY */\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\nvoid PNGAPI\npng_set_read_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr\n    read_user_transform_fn)\n{\n   png_debug(1, \"in png_set_read_user_transform_fn\");\n\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   png_ptr->transformations |= PNG_USER_TRANSFORM;\n   png_ptr->read_user_transform_fn = read_user_transform_fn;\n#endif\n}\n",
      "line_start": 1122,
      "line_end": 1132,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngrtran.c:convert_gamma_value",
      "clean_name": "convert_gamma_value",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   return output_gamma;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nstatic png_fixed_point\nconvert_gamma_value(png_structrp png_ptr, double output_gamma)\n{\n   /* The following silently ignores cases where fixed point (times 100,000)\n    * gamma values are passed to the floating point API.  This is safe and it\n    * means the fixed point constants work just fine with the floating point\n    * API.  The alternative would just lead to undetected errors and spurious\n    * bug reports.  Negative values fail inside the _fixed API unless they\n    * correspond to the flag values.\n    */\n   if (output_gamma > 0 && output_gamma < 128)\n      output_gamma *= PNG_FP_1;\n\n   /* This preserves -1 and -2 exactly: */\n   output_gamma = floor(output_gamma + .5);\n\n   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)\n      png_fixed_error(png_ptr, \"gamma value\");\n\n   return (png_fixed_point)output_gamma;\n}\n",
      "line_start": 308,
      "line_end": 328,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_rgb_to_gray",
      "clean_name": "png_do_rgb_to_gray",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " *  the API takes just red and green coefficients the blue coefficient is\n *  calculated to make the sum 32768.  This will result in different rounding\n *  to that used above.\n */\nstatic int\npng_do_rgb_to_gray(png_structrp png_ptr, png_row_infop row_info, png_bytep row)\n{\n   int rgb_error = 0;\n\n   png_debug(1, \"in png_do_rgb_to_gray\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_PALETTE) == 0 &&\n       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;\n      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;\n      png_uint_32 bc = 32768 - rc - gc;\n      png_uint_32 row_width = row_info->width;\n      int have_alpha = (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;\n\n      if (row_info->bit_depth == 8)\n      {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n         /* Notice that gamma to/from 1 are not necessarily inverses (if\n          * there is an overall gamma correction).  Prior to 1.5.5 this code\n          * checked the linearized values for equality; this doesn't match\n          * the documentation, the original values must be checked.\n          */\n         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte red   = *(sp++);\n               png_byte green = *(sp++);\n               png_byte blue  = *(sp++);\n\n               if (red != green || red != blue)\n               {\n                  red = png_ptr->gamma_to_1[red];\n                  green = png_ptr->gamma_to_1[green];\n                  blue = png_ptr->gamma_to_1[blue];\n\n                  rgb_error |= 1;\n                  *(dp++) = png_ptr->gamma_from_1[\n                      (rc*red + gc*green + bc*blue + 16384)>>15];\n               }\n\n               else\n               {\n                  /* If there is no overall correction the table will not be\n                   * set.\n                   */\n                  if (png_ptr->gamma_table != NULL)\n                     red = png_ptr->gamma_table[red];\n\n                  *(dp++) = red;\n               }\n\n               if (have_alpha != 0)\n                  *(dp++) = *(sp++);\n            }\n         }\n         else\n#endif\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte red   = *(sp++);\n               png_byte green = *(sp++);\n               png_byte blue  = *(sp++);\n\n               if (red != green || red != blue)\n               {\n                  rgb_error |= 1;\n                  /* NOTE: this is the historical approach which simply\n                   * truncates the results.\n                   */\n                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);\n               }\n\n               else\n                  *(dp++) = red;\n\n               if (have_alpha != 0)\n                  *(dp++) = *(sp++);\n            }\n         }\n      }\n\n      else /* RGB bit_depth == 16 */\n      {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_uint_16 red, green, blue, w;\n               png_byte hi,lo;\n\n               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));\n\n               if (red == green && red == blue)\n               {\n                  if (png_ptr->gamma_16_table != NULL)\n                     w = png_ptr->gamma_16_table[(red & 0xff)\n                         >> png_ptr->gamma_shift][red >> 8];\n\n                  else\n                     w = red;\n               }\n\n               else\n               {\n                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red & 0xff)\n                      >> png_ptr->gamma_shift][red>>8];\n                  png_uint_16 green_1 =\n                      png_ptr->gamma_16_to_1[(green & 0xff) >>\n                      png_ptr->gamma_shift][green>>8];\n                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue & 0xff)\n                      >> png_ptr->gamma_shift][blue>>8];\n                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1\n                      + bc*blue_1 + 16384)>>15);\n                  w = png_ptr->gamma_16_from_1[(gray16 & 0xff) >>\n                      png_ptr->gamma_shift][gray16 >> 8];\n                  rgb_error |= 1;\n               }\n\n               *(dp++) = (png_byte)((w>>8) & 0xff);\n               *(dp++) = (png_byte)(w & 0xff);\n\n               if (have_alpha != 0)\n               {\n                  *(dp++) = *(sp++);\n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n         else\n#endif\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_uint_16 red, green, blue, gray16;\n               png_byte hi,lo;\n\n               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));\n\n               if (red != green || red != blue)\n                  rgb_error |= 1;\n\n               /* From 1.5.5 in the 16-bit case do the accurate conversion even\n                * in the 'fast' case - this is because this is where the code\n                * ends up when handling linear 16-bit data.\n                */\n               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>\n                  15);\n               *(dp++) = (png_byte)((gray16 >> 8) & 0xff);\n               *(dp++) = (png_byte)(gray16 & 0xff);\n\n               if (have_alpha != 0)\n               {\n                  *(dp++) = *(sp++);\n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n      }\n\n      row_info->channels = (png_byte)(row_info->channels - 2);\n      row_info->color_type = (png_byte)(row_info->color_type &\n          ~PNG_COLOR_MASK_COLOR);\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n          row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n   return rgb_error;\n}\n",
      "line_start": 3117,
      "line_end": 3309,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 147,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_compose",
      "clean_name": "png_do_compose",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Replace any alpha or transparency with the supplied background color.\n * \"background\" is already in the screen gamma, while \"background_1\" is\n * at a gamma of 1.0.  Paletted files have already been taken care of.\n */\nstatic void\npng_do_compose(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\n{\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   png_const_bytep gamma_table = png_ptr->gamma_table;\n   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;\n   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;\n   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;\n   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;\n   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;\n   int gamma_shift = png_ptr->gamma_shift;\n   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;\n#endif\n\n   png_bytep sp;\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n   int shift;\n\n   png_debug(1, \"in png_do_compose\");\n\n   switch (row_info->color_type)\n   {\n      case PNG_COLOR_TYPE_GRAY:\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               sp = row;\n               shift = 7;\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((png_uint_16)((*sp >> shift) & 0x01)\n                     == png_ptr->trans_color.gray)\n                  {\n                     unsigned int tmp = *sp & (0x7f7f >> (7 - shift));\n                     tmp |=\n                         (unsigned int)(png_ptr->background.gray << shift);\n                     *sp = (png_byte)(tmp & 0xff);\n                  }\n\n                  if (shift == 0)\n                  {\n                     shift = 7;\n                     sp++;\n                  }\n\n                  else\n                     shift--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  shift = 6;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x03)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |=\n                           (unsigned int)png_ptr->background.gray << shift;\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     else\n                     {\n                        unsigned int p = (*sp >> shift) & 0x03;\n                        unsigned int g = (gamma_table [p | (p << 2) |\n                            (p << 4) | (p << 6)] >> 6) & 0x03;\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |= (unsigned int)(g << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 6;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 2;\n                  }\n               }\n\n               else\n#endif\n               {\n                  sp = row;\n                  shift = 6;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x03)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |=\n                            (unsigned int)png_ptr->background.gray << shift;\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 6;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 2;\n                  }\n               }\n               break;\n            }\n\n            case 4:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  shift = 4;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x0f)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |=\n                           (unsigned int)(png_ptr->background.gray << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     else\n                     {\n                        unsigned int p = (*sp >> shift) & 0x0f;\n                        unsigned int g = (gamma_table[p | (p << 4)] >> 4) &\n                           0x0f;\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |= (unsigned int)(g << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 4;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 4;\n                  }\n               }\n\n               else\n#endif\n               {\n                  sp = row;\n                  shift = 4;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x0f)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |=\n                           (unsigned int)(png_ptr->background.gray << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 4;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 4;\n                  }\n               }\n               break;\n            }\n\n            case 8:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp++)\n                  {\n                     if (*sp == png_ptr->trans_color.gray)\n                        *sp = (png_byte)png_ptr->background.gray;\n\n                     else\n                        *sp = gamma_table[*sp];\n                  }\n               }\n               else\n#endif\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp++)\n                  {\n                     if (*sp == png_ptr->trans_color.gray)\n                        *sp = (png_byte)png_ptr->background.gray;\n                  }\n               }\n               break;\n            }\n\n            case 16:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_16 != NULL)\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp += 2)\n                  {\n                     png_uint_16 v;\n\n                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                     if (v == png_ptr->trans_color.gray)\n                     {\n                        /* Background is already in screen gamma */\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray\n                             & 0xff);\n                     }\n\n                     else\n                     {\n                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                        *sp = (png_byte)((v >> 8) & 0xff);\n                        *(sp + 1) = (png_byte)(v & 0xff);\n                     }\n                  }\n               }\n               else\n#endif\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp += 2)\n                  {\n                     png_uint_16 v;\n\n                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                     if (v == png_ptr->trans_color.gray)\n                     {\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray\n                             & 0xff);\n                     }\n                  }\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_RGB:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 3)\n               {\n                  if (*sp == png_ptr->trans_color.red &&\n                      *(sp + 1) == png_ptr->trans_color.green &&\n                      *(sp + 2) == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else\n                  {\n                     *sp = gamma_table[*sp];\n                     *(sp + 1) = gamma_table[*(sp + 1)];\n                     *(sp + 2) = gamma_table[*(sp + 2)];\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 3)\n               {\n                  if (*sp == png_ptr->trans_color.red &&\n                      *(sp + 1) == png_ptr->trans_color.green &&\n                      *(sp + 2) == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n               }\n            }\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 6)\n               {\n                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                      + *(sp + 5));\n\n                  if (r == png_ptr->trans_color.red &&\n                      g == png_ptr->trans_color.green &&\n                      b == png_ptr->trans_color.blue)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 6)\n               {\n                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                      + *(sp + 5));\n\n                  if (r == png_ptr->trans_color.red &&\n                      g == png_ptr->trans_color.green &&\n                      b == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\n                gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 2)\n               {\n                  png_uint_16 a = *(sp + 1);\n\n                  if (a == 0xff)\n                     *sp = gamma_table[*sp];\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)png_ptr->background.gray;\n                  }\n\n                  else\n                  {\n                     png_byte v, w;\n\n                     v = gamma_to_1[*sp];\n                     png_composite(w, v, a, png_ptr->background_1.gray);\n                     if (optimize == 0)\n                        w = gamma_from_1[w];\n                     *sp = w;\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 2)\n               {\n                  png_byte a = *(sp + 1);\n\n                  if (a == 0)\n                     *sp = (png_byte)png_ptr->background.gray;\n\n                  else if (a < 0xff)\n                     png_composite(*sp, *sp, a, png_ptr->background.gray);\n               }\n            }\n         }\n         else /* if (png_ptr->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\n                gamma_16_to_1 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  if (a == (png_uint_16)0xffff)\n                  {\n                     png_uint_16 v;\n\n                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 g, v, w;\n\n                     g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\n                     png_composite_16(v, g, a, png_ptr->background_1.gray);\n                     if (optimize != 0)\n                        w = v;\n                     else\n                        w = gamma_16_from_1[(v & 0xff) >>\n                            gamma_shift][v >> 8];\n                     *sp = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(w & 0xff);\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\n                  }\n\n                  else if (a < 0xffff)\n                  {\n                     png_uint_16 g, v;\n\n                     g = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n                     png_composite_16(v, g, a, png_ptr->background.gray);\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\n                gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_byte a = *(sp + 3);\n\n                  if (a == 0xff)\n                  {\n                     *sp = gamma_table[*sp];\n                     *(sp + 1) = gamma_table[*(sp + 1)];\n                     *(sp + 2) = gamma_table[*(sp + 2)];\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else\n                  {\n                     png_byte v, w;\n\n                     v = gamma_to_1[*sp];\n                     png_composite(w, v, a, png_ptr->background_1.red);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *sp = w;\n\n                     v = gamma_to_1[*(sp + 1)];\n                     png_composite(w, v, a, png_ptr->background_1.green);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *(sp + 1) = w;\n\n                     v = gamma_to_1[*(sp + 2)];\n                     png_composite(w, v, a, png_ptr->background_1.blue);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *(sp + 2) = w;\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_byte a = *(sp + 3);\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else if (a < 0xff)\n                  {\n                     png_composite(*sp, *sp, a, png_ptr->background.red);\n\n                     png_composite(*(sp + 1), *(sp + 1), a,\n                         png_ptr->background.green);\n\n                     png_composite(*(sp + 2), *(sp + 2), a,\n                         png_ptr->background.blue);\n                  }\n               }\n            }\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\n                gamma_16_to_1 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 8)\n               {\n                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\n                      << 8) + (png_uint_16)(*(sp + 7)));\n\n                  if (a == (png_uint_16)0xffff)\n                  {\n                     png_uint_16 v;\n\n                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 v, w;\n\n                     v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\n                     png_composite_16(w, v, a, png_ptr->background_1.red);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n                     *sp = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(w & 0xff);\n\n                     v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     png_composite_16(w, v, a, png_ptr->background_1.green);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n\n                     *(sp + 2) = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(w & 0xff);\n\n                     v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     png_composite_16(w, v, a, png_ptr->background_1.blue);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n\n                     *(sp + 4) = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(w & 0xff);\n                  }\n               }\n            }\n\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 8)\n               {\n                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\n                      << 8) + (png_uint_16)(*(sp + 7)));\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else if (a < 0xffff)\n                  {\n                     png_uint_16 v;\n\n                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                         + *(sp + 3));\n                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                         + *(sp + 5));\n\n                     png_composite_16(v, r, a, png_ptr->background.red);\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     png_composite_16(v, g, a, png_ptr->background.green);\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     png_composite_16(v, b, a, png_ptr->background.blue);\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      default:\n         break;\n   }\n}\n",
      "line_start": 3318,
      "line_end": 4052,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 564,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_encode_alpha",
      "clean_name": "png_do_encode_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Encode the alpha channel to the output gamma (the input channel is always\n * linear.)  Called only with color types that have an alpha channel.  Needs the\n * from_1 tables.\n */\nstatic void\npng_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\n{\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_encode_alpha\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep table = png_ptr->gamma_from_1;\n\n         if (table != NULL)\n         {\n            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;\n\n            /* The alpha channel is the last component: */\n            row += step - 1;\n\n            for (; row_width > 0; --row_width, row += step)\n               *row = table[*row];\n\n            return;\n         }\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         png_uint_16pp table = png_ptr->gamma_16_from_1;\n         int gamma_shift = png_ptr->gamma_shift;\n\n         if (table != NULL)\n         {\n            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;\n\n            /* The alpha channel is the last component: */\n            row += step - 2;\n\n            for (; row_width > 0; --row_width, row += step)\n            {\n               png_uint_16 v;\n\n               v = table[*(row + 1) >> gamma_shift][*row];\n               *row = (png_byte)((v >> 8) & 0xff);\n               *(row + 1) = (png_byte)(v & 0xff);\n            }\n\n            return;\n         }\n      }\n   }\n\n   /* Only get to here if called with a weird row_info; no harm has been done,\n    * so just issue a warning.\n    */\n   png_warning(png_ptr, \"png_do_encode_alpha: unexpected call\");\n}\n",
      "line_start": 4263,
      "line_end": 4320,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_chop",
      "clean_name": "png_do_chop",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\nstatic void\n/* Simply discard the low byte.  This was the default behavior prior\n * to libpng-1.5.4.\n */\npng_do_chop(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_chop\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep sp = row; /* source */\n      png_bytep dp = row; /* destination */\n      png_bytep ep = sp + row_info->rowbytes; /* end+1 */\n\n      while (sp < ep)\n      {\n         *dp++ = *sp;\n         sp += 2; /* skip low byte */\n      }\n\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_info->width * row_info->channels;\n   }\n}\n",
      "line_start": 2568,
      "line_end": 2589,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_quantize",
      "clean_name": "png_do_quantize",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\nstatic void\npng_do_quantize(png_row_infop row_info, png_bytep row,\n    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)\n{\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_quantize\");\n\n   if (row_info->bit_depth == 8)\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n\n            /* This looks real messy, but the compiler will reduce\n             * it down to a reasonable formula.  For example, with\n             * 5 bits per color, we get:\n             * p = (((r >> 3) & 0x1f) << 10) |\n             *    (((g >> 3) & 0x1f) << 5) |\n             *    ((b >> 3) & 0x1f);\n             */\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n                (PNG_QUANTIZE_BLUE_BITS)) |\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n\n      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n         palette_lookup != NULL)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n            sp++;\n\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n                (PNG_QUANTIZE_BLUE_BITS)) |\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n\n      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\n         quantize_lookup)\n      {\n         sp = row;\n\n         for (i = 0; i < row_width; i++, sp++)\n         {\n            *sp = quantize_lookup[*sp];\n         }\n      }\n   }\n}\n",
      "line_start": 4761,
      "line_end": 4851,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 129,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_expand_16",
      "clean_name": "png_do_expand_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_EXPAND_16_SUPPORTED\n/* If the bit depth is 8 and the color type is not a palette type expand the\n * whole row to 16 bits.  Has no effect otherwise.\n */\nstatic void\npng_do_expand_16(png_row_infop row_info, png_bytep row)\n{\n   if (row_info->bit_depth == 8 &&\n      row_info->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      /* The row have a sequence of bytes containing [0..255] and we need\n       * to turn it into another row containing [0..65535], to do this we\n       * calculate:\n       *\n       *  (input / 255) * 65535\n       *\n       *  Which happens to be exactly input * 257 and this can be achieved\n       *  simply by byte replication in place (copying backwards).\n       */\n      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */\n      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */\n      while (dp > sp)\n      {\n         dp[-2] = dp[-1] = *--sp; dp -= 2;\n      }\n\n      row_info->rowbytes *= 2;\n      row_info->bit_depth = 16;\n      row_info->pixel_depth = (png_byte)(row_info->channels * 16);\n   }\n}\n",
      "line_start": 4731,
      "line_end": 4757,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_read_invert_alpha",
      "clean_name": "png_do_read_invert_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\nstatic void\npng_do_read_invert_alpha(png_row_infop row_info, png_bytep row)\n{\n   png_uint_32 row_width;\n   png_debug(1, \"in png_do_read_invert_alpha\");\n\n   row_width = row_info->width;\n   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         /* This inverts the alpha channel in RGBA */\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n\n/*          This does nothing:\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            We can replace it with:\n*/\n            sp-=3;\n            dp=sp;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This inverts the alpha channel in RRGGBBAA */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = (png_byte)(255 - *(--sp));\n\n/*          This does nothing:\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            We can replace it with:\n*/\n            sp-=6;\n            dp=sp;\n         }\n      }\n#endif\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         /* This inverts the alpha channel in GA */\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = *(--sp);\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else\n      {\n         /* This inverts the alpha channel in GGAA */\n         png_bytep sp  = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = (png_byte)(255 - *(--sp));\n/*\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n*/\n            sp-=2;\n            dp=sp;\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 2689,
      "line_end": 2786,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_unshift",
      "clean_name": "png_do_unshift",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * pixels back to their significant bits values.  Thus, if you have\n * a row of bit depth 8, but only 5 are significant, this will shift\n * the values back to 0 through 31.\n */\nstatic void\npng_do_unshift(png_row_infop row_info, png_bytep row,\n    png_const_color_8p sig_bits)\n{\n   int color_type;\n\n   png_debug(1, \"in png_do_unshift\");\n\n   /* The palette case has already been handled in the _init routine. */\n   color_type = row_info->color_type;\n\n   if (color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      int shift[4];\n      int channels = 0;\n      int bit_depth = row_info->bit_depth;\n\n      if ((color_type & PNG_COLOR_MASK_COLOR) != 0)\n      {\n         shift[channels++] = bit_depth - sig_bits->red;\n         shift[channels++] = bit_depth - sig_bits->green;\n         shift[channels++] = bit_depth - sig_bits->blue;\n      }\n\n      else\n      {\n         shift[channels++] = bit_depth - sig_bits->gray;\n      }\n\n      if ((color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      {\n         shift[channels++] = bit_depth - sig_bits->alpha;\n      }\n\n      {\n         int c, have_shift;\n\n         for (c = have_shift = 0; c < channels; ++c)\n         {\n            /* A shift of more than the bit depth is an error condition but it\n             * gets ignored here.\n             */\n            if (shift[c] <= 0 || shift[c] >= bit_depth)\n               shift[c] = 0;\n\n            else\n               have_shift = 1;\n         }\n\n         if (have_shift == 0)\n            return;\n      }\n\n      switch (bit_depth)\n      {\n         default:\n         /* Must be 1bpp gray: should not be here! */\n            /* NOTREACHED */\n            break;\n\n         case 2:\n         /* Must be 2bpp gray */\n         /* assert(channels == 1 && shift[0] == 1) */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n\n            while (bp < bp_end)\n            {\n               int b = (*bp >> 1) & 0x55;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n         case 4:\n         /* Must be 4bpp gray */\n         /* assert(channels == 1) */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int gray_shift = shift[0];\n            int mask =  0xf >> gray_shift;\n\n            mask |= mask << 4;\n\n            while (bp < bp_end)\n            {\n               int b = (*bp >> gray_shift) & mask;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n         case 8:\n         /* Single byte components, G, GA, RGB, RGBA */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int channel = 0;\n\n            while (bp < bp_end)\n            {\n               int b = *bp >> shift[channel];\n               if (++channel >= channels)\n                  channel = 0;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n         case 16:\n         /* Double byte components, G, GA, RGB, RGBA */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int channel = 0;\n\n            while (bp < bp_end)\n            {\n               int value = (bp[0] << 8) + bp[1];\n\n               value >>= shift[channel];\n               if (++channel >= channels)\n                  channel = 0;\n               *bp++ = (png_byte)(value >> 8);\n               *bp++ = (png_byte)value;\n            }\n            break;\n         }\n#endif\n      }\n   }\n}\n",
      "line_start": 2368,
      "line_end": 2502,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 96,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_read_swap_alpha",
      "clean_name": "png_do_read_swap_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\nstatic void\npng_do_read_swap_alpha(png_row_infop row_info, png_bytep row)\n{\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_read_swap_alpha\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n   {\n      /* This converts from RGBA to ARGB */\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This converts from RRGGBBAA to AARRGGBB */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save[2];\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save[0] = *(--sp);\n            save[1] = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save[0];\n            *(--dp) = save[1];\n         }\n      }\n#endif\n   }\n\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n   {\n      /* This converts from GA to AG */\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This converts from GGAA to AAGG */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save[2];\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save[0] = *(--sp);\n            save[1] = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save[0];\n            *(--dp) = save[1];\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 2593,
      "line_end": 2685,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_get_uint_32",
      "clean_name": "png_get_uint_32",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * these (unused but exported) functions.\n */\n\n/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\npng_uint_32 (PNGAPI\npng_get_uint_32)(png_const_bytep buf)\n{\n   png_uint_32 uval =\n       ((png_uint_32)(*(buf    )) << 24) +\n       ((png_uint_32)(*(buf + 1)) << 16) +\n       ((png_uint_32)(*(buf + 2)) <<  8) +\n       ((png_uint_32)(*(buf + 3))      ) ;\n\n   return uval;\n}\n",
      "line_start": 62,
      "line_end": 72,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_int_32",
      "clean_name": "png_get_int_32",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * data is stored in the PNG file in two's complement format and there\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\n * the following code does a two's complement to native conversion.\n */\npng_int_32 (PNGAPI\npng_get_int_32)(png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return (png_int_32)uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   if ((uval & 0x80000000) == 0) /* no overflow */\n      return -(png_int_32)uval;\n   /* The following has to be safe; this function only gets called on PNG data\n    * and if we get here that data is invalid.  0 is the most safe value and\n    * if not then an attacker would surely just generate a PNG with 0 instead.\n    */\n   return 0;\n}\n",
      "line_start": 79,
      "line_end": 94,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_uint_16",
      "clean_name": "png_get_uint_16",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   return 0;\n}\n\n/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\npng_uint_16 (PNGAPI\npng_get_uint_16)(png_const_bytep buf)\n{\n   /* ANSI-C requires an int value to accommodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}\n",
      "line_start": 97,
      "line_end": 110,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_cache_unknown_chunk",
      "clean_name": "png_cache_unknown_chunk",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */\nstatic int\npng_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)\n{\n   const png_alloc_size_t limit = png_chunk_max(png_ptr);\n\n   if (png_ptr->unknown_chunk.data != NULL)\n   {\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n   if (length <= limit)\n   {\n      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);\n      /* The following is safe because of the PNG_SIZE_MAX init above */\n      png_ptr->unknown_chunk.size = (size_t)length/*SAFE*/;\n      /* 'mode' is a flag array, only the bottom four bits matter here */\n      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;\n\n      if (length == 0)\n         png_ptr->unknown_chunk.data = NULL;\n\n      else\n      {\n         /* Do a 'warn' here - it is handled below. */\n         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n      }\n   }\n\n   if (png_ptr->unknown_chunk.data == NULL && length > 0)\n   {\n      /* This is benign because we clean up correctly */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"unknown chunk exceeds memory limits\");\n      return 0;\n   }\n\n   else\n   {\n      if (length > 0)\n         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);\n      png_crc_finish(png_ptr, 0);\n      return 1;\n   }\n}\n",
      "line_start": 2723,
      "line_end": 2768,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_hIST",
      "clean_name": "png_handle_hIST",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_eXIf NULL\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   /* This cast is safe because the chunk definition limits the length to a\n    * maximum of 1024 bytes.\n    *\n    * TODO: maybe use png_uint_32 anyway, not unsigned int, to reduce the\n    * casts.\n    */\n   num = (unsigned int)length / 2 ;\n\n   if (length != num * 2 ||\n       num != (unsigned int)png_ptr->num_palette ||\n       num > (unsigned int)PNG_MAX_PALETTE_LENGTH)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n   return handled_ok;\n}\n",
      "line_start": 2058,
      "line_end": 2096,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_iCCP",
      "clean_name": "png_handle_iCCP",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_sRGB NULL\n#endif /* READ_sRGB */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle profiles that are > 64K under DOS */\n{\n   png_const_charp errmsg = NULL; /* error message output, or no error */\n   int finished = 0; /* crc checked */\n\n   png_debug(1, \"in png_handle_iCCP\");\n\n   /* PNGv3: allow PNG files with both sRGB and iCCP because the PNG spec only\n    * ever said that there \"should\" be only one, not \"shall\" and the PNGv3\n    * colour chunk precedence rules give a handling for this case anyway.\n    */\n   {\n      uInt read_length, keyword_length;\n      char keyword[81];\n\n      /* Find the keyword; the keyword plus separator and compression method\n       * bytes can be at most 81 characters long.\n       */\n      read_length = 81; /* maximum */\n      if (read_length > length)\n         read_length = (uInt)/*SAFE*/length;\n\n      png_crc_read(png_ptr, (png_bytep)keyword, read_length);\n      length -= read_length;\n\n      if (length < LZ77Min)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"too short\");\n         return handled_error;\n      }\n\n      keyword_length = 0;\n      while (keyword_length < 80 && keyword_length < read_length &&\n         keyword[keyword_length] != 0)\n         ++keyword_length;\n\n      /* TODO: make the keyword checking common */\n      if (keyword_length >= 1 && keyword_length <= 79)\n      {\n         /* We only understand '0' compression - deflate - so if we get a\n          * different value we can't safely decode the chunk.\n          */\n         if (keyword_length+1 < read_length &&\n            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)\n         {\n            read_length -= keyword_length+2;\n\n            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)\n            {\n               Byte profile_header[132]={0};\n               Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n               png_alloc_size_t size = (sizeof profile_header);\n\n               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);\n               png_ptr->zstream.avail_in = read_length;\n               (void)png_inflate_read(png_ptr, local_buffer,\n                   (sizeof local_buffer), &length, profile_header, &size,\n                   0/*finish: don't, because the output is too small*/);\n\n               if (size == 0)\n               {\n                  /* We have the ICC profile header; do the basic header checks.\n                   */\n                  png_uint_32 profile_length = png_get_uint_32(profile_header);\n\n                  if (png_icc_check_length(png_ptr, keyword, profile_length) !=\n                      0)\n                  {\n                     /* The length is apparently ok, so we can check the 132\n                      * byte header.\n                      */\n                     if (png_icc_check_header(png_ptr, keyword, profile_length,\n                              profile_header, png_ptr->color_type) != 0)\n                     {\n                        /* Now read the tag table; a variable size buffer is\n                         * needed at this point, allocate one for the whole\n                         * profile.  The header check has already validated\n                         * that none of this stuff will overflow.\n                         */\n                        png_uint_32 tag_count =\n                           png_get_uint_32(profile_header + 128);\n                        png_bytep profile = png_read_buffer(png_ptr,\n                              profile_length);\n\n                        if (profile != NULL)\n                        {\n                           memcpy(profile, profile_header,\n                               (sizeof profile_header));\n\n                           size = 12 * tag_count;\n\n                           (void)png_inflate_read(png_ptr, local_buffer,\n                               (sizeof local_buffer), &length,\n                               profile + (sizeof profile_header), &size, 0);\n\n                           /* Still expect a buffer error because we expect\n                            * there to be some tag data!\n                            */\n                           if (size == 0)\n                           {\n                              if (png_icc_check_tag_table(png_ptr,\n                                       keyword, profile_length, profile) != 0)\n                              {\n                                 /* The profile has been validated for basic\n                                  * security issues, so read the whole thing in.\n                                  */\n                                 size = profile_length - (sizeof profile_header)\n                                     - 12 * tag_count;\n\n                                 (void)png_inflate_read(png_ptr, local_buffer,\n                                     (sizeof local_buffer), &length,\n                                     profile + (sizeof profile_header) +\n                                     12 * tag_count, &size, 1/*finish*/);\n\n                                 if (length > 0 && !(png_ptr->flags &\n                                     PNG_FLAG_BENIGN_ERRORS_WARN))\n                                    errmsg = \"extra compressed data\";\n\n                                 /* But otherwise allow extra data: */\n                                 else if (size == 0)\n                                 {\n                                    if (length > 0)\n                                    {\n                                       /* This can be handled completely, so\n                                        * keep going.\n                                        */\n                                       png_chunk_warning(png_ptr,\n                                           \"extra compressed data\");\n                                    }\n\n                                    png_crc_finish(png_ptr, length);\n                                    finished = 1;\n\n                                    /* Steal the profile for info_ptr. */\n                                    if (info_ptr != NULL)\n                                    {\n                                       png_free_data(png_ptr, info_ptr,\n                                           PNG_FREE_ICCP, 0);\n\n                                       info_ptr->iccp_name = png_voidcast(char*,\n                                           png_malloc_base(png_ptr,\n                                           keyword_length+1));\n                                       if (info_ptr->iccp_name != NULL)\n                                       {\n                                          memcpy(info_ptr->iccp_name, keyword,\n                                              keyword_length+1);\n                                          info_ptr->iccp_proflen =\n                                              profile_length;\n                                          info_ptr->iccp_profile = profile;\n                                          png_ptr->read_buffer = NULL; /*steal*/\n                                          info_ptr->free_me |= PNG_FREE_ICCP;\n                                          info_ptr->valid |= PNG_INFO_iCCP;\n                                       }\n\n                                       else\n                                          errmsg = \"out of memory\";\n                                    }\n\n                                    /* else the profile remains in the read\n                                     * buffer which gets reused for subsequent\n                                     * chunks.\n                                     */\n\n                                    if (errmsg == NULL)\n                                    {\n                                       png_ptr->zowner = 0;\n                                       return handled_ok;\n                                    }\n                                 }\n                                 if (errmsg == NULL)\n                                    errmsg = png_ptr->zstream.msg;\n                              }\n                              /* else png_icc_check_tag_table output an error */\n                           }\n                           else /* profile truncated */\n                              errmsg = png_ptr->zstream.msg;\n                        }\n\n                        else\n                           errmsg = \"out of memory\";\n                     }\n\n                     /* else png_icc_check_header output an error */\n                  }\n\n                  /* else png_icc_check_length output an error */\n               }\n\n               else /* profile truncated */\n                  errmsg = png_ptr->zstream.msg;\n\n               /* Release the stream */\n               png_ptr->zowner = 0;\n            }\n\n            else /* png_inflate_claim failed */\n               errmsg = png_ptr->zstream.msg;\n         }\n\n         else\n            errmsg = \"bad compression method\"; /* or missing */\n      }\n\n      else\n         errmsg = \"bad keyword\";\n   }\n\n   /* Failure: the reason is in 'errmsg' */\n   if (finished == 0)\n      png_crc_finish(png_ptr, length);\n\n   if (errmsg != NULL) /* else already output */\n      png_chunk_benign_error(png_ptr, errmsg);\n\n   return handled_error;\n}\n",
      "line_start": 1339,
      "line_end": 1557,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 213,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_inflate_read",
      "clean_name": "png_inflate_read",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#ifdef PNG_READ_iCCP_SUPPORTED\n/* Perform a partial read and decompress, producing 'avail_out' bytes and\n * reading from the current chunk as required.\n */\nstatic int\npng_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,\n    png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,\n    int finish)\n{\n   if (png_ptr->zowner == png_ptr->chunk_name)\n   {\n      int ret;\n\n      /* next_in and avail_in must have been initialized by the caller. */\n      png_ptr->zstream.next_out = next_out;\n      png_ptr->zstream.avail_out = 0; /* set in the loop */\n\n      do\n      {\n         if (png_ptr->zstream.avail_in == 0)\n         {\n            if (read_size > *chunk_bytes)\n               read_size = (uInt)*chunk_bytes;\n            *chunk_bytes -= read_size;\n\n            if (read_size > 0)\n               png_crc_read(png_ptr, read_buffer, read_size);\n\n            png_ptr->zstream.next_in = read_buffer;\n            png_ptr->zstream.avail_in = read_size;\n         }\n\n         if (png_ptr->zstream.avail_out == 0)\n         {\n            uInt avail = ZLIB_IO_MAX;\n            if (avail > *out_size)\n               avail = (uInt)*out_size;\n            *out_size -= avail;\n\n            png_ptr->zstream.avail_out = avail;\n         }\n\n         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all\n          * the available output is produced; this allows reading of truncated\n          * streams.\n          */\n         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?\n             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      }\n      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));\n\n      *out_size += png_ptr->zstream.avail_out;\n      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */\n\n      /* Ensure the error message pointer is always set: */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n",
      "line_start": 835,
      "line_end": 895,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_sPLT",
      "clean_name": "png_handle_sPLT",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_iCCP NULL\n#endif /* READ_iCCP */\n\n#ifdef PNG_READ_sPLT_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle chunks that are > 64K under DOS */\n{\n   png_bytep entry_start, buffer;\n   png_sPLT_t new_palette;\n   png_sPLT_entryp pp;\n   png_uint_32 data_length;\n   int entry_size, i;\n   png_uint_32 skip = 0;\n   png_uint_32 dl;\n   size_t max_dl;\n\n   png_debug(1, \"in png_handle_sPLT\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_warning(png_ptr, \"No space in chunk cache for sPLT\");\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1);\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n\n   /* WARNING: this may break if size_t is less than 32 bits; it is assumed\n    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a\n    * potential breakage point if the types in pngconf.h aren't exactly right.\n    */\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return handled_error;\n\n   buffer[length] = 0;\n\n   for (entry_start = buffer; *entry_start; entry_start++)\n      /* Empty loop to find end of name */ ;\n\n   ++entry_start;\n\n   /* A sample depth should follow the separator, and we should be on it  */\n   if (length < 2U || entry_start > buffer + (length - 2U))\n   {\n      png_warning(png_ptr, \"malformed sPLT chunk\");\n      return handled_error;\n   }\n\n   new_palette.depth = *entry_start++;\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\n   /* This must fit in a png_uint_32 because it is derived from the original\n    * chunk data length.\n    */\n   data_length = length - (png_uint_32)(entry_start - buffer);\n\n   /* Integrity-check the data length */\n   if ((data_length % (unsigned int)entry_size) != 0)\n   {\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\n      return handled_error;\n   }\n\n   dl = (png_uint_32)(data_length / (unsigned int)entry_size);\n   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));\n\n   if (dl > max_dl)\n   {\n      png_warning(png_ptr, \"sPLT chunk too long\");\n      return handled_error;\n   }\n\n   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);\n\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,\n       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));\n\n   if (new_palette.entries == NULL)\n   {\n      png_warning(png_ptr, \"sPLT chunk requires too much memory\");\n      return handled_error;\n   }\n\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n      pp = new_palette.entries + i;\n\n      if (new_palette.depth == 8)\n      {\n         pp->red = *entry_start++;\n         pp->green = *entry_start++;\n         pp->blue = *entry_start++;\n         pp->alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp->red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp->green = png_get_uint_16(entry_start); entry_start += 2;\n         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n\n   /* Discard all chunk data except the name and stash that */\n   new_palette.name = (png_charp)buffer;\n\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\n\n   png_free(png_ptr, new_palette.entries);\n   return handled_ok;\n}\n",
      "line_start": 1563,
      "line_end": 1692,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 148,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_set_cHRM_XYZ_fixed",
      "clean_name": "png_set_cHRM_XYZ_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n   info_ptr->valid |= PNG_INFO_cHRM;\n}\n\nvoid PNGFAPI\npng_set_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_fixed_point int_red_X, png_fixed_point int_red_Y,\n    png_fixed_point int_red_Z, png_fixed_point int_green_X,\n    png_fixed_point int_green_Y, png_fixed_point int_green_Z,\n    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,\n    png_fixed_point int_blue_Z)\n{\n   png_XYZ XYZ;\n   png_xy xy;\n\n   png_debug1(1, \"in %s storage function\", \"cHRM XYZ fixed\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   XYZ.red_X = int_red_X;\n   XYZ.red_Y = int_red_Y;\n   XYZ.red_Z = int_red_Z;\n   XYZ.green_X = int_green_X;\n   XYZ.green_Y = int_green_Y;\n   XYZ.green_Z = int_green_Z;\n   XYZ.blue_X = int_blue_X;\n   XYZ.blue_Y = int_blue_Y;\n   XYZ.blue_Z = int_blue_Z;\n\n   if (png_xy_from_XYZ(&xy, &XYZ) == 0)\n   {\n      info_ptr->cHRM = xy;\n      info_ptr->valid |= PNG_INFO_cHRM;\n   }\n\n   else\n      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n}\n",
      "line_start": 61,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_cHRM",
      "clean_name": "png_set_cHRM",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\n    double white_x, double white_y, double red_x, double red_y,\n    double green_x, double green_y, double blue_x, double blue_y)\n{\n   png_set_cHRM_fixed(png_ptr, info_ptr,\n       png_fixed(png_ptr, white_x, \"cHRM White X\"),\n       png_fixed(png_ptr, white_y, \"cHRM White Y\"),\n       png_fixed(png_ptr, red_x, \"cHRM Red X\"),\n       png_fixed(png_ptr, red_y, \"cHRM Red Y\"),\n       png_fixed(png_ptr, green_x, \"cHRM Green X\"),\n       png_fixed(png_ptr, green_y, \"cHRM Green Y\"),\n       png_fixed(png_ptr, blue_x, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_y, \"cHRM Blue Y\"));\n}\n",
      "line_start": 98,
      "line_end": 112,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_cHRM_XYZ",
      "clean_name": "png_set_cHRM_XYZ",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "       png_fixed(png_ptr, blue_x, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_y, \"cHRM Blue Y\"));\n}\n\nvoid PNGAPI\npng_set_cHRM_XYZ(png_const_structrp png_ptr, png_inforp info_ptr, double red_X,\n    double red_Y, double red_Z, double green_X, double green_Y, double green_Z,\n    double blue_X, double blue_Y, double blue_Z)\n{\n   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,\n       png_fixed(png_ptr, red_X, \"cHRM Red X\"),\n       png_fixed(png_ptr, red_Y, \"cHRM Red Y\"),\n       png_fixed(png_ptr, red_Z, \"cHRM Red Z\"),\n       png_fixed(png_ptr, green_X, \"cHRM Green X\"),\n       png_fixed(png_ptr, green_Y, \"cHRM Green Y\"),\n       png_fixed(png_ptr, green_Z, \"cHRM Green Z\"),\n       png_fixed(png_ptr, blue_X, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_Y, \"cHRM Blue Y\"),\n       png_fixed(png_ptr, blue_Z, \"cHRM Blue Z\"));\n}\n",
      "line_start": 114,
      "line_end": 129,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_cLLI",
      "clean_name": "png_set_cLLI",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_cLLI;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_cLLI(png_const_structrp png_ptr, png_inforp info_ptr,\n   double maxCLL, double maxFALL)\n{\n   png_set_cLLI_fixed(png_ptr, info_ptr,\n       png_fixed_ITU(png_ptr, maxCLL, \"png_set_cLLI(maxCLL)\"),\n       png_fixed_ITU(png_ptr, maxFALL, \"png_set_cLLI(maxFALL)\"));\n}\n",
      "line_start": 193,
      "line_end": 200,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_mDCV",
      "clean_name": "png_set_mDCV",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_mDCV;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_mDCV(png_const_structrp png_ptr, png_inforp info_ptr,\n    double white_x, double white_y, double red_x, double red_y, double green_x,\n    double green_y, double blue_x, double blue_y,\n    double maxDL, double minDL)\n{\n   png_set_mDCV_fixed(png_ptr, info_ptr,\n      png_fixed(png_ptr, white_x, \"png_set_mDCV(white(x))\"),\n      png_fixed(png_ptr, white_y, \"png_set_mDCV(white(y))\"),\n      png_fixed(png_ptr, red_x, \"png_set_mDCV(red(x))\"),\n      png_fixed(png_ptr, red_y, \"png_set_mDCV(red(y))\"),\n      png_fixed(png_ptr, green_x, \"png_set_mDCV(green(x))\"),\n      png_fixed(png_ptr, green_y, \"png_set_mDCV(green(y))\"),\n      png_fixed(png_ptr, blue_x, \"png_set_mDCV(blue(x))\"),\n      png_fixed(png_ptr, blue_y, \"png_set_mDCV(blue(y))\"),\n      png_fixed_ITU(png_ptr, maxDL, \"png_set_mDCV(maxDL)\"),\n      png_fixed_ITU(png_ptr, minDL, \"png_set_mDCV(minDL)\"));\n}\n",
      "line_start": 296,
      "line_end": 313,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_eXIf",
      "clean_name": "png_set_eXIf",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif /* FLOATING_POINT */\n#endif /* mDCV */\n\n#ifdef PNG_eXIf_SUPPORTED\nvoid PNGAPI\npng_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep exif)\n{\n  png_warning(png_ptr, \"png_set_eXIf does not work; use png_set_eXIf_1\");\n  PNG_UNUSED(info_ptr)\n  PNG_UNUSED(exif)\n}\n",
      "line_start": 318,
      "line_end": 325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_gAMA",
      "clean_name": "png_set_gAMA",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_gAMA;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)\n{\n   png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,\n       \"png_set_gAMA\"));\n}\n",
      "line_start": 373,
      "line_end": 378,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_hIST",
      "clean_name": "png_set_hIST",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\nvoid PNGAPI\npng_set_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_uint_16p hist)\n{\n   int i;\n\n   png_debug1(1, \"in %s storage function\", \"hIST\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (info_ptr->num_palette == 0 || info_ptr->num_palette\n       > PNG_MAX_PALETTE_LENGTH)\n   {\n      png_warning(png_ptr,\n          \"Invalid palette size, hIST allocation skipped\");\n\n      return;\n   }\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);\n\n   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in\n    * version 1.2.1\n    */\n   info_ptr->hist = png_voidcast(png_uint_16p, png_malloc_warn(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_uint_16))));\n\n   if (info_ptr->hist == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory for hIST chunk data\");\n      return;\n   }\n\n   for (i = 0; i < info_ptr->num_palette; i++)\n      info_ptr->hist[i] = hist[i];\n\n   info_ptr->free_me |= PNG_FREE_HIST;\n   info_ptr->valid |= PNG_INFO_hIST;\n}\n",
      "line_start": 383,
      "line_end": 422,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_sCAL",
      "clean_name": "png_set_sCAL",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_sCAL;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_sCAL(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\n    double width, double height)\n{\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\n\n   /* Check the arguments. */\n   if (width <= 0)\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\n\n   else if (height <= 0)\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\n\n   else\n   {\n      /* Convert 'width' and 'height' to ASCII. */\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\n\n      png_ascii_from_fp(png_ptr, swidth, (sizeof swidth), width,\n          PNG_sCAL_PRECISION);\n      png_ascii_from_fp(png_ptr, sheight, (sizeof sheight), height,\n          PNG_sCAL_PRECISION);\n\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\n   }\n}\n",
      "line_start": 665,
      "line_end": 691,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_sCAL_fixed",
      "clean_name": "png_set_sCAL_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FIXED_POINT_SUPPORTED\nvoid PNGAPI\npng_set_sCAL_fixed(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\n    png_fixed_point width, png_fixed_point height)\n{\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\n\n   /* Check the arguments. */\n   if (width <= 0)\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\n\n   else if (height <= 0)\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\n\n   else\n   {\n      /* Convert 'width' and 'height' to ASCII. */\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\n\n      png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);\n      png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);\n\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\n   }\n}\n",
      "line_start": 695,
      "line_end": 719,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_sRGB_gAMA_and_cHRM",
      "clean_name": "png_set_sRGB_gAMA_and_cHRM",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->rendering_intent = srgb_intent;\n   info_ptr->valid |= PNG_INFO_sRGB;\n}\n\nvoid PNGAPI\npng_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\n    int srgb_intent)\n{\n   png_debug1(1, \"in %s storage function\", \"sRGB_gAMA_and_cHRM\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   png_set_sRGB(png_ptr, info_ptr, srgb_intent);\n\n#  ifdef PNG_gAMA_SUPPORTED\n      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);\n#  endif /* gAMA */\n\n#  ifdef PNG_cHRM_SUPPORTED\n      png_set_cHRM_fixed(png_ptr, info_ptr,\n         /* color      x       y */\n         /* white */ 31270, 32900,\n         /* red   */ 64000, 33000,\n         /* green */ 30000, 60000,\n         /* blue  */ 15000,  6000);\n#  endif /* cHRM */\n}\n",
      "line_start": 832,
      "line_end": 855,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_iCCP",
      "clean_name": "png_set_iCCP",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#endif /* sRGB */\n\n\n#ifdef PNG_iCCP_SUPPORTED\nvoid PNGAPI\npng_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_charp name, int compression_type,\n    png_const_bytep profile, png_uint_32 proflen)\n{\n   png_charp new_iccp_name;\n   png_bytep new_iccp_profile;\n   size_t length;\n\n   png_debug1(1, \"in %s storage function\", \"iCCP\");\n\n   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)\n      return;\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n      png_app_error(png_ptr, \"Invalid iCCP compression method\");\n\n   length = strlen(name)+1;\n   new_iccp_name = png_voidcast(png_charp, png_malloc_warn(png_ptr, length));\n\n   if (new_iccp_name == NULL)\n   {\n      png_benign_error(png_ptr, \"Insufficient memory to process iCCP chunk\");\n\n      return;\n   }\n\n   memcpy(new_iccp_name, name, length);\n   new_iccp_profile = png_voidcast(png_bytep,\n       png_malloc_warn(png_ptr, proflen));\n\n   if (new_iccp_profile == NULL)\n   {\n      png_free(png_ptr, new_iccp_name);\n      png_benign_error(png_ptr,\n          \"Insufficient memory to process iCCP profile\");\n\n      return;\n   }\n\n   memcpy(new_iccp_profile, profile, proflen);\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);\n\n   info_ptr->iccp_proflen = proflen;\n   info_ptr->iccp_name = new_iccp_name;\n   info_ptr->iccp_profile = new_iccp_profile;\n   info_ptr->free_me |= PNG_FREE_ICCP;\n   info_ptr->valid |= PNG_INFO_iCCP;\n}\n",
      "line_start": 860,
      "line_end": 909,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_text",
      "clean_name": "png_set_text",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_TEXT_SUPPORTED\nvoid PNGAPI\npng_set_text(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int ret;\n   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);\n\n   if (ret != 0)\n      png_error(png_ptr, \"Insufficient memory to store text\");\n}\n",
      "line_start": 913,
      "line_end": 922,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_sPLT",
      "clean_name": "png_set_sPLT",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\nvoid PNGAPI\npng_set_sPLT(png_const_structrp png_ptr,\n    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)\n/*\n *  entries        - array of png_sPLT_t structures\n *                   to be added to the list of palettes\n *                   in the info structure.\n *\n *  nentries       - number of palette structures to be\n *                   added.\n */\n{\n   png_sPLT_tp np;\n\n   png_debug1(1, \"in %s storage function\", \"sPLT\");\n\n   if (png_ptr == NULL || info_ptr == NULL || nentries <= 0 || entries == NULL)\n      return;\n\n   /* Use the internal realloc function, which checks for all the possible\n    * overflows.  Notice that the parameters are (int) and (size_t)\n    */\n   np = png_voidcast(png_sPLT_tp,png_realloc_array(png_ptr,\n       info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries,\n       sizeof *np));\n\n   if (np == NULL)\n   {\n      /* Out of memory or too many chunks */\n      png_chunk_report(png_ptr, \"too many sPLT chunks\", PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   png_free(png_ptr, info_ptr->splt_palettes);\n\n   info_ptr->splt_palettes = np;\n   info_ptr->free_me |= PNG_FREE_SPLT;\n\n   np += info_ptr->splt_palettes_num;\n\n   do\n   {\n      size_t length;\n\n      /* Skip invalid input entries */\n      if (entries->name == NULL || entries->entries == NULL)\n      {\n         /* png_handle_sPLT doesn't do this, so this is an app error */\n         png_app_error(png_ptr, \"png_set_sPLT: invalid sPLT\");\n         /* Just skip the invalid entry */\n         continue;\n      }\n\n      np->depth = entries->depth;\n\n      /* In the event of out-of-memory just return - there's no point keeping\n       * on trying to add sPLT chunks.\n       */\n      length = strlen(entries->name) + 1;\n      np->name = png_voidcast(png_charp, png_malloc_base(png_ptr, length));\n\n      if (np->name == NULL)\n         break;\n\n      memcpy(np->name, entries->name, length);\n\n      /* IMPORTANT: we have memory now that won't get freed if something else\n       * goes wrong; this code must free it.  png_malloc_array produces no\n       * warnings; use a png_chunk_report (below) if there is an error.\n       */\n      np->entries = png_voidcast(png_sPLT_entryp, png_malloc_array(png_ptr,\n          entries->nentries, sizeof (png_sPLT_entry)));\n\n      if (np->entries == NULL)\n      {\n         png_free(png_ptr, np->name);\n         np->name = NULL;\n         break;\n      }\n\n      np->nentries = entries->nentries;\n      /* This multiply can't overflow because png_malloc_array has already\n       * checked it when doing the allocation.\n       */\n      memcpy(np->entries, entries->entries,\n          (unsigned int)entries->nentries * sizeof (png_sPLT_entry));\n\n      /* Note that 'continue' skips the advance of the out pointer and out\n       * count, so an invalid entry is not added.\n       */\n      info_ptr->valid |= PNG_INFO_sPLT;\n      ++(info_ptr->splt_palettes_num);\n      ++np;\n      ++entries;\n   }\n   while (--nentries);\n\n   if (nentries > 0)\n      png_chunk_report(png_ptr, \"sPLT out of memory\", PNG_CHUNK_WRITE_ERROR);\n}\n",
      "line_start": 1216,
      "line_end": 1315,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 103,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_unknown_chunks",
      "clean_name": "png_set_unknown_chunks",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "    */\n   return (png_byte)location;\n}\n\nvoid PNGAPI\npng_set_unknown_chunks(png_const_structrp png_ptr,\n    png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)\n{\n   png_unknown_chunkp np;\n\n   if (png_ptr == NULL || info_ptr == NULL || num_unknowns <= 0 ||\n       unknowns == NULL)\n      return;\n\n   /* Check for the failure cases where support has been disabled at compile\n    * time.  This code is hardly ever compiled - it's here because\n    * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this\n    * code) but may be meaningless if the read or write handling of unknown\n    * chunks is not compiled in.\n    */\n#  if !defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) && \\\n      defined(PNG_READ_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n      {\n         png_app_error(png_ptr, \"no unknown chunk support on read\");\n\n         return;\n      }\n#  endif\n#  if !defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED) && \\\n      defined(PNG_WRITE_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n      {\n         png_app_error(png_ptr, \"no unknown chunk support on write\");\n\n         return;\n      }\n#  endif\n\n   /* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that\n    * unknown critical chunks could be lost with just a warning resulting in\n    * undefined behavior.  Now png_chunk_report is used to provide behavior\n    * appropriate to read or write.\n    */\n   np = png_voidcast(png_unknown_chunkp, png_realloc_array(png_ptr,\n       info_ptr->unknown_chunks, info_ptr->unknown_chunks_num, num_unknowns,\n       sizeof *np));\n\n   if (np == NULL)\n   {\n      png_chunk_report(png_ptr, \"too many unknown chunks\",\n          PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   png_free(png_ptr, info_ptr->unknown_chunks);\n\n   info_ptr->unknown_chunks = np; /* safe because it is initialized */\n   info_ptr->free_me |= PNG_FREE_UNKN;\n\n   np += info_ptr->unknown_chunks_num;\n\n   /* Increment unknown_chunks_num each time round the loop to protect the\n    * just-allocated chunk data.\n    */\n   for (; num_unknowns > 0; --num_unknowns, ++unknowns)\n   {\n      memcpy(np->name, unknowns->name, (sizeof np->name));\n      np->name[(sizeof np->name)-1] = '\\0';\n      np->location = check_location(png_ptr, unknowns->location);\n\n      if (unknowns->size == 0)\n      {\n         np->data = NULL;\n         np->size = 0;\n      }\n\n      else\n      {\n         np->data = png_voidcast(png_bytep,\n             png_malloc_base(png_ptr, unknowns->size));\n\n         if (np->data == NULL)\n         {\n            png_chunk_report(png_ptr, \"unknown chunk: out of memory\",\n                PNG_CHUNK_WRITE_ERROR);\n            /* But just skip storing the unknown chunk */\n            continue;\n         }\n\n         memcpy(np->data, unknowns->data, unknowns->size);\n         np->size = unknowns->size;\n      }\n\n      /* These increments are skipped on out-of-memory for the data - the\n       * unknown chunk entry gets overwritten if the png_chunk_report returns.\n       * This is correct in the read case (the chunk is just dropped.)\n       */\n      ++np;\n      ++(info_ptr->unknown_chunks_num);\n   }\n}\n",
      "line_start": 1356,
      "line_end": 1453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_unknown_chunk_location",
      "clean_name": "png_set_unknown_chunk_location",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      ++(info_ptr->unknown_chunks_num);\n   }\n}\n\nvoid PNGAPI\npng_set_unknown_chunk_location(png_const_structrp png_ptr, png_inforp info_ptr,\n    int chunk, int location)\n{\n   /* This API is pretty pointless in 1.6.0 because the location can be set\n    * before the call to png_set_unknown_chunks.\n    *\n    * TODO: add a png_app_warning in 1.7\n    */\n   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&\n      chunk < info_ptr->unknown_chunks_num)\n   {\n      if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT)) == 0)\n      {\n         png_app_error(png_ptr, \"invalid unknown chunk location\");\n         /* Fake out the pre 1.6.0 behavior: */\n         if (((unsigned int)location & PNG_HAVE_IDAT) != 0) /* undocumented! */\n            location = PNG_AFTER_IDAT;\n\n         else\n            location = PNG_HAVE_IHDR; /* also undocumented */\n      }\n\n      info_ptr->unknown_chunks[chunk].location =\n         check_location(png_ptr, location);\n   }\n}\n",
      "line_start": 1455,
      "line_end": 1481,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_permit_mng_features",
      "clean_name": "png_permit_mng_features",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* STORE_UNKNOWN_CHUNKS */\n\n#ifdef PNG_MNG_FEATURES_SUPPORTED\npng_uint_32 PNGAPI\npng_permit_mng_features(png_structrp png_ptr, png_uint_32 mng_features)\n{\n   png_debug(1, \"in png_permit_mng_features\");\n\n   if (png_ptr == NULL)\n      return 0;\n\n   png_ptr->mng_features_permitted = mng_features & PNG_ALL_MNG_FEATURES;\n\n   return png_ptr->mng_features_permitted;\n}\n",
      "line_start": 1485,
      "line_end": 1496,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_read_user_chunk_fn",
      "clean_name": "png_set_read_user_chunk_fn",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_USER_CHUNKS_SUPPORTED\nvoid PNGAPI\npng_set_read_user_chunk_fn(png_structrp png_ptr, png_voidp user_chunk_ptr,\n    png_user_chunk_ptr read_user_chunk_fn)\n{\n   png_debug(1, \"in png_set_read_user_chunk_fn\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->read_user_chunk_fn = read_user_chunk_fn;\n   png_ptr->user_chunk_ptr = user_chunk_ptr;\n}\n",
      "line_start": 1690,
      "line_end": 1701,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_rows",
      "clean_name": "png_set_rows",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\nvoid PNGAPI\npng_set_rows(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytepp row_pointers)\n{\n   png_debug(1, \"in png_set_rows\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (info_ptr->row_pointers != NULL &&\n       (info_ptr->row_pointers != row_pointers))\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n\n   info_ptr->row_pointers = row_pointers;\n\n   if (row_pointers != NULL)\n      info_ptr->valid |= PNG_INFO_IDAT;\n}\n",
      "line_start": 1705,
      "line_end": 1722,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_compression_buffer_size",
      "clean_name": "png_set_compression_buffer_size",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      info_ptr->valid |= PNG_INFO_IDAT;\n}\n#endif\n\nvoid PNGAPI\npng_set_compression_buffer_size(png_structrp png_ptr, size_t size)\n{\n   png_debug(1, \"in png_set_compression_buffer_size\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (size == 0 || size > PNG_UINT_31_MAX)\n      png_error(png_ptr, \"invalid compression buffer size\");\n\n#  ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n   {\n      png_ptr->IDAT_read_size = (png_uint_32)size; /* checked above */\n      return;\n   }\n#  endif\n\n#  ifdef PNG_WRITE_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n   {\n      if (png_ptr->zowner != 0)\n      {\n         png_warning(png_ptr,\n             \"Compression buffer size cannot be changed because it is in use\");\n\n         return;\n      }\n\n#ifndef __COVERITY__\n      /* Some compilers complain that this is always false.  However, it\n       * can be true when integer overflow happens.\n       */\n      if (size > ZLIB_IO_MAX)\n      {\n         png_warning(png_ptr,\n             \"Compression buffer size limited to system maximum\");\n         size = ZLIB_IO_MAX; /* must fit */\n      }\n#endif\n\n      if (size < 6)\n      {\n         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH\n          * if this is permitted.\n          */\n         png_warning(png_ptr,\n             \"Compression buffer size cannot be reduced below 6\");\n\n         return;\n      }\n\n      if (png_ptr->zbuffer_size != size)\n      {\n         png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);\n         png_ptr->zbuffer_size = (uInt)size;\n      }\n   }\n#  endif\n}\n",
      "line_start": 1725,
      "line_end": 1785,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_invalid",
      "clean_name": "png_set_invalid",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   }\n#  endif\n}\n\nvoid PNGAPI\npng_set_invalid(png_const_structrp png_ptr, png_inforp info_ptr, int mask)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      info_ptr->valid &= (unsigned int)(~mask);\n}\n",
      "line_start": 1787,
      "line_end": 1792,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_user_limits",
      "clean_name": "png_set_user_limits",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n/* This function was added to libpng 1.2.6 */\nvoid PNGAPI\npng_set_user_limits(png_structrp png_ptr, png_uint_32 user_width_max,\n    png_uint_32 user_height_max)\n{\n   png_debug(1, \"in png_set_user_limits\");\n\n   /* Images with dimensions larger than these limits will be\n    * rejected by png_set_IHDR().  To accept any PNG datastream\n    * regardless of dimensions, set both limits to 0x7fffffff.\n    */\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->user_width_max = user_width_max;\n   png_ptr->user_height_max = user_height_max;\n}\n",
      "line_start": 1797,
      "line_end": 1812,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_chunk_cache_max",
      "clean_name": "png_set_chunk_cache_max",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   png_ptr->user_height_max = user_height_max;\n}\n\n/* This function was added to libpng 1.4.0 */\nvoid PNGAPI\npng_set_chunk_cache_max(png_structrp png_ptr, png_uint_32 user_chunk_cache_max)\n{\n   png_debug(1, \"in png_set_chunk_cache_max\");\n\n   if (png_ptr != NULL)\n      png_ptr->user_chunk_cache_max = user_chunk_cache_max;\n}\n",
      "line_start": 1815,
      "line_end": 1822,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_chunk_malloc_max",
      "clean_name": "png_set_chunk_malloc_max",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      png_ptr->user_chunk_cache_max = user_chunk_cache_max;\n}\n\n/* This function was added to libpng 1.4.1 */\nvoid PNGAPI\npng_set_chunk_malloc_max(png_structrp png_ptr,\n    png_alloc_size_t user_chunk_malloc_max)\n{\n   png_debug(1, \"in png_set_chunk_malloc_max\");\n\n   /* pngstruct::user_chunk_malloc_max is initialized to a non-zero value in\n    * png.c.  This API supports '0' for unlimited, make sure the correct\n    * (unlimited) value is set here to avoid a need to check for 0 everywhere\n    * the parameter is used.\n    */\n   if (png_ptr != NULL)\n   {\n      if (user_chunk_malloc_max == 0U) /* unlimited */\n      {\n#        ifdef PNG_MAX_MALLOC_64K\n            png_ptr->user_chunk_malloc_max = 65536U;\n#        else\n            png_ptr->user_chunk_malloc_max = PNG_SIZE_MAX;\n#        endif\n      }\n      else\n         png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n   }\n}\n",
      "line_start": 1825,
      "line_end": 1849,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_check_for_invalid_index",
      "clean_name": "png_set_check_for_invalid_index",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "    * from this gracefully by filling any incomplete palette with zeros\n    * (opaque black).  By default, when this occurs libpng will issue\n    * a benign error.  This API can be used to override that behavior.\n    */\nvoid PNGAPI\npng_set_check_for_invalid_index(png_structrp png_ptr, int allowed)\n{\n   png_debug(1, \"in png_set_check_for_invalid_index\");\n\n   if (allowed > 0)\n      png_ptr->num_palette_max = 0;\n\n   else\n      png_ptr->num_palette_max = -1;\n}\n",
      "line_start": 1884,
      "line_end": 1894,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_check_keyword",
      "clean_name": "png_check_keyword",
      "source_file": "/src/libpng/pngset.c",
      "source_code": " * The 'new_key' buffer must be 80 characters in size (for the keyword plus a\n * trailing '\\0').  If this routine returns 0 then there was no keyword, or a\n * valid one could not be generated, and the caller must png_error.\n */\npng_uint_32 /* PRIVATE */\npng_check_keyword(png_structrp png_ptr, png_const_charp key, png_bytep new_key)\n{\n#ifdef PNG_WARNINGS_SUPPORTED\n   png_const_charp orig_key = key;\n#endif\n   png_uint_32 key_len = 0;\n   int bad_character = 0;\n   int space = 1;\n\n   png_debug(1, \"in png_check_keyword\");\n\n   if (key == NULL)\n   {\n      *new_key = 0;\n      return 0;\n   }\n\n   while (*key && key_len < 79)\n   {\n      png_byte ch = (png_byte)*key++;\n\n      if ((ch > 32 && ch <= 126) || (ch >= 161 /*&& ch <= 255*/))\n      {\n         *new_key++ = ch; ++key_len; space = 0;\n      }\n\n      else if (space == 0)\n      {\n         /* A space or an invalid character when one wasn't seen immediately\n          * before; output just a space.\n          */\n         *new_key++ = 32; ++key_len; space = 1;\n\n         /* If the character was not a space then it is invalid. */\n         if (ch != 32)\n            bad_character = ch;\n      }\n\n      else if (bad_character == 0)\n         bad_character = ch; /* just skip it, record the first error */\n   }\n\n   if (key_len > 0 && space != 0) /* trailing space */\n   {\n      --key_len; --new_key;\n      if (bad_character == 0)\n         bad_character = 32;\n   }\n\n   /* Terminate the keyword */\n   *new_key = 0;\n\n   if (key_len == 0)\n      return 0;\n\n#ifdef PNG_WARNINGS_SUPPORTED\n   /* Try to only output one warning per keyword: */\n   if (*key != 0) /* keyword too long */\n      png_warning(png_ptr, \"keyword truncated\");\n\n   else if (bad_character != 0)\n   {\n      PNG_WARNING_PARAMETERS(p)\n\n      png_warning_parameter(p, 1, orig_key);\n      png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);\n\n      png_formatted_warning(png_ptr, p, \"keyword \\\"@1\\\": bad character '0x@2'\");\n   }\n#else /* !WARNINGS */\n   PNG_UNUSED(png_ptr)\n#endif /* !WARNINGS */\n\n   return key_len;\n}\n",
      "line_start": 1909,
      "line_end": 1984,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 88,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "pngset.c:check_location",
      "clean_name": "check_location",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* sPLT */\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\nstatic png_byte\ncheck_location(png_const_structrp png_ptr, int location)\n{\n   location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);\n\n   /* New in 1.6.0; copy the location and check it.  This is an API\n    * change; previously the app had to use the\n    * png_set_unknown_chunk_location API below for each chunk.\n    */\n   if (location == 0 && (png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n   {\n      /* Write struct, so unknown chunks come from the app */\n      png_app_warning(png_ptr,\n          \"png_set_unknown_chunks now expects a valid location\");\n      /* Use the old behavior */\n      location = (png_byte)(png_ptr->mode &\n          (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));\n   }\n\n   /* This need not be an internal error - if the app calls\n    * png_set_unknown_chunks on a read pointer it must get the location right.\n    */\n   if (location == 0)\n      png_error(png_ptr, \"invalid location in png_set_unknown_chunks\");\n\n   /* Now reduce the location to the top-most set bit by removing each least\n    * significant bit in turn.\n    */\n   while (location != (location & -location))\n      location &= ~(location & -location);\n\n   /* The cast is safe because 'location' is a bit mask and only the low four\n    * bits are significant.\n    */\n   return (png_byte)location;\n}\n",
      "line_start": 1319,
      "line_end": 1354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 39,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true
    },
    {
      "name": "png_set_bgr",
      "clean_name": "png_set_bgr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\n/* Turn on BGR-to-RGB mapping */\nvoid PNGAPI\npng_set_bgr(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_bgr\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_BGR;\n}\n",
      "line_start": 19,
      "line_end": 28,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_swap",
      "clean_name": "png_set_swap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\n/* Turn on 16-bit byte swapping */\nvoid PNGAPI\npng_set_swap(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_swap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth == 16)\n      png_ptr->transformations |= PNG_SWAP_BYTES;\n}\n",
      "line_start": 33,
      "line_end": 43,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_packswap",
      "clean_name": "png_set_packswap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)\n/* Turn on packed pixel swapping */\nvoid PNGAPI\npng_set_packswap(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_packswap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth < 8)\n      png_ptr->transformations |= PNG_PACKSWAP;\n}\n",
      "line_start": 68,
      "line_end": 78,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_shift",
      "clean_name": "png_set_shift",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)\nvoid PNGAPI\npng_set_shift(png_structrp png_ptr, png_const_color_8p true_bits)\n{\n   png_debug(1, \"in png_set_shift\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_SHIFT;\n   png_ptr->shift = *true_bits;\n}\n",
      "line_start": 82,
      "line_end": 92,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_swap_alpha",
      "clean_name": "png_set_swap_alpha",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \\\n    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)\nvoid PNGAPI\npng_set_swap_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_swap_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_SWAP_ALPHA;\n}\n",
      "line_start": 221,
      "line_end": 230,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_invert_alpha",
      "clean_name": "png_set_invert_alpha",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \\\n    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)\nvoid PNGAPI\npng_set_invert_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_invert_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_INVERT_ALPHA;\n}\n",
      "line_start": 235,
      "line_end": 244,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_invert_mono",
      "clean_name": "png_set_invert_mono",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)\nvoid PNGAPI\npng_set_invert_mono(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_invert_mono\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_INVERT_MONO;\n}\n",
      "line_start": 248,
      "line_end": 257,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_invert",
      "clean_name": "png_do_invert",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "   png_ptr->transformations |= PNG_INVERT_MONO;\n}\n\n/* Invert monochrome grayscale data */\nvoid /* PRIVATE */\npng_do_invert(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_invert\");\n\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\n   *   if (row_info->bit_depth == 1 &&\n   */\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i++)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp++;\n      }\n   }\n\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 8)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 2)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp += 2;\n      }\n   }\n\n#ifdef PNG_16BIT_SUPPORTED\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 4)\n      {\n         *rp = (png_byte)(~(*rp));\n         *(rp + 1) = (png_byte)(~(*(rp + 1)));\n         rp += 4;\n      }\n   }\n#endif\n}\n",
      "line_start": 260,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_swap",
      "clean_name": "png_do_swap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#ifdef PNG_16BIT_SUPPORTED\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\n/* Swaps byte order on 16-bit depth images */\nvoid /* PRIVATE */\npng_do_swap(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_swap\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop= row_info->width * row_info->channels;\n\n      for (i = 0; i < istop; i++, rp += 2)\n      {\n#ifdef PNG_BUILTIN_BSWAP16_SUPPORTED\n         /* Feature added to libpng-1.6.11 for testing purposes, not\n          * enabled by default.\n          */\n         *(png_uint_16*)rp = __builtin_bswap16(*(png_uint_16*)rp);\n#else\n         png_byte t = *rp;\n         *rp = *(rp + 1);\n         *(rp + 1) = t;\n#endif\n      }\n   }\n}\n",
      "line_start": 317,
      "line_end": 342,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_packswap",
      "clean_name": "png_do_packswap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF\n};\n\n/* Swaps pixel packing order within bytes */\nvoid /* PRIVATE */\npng_do_packswap(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_packswap\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_bytep rp;\n      png_const_bytep end, table;\n\n      end = row + row_info->rowbytes;\n\n      if (row_info->bit_depth == 1)\n         table = onebppswaptable;\n\n      else if (row_info->bit_depth == 2)\n         table = twobppswaptable;\n\n      else if (row_info->bit_depth == 4)\n         table = fourbppswaptable;\n\n      else\n         return;\n\n      for (rp = row; rp < end; rp++)\n         *rp = table[*rp];\n   }\n}\n",
      "line_start": 453,
      "line_end": 480,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_strip_channel",
      "clean_name": "png_do_strip_channel",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": " *\n * The routine isn't general - the channel must be the channel at the start or\n * end (not in the middle) of each pixel.\n */\nvoid /* PRIVATE */\npng_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)\n{\n   png_bytep sp = row; /* source pointer */\n   png_bytep dp = row; /* destination pointer */\n   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */\n\n   png_debug(1, \"in png_do_strip_channel\");\n\n   /* At the start sp will point to the first byte to copy and dp to where\n    * it is copied to.  ep always points just beyond the end of the row, so\n    * the loop simply copies (channels-1) channels until sp reaches ep.\n    *\n    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.\n    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.\n    */\n\n   /* GA, GX, XG cases */\n   if (row_info->channels == 2)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channel and, for sp, the filler */\n         {\n            sp += 2; ++dp;\n         }\n\n         /* For a 1 pixel wide image there is nothing to do */\n         while (sp < ep)\n         {\n            *dp++ = *sp; sp += 2;\n         }\n\n         row_info->pixel_depth = 8;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channel and, for sp, the filler */\n         {\n            sp += 4; dp += 2;\n         }\n\n         while (sp < ep)\n         {\n            *dp++ = *sp++; *dp++ = *sp; sp += 3;\n         }\n\n         row_info->pixel_depth = 16;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 1;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_GRAY;\n   }\n\n   /* RGBA, RGBX, XRGB cases */\n   else if (row_info->channels == 4)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channels and, for sp, the filler */\n         {\n            sp += 4; dp += 3;\n         }\n\n         /* Note that the loop adds 3 to dp and 4 to sp each time. */\n         while (sp < ep)\n         {\n            *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp; sp += 2;\n         }\n\n         row_info->pixel_depth = 24;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channels and, for sp, the filler */\n         {\n            sp += 8; dp += 6;\n         }\n\n         while (sp < ep)\n         {\n            /* Copy 6 bytes, skip 2 */\n            *dp++ = *sp++; *dp++ = *sp++;\n            *dp++ = *sp++; *dp++ = *sp++;\n            *dp++ = *sp++; *dp++ = *sp; sp += 3;\n         }\n\n         row_info->pixel_depth = 48;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 3;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_RGB;\n   }\n\n   else\n      return; /* The filler channel has gone already */\n\n   /* Fix the rowbytes value. */\n   row_info->rowbytes = (size_t)(dp-row);\n}\n",
      "line_start": 493,
      "line_end": 614,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 115,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_bgr",
      "clean_name": "png_do_bgr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\n/* Swaps red and blue bytes within a pixel */\nvoid /* PRIVATE */\npng_do_bgr(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_bgr\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_uint_32 row_width = row_info->width;\n      if (row_info->bit_depth == 8)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 3)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 4)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n      }\n\n#ifdef PNG_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 6)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 8)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 619,
      "line_end": 693,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_do_check_palette_indexes",
      "clean_name": "png_do_check_palette_indexes",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \\\n    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)\n/* Added at libpng-1.5.10 */\nvoid /* PRIVATE */\npng_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)\n{\n   png_debug(1, \"in png_do_check_palette_indexes\");\n\n   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&\n      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */\n   {\n      /* Calculations moved outside switch in an attempt to stop different\n       * compiler warnings.  'padding' is in *bits* within the last byte, it is\n       * an 'int' because pixel_depth becomes an 'int' in the expression below,\n       * and this calculation is used because it avoids warnings that other\n       * forms produced on either GCC or MSVC.\n       */\n      int padding = PNG_PADBITS(row_info->pixel_depth, row_info->width);\n      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            /* in this case, all bytes must be 0 so we don't need\n             * to unpack the pixels except for the rightmost one.\n             */\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              if ((*rp >> padding) != 0)\n                 png_ptr->num_palette_max = 1;\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 2:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 2) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 6) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 4:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 8:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n               if (*rp > png_ptr->num_palette_max)\n                  png_ptr->num_palette_max = (int) *rp;\n            }\n\n            break;\n         }\n\n         default:\n            break;\n      }\n   }\n}\n",
      "line_start": 699,
      "line_end": 798,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 87,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_set_user_transform_info",
      "clean_name": "png_set_user_transform_info",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\nvoid PNGAPI\npng_set_user_transform_info(png_structrp png_ptr, png_voidp\n   user_transform_ptr, int user_transform_depth, int user_transform_channels)\n{\n   png_debug(1, \"in png_set_user_transform_info\");\n\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n      (png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)\n   {\n      png_app_error(png_ptr,\n          \"info change after png_start_read_image or png_read_update_info\");\n      return;\n   }\n#endif\n\n   png_ptr->user_transform_ptr = user_transform_ptr;\n   png_ptr->user_transform_depth = (png_byte)user_transform_depth;\n   png_ptr->user_transform_channels = (png_byte)user_transform_channels;\n}\n",
      "line_start": 804,
      "line_end": 826,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_user_transform_ptr",
      "clean_name": "png_get_user_transform_ptr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": " * associated with this pointer before png_write_destroy and png_read_destroy\n * are called.\n */\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\npng_voidp PNGAPI\npng_get_user_transform_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return png_ptr->user_transform_ptr;\n}\n",
      "line_start": 835,
      "line_end": 842,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_current_row_number",
      "clean_name": "png_get_current_row_number",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED\npng_uint_32 PNGAPI\npng_get_current_row_number(png_const_structrp png_ptr)\n{\n   /* See the comments in png.h - this is the sub-image row when reading an\n    * interlaced image.\n    */\n   if (png_ptr != NULL)\n      return png_ptr->row_number;\n\n   return PNG_UINT_32_MAX; /* help the app not to fail silently */\n}\n",
      "line_start": 846,
      "line_end": 856,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_get_current_pass_number",
      "clean_name": "png_get_current_pass_number",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n   return PNG_UINT_32_MAX; /* help the app not to fail silently */\n}\n\npng_byte PNGAPI\npng_get_current_pass_number(png_const_structrp png_ptr)\n{\n   if (png_ptr != NULL)\n      return png_ptr->pass;\n   return 8; /* invalid */\n}\n",
      "line_start": 858,
      "line_end": 864,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false
    },
    {
      "name": "png_combine_row",
      "clean_name": "png_combine_row",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * depending on the 'display' value; if 'display' is true then the whole row\n * (dp) is filled from the start by replicating the available pixels.  If\n * 'display' is false only those pixels present in the pass are filled in.\n */\nvoid /* PRIVATE */\npng_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)\n{\n   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;\n   png_const_bytep sp = png_ptr->row_buf + 1;\n   png_alloc_size_t row_width = png_ptr->width;\n   unsigned int pass = png_ptr->pass;\n   png_bytep end_ptr = 0;\n   png_byte end_byte = 0;\n   unsigned int end_mask;\n\n   png_debug(1, \"in png_combine_row\");\n\n   /* Added in 1.5.6: it should not be possible to enter this routine until at\n    * least one row has been read from the PNG data and transformed.\n    */\n   if (pixel_depth == 0)\n      png_error(png_ptr, \"internal row logic error\");\n\n   /* Added in 1.5.4: the pixel depth should match the information returned by\n    * any call to png_read_update_info at this point.  Do not continue if we got\n    * this wrong.\n    */\n   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=\n          PNG_ROWBYTES(pixel_depth, row_width))\n      png_error(png_ptr, \"internal row size calculation error\");\n\n   /* Don't expect this to ever happen: */\n   if (row_width == 0)\n      png_error(png_ptr, \"internal row width error\");\n\n   /* Preserve the last byte in cases where only part of it will be overwritten,\n    * the multiply below may overflow, we don't care because ANSI-C guarantees\n    * we get the low bits.\n    */\n   end_mask = (pixel_depth * row_width) & 7;\n   if (end_mask != 0)\n   {\n      /* end_ptr == NULL is a flag to say do nothing */\n      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;\n      end_byte = *end_ptr;\n#     ifdef PNG_READ_PACKSWAP_SUPPORTED\n      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n         /* little-endian byte */\n         end_mask = (unsigned int)(0xff << end_mask);\n\n      else /* big-endian byte */\n#     endif\n      end_mask = 0xff >> end_mask;\n      /* end_mask is now the bits to *keep* from the destination row */\n   }\n\n   /* For non-interlaced images this reduces to a memcpy(). A memcpy()\n    * will also happen if interlacing isn't supported or if the application\n    * does not call png_set_interlace_handling().  In the latter cases the\n    * caller just gets a sequence of the unexpanded rows from each interlace\n    * pass.\n    */\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced != 0 &&\n       (png_ptr->transformations & PNG_INTERLACE) != 0 &&\n       pass < 6 && (display == 0 ||\n       /* The following copies everything for 'display' on passes 0, 2 and 4. */\n       (display == 1 && (pass & 1) != 0)))\n   {\n      /* Narrow images may have no bits in a pass; the caller should handle\n       * this, but this test is cheap:\n       */\n      if (row_width <= PNG_PASS_START_COL(pass))\n         return;\n\n      if (pixel_depth < 8)\n      {\n         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit\n          * into 32 bits, then a single loop over the bytes using the four byte\n          * values in the 32-bit mask can be used.  For the 'display' option the\n          * expanded mask may also not require any masking within a byte.  To\n          * make this work the PACKSWAP option must be taken into account - it\n          * simply requires the pixels to be reversed in each byte.\n          *\n          * The 'regular' case requires a mask for each of the first 6 passes,\n          * the 'display' case does a copy for the even passes in the range\n          * 0..6.  This has already been handled in the test above.\n          *\n          * The masks are arranged as four bytes with the first byte to use in\n          * the lowest bits (little-endian) regardless of the order (PACKSWAP or\n          * not) of the pixels in each byte.\n          *\n          * NOTE: the whole of this logic depends on the caller of this function\n          * only calling it on rows appropriate to the pass.  This function only\n          * understands the 'x' logic; the 'y' logic is handled by the caller.\n          *\n          * The following defines allow generation of compile time constant bit\n          * masks for each pixel depth and each possibility of swapped or not\n          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,\n          * is in the range 0..7; and the result is 1 if the pixel is to be\n          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'\n          * for the block method.\n          *\n          * With some compilers a compile time expression of the general form:\n          *\n          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)\n          *\n          * Produces warnings with values of 'shift' in the range 33 to 63\n          * because the right hand side of the ?: expression is evaluated by\n          * the compiler even though it isn't used.  Microsoft Visual C (various\n          * versions) and the Intel C compiler are known to do this.  To avoid\n          * this the following macros are used in 1.5.6.  This is a temporary\n          * solution to avoid destabilizing the code during the release process.\n          */\n#        if PNG_USE_COMPILE_TIME_MASKS\n#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))\n#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))\n#        else\n#           define PNG_LSR(x,s) ((x)>>(s))\n#           define PNG_LSL(x,s) ((x)<<(s))\n#        endif\n#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)\n#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)\n\n         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is\n          * little endian - the first pixel is at bit 0 - however the extra\n          * parameter 's' can be set to cause the mask position to be swapped\n          * within each byte, to match the PNG format.  This is done by XOR of\n          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.\n          */\n#        define PIXEL_MASK(p,x,d,s) \\\n            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))\n\n         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.\n          */\n#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n\n         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp\n          * cases the result needs replicating, for the 4-bpp case the above\n          * generates a full 32 bits.\n          */\n#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))\n\n#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\\\n            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\\\n            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)\n\n#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\\\n            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\\\n            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)\n\n#if PNG_USE_COMPILE_TIME_MASKS\n         /* Utility macros to construct all the masks for a depth/swap\n          * combination.  The 's' parameter says whether the format is PNG\n          * (big endian bytes) or not.  Only the three odd-numbered passes are\n          * required for the display/block algorithm.\n          */\n#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\\\n            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }\n\n#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }\n\n#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))\n\n         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and\n          * then pass:\n          */\n         static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }\n         };\n\n         /* display_mask has only three entries for the odd passes, so index by\n          * pass>>1.\n          */\n         static const png_uint_32 display_mask[2][3][3] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }\n         };\n\n#        define MASK(pass,depth,display,png)\\\n            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\\\n               row_mask[png][DEPTH_INDEX(depth)][pass])\n\n#else /* !PNG_USE_COMPILE_TIME_MASKS */\n         /* This is the runtime alternative: it seems unlikely that this will\n          * ever be either smaller or faster than the compile time approach.\n          */\n#        define MASK(pass,depth,display,png)\\\n            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))\n#endif /* !USE_COMPILE_TIME_MASKS */\n\n         /* Use the appropriate mask to copy the required bits.  In some cases\n          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is\n          * the number of pixels, but the code copies bytes, so it is necessary\n          * to special case the end.\n          */\n         png_uint_32 pixels_per_byte = 8 / pixel_depth;\n         png_uint_32 mask;\n\n#        ifdef PNG_READ_PACKSWAP_SUPPORTED\n         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n            mask = MASK(pass, pixel_depth, display, 0);\n\n         else\n#        endif\n         mask = MASK(pass, pixel_depth, display, 1);\n\n         for (;;)\n         {\n            png_uint_32 m;\n\n            /* It doesn't matter in the following if png_uint_32 has more than\n             * 32 bits because the high bits always match those in m<<24; it is,\n             * however, essential to use OR here, not +, because of this.\n             */\n            m = mask;\n            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */\n            m &= 0xff;\n\n            if (m != 0) /* something to copy */\n            {\n               if (m != 0xff)\n                  *dp = (png_byte)((*dp & ~m) | (*sp & m));\n               else\n                  *dp = *sp;\n            }\n\n            /* NOTE: this may overwrite the last byte with garbage if the image\n             * is not an exact number of bytes wide; libpng has always done\n             * this.\n             */\n            if (row_width <= pixels_per_byte)\n               break; /* May need to restore part of the last byte */\n\n            row_width -= pixels_per_byte;\n            ++dp;\n            ++sp;\n         }\n      }\n\n      else /* pixel_depth >= 8 */\n      {\n         unsigned int bytes_to_copy, bytes_to_jump;\n\n         /* Validate the depth - it must be a multiple of 8 */\n         if (pixel_depth & 7)\n            png_error(png_ptr, \"invalid user transform pixel depth\");\n\n         pixel_depth >>= 3; /* now in bytes */\n         row_width *= pixel_depth;\n\n         /* Regardless of pass number the Adam 7 interlace always results in a\n          * fixed number of pixels to copy then to skip.  There may be a\n          * different number of pixels to skip at the start though.\n          */\n         {\n            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;\n\n            row_width -= offset;\n            dp += offset;\n            sp += offset;\n         }\n\n         /* Work out the bytes to copy. */\n         if (display != 0)\n         {\n            /* When doing the 'block' algorithm the pixel in the pass gets\n             * replicated to adjacent pixels.  This is why the even (0,2,4,6)\n             * passes are skipped above - the entire expanded row is copied.\n             */\n            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;\n\n            /* But don't allow this number to exceed the actual row width. */\n            if (bytes_to_copy > row_width)\n               bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n         }\n\n         else /* normal row; Adam7 only ever gives us one pixel to copy. */\n            bytes_to_copy = pixel_depth;\n\n         /* In Adam7 there is a constant offset between where the pixels go. */\n         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;\n\n         /* And simply copy these bytes.  Some optimization is possible here,\n          * depending on the value of 'bytes_to_copy'.  Special case the low\n          * byte counts, which we know to be frequent.\n          *\n          * Notice that these cases all 'return' rather than 'break' - this\n          * avoids an unnecessary test on whether to restore the last byte\n          * below.\n          */\n         switch (bytes_to_copy)\n         {\n            case 1:\n               for (;;)\n               {\n                  *dp = *sp;\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  dp += bytes_to_jump;\n                  sp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            case 2:\n               /* There is a possibility of a partial copy at the end here; this\n                * slows the code down somewhat.\n                */\n               do\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n               while (row_width > 1);\n\n               /* And there can only be one byte left at this point: */\n               *dp = *sp;\n               return;\n\n            case 3:\n               /* This can only be the RGB case, so each copy is exactly one\n                * pixel and it is not necessary to check for a partial copy.\n                */\n               for (;;)\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            default:\n#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE\n               /* Check for double byte alignment and, if possible, use a\n                * 16-bit copy.  Don't attempt this for narrow images - ones that\n                * are less than an interlace panel wide.  Don't attempt it for\n                * wide bytes_to_copy either - use the memcpy there.\n                */\n               if (bytes_to_copy < 16 /*else use memcpy*/ &&\n                   png_isaligned(dp, png_uint_16) &&\n                   png_isaligned(sp, png_uint_16) &&\n                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&\n                   bytes_to_jump % (sizeof (png_uint_16)) == 0)\n               {\n                  /* Everything is aligned for png_uint_16 copies, but try for\n                   * png_uint_32 first.\n                   */\n                  if (png_isaligned(dp, png_uint_32) &&\n                      png_isaligned(sp, png_uint_32) &&\n                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&\n                      bytes_to_jump % (sizeof (png_uint_32)) == 0)\n                  {\n                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);\n                     png_const_uint_32p sp32 = png_aligncastconst(\n                         png_const_uint_32p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                         (sizeof (png_uint_32));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp32++ = *sp32++;\n                           c -= (sizeof (png_uint_32));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp32 += skip;\n                        sp32 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* Get to here when the row_width truncates the final copy.\n                      * There will be 1-3 bytes left to copy, so don't try the\n                      * 16-bit loop below.\n                      */\n                     dp = (png_bytep)dp32;\n                     sp = (png_const_bytep)sp32;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n\n                  /* Else do it in 16-bit quantities, but only if the size is\n                   * not too large.\n                   */\n                  else\n                  {\n                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);\n                     png_const_uint_16p sp16 = png_aligncastconst(\n                        png_const_uint_16p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                        (sizeof (png_uint_16));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp16++ = *sp16++;\n                           c -= (sizeof (png_uint_16));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp16 += skip;\n                        sp16 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* End of row - 1 byte left, bytes_to_copy > row_width: */\n                     dp = (png_bytep)dp16;\n                     sp = (png_const_bytep)sp16;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n               }\n#endif /* ALIGN_TYPE code */\n\n               /* The true default - use a memcpy: */\n               for (;;)\n               {\n                  memcpy(dp, sp, bytes_to_copy);\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n                  if (bytes_to_copy > row_width)\n                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n               }\n         }\n\n         /* NOT REACHED*/\n      } /* pixel_depth >= 8 */\n\n      /* Here if pixel_depth < 8 to check 'end_ptr' below. */\n   }\n   else\n#endif /* READ_INTERLACING */\n\n   /* If here then the switch above wasn't used so just memcpy the whole row\n    * from the temporary row buffer (notice that this overwrites the end of the\n    * destination row if it is a partial byte.)\n    */\n   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));\n\n   /* Restore the overwritten bits from the last byte if necessary. */\n   if (end_ptr != NULL)\n      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n",
      "line_start": 3238,
      "line_end": 3719,
      "execution_count": 27980,
      "covered_regions": 128,
      "total_regions": 4830,
      "coverage_percent": 2.65,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_do_unpack",
      "clean_name": "png_do_unpack",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * a bit depth of 1, you would end up with bytes that only contained\n * the numbers 0 or 1.  If you would rather they contain 0 and 255, use\n * png_do_shift() after this.\n */\nstatic void\npng_do_unpack(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_unpack\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_uint_32 i;\n      png_uint_32 row_width=row_info->width;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_width - 1) >> 3);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = 7U - ((row_width + 7U) & 0x07);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x01);\n\n               if (shift == 7)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift++;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 2:\n         {\n\n            png_bytep sp = row + (size_t)((row_width - 1) >> 2);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = ((3U - ((row_width + 3U) & 0x03)) << 1);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x03);\n\n               if (shift == 6)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift += 2;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_width - 1) >> 1);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = ((1U - ((row_width + 1U) & 0x01)) << 2);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x0f);\n\n               if (shift == 4)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift = 4;\n\n               dp--;\n            }\n            break;\n         }\n\n         default:\n            break;\n      }\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_width * row_info->channels;\n   }\n}\n",
      "line_start": 2270,
      "line_end": 2359,
      "execution_count": 1103,
      "covered_regions": 4,
      "total_regions": 58,
      "coverage_percent": 6.9,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_zstream_error",
      "clean_name": "png_zstream_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.\n * If it doesn't 'ret' is used to set it to something appropriate, even in cases\n * like Z_OK or Z_STREAM_END where the error code is apparently a success code.\n */\nvoid /* PRIVATE */\npng_zstream_error(png_structrp png_ptr, int ret)\n{\n   /* Translate 'ret' into an appropriate error string, priority is given to the\n    * one in zstream if set.  This always returns a string, even in cases like\n    * Z_OK or Z_STREAM_END where the error code is a success code.\n    */\n   if (png_ptr->zstream.msg == NULL) switch (ret)\n   {\n      default:\n      case Z_OK:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return code\");\n         break;\n\n      case Z_STREAM_END:\n         /* Normal exit */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected end of LZ stream\");\n         break;\n\n      case Z_NEED_DICT:\n         /* This means the deflate stream did not have a dictionary; this\n          * indicates a bogus PNG.\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"missing LZ dictionary\");\n         break;\n\n      case Z_ERRNO:\n         /* gz APIs only: should not happen */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zlib IO error\");\n         break;\n\n      case Z_STREAM_ERROR:\n         /* internal libpng error */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"bad parameters to zlib\");\n         break;\n\n      case Z_DATA_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"damaged LZ stream\");\n         break;\n\n      case Z_MEM_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"insufficient memory\");\n         break;\n\n      case Z_BUF_ERROR:\n         /* End of input or output; not a problem if the caller is doing\n          * incremental read or write.\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"truncated\");\n         break;\n\n      case Z_VERSION_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unsupported zlib version\");\n         break;\n\n      case PNG_UNEXPECTED_ZLIB_RETURN:\n         /* Compile errors here mean that zlib now uses the value co-opted in\n          * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above\n          * and change pngpriv.h.  Note that this message is \"... return\",\n          * whereas the default/Z_OK one is \"... return code\".\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return\");\n         break;\n   }\n}\n",
      "line_start": 999,
      "line_end": 1063,
      "execution_count": 454,
      "covered_regions": 9,
      "total_regions": 73,
      "coverage_percent": 12.33,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_do_read_interlace",
      "clean_name": "png_do_read_interlace",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\nvoid /* PRIVATE */\npng_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,\n    png_uint_32 transformations /* Because these may affect the byte layout */)\n{\n   png_debug(1, \"in png_do_read_interlace\");\n   if (row != NULL && row_info != NULL)\n   {\n      png_uint_32 final_width;\n\n      final_width = row_info->width * png_pass_inc[pass];\n\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 3);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_byte v;\n            png_uint_32 i;\n            int j;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n                sshift = ((row_info->width + 7) & 0x07);\n                dshift = ((final_width + 7) & 0x07);\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n\n            else\n#endif\n            {\n                sshift = 7 - ((row_info->width + 7) & 0x07);\n                dshift = 7 - ((final_width + 7) & 0x07);\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               v = (png_byte)((*sp >> sshift) & 0x01);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 3) & 0x03) << 1);\n               dshift = (((final_width + 3) & 0x03) << 1);\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n\n            else\n#endif\n            {\n               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);\n               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v;\n               int j;\n\n               v = (png_byte)((*sp >> sshift) & 0x03);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 1);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            png_uint_32 i;\n            int jstop = (int)png_pass_inc[pass];\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 1) & 0x01) << 2);\n               dshift = (((final_width + 1) & 0x01) << 2);\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n\n            else\n#endif\n            {\n               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);\n               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);\n               int j;\n\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         default:\n         {\n            size_t pixel_bytes = (row_info->pixel_depth >> 3);\n\n            png_bytep sp = row + (size_t)(row_info->width - 1)\n                * pixel_bytes;\n\n            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;\n\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */\n               int j;\n\n               memcpy(v, sp, pixel_bytes);\n\n               for (j = 0; j < jstop; j++)\n               {\n                  memcpy(dp, v, pixel_bytes);\n                  dp -= pixel_bytes;\n               }\n\n               sp -= pixel_bytes;\n            }\n            break;\n         }\n      }\n\n      row_info->width = final_width;\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\n   }\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\n   PNG_UNUSED(transformations)  /* Silence compiler warning */\n#endif\n}\n",
      "line_start": 3722,
      "line_end": 3962,
      "execution_count": 2984,
      "covered_regions": 27,
      "total_regions": 147,
      "coverage_percent": 18.37,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_init_read_transformations",
      "clean_name": "png_init_read_transformations",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n}\n#endif /* READ_GAMMA */\n\nvoid /* PRIVATE */\npng_init_read_transformations(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_init_read_transformations\");\n\n   /* This internal function is called from png_read_start_row in pngrutil.c\n    * and it is called before the 'rowbytes' calculation is done, so the code\n    * in here can change or update the transformations flags.\n    *\n    * First do updates that do not depend on the details of the PNG image data\n    * being processed.\n    */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds\n    * png_set_alpha_mode and this is another source for a default file gamma so\n    * the test needs to be performed later - here.  In addition prior to 1.5.4\n    * the tests were repeated for the PALETTE color type here - this is no\n    * longer necessary (and doesn't seem to have been necessary before.)\n    *\n    * PNGv3: the new mandatory precedence/priority rules for colour space chunks\n    * are handled here (by calling the above function).\n    *\n    * Turn the gamma transformation on or off as appropriate.  Notice that\n    * PNG_GAMMA just refers to the file->screen correction.  Alpha composition\n    * may independently cause gamma correction because it needs linear data\n    * (e.g. if the file has a gAMA chunk but the screen gamma hasn't been\n    * specified.)  In any case this flag may get turned off in the code\n    * immediately below if the transform can be handled outside the row loop.\n    */\n   if (png_init_gamma_values(png_ptr) != 0)\n      png_ptr->transformations |= PNG_GAMMA;\n\n   else\n      png_ptr->transformations &= ~PNG_GAMMA;\n#endif\n\n   /* Certain transformations have the effect of preventing other\n    * transformations that happen afterward in png_do_read_transformations;\n    * resolve the interdependencies here.  From the code of\n    * png_do_read_transformations the order is:\n    *\n    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)\n    *  2) PNG_STRIP_ALPHA (if no compose)\n    *  3) PNG_RGB_TO_GRAY\n    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY\n    *  5) PNG_COMPOSE\n    *  6) PNG_GAMMA\n    *  7) PNG_STRIP_ALPHA (if compose)\n    *  8) PNG_ENCODE_ALPHA\n    *  9) PNG_SCALE_16_TO_8\n    * 10) PNG_16_TO_8\n    * 11) PNG_QUANTIZE (converts to palette)\n    * 12) PNG_EXPAND_16\n    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY\n    * 14) PNG_INVERT_MONO\n    * 15) PNG_INVERT_ALPHA\n    * 16) PNG_SHIFT\n    * 17) PNG_PACK\n    * 18) PNG_BGR\n    * 19) PNG_PACKSWAP\n    * 20) PNG_FILLER (includes PNG_ADD_ALPHA)\n    * 21) PNG_SWAP_ALPHA\n    * 22) PNG_SWAP_BYTES\n    * 23) PNG_USER_TRANSFORM [must be last]\n    */\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) == 0)\n   {\n      /* Stripping the alpha channel happens immediately after the 'expand'\n       * transformations, before all other transformation, so it cancels out\n       * the alpha handling.  It has the side effect negating the effect of\n       * PNG_EXPAND_tRNS too:\n       */\n      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |\n         PNG_EXPAND_tRNS);\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n\n      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen\n       * so transparency information would remain just so long as it wasn't\n       * expanded.  This produces unexpected API changes if the set of things\n       * that do PNG_EXPAND_tRNS changes (perfectly possible given the\n       * documentation - which says ask for what you want, accept what you\n       * get.)  This makes the behavior consistent from 1.5.4:\n       */\n      png_ptr->num_trans = 0;\n   }\n#endif /* STRIP_ALPHA supported, no COMPOSE */\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA\n    * settings will have no effect.\n    */\n   if (png_gamma_significant(png_ptr->screen_gamma) == 0)\n   {\n      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n   }\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   /* Make sure the coefficients for the rgb to gray conversion are set\n    * appropriately.\n    */\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n      png_set_rgb_coefficients(png_ptr);\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\n   /* Detect gray background and attempt to enable optimization for\n    * gray --> RGB case.\n    *\n    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or\n    * RGB_ALPHA (in which case need_expand is superfluous anyway), the\n    * background color might actually be gray yet not be flagged as such.\n    * This is not a problem for the current code, which uses\n    * PNG_BACKGROUND_IS_GRAY only to decide when to do the\n    * png_do_gray_to_rgb() transformation.\n    *\n    * TODO: this code needs to be revised to avoid the complexity and\n    * interdependencies.  The color type of the background should be recorded in\n    * png_set_background, along with the bit depth, then the code has a record\n    * of exactly what color space the background is currently in.\n    */\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0)\n   {\n      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if\n       * the file was grayscale the background value is gray.\n       */\n      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\n   }\n\n   else if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n   {\n      /* PNG_COMPOSE: png_set_background was called with need_expand false,\n       * so the color is in the color space of the output or png_set_alpha_mode\n       * was called and the color is black.  Ignore RGB_TO_GRAY because that\n       * happens before GRAY_TO_RGB.\n       */\n      if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n      {\n         if (png_ptr->background.red == png_ptr->background.green &&\n             png_ptr->background.red == png_ptr->background.blue)\n         {\n            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\n            png_ptr->background.gray = png_ptr->background.red;\n         }\n      }\n   }\n#endif /* READ_EXPAND && READ_BACKGROUND */\n#endif /* READ_GRAY_TO_RGB */\n\n   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations\n    * can be performed directly on the palette, and some (such as rgb to gray)\n    * can be optimized inside the palette.  This is particularly true of the\n    * composite (background and alpha) stuff, which can be pretty much all done\n    * in the palette even if the result is expanded to RGB or gray afterward.\n    *\n    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and\n    * earlier and the palette stuff is actually handled on the first row.  This\n    * leads to the reported bug that the palette returned by png_get_PLTE is not\n    * updated.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      png_init_palette_transformations(png_ptr);\n\n   else\n      png_init_rgb_transformations(png_ptr);\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\n   defined(PNG_READ_EXPAND_16_SUPPORTED)\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&\n       png_ptr->bit_depth != 16)\n   {\n      /* TODO: fix this.  Because the expand_16 operation is after the compose\n       * handling the background color must be 8, not 16, bits deep, but the\n       * application will supply a 16-bit value so reduce it here.\n       *\n       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at\n       * present, so that case is ok (until do_expand_16 is moved.)\n       *\n       * NOTE: this discards the low 16 bits of the user supplied background\n       * color, but until expand_16 works properly there is no choice!\n       */\n#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))\n      CHOP(png_ptr->background.red);\n      CHOP(png_ptr->background.green);\n      CHOP(png_ptr->background.blue);\n      CHOP(png_ptr->background.gray);\n#     undef CHOP\n   }\n#endif /* READ_BACKGROUND && READ_EXPAND_16 */\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\n   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \\\n   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))\n   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&\n       png_ptr->bit_depth == 16)\n   {\n      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per\n       * component this will also happen after PNG_COMPOSE and so the background\n       * color must be pre-expanded here.\n       *\n       * TODO: fix this too.\n       */\n      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);\n      png_ptr->background.green =\n         (png_uint_16)(png_ptr->background.green * 257);\n      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);\n      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);\n   }\n#endif\n\n   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the\n    * background support (see the comments in scripts/pnglibconf.dfa), this\n    * allows pre-multiplication of the alpha channel to be implemented as\n    * compositing on black.  This is probably sub-optimal and has been done in\n    * 1.5.4 betas simply to enable external critique and testing (i.e. to\n    * implement the new API quickly, without lots of internal changes.)\n    */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\n      /* Includes ALPHA_MODE */\n      png_ptr->background_1 = png_ptr->background;\n#  endif\n\n   /* This needs to change - in the palette image case a whole set of tables are\n    * built when it would be quicker to just calculate the correct value for\n    * each palette entry directly.  Also, the test is too tricky - why check\n    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that\n    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the\n    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction\n    * the gamma tables will not be built even if composition is required on a\n    * gamma encoded value.\n    *\n    * In 1.5.4 this is addressed below by an additional check on the individual\n    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the\n    * tables.\n    */\n   if ((png_ptr->transformations & PNG_GAMMA) != 0 ||\n       ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0 &&\n        (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n         png_gamma_significant(png_ptr->screen_gamma) != 0)) ||\n        ((png_ptr->transformations & PNG_COMPOSE) != 0 &&\n         (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n          png_gamma_significant(png_ptr->screen_gamma) != 0\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\n         || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE &&\n           png_gamma_significant(png_ptr->background_gamma) != 0)\n#  endif\n        )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&\n       png_gamma_significant(png_ptr->screen_gamma) != 0))\n   {\n      png_build_gamma_table(png_ptr, png_ptr->bit_depth);\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n      if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      {\n         /* Issue a warning about this combination: because RGB_TO_GRAY is\n          * optimized to do the gamma transform if present yet do_background has\n          * to do the same thing if both options are set a\n          * double-gamma-correction happens.  This is true in all versions of\n          * libpng to date.\n          */\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n            png_warning(png_ptr,\n                \"libpng does not support gamma+background+rgb_to_gray\");\n\n         if ((png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) != 0)\n         {\n            /* We don't get to here unless there is a tRNS chunk with non-opaque\n             * entries - see the checking code at the start of this function.\n             */\n            png_color back, back_1;\n            png_colorp palette = png_ptr->palette;\n            int num_palette = png_ptr->num_palette;\n            int i;\n            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)\n            {\n\n               back.red = png_ptr->gamma_table[png_ptr->background.red];\n               back.green = png_ptr->gamma_table[png_ptr->background.green];\n               back.blue = png_ptr->gamma_table[png_ptr->background.blue];\n\n               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];\n               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];\n               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];\n            }\n            else\n            {\n               png_fixed_point g, gs;\n\n               switch (png_ptr->background_gamma_type)\n               {\n                  case PNG_BACKGROUND_GAMMA_SCREEN:\n                     g = (png_ptr->screen_gamma);\n                     gs = PNG_FP_1;\n                     break;\n\n                  case PNG_BACKGROUND_GAMMA_FILE:\n                     g = png_reciprocal(png_ptr->file_gamma);\n                     gs = png_reciprocal2(png_ptr->file_gamma,\n                         png_ptr->screen_gamma);\n                     break;\n\n                  case PNG_BACKGROUND_GAMMA_UNIQUE:\n                     g = png_reciprocal(png_ptr->background_gamma);\n                     gs = png_reciprocal2(png_ptr->background_gamma,\n                         png_ptr->screen_gamma);\n                     break;\n                  default:\n                     g = PNG_FP_1;    /* back_1 */\n                     gs = PNG_FP_1;   /* back */\n                     break;\n               }\n\n               if (png_gamma_significant(gs) != 0)\n               {\n                  back.red = png_gamma_8bit_correct(png_ptr->background.red,\n                      gs);\n                  back.green = png_gamma_8bit_correct(png_ptr->background.green,\n                      gs);\n                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,\n                      gs);\n               }\n\n               else\n               {\n                  back.red   = (png_byte)png_ptr->background.red;\n                  back.green = (png_byte)png_ptr->background.green;\n                  back.blue  = (png_byte)png_ptr->background.blue;\n               }\n\n               if (png_gamma_significant(g) != 0)\n               {\n                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,\n                      g);\n                  back_1.green = png_gamma_8bit_correct(\n                      png_ptr->background.green, g);\n                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,\n                      g);\n               }\n\n               else\n               {\n                  back_1.red   = (png_byte)png_ptr->background.red;\n                  back_1.green = (png_byte)png_ptr->background.green;\n                  back_1.blue  = (png_byte)png_ptr->background.blue;\n               }\n            }\n\n            for (i = 0; i < num_palette; i++)\n            {\n               if (i < (int)png_ptr->num_trans &&\n                   png_ptr->trans_alpha[i] != 0xff)\n               {\n                  if (png_ptr->trans_alpha[i] == 0)\n                  {\n                     palette[i] = back;\n                  }\n                  else /* if (png_ptr->trans_alpha[i] != 0xff) */\n                  {\n                     if ((png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0)\n                     {\n                        /* Premultiply only:\n                         * component = round((component * alpha) / 255)\n                         */\n                        png_uint_32 component;\n\n                        component = png_ptr->gamma_to_1[palette[i].red];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].red = png_ptr->gamma_from_1[component];\n\n                        component = png_ptr->gamma_to_1[palette[i].green];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].green = png_ptr->gamma_from_1[component];\n\n                        component = png_ptr->gamma_to_1[palette[i].blue];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].blue = png_ptr->gamma_from_1[component];\n                     }\n                     else\n                     {\n                        /* Composite with background color:\n                         * component =\n                         *    alpha * component + (1 - alpha) * background\n                         */\n                        png_byte v, w;\n\n                        v = png_ptr->gamma_to_1[palette[i].red];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.red);\n                        palette[i].red = png_ptr->gamma_from_1[w];\n\n                        v = png_ptr->gamma_to_1[palette[i].green];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.green);\n                        palette[i].green = png_ptr->gamma_from_1[w];\n\n                        v = png_ptr->gamma_to_1[palette[i].blue];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.blue);\n                        palette[i].blue = png_ptr->gamma_from_1[w];\n                     }\n                  }\n               }\n               else\n               {\n                  palette[i].red = png_ptr->gamma_table[palette[i].red];\n                  palette[i].green = png_ptr->gamma_table[palette[i].green];\n                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];\n               }\n            }\n\n            /* Prevent the transformations being done again.\n             *\n             * NOTE: this is highly dubious; it removes the transformations in\n             * place.  This seems inconsistent with the general treatment of the\n             * transformations elsewhere.\n             */\n            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);\n         } /* color_type == PNG_COLOR_TYPE_PALETTE */\n\n         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */\n         else /* color_type != PNG_COLOR_TYPE_PALETTE */\n         {\n            int gs_sig, g_sig;\n            png_fixed_point g = PNG_FP_1;  /* Correction to linear */\n            png_fixed_point gs = PNG_FP_1; /* Correction to screen */\n\n            switch (png_ptr->background_gamma_type)\n            {\n               case PNG_BACKGROUND_GAMMA_SCREEN:\n                  g = png_ptr->screen_gamma;\n                  /* gs = PNG_FP_1; */\n                  break;\n\n               case PNG_BACKGROUND_GAMMA_FILE:\n                  g = png_reciprocal(png_ptr->file_gamma);\n                  gs = png_reciprocal2(png_ptr->file_gamma,\n                      png_ptr->screen_gamma);\n                  break;\n\n               case PNG_BACKGROUND_GAMMA_UNIQUE:\n                  g = png_reciprocal(png_ptr->background_gamma);\n                  gs = png_reciprocal2(png_ptr->background_gamma,\n                      png_ptr->screen_gamma);\n                  break;\n\n               default:\n                  png_error(png_ptr, \"invalid background gamma type\");\n            }\n\n            g_sig = png_gamma_significant(g);\n            gs_sig = png_gamma_significant(gs);\n\n            if (g_sig != 0)\n               png_ptr->background_1.gray = png_gamma_correct(png_ptr,\n                   png_ptr->background.gray, g);\n\n            if (gs_sig != 0)\n               png_ptr->background.gray = png_gamma_correct(png_ptr,\n                   png_ptr->background.gray, gs);\n\n            if ((png_ptr->background.red != png_ptr->background.green) ||\n                (png_ptr->background.red != png_ptr->background.blue) ||\n                (png_ptr->background.red != png_ptr->background.gray))\n            {\n               /* RGB or RGBA with color background */\n               if (g_sig != 0)\n               {\n                  png_ptr->background_1.red = png_gamma_correct(png_ptr,\n                      png_ptr->background.red, g);\n\n                  png_ptr->background_1.green = png_gamma_correct(png_ptr,\n                      png_ptr->background.green, g);\n\n                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,\n                      png_ptr->background.blue, g);\n               }\n\n               if (gs_sig != 0)\n               {\n                  png_ptr->background.red = png_gamma_correct(png_ptr,\n                      png_ptr->background.red, gs);\n\n                  png_ptr->background.green = png_gamma_correct(png_ptr,\n                      png_ptr->background.green, gs);\n\n                  png_ptr->background.blue = png_gamma_correct(png_ptr,\n                      png_ptr->background.blue, gs);\n               }\n            }\n\n            else\n            {\n               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */\n               png_ptr->background_1.red = png_ptr->background_1.green\n                   = png_ptr->background_1.blue = png_ptr->background_1.gray;\n\n               png_ptr->background.red = png_ptr->background.green\n                   = png_ptr->background.blue = png_ptr->background.gray;\n            }\n\n            /* The background is now in screen gamma: */\n            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;\n         } /* color_type != PNG_COLOR_TYPE_PALETTE */\n      }/* png_ptr->transformations & PNG_BACKGROUND */\n\n      else\n      /* Transformation does not include PNG_BACKGROUND */\n#endif /* READ_BACKGROUND */\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */\n         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||\n         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\n#endif\n         )\n      {\n         png_colorp palette = png_ptr->palette;\n         int num_palette = png_ptr->num_palette;\n         int i;\n\n         /* NOTE: there are other transformations that should probably be in\n          * here too.\n          */\n         for (i = 0; i < num_palette; i++)\n         {\n            palette[i].red = png_ptr->gamma_table[palette[i].red];\n            palette[i].green = png_ptr->gamma_table[palette[i].green];\n            palette[i].blue = png_ptr->gamma_table[palette[i].blue];\n         }\n\n         /* Done the gamma correction. */\n         png_ptr->transformations &= ~PNG_GAMMA;\n      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */\n   }\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   else\n#endif\n#endif /* READ_GAMMA */\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   /* No GAMMA transformation (see the hanging else 4 lines above) */\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\n   {\n      int i;\n      int istop = (int)png_ptr->num_trans;\n      png_color back;\n      png_colorp palette = png_ptr->palette;\n\n      back.red   = (png_byte)png_ptr->background.red;\n      back.green = (png_byte)png_ptr->background.green;\n      back.blue  = (png_byte)png_ptr->background.blue;\n\n      for (i = 0; i < istop; i++)\n      {\n         if (png_ptr->trans_alpha[i] == 0)\n         {\n            palette[i] = back;\n         }\n\n         else if (png_ptr->trans_alpha[i] != 0xff)\n         {\n            /* The png_composite() macro is defined in png.h */\n            png_composite(palette[i].red, palette[i].red,\n                png_ptr->trans_alpha[i], back.red);\n\n            png_composite(palette[i].green, palette[i].green,\n                png_ptr->trans_alpha[i], back.green);\n\n            png_composite(palette[i].blue, palette[i].blue,\n                png_ptr->trans_alpha[i], back.blue);\n         }\n      }\n\n      png_ptr->transformations &= ~PNG_COMPOSE;\n   }\n#endif /* READ_BACKGROUND */\n\n#ifdef PNG_READ_SHIFT_SUPPORTED\n   if ((png_ptr->transformations & PNG_SHIFT) != 0 &&\n       (png_ptr->transformations & PNG_EXPAND) == 0 &&\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\n   {\n      int i;\n      int istop = png_ptr->num_palette;\n      int shift = 8 - png_ptr->sig_bit.red;\n\n      png_ptr->transformations &= ~PNG_SHIFT;\n\n      /* significant bits can be in the range 1 to 7 for a meaningful result, if\n       * the number of significant bits is 0 then no shift is done (this is an\n       * error condition which is silently ignored.)\n       */\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].red;\n\n            component >>= shift;\n            png_ptr->palette[i].red = (png_byte)component;\n         }\n\n      shift = 8 - png_ptr->sig_bit.green;\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].green;\n\n            component >>= shift;\n            png_ptr->palette[i].green = (png_byte)component;\n         }\n\n      shift = 8 - png_ptr->sig_bit.blue;\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].blue;\n\n            component >>= shift;\n            png_ptr->palette[i].blue = (png_byte)component;\n         }\n   }\n#endif /* READ_SHIFT */\n}\n",
      "line_start": 1414,
      "line_end": 2052,
      "execution_count": 358,
      "covered_regions": 134,
      "total_regions": 613,
      "coverage_percent": 21.86,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_do_read_filler",
      "clean_name": "png_do_read_filler",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n/* Add filler channel if we have RGB color */\nstatic void\npng_do_read_filler(png_row_infop row_info, png_bytep row,\n    png_uint_32 filler, png_uint_32 flags)\n{\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n   png_byte hi_filler = (png_byte)(filler>>8);\n#endif\n   png_byte lo_filler = (png_byte)filler;\n\n   png_debug(1, \"in png_do_read_filler\");\n\n   if (\n       row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from G to GX */\n            png_bytep sp = row + (size_t)row_width;\n            png_bytep dp =  sp + (size_t)row_width;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            row_info->channels = 2;\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n\n         else\n         {\n            /* This changes the data from G to XG */\n            png_bytep sp = row + (size_t)row_width;\n            png_bytep dp = sp  + (size_t)row_width;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n            }\n            row_info->channels = 2;\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from GG to GGXX */\n            png_bytep sp = row + (size_t)row_width * 2;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            *(--dp) = hi_filler;\n            row_info->channels = 2;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n\n         else\n         {\n            /* This changes the data from GG to XXGG */\n            png_bytep sp = row + (size_t)row_width * 2;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n            }\n            row_info->channels = 2;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n      }\n#endif\n   } /* COLOR_TYPE == GRAY */\n   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from RGB to RGBX */\n            png_bytep sp = row + (size_t)row_width * 3;\n            png_bytep dp = sp  + (size_t)row_width;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            row_info->channels = 4;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n\n         else\n         {\n            /* This changes the data from RGB to XRGB */\n            png_bytep sp = row + (size_t)row_width * 3;\n            png_bytep dp = sp + (size_t)row_width;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n            }\n            row_info->channels = 4;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from RRGGBB to RRGGBBXX */\n            png_bytep sp = row + (size_t)row_width * 6;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            *(--dp) = hi_filler;\n            row_info->channels = 4;\n            row_info->pixel_depth = 64;\n            row_info->rowbytes = row_width * 8;\n         }\n\n         else\n         {\n            /* This changes the data from RRGGBB to XXRRGGBB */\n            png_bytep sp = row + (size_t)row_width * 6;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n            }\n\n            row_info->channels = 4;\n            row_info->pixel_depth = 64;\n            row_info->rowbytes = row_width * 8;\n         }\n      }\n#endif\n   } /* COLOR_TYPE == RGB */\n}\n",
      "line_start": 2791,
      "line_end": 2973,
      "execution_count": 7005,
      "covered_regions": 27,
      "total_regions": 111,
      "coverage_percent": 24.32,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_alpha_mode_fixed",
      "clean_name": "png_set_alpha_mode_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif /* READ_ALPHA_MODE || READ_GAMMA */\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\nvoid PNGFAPI\npng_set_alpha_mode_fixed(png_structrp png_ptr, int mode,\n    png_fixed_point output_gamma)\n{\n   png_fixed_point file_gamma;\n   int compose = 0;\n\n   png_debug(1, \"in png_set_alpha_mode_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   output_gamma = translate_gamma_flags(output_gamma, 1/*screen*/);\n   if (unsupported_gamma(png_ptr, output_gamma, 0/*error*/))\n      return;\n\n   /* The default file gamma is the inverse of the output gamma; the output\n    * gamma may be changed below so get the file value first.  The default_gamma\n    * is set here and from the simplified API (which uses a different algorithm)\n    * so don't overwrite a set value:\n    */\n   file_gamma = png_ptr->default_gamma;\n   if (file_gamma == 0)\n   {\n      file_gamma = png_reciprocal(output_gamma);\n      png_ptr->default_gamma = file_gamma;\n   }\n\n   /* There are really 8 possibilities here, composed of any combination\n    * of:\n    *\n    *    premultiply the color channels\n    *    do not encode non-opaque pixels\n    *    encode the alpha as well as the color channels\n    *\n    * The differences disappear if the input/output ('screen') gamma is 1.0,\n    * because then the encoding is a no-op and there is only the choice of\n    * premultiplying the color channels or not.\n    *\n    * png_set_alpha_mode and png_set_background interact because both use\n    * png_compose to do the work.  Calling both is only useful when\n    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along\n    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.\n    */\n   switch (mode)\n   {\n      case PNG_ALPHA_PNG:        /* default: png standard */\n         /* No compose, but it may be set by png_set_background! */\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         break;\n\n      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */\n         compose = 1;\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         /* The output is linear: */\n         output_gamma = PNG_FP_1;\n         break;\n\n      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */\n         compose = 1;\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;\n         /* output_gamma records the encoding of opaque pixels! */\n         break;\n\n      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */\n         compose = 1;\n         png_ptr->transformations |= PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid alpha mode\");\n   }\n\n   /* Set the screen gamma values: */\n   png_ptr->screen_gamma = output_gamma;\n\n   /* Finally, if pre-multiplying, set the background fields to achieve the\n    * desired result.\n    */\n   if (compose != 0)\n   {\n      /* And obtain alpha pre-multiplication by composing on black: */\n      memset(&png_ptr->background, 0, (sizeof png_ptr->background));\n      png_ptr->background_gamma = file_gamma; /* just in case */\n      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n\n      if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n         png_error(png_ptr,\n             \"conflicting calls to set alpha mode and background\");\n\n      png_ptr->transformations |= PNG_COMPOSE;\n   }\n}\n",
      "line_start": 360,
      "line_end": 457,
      "execution_count": 358,
      "covered_regions": 24,
      "total_regions": 94,
      "coverage_percent": 25.53,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_crc_action",
      "clean_name": "png_set_crc_action",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n#ifdef PNG_READ_SUPPORTED\n\n/* Set the action on getting a CRC error for an ancillary or critical chunk. */\nvoid PNGAPI\npng_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)\n{\n   png_debug(1, \"in png_set_crc_action\");\n\n   if (png_ptr == NULL)\n      return;\n\n   /* Tell libpng how we react to CRC errors in critical chunks */\n   switch (crit_action)\n   {\n      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                               /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |\n                           PNG_FLAG_CRC_CRITICAL_IGNORE;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */\n         png_warning(png_ptr,\n             \"Can't discard critical data on CRC error\");\n         /* FALLTHROUGH */\n      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         break;\n   }\n\n   /* Tell libpng how we react to CRC errors in ancillary chunks */\n   switch (ancil_action)\n   {\n      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                              /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |\n                           PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         break;\n   }\n}\n",
      "line_start": 40,
      "line_end": 106,
      "execution_count": 179,
      "covered_regions": 35,
      "total_regions": 129,
      "coverage_percent": 27.13,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_init_rgb_transformations",
      "clean_name": "png_init_rgb_transformations",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   } /* background expand and (therefore) no alpha association. */\n#endif /* READ_EXPAND && READ_BACKGROUND */\n}\n\nstatic void /* PRIVATE */\npng_init_rgb_transformations(png_structrp png_ptr)\n{\n   /* Added to libpng-1.5.4: check the color type to determine whether there\n    * is any alpha or transparency in the image and simply cancel the\n    * background and alpha mode stuff if there isn't.\n    */\n   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;\n   int input_has_transparency = png_ptr->num_trans > 0;\n\n   /* If no alpha we can optimize. */\n   if (input_has_alpha == 0)\n   {\n      /* Any alpha means background and associative alpha processing is\n       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA\n       * and ENCODE_ALPHA are irrelevant.\n       */\n#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n#     endif\n\n      if (input_has_transparency == 0)\n         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);\n   }\n\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\n   /* png_set_background handling - deals with the complexity of whether the\n    * background color is in the file format or the screen format in the case\n    * where an 'expand' will happen.\n    */\n\n   /* The following code cannot be entered in the alpha pre-multiplication case\n    * because PNG_BACKGROUND_EXPAND is cancelled below.\n    */\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&\n       (png_ptr->transformations & PNG_EXPAND) != 0 &&\n       (png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n       /* i.e., GRAY or GRAY_ALPHA */\n   {\n      {\n         /* Expand background and tRNS chunks */\n         int gray = png_ptr->background.gray;\n         int trans_gray = png_ptr->trans_color.gray;\n\n         switch (png_ptr->bit_depth)\n         {\n            case 1:\n               gray *= 0xff;\n               trans_gray *= 0xff;\n               break;\n\n            case 2:\n               gray *= 0x55;\n               trans_gray *= 0x55;\n               break;\n\n            case 4:\n               gray *= 0x11;\n               trans_gray *= 0x11;\n               break;\n\n            default:\n\n            case 8:\n               /* FALLTHROUGH */ /*  (Already 8 bits) */\n\n            case 16:\n               /* Already a full 16 bits */\n               break;\n         }\n\n         png_ptr->background.red = png_ptr->background.green =\n            png_ptr->background.blue = (png_uint_16)gray;\n\n         if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)\n         {\n            png_ptr->trans_color.red = png_ptr->trans_color.green =\n               png_ptr->trans_color.blue = (png_uint_16)trans_gray;\n         }\n      }\n   } /* background expand and (therefore) no alpha association. */\n#endif /* READ_EXPAND && READ_BACKGROUND */\n}\n",
      "line_start": 1255,
      "line_end": 1338,
      "execution_count": 226,
      "covered_regions": 22,
      "total_regions": 66,
      "coverage_percent": 33.33,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_handle_unknown",
      "clean_name": "png_handle_unknown",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "}\n#endif /* READ_UNKNOWN_CHUNKS */\n\n/* Handle an unknown, or known but disabled, chunk */\npng_handle_result_code /*PRIVATE*/\npng_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 length, int keep)\n{\n   png_handle_result_code handled = handled_discarded; /* the default */\n\n   png_debug(1, \"in png_handle_unknown\");\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing\n    * the bug which meant that setting a non-default behavior for a specific\n    * chunk would be ignored (the default was always used unless a user\n    * callback was installed).\n    *\n    * 'keep' is the value from the png_chunk_unknown_handling, the setting for\n    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it\n    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.\n    * This is just an optimization to avoid multiple calls to the lookup\n    * function.\n    */\n#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n   keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);\n#     endif\n#  endif\n\n   /* One of the following methods will read the chunk or skip it (at least one\n    * of these is always defined because this is the only way to switch on\n    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n    */\n#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED\n   /* The user callback takes precedence over the chunk keep value, but the\n    * keep value is still required to validate a save of a critical chunk.\n    */\n   if (png_ptr->read_user_chunk_fn != NULL)\n   {\n      if (png_cache_unknown_chunk(png_ptr, length) != 0)\n      {\n         /* Callback to user unknown chunk handler */\n         int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,\n             &png_ptr->unknown_chunk);\n\n         /* ret is:\n          * negative: An error occurred; png_chunk_error will be called.\n          *     zero: The chunk was not handled, the chunk will be discarded\n          *           unless png_set_keep_unknown_chunks has been used to set\n          *           a 'keep' behavior for this particular chunk, in which\n          *           case that will be used.  A critical chunk will cause an\n          *           error at this point unless it is to be saved.\n          * positive: The chunk was handled, libpng will ignore/discard it.\n          */\n         if (ret < 0) /* handled_error */\n            png_chunk_error(png_ptr, \"error in user chunk\");\n\n         else if (ret == 0)\n         {\n            /* If the keep value is 'default' or 'never' override it, but\n             * still error out on critical chunks unless the keep value is\n             * 'always'  While this is weird it is the behavior in 1.4.12.\n             * A possible improvement would be to obey the value set for the\n             * chunk, but this would be an API change that would probably\n             * damage some applications.\n             *\n             * The png_app_warning below catches the case that matters, where\n             * the application has not set specific save or ignore for this\n             * chunk or global save or ignore.\n             */\n            if (keep < PNG_HANDLE_CHUNK_IF_SAFE)\n            {\n#              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n               if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)\n               {\n                  png_chunk_warning(png_ptr, \"Saving unknown chunk:\");\n                  png_app_warning(png_ptr,\n                      \"forcing save of an unhandled chunk;\"\n                      \" please call png_set_keep_unknown_chunks\");\n                      /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */\n               }\n#              endif\n               keep = PNG_HANDLE_CHUNK_IF_SAFE;\n            }\n         }\n\n         else /* chunk was handled */\n         {\n            handled = handled_ok;\n            /* Critical chunks can be safely discarded at this point. */\n            keep = PNG_HANDLE_CHUNK_NEVER;\n         }\n      }\n\n      else\n         keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */\n   }\n\n   else\n   /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */\n#  endif /* READ_USER_CHUNKS */\n\n#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED\n   {\n      /* keep is currently just the per-chunk setting, if there was no\n       * setting change it to the global default now (not that this may\n       * still be AS_DEFAULT) then obtain the cache of the chunk if required,\n       * if not simply skip the chunk.\n       */\n      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)\n         keep = png_ptr->unknown_default;\n\n      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n      {\n         if (png_cache_unknown_chunk(png_ptr, length) == 0)\n            keep = PNG_HANDLE_CHUNK_NEVER;\n      }\n\n      else\n         png_crc_finish(png_ptr, length);\n   }\n#  else\n#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED\n#        error no method to support READ_UNKNOWN_CHUNKS\n#     endif\n\n   {\n      /* If here there is no read callback pointer set and no support is\n       * compiled in to just save the unknown chunks, so simply skip this\n       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then\n       * the app has erroneously asked for unknown chunk saving when there\n       * is no support.\n       */\n      if (keep > PNG_HANDLE_CHUNK_NEVER)\n         png_app_error(png_ptr, \"no unknown chunk support available\");\n\n      png_crc_finish(png_ptr, length);\n   }\n#  endif\n\n#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   /* Now store the chunk in the chunk list if appropriate, and if the limits\n    * permit it.\n    */\n   if (keep == PNG_HANDLE_CHUNK_ALWAYS ||\n      (keep == PNG_HANDLE_CHUNK_IF_SAFE &&\n       PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))\n   {\n#     ifdef PNG_USER_LIMITS_SUPPORTED\n      switch (png_ptr->user_chunk_cache_max)\n      {\n         case 2:\n            png_ptr->user_chunk_cache_max = 1;\n            png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n            /* FALLTHROUGH */\n         case 1:\n            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical\n             * chunk being skipped, now there will be a hard error below.\n             */\n            break;\n\n         default: /* not at limit */\n            --(png_ptr->user_chunk_cache_max);\n            /* FALLTHROUGH */\n         case 0: /* no limit */\n#  endif /* USER_LIMITS */\n            /* Here when the limit isn't reached or when limits are compiled\n             * out; store the chunk.\n             */\n            png_set_unknown_chunks(png_ptr, info_ptr,\n                &png_ptr->unknown_chunk, 1);\n            handled = handled_saved;\n#  ifdef PNG_USER_LIMITS_SUPPORTED\n            break;\n      }\n#  endif\n   }\n#  else /* no store support: the chunk must be handled by the user callback */\n   PNG_UNUSED(info_ptr)\n#  endif\n\n   /* Regardless of the error handling below the cached data (if any) can be\n    * freed now.  Notice that the data is not freed if there is a png_error, but\n    * it will be freed by destroy_read_struct.\n    */\n   if (png_ptr->unknown_chunk.data != NULL)\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n   png_ptr->unknown_chunk.data = NULL;\n\n#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */\n   /* There is no support to read an unknown chunk, so just skip it. */\n   png_crc_finish(png_ptr, length);\n   PNG_UNUSED(info_ptr)\n   PNG_UNUSED(keep)\n#endif /* !READ_UNKNOWN_CHUNKS */\n\n   /* Check for unhandled critical chunks */\n   if (handled < handled_saved && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n      png_chunk_error(png_ptr, \"unhandled critical chunk\");\n\n   return handled;\n}\n",
      "line_start": 2772,
      "line_end": 2972,
      "execution_count": 4,
      "covered_regions": 54,
      "total_regions": 157,
      "coverage_percent": 34.39,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_read_fn",
      "clean_name": "png_set_read_fn",
      "source_file": "/src/libpng/pngrio.c",
      "source_code": " *                function should call png_error(png_ptr, \"Error msg\").\n *                May be NULL, in which case libpng's default function will\n *                be used.\n */\nvoid PNGAPI\npng_set_read_fn(png_structrp png_ptr, png_voidp io_ptr,\n    png_rw_ptr read_data_fn)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->io_ptr = io_ptr;\n\n#ifdef PNG_STDIO_SUPPORTED\n   if (read_data_fn != NULL)\n      png_ptr->read_data_fn = read_data_fn;\n\n   else\n      png_ptr->read_data_fn = png_default_read_data;\n#else\n   png_ptr->read_data_fn = read_data_fn;\n#endif\n\n#ifdef PNG_WRITE_SUPPORTED\n   /* It is an error to write to a read device */\n   if (png_ptr->write_data_fn != NULL)\n   {\n      png_ptr->write_data_fn = NULL;\n      png_warning(png_ptr,\n          \"Can't set both read_data_fn and write_data_fn in the\"\n          \" same structure\");\n   }\n#endif\n\n#ifdef PNG_WRITE_FLUSH_SUPPORTED\n   png_ptr->output_flush_fn = NULL;\n#endif\n}\n",
      "line_start": 85,
      "line_end": 118,
      "execution_count": 537,
      "covered_regions": 5,
      "total_regions": 14,
      "coverage_percent": 35.71,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_safe_execute",
      "clean_name": "png_safe_execute",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   }\n}\n#endif\n\nint /* PRIVATE */\npng_safe_execute(png_imagep image, int (*function)(png_voidp), png_voidp arg)\n{\n   const png_voidp saved_error_buf = image->opaque->error_buf;\n   jmp_buf safe_jmpbuf;\n\n   /* Safely execute function(arg), with png_error returning back here. */\n   if (setjmp(safe_jmpbuf) == 0)\n   {\n      int result;\n\n      image->opaque->error_buf = safe_jmpbuf;\n      result = function(arg);\n      image->opaque->error_buf = saved_error_buf;\n\n      if (result)\n         return 1; /* success */\n   }\n\n   /* The function failed either because of a caught png_error and a regular\n    * return of false above or because of an uncaught png_error from the\n    * function itself.  Ensure that the error_buf is always set back to the\n    * value saved above:\n    */\n   image->opaque->error_buf = saved_error_buf;\n\n   /* On the final false return, when about to return control to the caller, the\n    * image is freed (png_image_free does this check but it is duplicated here\n    * for clarity:\n    */\n   if (saved_error_buf == NULL)\n      png_image_free(image);\n\n   return 0; /* failure */\n}\n",
      "line_start": 811,
      "line_end": 845,
      "execution_count": 363,
      "covered_regions": 8,
      "total_regions": 22,
      "coverage_percent": 36.36,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_crc_finish_critical",
      "clean_name": "png_crc_finish_critical",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * takes the value for the 'critical' flag to check.  This allows PLTE and IEND\n * handling code to ignore the CRC error and removes some confusing code\n * duplication.\n */\nstatic int\npng_crc_finish_critical(png_structrp png_ptr, png_uint_32 skip,\n      int handle_as_ancillary)\n{\n   /* The size of the local buffer for inflate is a good guess as to a\n    * reasonable size to use for buffering reads from the application.\n    */\n   while (skip > 0)\n   {\n      png_uint_32 len;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      len = (sizeof tmpbuf);\n      if (len > skip)\n         len = skip;\n      skip -= len;\n\n      png_crc_read(png_ptr, tmpbuf, len);\n   }\n\n   /* If 'handle_as_ancillary' has been requested and this is a critical chunk\n    * but PNG_FLAG_CRC_CRITICAL_IGNORE was set then png_read_crc did not, in\n    * fact, calculate the CRC so the ANCILLARY settings should not be used\n    * instead.\n    */\n   if (handle_as_ancillary &&\n       (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n      handle_as_ancillary = 0;\n\n   /* TODO: this might be more comprehensible if png_crc_error was inlined here.\n    */\n   if (png_crc_error(png_ptr, handle_as_ancillary) != 0)\n   {\n      /* See above for the explanation of how the flags work. */\n      if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n          (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :\n          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)\n         png_chunk_warning(png_ptr, \"CRC error\");\n\n      else\n         png_chunk_error(png_ptr, \"CRC error\");\n\n      return 1;\n   }\n\n   return 0;\n}\n",
      "line_start": 311,
      "line_end": 357,
      "execution_count": 2002,
      "covered_regions": 20,
      "total_regions": 55,
      "coverage_percent": 36.36,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_decompress_chunk",
      "clean_name": "png_decompress_chunk",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * trailing compressed part.  What we get back is an allocated area\n * holding the original prefix part and an uncompressed version of the\n * trailing part (the malloc area passed in is freed).\n */\nstatic int\npng_decompress_chunk(png_structrp png_ptr,\n    png_uint_32 chunklength, png_uint_32 prefix_size,\n    png_alloc_size_t *newlength /* must be initialized to the maximum! */,\n    int terminate /*add a '\\0' to the end of the uncompressed data*/)\n{\n   /* TODO: implement different limits for different types of chunk.\n    *\n    * The caller supplies *newlength set to the maximum length of the\n    * uncompressed data, but this routine allocates space for the prefix and\n    * maybe a '\\0' terminator too.  We have to assume that 'prefix_size' is\n    * limited only by the maximum chunk size.\n    */\n   png_alloc_size_t limit = png_chunk_max(png_ptr);\n\n   if (limit >= prefix_size + (terminate != 0))\n   {\n      int ret;\n\n      limit -= prefix_size + (terminate != 0);\n\n      if (limit < *newlength)\n         *newlength = limit;\n\n      /* Now try to claim the stream. */\n      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);\n\n      if (ret == Z_OK)\n      {\n         png_uint_32 lzsize = chunklength - prefix_size;\n\n         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n             /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,\n             /* output: */ NULL, newlength);\n\n         if (ret == Z_STREAM_END)\n         {\n            /* Use 'inflateReset' here, not 'inflateReset2' because this\n             * preserves the previously decided window size (otherwise it would\n             * be necessary to store the previous window size.)  In practice\n             * this doesn't matter anyway, because png_inflate will call inflate\n             * with Z_FINISH in almost all cases, so the window will not be\n             * maintained.\n             */\n            if (inflateReset(&png_ptr->zstream) == Z_OK)\n            {\n               /* Because of the limit checks above we know that the new,\n                * expanded, size will fit in a size_t (let alone an\n                * png_alloc_size_t).  Use png_malloc_base here to avoid an\n                * extra OOM message.\n                */\n               png_alloc_size_t new_size = *newlength;\n               png_alloc_size_t buffer_size = prefix_size + new_size +\n                   (terminate != 0);\n               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,\n                   buffer_size));\n\n               if (text != NULL)\n               {\n                  memset(text, 0, buffer_size);\n\n                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,\n                      png_ptr->read_buffer + prefix_size, &lzsize,\n                      text + prefix_size, newlength);\n\n                  if (ret == Z_STREAM_END)\n                  {\n                     if (new_size == *newlength)\n                     {\n                        if (terminate != 0)\n                           text[prefix_size + *newlength] = 0;\n\n                        if (prefix_size > 0)\n                           memcpy(text, png_ptr->read_buffer, prefix_size);\n\n                        {\n                           png_bytep old_ptr = png_ptr->read_buffer;\n\n                           png_ptr->read_buffer = text;\n                           png_ptr->read_buffer_size = buffer_size;\n                           text = old_ptr; /* freed below */\n                        }\n                     }\n\n                     else\n                     {\n                        /* The size changed on the second read, there can be no\n                         * guarantee that anything is correct at this point.\n                         * The 'msg' pointer has been set to \"unexpected end of\n                         * LZ stream\", which is fine, but return an error code\n                         * that the caller won't accept.\n                         */\n                        ret = PNG_UNEXPECTED_ZLIB_RETURN;\n                     }\n                  }\n\n                  else if (ret == Z_OK)\n                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */\n\n                  /* Free the text pointer (this is the old read_buffer on\n                   * success)\n                   */\n                  png_free(png_ptr, text);\n\n                  /* This really is very benign, but it's still an error because\n                   * the extra space may otherwise be used as a Trojan Horse.\n                   */\n                  if (ret == Z_STREAM_END &&\n                      chunklength - prefix_size != lzsize)\n                     png_chunk_benign_error(png_ptr, \"extra compressed data\");\n               }\n\n               else\n               {\n                  /* Out of memory allocating the buffer */\n                  ret = Z_MEM_ERROR;\n                  png_zstream_error(png_ptr, Z_MEM_ERROR);\n               }\n            }\n\n            else\n            {\n               /* inflateReset failed, store the error message */\n               png_zstream_error(png_ptr, ret);\n               ret = PNG_UNEXPECTED_ZLIB_RETURN;\n            }\n         }\n\n         else if (ret == Z_OK)\n            ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n         /* Release the claimed stream */\n         png_ptr->zowner = 0;\n      }\n\n      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */\n         ret = PNG_UNEXPECTED_ZLIB_RETURN;\n\n      return ret;\n   }\n\n   else\n   {\n      /* Application/configuration limits exceeded */\n      png_zstream_error(png_ptr, Z_MEM_ERROR);\n      return Z_MEM_ERROR;\n   }\n}\n",
      "line_start": 680,
      "line_end": 827,
      "execution_count": 227,
      "covered_regions": 49,
      "total_regions": 131,
      "coverage_percent": 37.4,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_longjmp_fn",
      "clean_name": "png_set_longjmp_fn",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "#ifdef PNG_SETJMP_SUPPORTED\n/* This API only exists if ANSI-C style error handling is used,\n * otherwise it is necessary for png_default_error to be overridden.\n */\njmp_buf* PNGAPI\npng_set_longjmp_fn(png_structrp png_ptr, png_longjmp_ptr longjmp_fn,\n    size_t jmp_buf_size)\n{\n   /* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value\n    * and it must not change after that.  Libpng doesn't care how big the\n    * buffer is, just that it doesn't change.\n    *\n    * If the buffer size is no *larger* than the size of jmp_buf when libpng is\n    * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0\n    * semantics that this call will not fail.  If the size is larger, however,\n    * the buffer is allocated and this may fail, causing the function to return\n    * NULL.\n    */\n   if (png_ptr == NULL)\n      return NULL;\n\n   if (png_ptr->jmp_buf_ptr == NULL)\n   {\n      png_ptr->jmp_buf_size = 0; /* not allocated */\n\n      if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))\n         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;\n\n      else\n      {\n         png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf *,\n             png_malloc_warn(png_ptr, jmp_buf_size));\n\n         if (png_ptr->jmp_buf_ptr == NULL)\n            return NULL; /* new NULL return on OOM */\n\n         png_ptr->jmp_buf_size = jmp_buf_size;\n      }\n   }\n\n   else /* Already allocated: check the size */\n   {\n      size_t size = png_ptr->jmp_buf_size;\n\n      if (size == 0)\n      {\n         size = (sizeof png_ptr->jmp_buf_local);\n         if (png_ptr->jmp_buf_ptr != &png_ptr->jmp_buf_local)\n         {\n            /* This is an internal error in libpng: somehow we have been left\n             * with a stack allocated jmp_buf when the application regained\n             * control.  It's always possible to fix this up, but for the moment\n             * this is a png_error because that makes it easy to detect.\n             */\n            png_error(png_ptr, \"Libpng jmp_buf still allocated\");\n            /* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */\n         }\n      }\n\n      if (size != jmp_buf_size)\n      {\n         png_warning(png_ptr, \"Application jmp_buf size changed\");\n         return NULL; /* caller will probably crash: no choice here */\n      }\n   }\n\n   /* Finally fill in the function, now we have a satisfactory buffer. It is\n    * valid to change the function on every call.\n    */\n   png_ptr->longjmp_fn = longjmp_fn;\n   return png_ptr->jmp_buf_ptr;\n}\n",
      "line_start": 541,
      "line_end": 608,
      "execution_count": 358,
      "covered_regions": 23,
      "total_regions": 59,
      "coverage_percent": 38.98,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_image_read_direct",
      "clean_name": "png_image_read_direct",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 1;\n}\n\n/* The guts of png_image_finish_read as a png_safe_execute callback. */\nstatic int\npng_image_read_direct(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_inforp info_ptr = image->opaque->info_ptr;\n\n   png_uint_32 format = image->format;\n   int linear = (format & PNG_FORMAT_FLAG_LINEAR) != 0;\n   int do_local_compose = 0;\n   int do_local_background = 0; /* to avoid double gamma correction bug */\n   int do_local_scale = 0; /* for interlaced 16-to-8 bit conversion */\n   int passes = 0;\n\n   /* Add transforms to ensure the correct output format is produced then check\n    * that the required implementation support is there.  Always expand; always\n    * need 8 bits minimum, no palette and expanded tRNS.\n    */\n   png_set_expand(png_ptr);\n\n   /* Now check the format to see if it was modified. */\n   {\n      png_uint_32 base_format = png_image_format(png_ptr) &\n         ~PNG_FORMAT_FLAG_COLORMAP /* removed by png_set_expand */;\n      png_uint_32 change = format ^ base_format;\n      png_fixed_point output_gamma;\n      int mode; /* alpha mode */\n\n      /* Do this first so that we have a record if rgb to gray is happening. */\n      if ((change & PNG_FORMAT_FLAG_COLOR) != 0)\n      {\n         /* gray<->color transformation required. */\n         if ((format & PNG_FORMAT_FLAG_COLOR) != 0)\n            png_set_gray_to_rgb(png_ptr);\n\n         else\n         {\n            /* libpng can't do both rgb to gray and\n             * background/pre-multiplication if there is also significant gamma\n             * correction, because both operations require linear colors and\n             * the code only supports one transform doing the gamma correction.\n             * Handle this by doing the pre-multiplication or background\n             * operation in this code, if necessary.\n             *\n             * TODO: fix this by rewriting pngrtran.c (!)\n             *\n             * For the moment (given that fixing this in pngrtran.c is an\n             * enormous change) 'do_local_background' is used to indicate that\n             * the problem exists.\n             */\n            if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n               do_local_background = 1/*maybe*/;\n\n            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,\n                PNG_RGB_TO_GRAY_DEFAULT, PNG_RGB_TO_GRAY_DEFAULT);\n         }\n\n         change &= ~PNG_FORMAT_FLAG_COLOR;\n      }\n\n      /* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.\n       */\n      {\n         /* This is safe but should no longer be necessary as\n          * png_ptr->default_gamma should have been set after the\n          * info-before-IDAT was read in png_image_read_header.\n          *\n          * TODO: 1.8: remove this and see what happens.\n          */\n         png_fixed_point input_gamma_default;\n\n         if ((base_format & PNG_FORMAT_FLAG_LINEAR) != 0 &&\n             (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n            input_gamma_default = PNG_GAMMA_LINEAR;\n         else\n            input_gamma_default = PNG_DEFAULT_sRGB;\n\n         /* Call png_set_alpha_mode to set the default for the input gamma; the\n          * output gamma is set by a second call below.\n          */\n         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);\n      }\n\n      if (linear != 0)\n      {\n         /* If there *is* an alpha channel in the input it must be multiplied\n          * out; use PNG_ALPHA_STANDARD, otherwise just use PNG_ALPHA_PNG.\n          */\n         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n            mode = PNG_ALPHA_STANDARD; /* associated alpha */\n\n         else\n            mode = PNG_ALPHA_PNG;\n\n         output_gamma = PNG_GAMMA_LINEAR;\n      }\n\n      else\n      {\n         mode = PNG_ALPHA_PNG;\n         output_gamma = PNG_DEFAULT_sRGB;\n      }\n\n      if ((change & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0)\n      {\n         mode = PNG_ALPHA_OPTIMIZED;\n         change &= ~PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;\n      }\n\n      /* If 'do_local_background' is set check for the presence of gamma\n       * correction; this is part of the work-round for the libpng bug\n       * described above.\n       *\n       * TODO: fix libpng and remove this.\n       */\n      if (do_local_background != 0)\n      {\n         png_fixed_point gtest;\n\n         /* This is 'png_gamma_threshold' from pngrtran.c; the test used for\n          * gamma correction, the screen gamma hasn't been set on png_struct\n          * yet; it's set below.  png_struct::gamma, however, is set to the\n          * final value.\n          */\n         if (png_muldiv(&gtest, output_gamma,\n                  png_resolve_file_gamma(png_ptr), PNG_FP_1) != 0 &&\n             png_gamma_significant(gtest) == 0)\n            do_local_background = 0;\n\n         else if (mode == PNG_ALPHA_STANDARD)\n         {\n            do_local_background = 2/*required*/;\n            mode = PNG_ALPHA_PNG; /* prevent libpng doing it */\n         }\n\n         /* else leave as 1 for the checks below */\n      }\n\n      /* If the bit-depth changes then handle that here. */\n      if ((change & PNG_FORMAT_FLAG_LINEAR) != 0)\n      {\n         if (linear != 0 /*16-bit output*/)\n            png_set_expand_16(png_ptr);\n\n         else /* 8-bit output */\n         {\n            png_set_scale_16(png_ptr);\n\n            /* For interlaced images, use local_row buffer to avoid overflow\n             * in png_combine_row() which writes using IHDR bit-depth.\n             */\n            if (png_ptr->interlaced != 0)\n               do_local_scale = 1;\n         }\n\n         change &= ~PNG_FORMAT_FLAG_LINEAR;\n      }\n\n      /* Now the background/alpha channel changes. */\n      if ((change & PNG_FORMAT_FLAG_ALPHA) != 0)\n      {\n         /* Removing an alpha channel requires composition for the 8-bit\n          * formats; for the 16-bit it is already done, above, by the\n          * pre-multiplication and the channel just needs to be stripped.\n          */\n         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n         {\n            /* If RGB->gray is happening the alpha channel must be left and the\n             * operation completed locally.\n             *\n             * TODO: fix libpng and remove this.\n             */\n            if (do_local_background != 0)\n               do_local_background = 2/*required*/;\n\n            /* 16-bit output: just remove the channel */\n            else if (linear != 0) /* compose on black (well, pre-multiply) */\n               png_set_strip_alpha(png_ptr);\n\n            /* 8-bit output: do an appropriate compose */\n            else if (display->background != NULL)\n            {\n               png_color_16 c;\n\n               c.index = 0; /*unused*/\n               c.red = display->background->red;\n               c.green = display->background->green;\n               c.blue = display->background->blue;\n               c.gray = display->background->green;\n\n               /* This is always an 8-bit sRGB value, using the 'green' channel\n                * for gray is much better than calculating the luminance here;\n                * we can get off-by-one errors in that calculation relative to\n                * the app expectations and that will show up in transparent\n                * pixels.\n                */\n               png_set_background_fixed(png_ptr, &c,\n                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                   0/*gamma: not used*/);\n            }\n\n            else /* compose on row: implemented below. */\n            {\n               do_local_compose = 1;\n               /* This leaves the alpha channel in the output, so it has to be\n                * removed by the code below.  Set the encoding to the 'OPTIMIZE'\n                * one so the code only has to hack on the pixels that require\n                * composition.\n                */\n               mode = PNG_ALPHA_OPTIMIZED;\n            }\n         }\n\n         else /* output needs an alpha channel */\n         {\n            /* This is tricky because it happens before the swap operation has\n             * been accomplished; however, the swap does *not* swap the added\n             * alpha channel (weird API), so it must be added in the correct\n             * place.\n             */\n            png_uint_32 filler; /* opaque filler */\n            int where;\n\n            if (linear != 0)\n               filler = 65535;\n\n            else\n               filler = 255;\n\n#ifdef PNG_FORMAT_AFIRST_SUPPORTED\n            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)\n            {\n               where = PNG_FILLER_BEFORE;\n               change &= ~PNG_FORMAT_FLAG_AFIRST;\n            }\n\n            else\n#endif\n            where = PNG_FILLER_AFTER;\n\n            png_set_add_alpha(png_ptr, filler, where);\n         }\n\n         /* This stops the (irrelevant) call to swap_alpha below. */\n         change &= ~PNG_FORMAT_FLAG_ALPHA;\n      }\n\n      /* Now set the alpha mode correctly; this is always done, even if there is\n       * no alpha channel in either the input or the output because it correctly\n       * sets the output gamma.\n       */\n      png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);\n\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\n         if ((change & PNG_FORMAT_FLAG_BGR) != 0)\n         {\n            /* Check only the output format; PNG is never BGR; don't do this if\n             * the output is gray, but fix up the 'format' value in that case.\n             */\n            if ((format & PNG_FORMAT_FLAG_COLOR) != 0)\n               png_set_bgr(png_ptr);\n\n            else\n               format &= ~PNG_FORMAT_FLAG_BGR;\n\n            change &= ~PNG_FORMAT_FLAG_BGR;\n         }\n#     endif\n\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\n         if ((change & PNG_FORMAT_FLAG_AFIRST) != 0)\n         {\n            /* Only relevant if there is an alpha channel - it's particularly\n             * important to handle this correctly because do_local_compose may\n             * be set above and then libpng will keep the alpha channel for this\n             * code to remove.\n             */\n            if ((format & PNG_FORMAT_FLAG_ALPHA) != 0)\n            {\n               /* Disable this if doing a local background,\n                * TODO: remove this when local background is no longer required.\n                */\n               if (do_local_background != 2)\n                  png_set_swap_alpha(png_ptr);\n            }\n\n            else\n               format &= ~PNG_FORMAT_FLAG_AFIRST;\n\n            change &= ~PNG_FORMAT_FLAG_AFIRST;\n         }\n#     endif\n\n      /* If the *output* is 16-bit then we need to check for a byte-swap on this\n       * architecture.\n       */\n      if (linear != 0)\n      {\n         png_uint_16 le = 0x0001;\n\n         if ((*(png_const_bytep) & le) != 0)\n            png_set_swap(png_ptr);\n      }\n\n      /* If change is not now 0 some transformation is missing - error out. */\n      if (change != 0)\n         png_error(png_ptr, \"png_read_image: unsupported transformation\");\n   }\n\n   PNG_SKIP_CHUNKS(png_ptr);\n\n   /* Update the 'info' structure and make sure the result is as required; first\n    * make sure to turn on the interlace handling if it will be required\n    * (because it can't be turned on *after* the call to png_read_update_info!)\n    *\n    * TODO: remove the do_local_background fixup below.\n    */\n   if (do_local_compose == 0 && do_local_background != 2)\n      passes = png_set_interlace_handling(png_ptr);\n\n   png_read_update_info(png_ptr, info_ptr);\n\n   {\n      png_uint_32 info_format = 0;\n\n      if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n         info_format |= PNG_FORMAT_FLAG_COLOR;\n\n      if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      {\n         /* do_local_compose removes this channel below. */\n         if (do_local_compose == 0)\n         {\n            /* do_local_background does the same if required. */\n            if (do_local_background != 2 ||\n               (format & PNG_FORMAT_FLAG_ALPHA) != 0)\n               info_format |= PNG_FORMAT_FLAG_ALPHA;\n         }\n      }\n\n      else if (do_local_compose != 0) /* internal error */\n         png_error(png_ptr, \"png_image_read: alpha channel lost\");\n\n      if ((format & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0) {\n         info_format |= PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;\n      }\n\n      if (info_ptr->bit_depth == 16)\n         info_format |= PNG_FORMAT_FLAG_LINEAR;\n\n#ifdef PNG_FORMAT_BGR_SUPPORTED\n      if ((png_ptr->transformations & PNG_BGR) != 0)\n         info_format |= PNG_FORMAT_FLAG_BGR;\n#endif\n\n#ifdef PNG_FORMAT_AFIRST_SUPPORTED\n         if (do_local_background == 2)\n         {\n            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)\n               info_format |= PNG_FORMAT_FLAG_AFIRST;\n         }\n\n         if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0 ||\n            ((png_ptr->transformations & PNG_ADD_ALPHA) != 0 &&\n            (png_ptr->flags & PNG_FLAG_FILLER_AFTER) == 0))\n         {\n            if (do_local_background == 2)\n               png_error(png_ptr, \"unexpected alpha swap transformation\");\n\n            info_format |= PNG_FORMAT_FLAG_AFIRST;\n         }\n#     endif\n\n      /* This is actually an internal error. */\n      if (info_format != format)\n         png_error(png_ptr, \"png_read_image: invalid transformations\");\n   }\n\n   /* Now read the rows.  If do_local_compose is set then it is necessary to use\n    * a local row buffer.  The output will be GA, RGBA or BGRA and must be\n    * converted to G, RGB or BGR as appropriate.  The 'local_row' member of the\n    * display acts as a flag.\n    */\n   {\n      png_voidp first_row = display->buffer;\n      ptrdiff_t row_bytes = display->row_stride;\n\n      if (linear != 0)\n         row_bytes *= 2;\n\n      /* The following expression is designed to work correctly whether it gives\n       * a signed or an unsigned result.\n       */\n      if (row_bytes < 0)\n      {\n         char *ptr = png_voidcast(char*, first_row);\n         ptr += (image->height-1) * (-row_bytes);\n         first_row = png_voidcast(png_voidp, ptr);\n      }\n\n      display->first_row = first_row;\n      display->row_bytes = row_bytes;\n   }\n\n   if (do_local_compose != 0)\n   {\n      int result;\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n\n      display->local_row = row;\n      result = png_safe_execute(image, png_image_read_composite, display);\n      display->local_row = NULL;\n      png_free(png_ptr, row);\n\n      return result;\n   }\n\n   else if (do_local_background == 2)\n   {\n      int result;\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n\n      display->local_row = row;\n      result = png_safe_execute(image, png_image_read_background, display);\n      display->local_row = NULL;\n      png_free(png_ptr, row);\n\n      return result;\n   }\n\n   else if (do_local_scale != 0)\n   {\n      /* For interlaced 16-to-8 conversion, use an intermediate row buffer\n       * to avoid buffer overflows in png_combine_row. The local_row is sized\n       * for the transformed (8-bit) output, preventing the overflow that would\n       * occur if png_combine_row wrote 16-bit data directly to the user buffer.\n       */\n      int result;\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n\n      display->local_row = row;\n      result = png_safe_execute(image, png_image_read_direct_scaled, display);\n      display->local_row = NULL;\n      png_free(png_ptr, row);\n\n      return result;\n   }\n\n   else\n   {\n      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;\n\n      while (--passes >= 0)\n      {\n         png_uint_32      y = image->height;\n         png_bytep        row = png_voidcast(png_bytep, display->first_row);\n\n         for (; y > 0; --y)\n         {\n            png_read_row(png_ptr, row, NULL);\n            row += row_bytes;\n         }\n      }\n\n      return 1;\n   }\n}\n",
      "line_start": 3585,
      "line_end": 4053,
      "execution_count": 179,
      "covered_regions": 201,
      "total_regions": 513,
      "coverage_percent": 39.18,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_IEND",
      "clean_name": "png_handle_IEND",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * unknown handling (this is allowed), so:\n */\n#define png_handle_IDAT NULL\n\nstatic png_handle_result_code\npng_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_debug(1, \"in png_handle_IEND\");\n\n   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);\n\n   if (length != 0)\n      png_chunk_benign_error(png_ptr, \"invalid\");\n\n   png_crc_finish_critical(png_ptr, length, 1/*handle as ancillary*/);\n\n   return handled_ok;\n   PNG_UNUSED(info_ptr)\n}\n",
      "line_start": 1097,
      "line_end": 1111,
      "execution_count": 179,
      "covered_regions": 8,
      "total_regions": 20,
      "coverage_percent": 40.0,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_gamma",
      "clean_name": "png_do_gamma",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * or RGB images. If your bit depth is 8, use gamma_table, if it\n * is 16, use gamma_16_table and gamma_shift.  Build these with\n * build_gamma_table().\n */\nstatic void\npng_do_gamma(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\n{\n   png_const_bytep gamma_table = png_ptr->gamma_table;\n   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;\n   int gamma_shift = png_ptr->gamma_shift;\n\n   png_bytep sp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_gamma\");\n\n   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||\n       (row_info->bit_depth == 16 && gamma_16_table != NULL)))\n   {\n      switch (row_info->color_type)\n      {\n         case PNG_COLOR_TYPE_RGB:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n                  *sp = gamma_table[*sp];\n                  sp++;\n               }\n            }\n\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_RGB_ALPHA:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n\n                  *sp = gamma_table[*sp];\n                  sp++;\n\n                  *sp = gamma_table[*sp];\n                  sp++;\n\n                  sp++;\n               }\n            }\n\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n\n                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 4;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_GRAY_ALPHA:\n         {\n            if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp += 2;\n               }\n            }\n\n            else /* if (row_info->bit_depth == 16) */\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 4;\n               }\n            }\n            break;\n         }\n\n         case PNG_COLOR_TYPE_GRAY:\n         {\n            if (row_info->bit_depth == 2)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i += 4)\n               {\n                  int a = *sp & 0xc0;\n                  int b = *sp & 0x30;\n                  int c = *sp & 0x0c;\n                  int d = *sp & 0x03;\n\n                  *sp = (png_byte)(\n                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|\n                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|\n                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|\n                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));\n                  sp++;\n               }\n            }\n\n            if (row_info->bit_depth == 4)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i += 2)\n               {\n                  int msb = *sp & 0xf0;\n                  int lsb = *sp & 0x0f;\n\n                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)\n                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));\n                  sp++;\n               }\n            }\n\n            else if (row_info->bit_depth == 8)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  *sp = gamma_table[*sp];\n                  sp++;\n               }\n            }\n\n            else if (row_info->bit_depth == 16)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++)\n               {\n                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];\n                  *sp = (png_byte)((v >> 8) & 0xff);\n                  *(sp + 1) = (png_byte)(v & 0xff);\n                  sp += 2;\n               }\n            }\n            break;\n         }\n\n         default:\n            break;\n      }\n   }\n}\n",
      "line_start": 4062,
      "line_end": 4255,
      "execution_count": 7612,
      "covered_regions": 55,
      "total_regions": 137,
      "coverage_percent": 40.15,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:unsupported_gamma",
      "clean_name": "unsupported_gamma",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   return (png_fixed_point)output_gamma;\n}\n#  endif\n\nstatic int\nunsupported_gamma(png_structrp png_ptr, png_fixed_point gamma, int warn)\n{\n   /* Validate a gamma value to ensure it is in a reasonable range.  The value\n    * is expected to be 1 or greater, but this range test allows for some\n    * viewing correction values.  The intent is to weed out the API users\n    * who might use the inverse of the gamma value accidentally!\n    *\n    * 1.6.47: apply the test in png_set_gamma as well but only warn and return\n    * false if it fires.\n    *\n    * TODO: 1.8: make this an app_error in png_set_gamma as well.\n    */\n   if (gamma < PNG_LIB_GAMMA_MIN || gamma > PNG_LIB_GAMMA_MAX)\n   {\n#     define msg \"gamma out of supported range\"\n      if (warn)\n         png_app_warning(png_ptr, msg);\n      else\n         png_app_error(png_ptr, msg);\n      return 1;\n#     undef msg\n   }\n\n   return 0;\n}\n",
      "line_start": 331,
      "line_end": 356,
      "execution_count": 358,
      "covered_regions": 12,
      "total_regions": 29,
      "coverage_percent": 41.38,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_free_jmpbuf",
      "clean_name": "png_free_jmpbuf",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   png_ptr->longjmp_fn = longjmp_fn;\n   return png_ptr->jmp_buf_ptr;\n}\n\nvoid /* PRIVATE */\npng_free_jmpbuf(png_structrp png_ptr)\n{\n   if (png_ptr != NULL)\n   {\n      jmp_buf *jb = png_ptr->jmp_buf_ptr;\n\n      /* A size of 0 is used to indicate a local, stack, allocation of the\n       * pointer; used here and in png.c\n       */\n      if (jb != NULL && png_ptr->jmp_buf_size > 0)\n      {\n\n         /* This stuff is so that a failure to free the error control structure\n          * does not leave libpng in a state with no valid error handling: the\n          * free always succeeds, if there is an error it gets ignored.\n          */\n         if (jb != &png_ptr->jmp_buf_local)\n         {\n            /* Make an internal, libpng, jmp_buf to return here */\n            jmp_buf free_jmp_buf;\n\n            if (!setjmp(free_jmp_buf))\n            {\n               png_ptr->jmp_buf_ptr = &free_jmp_buf; /* come back here */\n               png_ptr->jmp_buf_size = 0; /* stack allocation */\n               png_ptr->longjmp_fn = longjmp;\n               png_free(png_ptr, jb); /* Return to setjmp on error */\n            }\n         }\n      }\n\n      /* *Always* cancel everything out: */\n      png_ptr->jmp_buf_size = 0;\n      png_ptr->jmp_buf_ptr = NULL;\n      png_ptr->longjmp_fn = 0;\n   }\n}\n",
      "line_start": 610,
      "line_end": 647,
      "execution_count": 358,
      "covered_regions": 12,
      "total_regions": 28,
      "coverage_percent": 42.86,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_check_IHDR",
      "clean_name": "png_check_IHDR",
      "source_file": "/src/libpng/png.c",
      "source_code": "   }\n}\n#endif /* READ_RGB_TO_GRAY */\n\nvoid /* PRIVATE */\npng_check_IHDR(png_const_structrp png_ptr,\n    png_uint_32 width, png_uint_32 height, int bit_depth,\n    int color_type, int interlace_type, int compression_type,\n    int filter_type)\n{\n   int error = 0;\n\n   /* Check for width and height valid values */\n   if (width == 0)\n   {\n      png_warning(png_ptr, \"Image width is zero in IHDR\");\n      error = 1;\n   }\n\n   if (width > PNG_UINT_31_MAX)\n   {\n      png_warning(png_ptr, \"Invalid image width in IHDR\");\n      error = 1;\n   }\n\n   /* The bit mask on the first line below must be at least as big as a\n    * png_uint_32.  \"~7U\" is not adequate on 16-bit systems because it will\n    * be an unsigned 16-bit value.  Casting to (png_alloc_size_t) makes the\n    * type of the result at least as bit (in bits) as the RHS of the > operator\n    * which also avoids a common warning on 64-bit systems that the comparison\n    * of (png_uint_32) against the constant value on the RHS will always be\n    * false.\n    */\n   if (((width + 7) & ~(png_alloc_size_t)7) >\n       (((PNG_SIZE_MAX\n           - 48        /* big_row_buf hack */\n           - 1)        /* filter byte */\n           / 8)        /* 8-byte RGBA pixels */\n           - 1))       /* extra max_pixel_depth pad */\n   {\n      /* The size of the row must be within the limits of this architecture.\n       * Because the read code can perform arbitrary transformations the\n       * maximum size is checked here.  Because the code in png_read_start_row\n       * adds extra space \"for safety's sake\" in several places a conservative\n       * limit is used here.\n       *\n       * NOTE: it would be far better to check the size that is actually used,\n       * but the effect in the real world is minor and the changes are more\n       * extensive, therefore much more dangerous and much more difficult to\n       * write in a way that avoids compiler warnings.\n       */\n      png_warning(png_ptr, \"Image width is too large for this architecture\");\n      error = 1;\n   }\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (width > png_ptr->user_width_max)\n#else\n   if (width > PNG_USER_WIDTH_MAX)\n#endif\n   {\n      png_warning(png_ptr, \"Image width exceeds user limit in IHDR\");\n      error = 1;\n   }\n\n   if (height == 0)\n   {\n      png_warning(png_ptr, \"Image height is zero in IHDR\");\n      error = 1;\n   }\n\n   if (height > PNG_UINT_31_MAX)\n   {\n      png_warning(png_ptr, \"Invalid image height in IHDR\");\n      error = 1;\n   }\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (height > png_ptr->user_height_max)\n#else\n   if (height > PNG_USER_HEIGHT_MAX)\n#endif\n   {\n      png_warning(png_ptr, \"Image height exceeds user limit in IHDR\");\n      error = 1;\n   }\n\n   /* Check other values */\n   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&\n       bit_depth != 8 && bit_depth != 16)\n   {\n      png_warning(png_ptr, \"Invalid bit depth in IHDR\");\n      error = 1;\n   }\n\n   if (color_type < 0 || color_type == 1 ||\n       color_type == 5 || color_type > 6)\n   {\n      png_warning(png_ptr, \"Invalid color type in IHDR\");\n      error = 1;\n   }\n\n   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||\n       ((color_type == PNG_COLOR_TYPE_RGB ||\n         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||\n         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))\n   {\n      png_warning(png_ptr, \"Invalid color type/bit depth combination in IHDR\");\n      error = 1;\n   }\n\n   if (interlace_type >= PNG_INTERLACE_LAST)\n   {\n      png_warning(png_ptr, \"Unknown interlace method in IHDR\");\n      error = 1;\n   }\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n   {\n      png_warning(png_ptr, \"Unknown compression method in IHDR\");\n      error = 1;\n   }\n\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   /* Accept filter_method 64 (intrapixel differencing) only if\n    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and\n    * 2. Libpng did not read a PNG signature (this filter_method is only\n    *    used in PNG datastreams that are embedded in MNG datastreams) and\n    * 3. The application called png_permit_mng_features with a mask that\n    *    included PNG_FLAG_MNG_FILTER_64 and\n    * 4. The filter_method is 64 and\n    * 5. The color_type is RGB or RGBA\n    */\n   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0 &&\n       png_ptr->mng_features_permitted != 0)\n      png_warning(png_ptr, \"MNG features are not allowed in a PNG datastream\");\n\n   if (filter_type != PNG_FILTER_TYPE_BASE)\n   {\n      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&\n          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&\n          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&\n          (color_type == PNG_COLOR_TYPE_RGB ||\n          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))\n      {\n         png_warning(png_ptr, \"Unknown filter method in IHDR\");\n         error = 1;\n      }\n\n      if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0)\n      {\n         png_warning(png_ptr, \"Invalid filter method in IHDR\");\n         error = 1;\n      }\n   }\n\n#else\n   if (filter_type != PNG_FILTER_TYPE_BASE)\n   {\n      png_warning(png_ptr, \"Unknown filter method in IHDR\");\n      error = 1;\n   }\n#endif\n\n   if (error == 1)\n      png_error(png_ptr, \"Invalid IHDR data\");\n}\n",
      "line_start": 1957,
      "line_end": 2119,
      "execution_count": 537,
      "covered_regions": 91,
      "total_regions": 211,
      "coverage_percent": 43.13,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libpng/contrib/oss-fuzz/libpng_read_fuzzer.cc",
      "source_code": "static const int kPngHeaderSize = 8;\n\n// Entry point for LibFuzzer.\n// Roughly follows the libpng book example:\n// http://www.libpng.org/pub/png/book/chapter13.html\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  if (size < kPngHeaderSize) {\n    return 0;\n  }\n\n  std::vector<unsigned char> v(data, data + size);\n  if (png_sig_cmp(v.data(), 0, kPngHeaderSize)) {\n    // not a PNG.\n    return 0;\n  }\n\n  PngObjectHandler png_handler;\n  png_handler.png_ptr = nullptr;\n  png_handler.row_ptr = nullptr;\n  png_handler.info_ptr = nullptr;\n  png_handler.end_info_ptr = nullptr;\n\n  png_handler.png_ptr = png_create_read_struct\n    (PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);\n  if (!png_handler.png_ptr) {\n    return 0;\n  }\n\n  png_handler.info_ptr = png_create_info_struct(png_handler.png_ptr);\n  if (!png_handler.info_ptr) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  png_handler.end_info_ptr = png_create_info_struct(png_handler.png_ptr);\n  if (!png_handler.end_info_ptr) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  // Use a custom allocator that fails for large allocations to avoid OOM.\n  png_set_mem_fn(png_handler.png_ptr, nullptr, limited_malloc, default_free);\n\n  png_set_crc_action(png_handler.png_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);\n#ifdef PNG_IGNORE_ADLER32\n  png_set_option(png_handler.png_ptr, PNG_IGNORE_ADLER32, PNG_OPTION_ON);\n#endif\n\n  // Setting up reading from buffer.\n  png_handler.buf_state = new BufState();\n  png_handler.buf_state->data = data + kPngHeaderSize;\n  png_handler.buf_state->bytes_left = size - kPngHeaderSize;\n  png_set_read_fn(png_handler.png_ptr, png_handler.buf_state, user_read_data);\n  png_set_sig_bytes(png_handler.png_ptr, kPngHeaderSize);\n\n  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  // Reading.\n  png_read_info(png_handler.png_ptr, png_handler.info_ptr);\n\n  // reset error handler to put png_deleter into scope.\n  if (setjmp(png_jmpbuf(png_handler.png_ptr))) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  png_uint_32 width, height;\n  int bit_depth, color_type, interlace_type, compression_type;\n  int filter_type;\n\n  if (!png_get_IHDR(png_handler.png_ptr, png_handler.info_ptr, &width,\n                    &height, &bit_depth, &color_type, &interlace_type,\n                    &compression_type, &filter_type)) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  // This is going to be too slow.\n  if (width && height > 100000000 / width) {\n    PNG_CLEANUP\n    return 0;\n  }\n\n  // Set several transforms that browsers typically use:\n  png_set_gray_to_rgb(png_handler.png_ptr);\n  png_set_expand(png_handler.png_ptr);\n  png_set_packing(png_handler.png_ptr);\n  png_set_scale_16(png_handler.png_ptr);\n  png_set_tRNS_to_alpha(png_handler.png_ptr);\n\n  int passes = png_set_interlace_handling(png_handler.png_ptr);\n\n  png_read_update_info(png_handler.png_ptr, png_handler.info_ptr);\n\n  png_handler.row_ptr = png_malloc(\n      png_handler.png_ptr, png_get_rowbytes(png_handler.png_ptr,\n                                            png_handler.info_ptr));\n\n  for (int pass = 0; pass < passes; ++pass) {\n    for (png_uint_32 y = 0; y < height; ++y) {\n      png_read_row(png_handler.png_ptr,\n                   static_cast<png_bytep>(png_handler.row_ptr), nullptr);\n    }\n  }\n\n  png_read_end(png_handler.png_ptr, png_handler.end_info_ptr);\n\n  PNG_CLEANUP\n\n#ifdef PNG_SIMPLIFIED_READ_SUPPORTED\n  // Simplified READ API\n  png_image image;\n  memset(&image, 0, (sizeof image));\n  image.version = PNG_IMAGE_VERSION;\n\n  if (!png_image_begin_read_from_memory(&image, data, size)) {\n    return 0;\n  }\n\n  image.format = PNG_FORMAT_RGBA;\n  std::vector<png_byte> buffer(PNG_IMAGE_SIZE(image));\n  png_image_finish_read(&image, NULL, buffer.data(), 0, NULL);\n#endif\n\n  return 0;\n}\n",
      "line_start": 99,
      "line_end": 223,
      "execution_count": 179,
      "covered_regions": 135,
      "total_regions": 312,
      "coverage_percent": 43.27,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_user_version_check",
      "clean_name": "png_user_version_check",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Check a user supplied version number, called from both read and write\n * functions that create a png_struct.\n */\nint\npng_user_version_check(png_structrp png_ptr, png_const_charp user_png_ver)\n{\n   /* Libpng versions 1.0.0 and later are binary compatible if the version\n    * string matches through the second '.'; we must recompile any\n    * applications that use any older library version.\n    */\n\n   if (user_png_ver != NULL)\n   {\n      int i = -1;\n      int found_dots = 0;\n\n      do\n      {\n         i++;\n         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])\n            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n         if (user_png_ver[i] == '.')\n            found_dots++;\n      } while (found_dots < 2 && user_png_ver[i] != 0 &&\n            PNG_LIBPNG_VER_STRING[i] != 0);\n   }\n\n   else\n      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n\n   if ((png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH) != 0)\n   {\n#ifdef PNG_WARNINGS_SUPPORTED\n      size_t pos = 0;\n      char m[128];\n\n      pos = png_safecat(m, (sizeof m), pos,\n          \"Application built with libpng-\");\n      pos = png_safecat(m, (sizeof m), pos, user_png_ver);\n      pos = png_safecat(m, (sizeof m), pos, \" but running with \");\n      pos = png_safecat(m, (sizeof m), pos, PNG_LIBPNG_VER_STRING);\n      PNG_UNUSED(pos)\n\n      png_warning(png_ptr, m);\n#endif\n\n      return 0;\n   }\n\n   /* Success return. */\n   return 1;\n}\n",
      "line_start": 204,
      "line_end": 252,
      "execution_count": 358,
      "covered_regions": 26,
      "total_regions": 58,
      "coverage_percent": 44.83,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "_ZN16PngObjectHandlerD2Ev",
      "clean_name": "PngObjectHandler::~PngObjectHandler()",
      "source_file": "/src/libpng/contrib/oss-fuzz/libpng_read_fuzzer.cc",
      "source_code": "  png_infop end_info_ptr = nullptr;\n  png_voidp row_ptr = nullptr;\n  BufState* buf_state = nullptr;\n\n  ~PngObjectHandler() {\n    if (row_ptr)\n      png_free(png_ptr, row_ptr);\n    if (end_info_ptr)\n      png_destroy_read_struct(&png_ptr, &info_ptr, &end_info_ptr);\n    else if (info_ptr)\n      png_destroy_read_struct(&png_ptr, &info_ptr, nullptr);\n    else\n      png_destroy_read_struct(&png_ptr, nullptr, nullptr);\n    delete buf_state;\n  }\n",
      "line_start": 56,
      "line_end": 66,
      "execution_count": 179,
      "covered_regions": 10,
      "total_regions": 22,
      "coverage_percent": 45.45,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_rtran_ok",
      "clean_name": "png_rtran_ok",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * png_read_update_info have not been called.  It is not necessary for the IHDR\n * to have been read in all cases; the need_IHDR parameter allows for this\n * check too.\n */\nstatic int\npng_rtran_ok(png_structrp png_ptr, int need_IHDR)\n{\n   if (png_ptr != NULL)\n   {\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)\n         png_app_error(png_ptr,\n             \"invalid after png_start_read_image or png_read_update_info\");\n\n      else if (need_IHDR && (png_ptr->mode & PNG_HAVE_IHDR) == 0)\n         png_app_error(png_ptr, \"invalid before the PNG header has been read\");\n\n      else\n      {\n         /* Turn on failure to initialize correctly for all transforms. */\n         png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;\n\n         return 1; /* Ok */\n      }\n   }\n\n   return 0; /* no png_error possible! */\n}\n",
      "line_start": 114,
      "line_end": 136,
      "execution_count": 1614,
      "covered_regions": 16,
      "total_regions": 35,
      "coverage_percent": 45.71,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_sig_bytes",
      "clean_name": "png_set_sig_bytes",
      "source_file": "/src/libpng/png.c",
      "source_code": " * or write any of the magic bytes before it starts on the IHDR.\n */\n\n#ifdef PNG_READ_SUPPORTED\nvoid PNGAPI\npng_set_sig_bytes(png_structrp png_ptr, int num_bytes)\n{\n   unsigned int nb = (unsigned int)num_bytes;\n\n   png_debug(1, \"in png_set_sig_bytes\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (num_bytes < 0)\n      nb = 0;\n\n   if (nb > 8)\n      png_error(png_ptr, \"Too many bytes for PNG signature\");\n\n   png_ptr->sig_bytes = (png_byte)nb;\n}\n",
      "line_start": 52,
      "line_end": 69,
      "execution_count": 179,
      "covered_regions": 11,
      "total_regions": 24,
      "coverage_percent": 45.83,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_sig_cmp",
      "clean_name": "png_sig_cmp",
      "source_file": "/src/libpng/png.c",
      "source_code": " * an integer less than, equal to, or greater than zero if sig is found,\n * respectively, to be less than, to match, or be greater than the correct\n * PNG signature (this is the same behavior as strcmp, memcmp, etc).\n */\nint PNGAPI\npng_sig_cmp(png_const_bytep sig, size_t start, size_t num_to_check)\n{\n   static const png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n\n   if (num_to_check > 8)\n      num_to_check = 8;\n\n   else if (num_to_check < 1)\n      return -1;\n\n   if (start > 7)\n      return -1;\n\n   if (start + num_to_check > 8)\n      num_to_check = 8 - start;\n\n   return memcmp(&sig[start], &png_signature[start], num_to_check);\n}\n",
      "line_start": 79,
      "line_end": 97,
      "execution_count": 358,
      "covered_regions": 11,
      "total_regions": 24,
      "coverage_percent": 45.83,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_do_read_transformations",
      "clean_name": "png_do_read_transformations",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Transform the row.  The order of transformations is significant,\n * and is very touchy.  If you add a transformation, take care to\n * decide how it fits in with the other transformations here.\n */\nvoid /* PRIVATE */\npng_do_read_transformations(png_structrp png_ptr, png_row_infop row_info)\n{\n   png_debug(1, \"in png_do_read_transformations\");\n\n   if (png_ptr->row_buf == NULL)\n   {\n      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this\n       * error is incredibly rare and incredibly easy to debug without this\n       * information.\n       */\n      png_error(png_ptr, \"NULL row buffer\");\n   }\n\n   /* The following is debugging; prior to 1.5.4 the code was never compiled in;\n    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro\n    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.6 the new flag is set only for\n    * all transformations, however in practice the ROW_INIT always gets done on\n    * demand, if necessary.\n    */\n   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&\n       (png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n   {\n      /* Application has failed to call either png_read_start_image() or\n       * png_read_update_info() after setting transforms that expand pixels.\n       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).\n       */\n      png_error(png_ptr, \"Uninitialized row\");\n   }\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE\n         if ((png_ptr->num_trans > 0) && (png_ptr->bit_depth == 8))\n         {\n            if (png_ptr->riffled_palette == NULL)\n            {\n               /* Initialize the accelerated palette expansion. */\n               png_ptr->riffled_palette =\n                   (png_bytep)png_malloc(png_ptr, 256 * 4);\n               png_riffle_palette_neon(png_ptr);\n            }\n         }\n#endif\n         png_do_expand_palette(png_ptr, row_info, png_ptr->row_buf + 1,\n             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);\n      }\n\n      else\n      {\n         if (png_ptr->num_trans != 0 &&\n             (png_ptr->transformations & PNG_EXPAND_tRNS) != 0)\n            png_do_expand(row_info, png_ptr->row_buf + 1,\n                &(png_ptr->trans_color));\n\n         else\n            png_do_expand(row_info, png_ptr->row_buf + 1, NULL);\n      }\n   }\n#endif\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) == 0 &&\n       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n      png_do_strip_channel(row_info, png_ptr->row_buf + 1,\n          0 /* at_start == false, because SWAP_ALPHA happens later */);\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n   {\n      int rgb_error =\n          png_do_rgb_to_gray(png_ptr, row_info,\n              png_ptr->row_buf + 1);\n\n      if (rgb_error != 0)\n      {\n         png_ptr->rgb_to_gray_status=1;\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==\n             PNG_RGB_TO_GRAY_WARN)\n            png_warning(png_ptr, \"png_do_rgb_to_gray found nongray pixel\");\n\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==\n             PNG_RGB_TO_GRAY_ERR)\n            png_error(png_ptr, \"png_do_rgb_to_gray found nongray pixel\");\n      }\n   }\n#endif\n\n/* From Andreas Dilger e-mail to png-implement, 26 March 1998:\n *\n *   In most cases, the \"simple transparency\" should be done prior to doing\n *   gray-to-RGB, or you will have to test 3x as many bytes to check if a\n *   pixel is transparent.  You would also need to make sure that the\n *   transparency information is upgraded to RGB.\n *\n *   To summarize, the current flow is:\n *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite\n *                                   with background \"in place\" if transparent,\n *                                   convert to RGB if necessary\n *   - Gray + alpha -> composite with gray background and remove alpha bytes,\n *                                   convert to RGB if necessary\n *\n *   To support RGB backgrounds for gray images we need:\n *   - Gray + simple transparency -> convert to RGB + simple transparency,\n *                                   compare 3 or 6 bytes and composite with\n *                                   background \"in place\" if transparent\n *                                   (3x compare/pixel compared to doing\n *                                   composite with gray bkgrnd)\n *   - Gray + alpha -> convert to RGB + alpha, composite with background and\n *                                   remove alpha bytes (3x float\n *                                   operations/pixel compared with composite\n *                                   on gray background)\n *\n *  Greg's change will do this.  The reason it wasn't done before is for\n *  performance, as this increases the per-pixel operations.  If we would check\n *  in advance if the background was gray or RGB, and position the gray-to-RGB\n *  transform appropriately, then it would save a lot of work/time.\n */\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   /* If gray -> RGB, do so now only if background is non-gray; else do later\n    * for performance reasons\n    */\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&\n       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) == 0)\n      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);\n#endif\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);\n#endif\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   if ((png_ptr->transformations & PNG_GAMMA) != 0 &&\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n      /* Because RGB_TO_GRAY does the gamma transform. */\n      (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0 &&\n#endif\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\n      /* Because PNG_COMPOSE does the gamma transform if there is something to\n       * do (if there is an alpha channel or transparency.)\n       */\n       !((png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       ((png_ptr->num_trans != 0) ||\n       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)) &&\n#endif\n      /* Because png_init_read_transformations transforms the palette, unless\n       * RGB_TO_GRAY will do the transform.\n       */\n       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))\n      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);\n#endif\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))\n      png_do_strip_channel(row_info, png_ptr->row_buf + 1,\n          0 /* at_start == false, because SWAP_ALPHA happens later */);\n#endif\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&\n       (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);\n#endif\n\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n   if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)\n      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n   /* There is no harm in doing both of these because only one has any effect,\n    * by putting the 'scale' option first if the app asks for scale (either by\n    * calling the API or in a TRANSFORM flag) this is what happens.\n    */\n   if ((png_ptr->transformations & PNG_16_TO_8) != 0)\n      png_do_chop(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\n   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)\n      png_do_quantize(row_info, png_ptr->row_buf + 1,\n          png_ptr->palette_lookup, png_ptr->quantize_index);\n#endif /* READ_QUANTIZE */\n\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n   /* Do the expansion now, after all the arithmetic has been done.  Notice\n    * that previous transformations can handle the PNG_EXPAND_16 flag if this\n    * is efficient (particularly true in the case of gamma correction, where\n    * better accuracy results faster!)\n    */\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)\n      png_do_expand_16(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   /* NOTE: moved here in 1.5.4 (from much later in this list.) */\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&\n       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) != 0)\n      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_INVERT_SUPPORTED\n   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)\n      png_do_invert(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)\n      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_SHIFT_SUPPORTED\n   if ((png_ptr->transformations & PNG_SHIFT) != 0)\n      png_do_unshift(row_info, png_ptr->row_buf + 1,\n          &(png_ptr->shift));\n#endif\n\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0)\n      png_do_unpack(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n   /* Added at libpng-1.5.10 */\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\n       png_ptr->num_palette_max >= 0)\n      png_do_check_palette_indexes(png_ptr, row_info);\n#endif\n\n#ifdef PNG_READ_BGR_SUPPORTED\n   if ((png_ptr->transformations & PNG_BGR) != 0)\n      png_do_bgr(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n      png_do_packswap(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   if ((png_ptr->transformations & PNG_FILLER) != 0)\n      png_do_read_filler(row_info, png_ptr->row_buf + 1,\n          (png_uint_32)png_ptr->filler, png_ptr->flags);\n#endif\n\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0)\n      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);\n#endif\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n#ifdef PNG_READ_SWAP_SUPPORTED\n   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)\n      png_do_swap(row_info, png_ptr->row_buf + 1);\n#endif\n#endif\n\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n   {\n      if (png_ptr->read_user_transform_fn != NULL)\n         (*(png_ptr->read_user_transform_fn)) /* User read transform function */\n             (png_ptr,     /* png_ptr */\n             row_info,     /* row_info: */\n                /*  png_uint_32 width;       width of row */\n                /*  size_t rowbytes;         number of bytes in row */\n                /*  png_byte color_type;     color type of pixels */\n                /*  png_byte bit_depth;      bit depth of samples */\n                /*  png_byte channels;       number of channels (1-4) */\n                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */\n             png_ptr->row_buf + 1);    /* start of pixel data for row */\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\n      if (png_ptr->user_transform_depth != 0)\n         row_info->bit_depth = png_ptr->user_transform_depth;\n\n      if (png_ptr->user_transform_channels != 0)\n         row_info->channels = png_ptr->user_transform_channels;\n#endif\n      row_info->pixel_depth = (png_byte)(row_info->bit_depth *\n          row_info->channels);\n\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);\n   }\n#endif\n}\n",
      "line_start": 4858,
      "line_end": 5155,
      "execution_count": 27980,
      "covered_regions": 166,
      "total_regions": 359,
      "coverage_percent": 46.24,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_PLTE",
      "clean_name": "png_handle_PLTE",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "/* TODO: there are several obvious errors in this code when handling\n * out-of-place chunks and there is much over-complexity caused by trying to\n * patch up the problems.\n */\nstatic png_handle_result_code\npng_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n\n   png_debug(1, \"in png_handle_PLTE\");\n\n   /* 1.6.47: consistency.  This used to be especially treated as a critical\n    * error even in an image which is not colour mapped, there isn't a good\n    * justification for treating some errors here one way and others another so\n    * everything uses the same logic.\n    */\n   if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n      errmsg = \"duplicate\";\n\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      errmsg = \"out of place\";\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n      errmsg = \"ignored in grayscale PNG\";\n\n   else if (length > 3*PNG_MAX_PALETTE_LENGTH || (length % 3) != 0)\n      errmsg = \"invalid\";\n\n   /* This drops PLTE in favour of tRNS or bKGD because both of those chunks\n    * can have an effect on the rendering of the image whereas PLTE only matters\n    * in the case of an 8-bit display with a decoder which controls the palette.\n    *\n    * The alternative here is to ignore the error and store the palette anyway;\n    * destroying the tRNS will definately cause problems.\n    *\n    * NOTE: the case of PNG_COLOR_TYPE_PALETTE need not be considered because\n    * the png_handle_ routines for the three 'after PLTE' chunks tRNS, bKGD and\n    * hIST all check for a preceding PLTE in these cases.\n    */\n   else if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE &&\n            (png_has_chunk(png_ptr, tRNS) || png_has_chunk(png_ptr, bKGD)))\n      errmsg = \"out of place\";\n\n   else\n   {\n      /* If the palette has 256 or fewer entries but is too large for the bit\n       * depth we don't issue an error to preserve the behavior of previous\n       * libpng versions. We silently truncate the unused extra palette entries\n       * here.\n       */\n      const unsigned max_palette_length =\n         (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n            1U << png_ptr->bit_depth : PNG_MAX_PALETTE_LENGTH;\n\n      /* The cast is safe because 'length' is less than\n       * 3*PNG_MAX_PALETTE_LENGTH\n       */\n      const unsigned num = (length > 3U*max_palette_length) ?\n         max_palette_length : (unsigned)length / 3U;\n\n      unsigned i, j;\n      png_byte buf[3*PNG_MAX_PALETTE_LENGTH];\n      png_color palette[PNG_MAX_PALETTE_LENGTH];\n\n      /* Read the chunk into the buffer then read to the end of the chunk. */\n      png_crc_read(png_ptr, buf, num*3U);\n      png_crc_finish_critical(png_ptr, length - 3U*num,\n            /* Handle as ancillary if PLTE is optional: */\n            png_ptr->color_type != PNG_COLOR_TYPE_PALETTE);\n\n      for (i = 0U, j = 0U; i < num; i++)\n      {\n         palette[i].red = buf[j++];\n         palette[i].green = buf[j++];\n         palette[i].blue = buf[j++];\n      }\n\n      /* A valid PLTE chunk has been read */\n      png_ptr->mode |= PNG_HAVE_PLTE;\n\n      /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to\n       * its own copy of the palette.  This has the side effect that when\n       * png_start_row is called (this happens after any call to\n       * png_read_update_info) the info_ptr palette gets changed.  This is\n       * extremely unexpected and confusing.\n       *\n       * REVIEW: there have been consistent bugs in the past about gamma and\n       * similar transforms to colour mapped images being useless because the\n       * modified palette cannot be accessed because of the above.\n       *\n       * CONSIDER: Fix this by not sharing the palette in this way.  But does\n       * this completely fix the problem?\n       */\n      png_set_PLTE(png_ptr, info_ptr, palette, num);\n      return handled_ok;\n   }\n\n   /* Here on error: errmsg is non NULL. */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_error(png_ptr, errmsg);\n   }\n\n   else /* not critical to this image */\n   {\n      png_crc_finish_critical(png_ptr, length, 1/*handle as ancillary*/);\n      png_chunk_benign_error(png_ptr, errmsg);\n   }\n\n   /* Because PNG_UNUSED(errmsg) does not work if all the uses are compiled out\n    * (this does happen).\n    */\n   return errmsg != NULL ? handled_error : handled_error;\n}\n",
      "line_start": 980,
      "line_end": 1090,
      "execution_count": 132,
      "covered_regions": 66,
      "total_regions": 141,
      "coverage_percent": 46.81,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_handle_as_unknown",
      "clean_name": "png_handle_as_unknown",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\nint PNGAPI\npng_handle_as_unknown(png_const_structrp png_ptr, png_const_bytep chunk_name)\n{\n   /* Check chunk_name and return \"keep\" value if it's on the list, else 0 */\n   png_const_bytep p, p_end;\n\n   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)\n      return PNG_HANDLE_CHUNK_AS_DEFAULT;\n\n   p_end = png_ptr->chunk_list;\n   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */\n\n   /* The code is the fifth byte after each four byte string.  Historically this\n    * code was always searched from the end of the list, this is no longer\n    * necessary because the 'set' routine handles duplicate entries correctly.\n    */\n   do /* num_chunk_list > 0, so at least one */\n   {\n      p -= 5;\n\n      if (memcmp(chunk_name, p, 4) == 0)\n         return p[4];\n   }\n   while (p > p_end);\n\n   /* This means that known chunks should be processed and unknown chunks should\n    * be handled according to the value of png_ptr->unknown_default; this can be\n    * confusing because, as a result, there are two levels of defaulting for\n    * unknown chunks.\n    */\n   return PNG_HANDLE_CHUNK_AS_DEFAULT;\n}\n",
      "line_start": 927,
      "line_end": 958,
      "execution_count": 1642,
      "covered_regions": 16,
      "total_regions": 33,
      "coverage_percent": 48.48,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_finish_IDAT",
      "clean_name": "png_read_finish_IDAT",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "         png_chunk_benign_error(png_ptr, \"Too much image data\");\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_IDAT(png_structrp png_ptr)\n{\n   /* We don't need any more data and the stream should have ended, however the\n    * LZ end code may actually not have been processed.  In this case we must\n    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk\n    * may still remain to be consumed.\n    */\n   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n   {\n      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in\n       * the compressed stream, but the stream may be damaged too, so even after\n       * this call we may need to terminate the zstream ownership.\n       */\n      png_read_IDAT_data(png_ptr, NULL, 0);\n      png_ptr->zstream.next_out = NULL; /* safety */\n\n      /* Now clear everything out for safety; the following may not have been\n       * done.\n       */\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)\n      {\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n      }\n   }\n\n   /* If the zstream has not been released do it now *and* terminate the reading\n    * of the final IDAT chunk.\n    */\n   if (png_ptr->zowner == png_IDAT)\n   {\n      /* Always do this; the pointers otherwise point into the read buffer. */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n\n      /* Now we no longer own the zstream. */\n      png_ptr->zowner = 0;\n\n      /* The slightly weird semantics of the sequential IDAT reading is that we\n       * are always in or at the end of an IDAT chunk, so we always need to do a\n       * crc_finish here.  If idat_size is non-zero we also need to read the\n       * spurious bytes at the end of the chunk now.\n       */\n      (void)png_crc_finish(png_ptr, png_ptr->idat_size);\n   }\n}\n",
      "line_start": 4320,
      "line_end": 4366,
      "execution_count": 537,
      "covered_regions": 21,
      "total_regions": 43,
      "coverage_percent": 48.84,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_inflate_claim",
      "clean_name": "png_inflate_claim",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * decompression.  Returns Z_OK on success, else a zlib error code.  It checks\n * the owner but, in final release builds, just issues a warning if some other\n * chunk apparently owns the stream.  Prior to release it does a png_error.\n */\nstatic int\npng_inflate_claim(png_structrp png_ptr, png_uint_32 owner)\n{\n   if (png_ptr->zowner != 0)\n   {\n      char msg[64];\n\n      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);\n      /* So the message that results is \"<chunk> using zstream\"; this is an\n       * internal error, but is very useful for debugging.  i18n requirements\n       * are minimal.\n       */\n      (void)png_safecat(msg, (sizeof msg), 4, \" using zstream\");\n#if PNG_RELEASE_BUILD\n      png_chunk_warning(png_ptr, msg);\n      png_ptr->zowner = 0;\n#else\n      png_chunk_error(png_ptr, msg);\n#endif\n   }\n\n   /* Implementation note: unlike 'png_deflate_claim' this internal function\n    * does not take the size of the data as an argument.  Some efficiency could\n    * be gained by using this when it is known *if* the zlib stream itself does\n    * not record the number; however, this is an illusion: the original writer\n    * of the PNG may have selected a lower window size, and we really must\n    * follow that because, for systems with with limited capabilities, we\n    * would otherwise reject the application's attempts to use a smaller window\n    * size (zlib doesn't have an interface to say \"this or lower\"!).\n    *\n    * inflateReset2 was added to zlib 1.2.4; before this the window could not be\n    * reset, therefore it is necessary to always allocate the maximum window\n    * size with earlier zlibs just in case later compressed chunks need it.\n    */\n   {\n      int ret; /* zlib return code */\n#if ZLIB_VERNUM >= 0x1240\n      int window_bits = 0;\n\n# if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)\n      if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==\n          PNG_OPTION_ON)\n      {\n         window_bits = 15;\n         png_ptr->zstream_start = 0; /* fixed window size */\n      }\n\n      else\n      {\n         png_ptr->zstream_start = 1;\n      }\n# endif\n\n#endif /* ZLIB_VERNUM >= 0x1240 */\n\n      /* Set this for safety, just in case the previous owner left pointers to\n       * memory allocations.\n       */\n      png_ptr->zstream.next_in = NULL;\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.next_out = NULL;\n      png_ptr->zstream.avail_out = 0;\n\n      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateReset2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateReset(&png_ptr->zstream);\n#endif\n      }\n\n      else\n      {\n#if ZLIB_VERNUM >= 0x1240\n         ret = inflateInit2(&png_ptr->zstream, window_bits);\n#else\n         ret = inflateInit(&png_ptr->zstream);\n#endif\n\n         if (ret == Z_OK)\n            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;\n      }\n\n#ifdef PNG_DISABLE_ADLER32_CHECK_SUPPORTED\n      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)\n         /* Turn off validation of the ADLER32 checksum in IDAT chunks */\n         ret = inflateValidate(&png_ptr->zstream, 0);\n#endif\n\n      if (ret == Z_OK)\n         png_ptr->zowner = owner;\n\n      else\n         png_zstream_error(png_ptr, ret);\n\n      return ret;\n   }\n\n#ifdef window_bits\n# undef window_bits\n#endif\n}\n",
      "line_start": 413,
      "line_end": 515,
      "execution_count": 585,
      "covered_regions": 32,
      "total_regions": 65,
      "coverage_percent": 49.23,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_free_data",
      "clean_name": "png_free_data",
      "source_file": "/src/libpng/png.c",
      "source_code": "   else\n      png_error(png_ptr, \"Unknown freer parameter in png_data_freer\");\n}\n\nvoid PNGAPI\npng_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,\n    int num)\n{\n   png_debug(1, \"in png_free_data\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n#ifdef PNG_TEXT_SUPPORTED\n   /* Free text item num or (if num == -1) all text items */\n   if (info_ptr->text != NULL &&\n       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->text[num].key);\n         info_ptr->text[num].key = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->num_text; i++)\n            png_free(png_ptr, info_ptr->text[i].key);\n\n         png_free(png_ptr, info_ptr->text);\n         info_ptr->text = NULL;\n         info_ptr->num_text = 0;\n         info_ptr->max_text = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\n   /* Free any tRNS entry */\n   if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)\n   {\n      info_ptr->valid &= ~PNG_INFO_tRNS;\n      png_free(png_ptr, info_ptr->trans_alpha);\n      info_ptr->trans_alpha = NULL;\n      info_ptr->num_trans = 0;\n   }\n#endif\n\n#ifdef PNG_sCAL_SUPPORTED\n   /* Free any sCAL entry */\n   if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->scal_s_width);\n      png_free(png_ptr, info_ptr->scal_s_height);\n      info_ptr->scal_s_width = NULL;\n      info_ptr->scal_s_height = NULL;\n      info_ptr->valid &= ~PNG_INFO_sCAL;\n   }\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\n   /* Free any pCAL entry */\n   if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->pcal_purpose);\n      png_free(png_ptr, info_ptr->pcal_units);\n      info_ptr->pcal_purpose = NULL;\n      info_ptr->pcal_units = NULL;\n\n      if (info_ptr->pcal_params != NULL)\n         {\n            int i;\n\n            for (i = 0; i < info_ptr->pcal_nparams; i++)\n               png_free(png_ptr, info_ptr->pcal_params[i]);\n\n            png_free(png_ptr, info_ptr->pcal_params);\n            info_ptr->pcal_params = NULL;\n         }\n      info_ptr->valid &= ~PNG_INFO_pCAL;\n   }\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\n   /* Free any profile entry */\n   if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->iccp_name);\n      png_free(png_ptr, info_ptr->iccp_profile);\n      info_ptr->iccp_name = NULL;\n      info_ptr->iccp_profile = NULL;\n      info_ptr->valid &= ~PNG_INFO_iCCP;\n   }\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\n   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */\n   if (info_ptr->splt_palettes != NULL &&\n       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n         png_free(png_ptr, info_ptr->splt_palettes[num].name);\n         png_free(png_ptr, info_ptr->splt_palettes[num].entries);\n         info_ptr->splt_palettes[num].name = NULL;\n         info_ptr->splt_palettes[num].entries = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->splt_palettes_num; i++)\n         {\n            png_free(png_ptr, info_ptr->splt_palettes[i].name);\n            png_free(png_ptr, info_ptr->splt_palettes[i].entries);\n         }\n\n         png_free(png_ptr, info_ptr->splt_palettes);\n         info_ptr->splt_palettes = NULL;\n         info_ptr->splt_palettes_num = 0;\n         info_ptr->valid &= ~PNG_INFO_sPLT;\n      }\n   }\n#endif\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\n   if (info_ptr->unknown_chunks != NULL &&\n       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)\n   {\n      if (num != -1)\n      {\n          png_free(png_ptr, info_ptr->unknown_chunks[num].data);\n          info_ptr->unknown_chunks[num].data = NULL;\n      }\n\n      else\n      {\n         int i;\n\n         for (i = 0; i < info_ptr->unknown_chunks_num; i++)\n            png_free(png_ptr, info_ptr->unknown_chunks[i].data);\n\n         png_free(png_ptr, info_ptr->unknown_chunks);\n         info_ptr->unknown_chunks = NULL;\n         info_ptr->unknown_chunks_num = 0;\n      }\n   }\n#endif\n\n#ifdef PNG_eXIf_SUPPORTED\n   /* Free any eXIf entry */\n   if (((mask & PNG_FREE_EXIF) & info_ptr->free_me) != 0)\n   {\n      if (info_ptr->exif)\n      {\n         png_free(png_ptr, info_ptr->exif);\n         info_ptr->exif = NULL;\n      }\n      info_ptr->valid &= ~PNG_INFO_eXIf;\n   }\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\n   /* Free any hIST entry */\n   if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->hist);\n      info_ptr->hist = NULL;\n      info_ptr->valid &= ~PNG_INFO_hIST;\n   }\n#endif\n\n   /* Free any PLTE entry that was internally allocated */\n   if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)\n   {\n      png_free(png_ptr, info_ptr->palette);\n      info_ptr->palette = NULL;\n      info_ptr->valid &= ~PNG_INFO_PLTE;\n      info_ptr->num_palette = 0;\n   }\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\n   /* Free any image bits attached to the info structure */\n   if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)\n   {\n      if (info_ptr->row_pointers != NULL)\n      {\n         png_uint_32 row;\n         for (row = 0; row < info_ptr->height; row++)\n            png_free(png_ptr, info_ptr->row_pointers[row]);\n\n         png_free(png_ptr, info_ptr->row_pointers);\n         info_ptr->row_pointers = NULL;\n      }\n      info_ptr->valid &= ~PNG_INFO_IDAT;\n   }\n#endif\n\n   if (num != -1)\n      mask &= ~PNG_FREE_MUL;\n\n   info_ptr->free_me &= ~mask;\n}\n",
      "line_start": 479,
      "line_end": 680,
      "execution_count": 794,
      "covered_regions": 128,
      "total_regions": 258,
      "coverage_percent": 49.61,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "_Z14limited_mallocP14png_struct_defm",
      "clean_name": "limited_malloc(png_struct_def*, unsigned long)",
      "source_file": "/src/libpng/contrib/oss-fuzz/libpng_read_fuzzer.cc",
      "source_code": "  buf_state->bytes_left -= length;\n  buf_state->data += length;\n}\n\nvoid* limited_malloc(png_structp, png_alloc_size_t size) {\n  // libpng may allocate large amounts of memory that the fuzzer reports as\n  // an error. In order to silence these errors, make libpng fail when trying\n  // to allocate a large amount. This allocator used to be in the Chromium\n  // version of this fuzzer.\n  // This number is chosen to match the default png_user_chunk_malloc_max.\n  if (size > 8000000)\n    return nullptr;\n\n  return malloc(size);\n}\n",
      "line_start": 79,
      "line_end": 89,
      "execution_count": 1831,
      "covered_regions": 4,
      "total_regions": 8,
      "coverage_percent": 50.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_malloc",
      "clean_name": "png_malloc",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "/* Various functions that have different error handling are derived from this.\n * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate\n * function png_malloc_default is also provided.\n */\nPNG_FUNCTION(png_voidp,PNGAPI\npng_malloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)\n{\n   png_voidp ret;\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   ret = png_malloc_base(png_ptr, size);\n\n   if (ret == NULL)\n       png_error(png_ptr, \"Out of memory\"); /* 'm' means png_malloc */\n\n   return ret;\n}\n",
      "line_start": 169,
      "line_end": 183,
      "execution_count": 1685,
      "covered_regions": 11,
      "total_regions": 22,
      "coverage_percent": 50.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_IDAT_data",
      "clean_name": "png_read_IDAT_data",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   }\n}\n\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\nvoid /* PRIVATE */\npng_read_IDAT_data(png_structrp png_ptr, png_bytep output,\n    png_alloc_size_t avail_out)\n{\n   /* Loop reading IDATs and decompressing the result into output[avail_out] */\n   png_ptr->zstream.next_out = output;\n   png_ptr->zstream.avail_out = 0; /* safety: set below */\n\n   if (output == NULL)\n      avail_out = 0;\n\n   do\n   {\n      int ret;\n      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];\n\n      if (png_ptr->zstream.avail_in == 0)\n      {\n         uInt avail_in;\n         png_bytep buffer;\n\n         while (png_ptr->idat_size == 0)\n         {\n            png_crc_finish(png_ptr, 0);\n\n            png_ptr->idat_size = png_read_chunk_header(png_ptr);\n            /* This is an error even in the 'check' case because the code just\n             * consumed a non-IDAT header.\n             */\n            if (png_ptr->chunk_name != png_IDAT)\n               png_error(png_ptr, \"Not enough image data\");\n         }\n\n         avail_in = png_ptr->IDAT_read_size;\n\n         if (avail_in > png_chunk_max(png_ptr))\n            avail_in = (uInt)/*SAFE*/png_chunk_max(png_ptr);\n\n         if (avail_in > png_ptr->idat_size)\n            avail_in = (uInt)png_ptr->idat_size;\n\n         /* A PNG with a gradually increasing IDAT size will defeat this attempt\n          * to minimize memory usage by causing lots of re-allocs, but\n          * realistically doing IDAT_read_size re-allocs is not likely to be a\n          * big problem.\n          *\n          * An error here corresponds to the system being out of memory.\n          */\n         buffer = png_read_buffer(png_ptr, avail_in);\n\n         if (buffer == NULL)\n            png_chunk_error(png_ptr, \"out of memory\");\n\n         png_crc_read(png_ptr, buffer, avail_in);\n         png_ptr->idat_size -= avail_in;\n\n         png_ptr->zstream.next_in = buffer;\n         png_ptr->zstream.avail_in = avail_in;\n      }\n\n      /* And set up the output side. */\n      if (output != NULL) /* standard read */\n      {\n         uInt out = ZLIB_IO_MAX;\n\n         if (out > avail_out)\n            out = (uInt)avail_out;\n\n         avail_out -= out;\n         png_ptr->zstream.avail_out = out;\n      }\n\n      else /* after last row, checking for end */\n      {\n         png_ptr->zstream.next_out = tmpbuf;\n         png_ptr->zstream.avail_out = (sizeof tmpbuf);\n      }\n\n      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the\n       * process.  If the LZ stream is truncated the sequential reader will\n       * terminally damage the stream, above, by reading the chunk header of the\n       * following chunk (it then exits with png_error).\n       *\n       * TODO: deal more elegantly with truncated IDAT lists.\n       */\n      ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);\n\n      /* Take the unconsumed output back. */\n      if (output != NULL)\n         avail_out += png_ptr->zstream.avail_out;\n\n      else /* avail_out counts the extra bytes */\n         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;\n\n      png_ptr->zstream.avail_out = 0;\n\n      if (ret == Z_STREAM_END)\n      {\n         /* Do this for safety; we won't read any more into this row. */\n         png_ptr->zstream.next_out = NULL;\n\n         png_ptr->mode |= PNG_AFTER_IDAT;\n         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;\n\n         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)\n            png_chunk_benign_error(png_ptr, \"Extra compressed data\");\n         break;\n      }\n\n      if (ret != Z_OK)\n      {\n         png_zstream_error(png_ptr, ret);\n\n         if (output != NULL)\n            png_chunk_error(png_ptr, png_ptr->zstream.msg);\n\n         else /* checking */\n         {\n            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);\n            return;\n         }\n      }\n   } while (avail_out > 0);\n\n   if (avail_out > 0)\n   {\n      /* The stream ended before the image; this is the same as too few IDATs so\n       * should be handled the same way.\n       */\n      if (output != NULL)\n         png_error(png_ptr, \"Not enough image data\");\n\n      else /* the deflate stream contained extra data */\n         png_chunk_benign_error(png_ptr, \"Too much image data\");\n   }\n}\n",
      "line_start": 4183,
      "line_end": 4318,
      "execution_count": 27980,
      "covered_regions": 80,
      "total_regions": 160,
      "coverage_percent": 50.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_get_int_32_checked",
      "clean_name": "png_get_int_32_checked",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_sBIT NULL\n#endif\n\n#ifdef PNG_READ_cHRM_SUPPORTED\nstatic png_int_32\npng_get_int_32_checked(png_const_bytep buf, int *error)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return (png_int_32)uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   if ((uval & 0x80000000) == 0) /* no overflow */\n      return -(png_int_32)uval;\n\n   /* This version of png_get_int_32 has a way of returning the error to the\n    * caller, so:\n    */\n   *error = 1;\n   return 0; /* Safe */\n}\n",
      "line_start": 1221,
      "line_end": 1237,
      "execution_count": 864,
      "covered_regions": 9,
      "total_regions": 18,
      "coverage_percent": 50.0,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_read_sig",
      "clean_name": "png_read_sig",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "\n#endif /* READ_INT_FUNCTIONS */\n\n/* Read and check the PNG file signature */\nvoid /* PRIVATE */\npng_read_sig(png_structrp png_ptr, png_inforp info_ptr)\n{\n   size_t num_checked, num_to_check;\n\n   /* Exit if the user application does not expect a signature. */\n   if (png_ptr->sig_bytes >= 8)\n      return;\n\n   num_checked = png_ptr->sig_bytes;\n   num_to_check = 8 - num_checked;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;\n#endif\n\n   /* The signature must be serialized in a single I/O call. */\n   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);\n   png_ptr->sig_bytes = 8;\n\n   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)\n   {\n      if (num_checked < 4 &&\n          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4) != 0)\n         png_error(png_ptr, \"Not a PNG file\");\n      else\n         png_error(png_ptr, \"PNG file corrupted by ASCII conversion\");\n   }\n   if (num_checked < 3)\n      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;\n}\n",
      "line_start": 115,
      "line_end": 145,
      "execution_count": 358,
      "covered_regions": 22,
      "total_regions": 43,
      "coverage_percent": 51.16,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_destroy_gamma_table",
      "clean_name": "png_destroy_gamma_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Used from png_read_destroy and below to release the memory used by the gamma\n * tables.\n */\nvoid /* PRIVATE */\npng_destroy_gamma_table(png_structrp png_ptr)\n{\n   png_free(png_ptr, png_ptr->gamma_table);\n   png_ptr->gamma_table = NULL;\n\n#ifdef PNG_16BIT_SUPPORTED\n   if (png_ptr->gamma_16_table != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_table[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_table);\n   png_ptr->gamma_16_table = NULL;\n   }\n#endif /* 16BIT */\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n   png_free(png_ptr, png_ptr->gamma_from_1);\n   png_ptr->gamma_from_1 = NULL;\n   png_free(png_ptr, png_ptr->gamma_to_1);\n   png_ptr->gamma_to_1 = NULL;\n\n#ifdef PNG_16BIT_SUPPORTED\n   if (png_ptr->gamma_16_from_1 != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_from_1);\n   png_ptr->gamma_16_from_1 = NULL;\n   }\n   if (png_ptr->gamma_16_to_1 != NULL)\n   {\n      int i;\n      int istop = (1 << (8 - png_ptr->gamma_shift));\n      for (i = 0; i < istop; i++)\n      {\n         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);\n      }\n   png_free(png_ptr, png_ptr->gamma_16_to_1);\n   png_ptr->gamma_16_to_1 = NULL;\n   }\n#endif /* 16BIT */\n#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */\n}\n",
      "line_start": 3541,
      "line_end": 3594,
      "execution_count": 358,
      "covered_regions": 27,
      "total_regions": 52,
      "coverage_percent": 51.92,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_mDCV_fixed",
      "clean_name": "png_set_mDCV_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n   return (png_uint_16)/*SAFE*/v;\n}\n\nvoid PNGAPI\npng_set_mDCV_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_fixed_point white_x, png_fixed_point white_y,\n    png_fixed_point red_x, png_fixed_point red_y,\n    png_fixed_point green_x, png_fixed_point green_y,\n    png_fixed_point blue_x, png_fixed_point blue_y,\n    png_uint_32 maxDL,\n    png_uint_32 minDL)\n{\n   png_uint_16 rx, ry, gx, gy, bx, by, wx, wy;\n   int error;\n\n   png_debug1(1, \"in %s storage function\", \"mDCV\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* Check the input values to ensure they are in the expected range: */\n   error = 0;\n   rx = png_ITU_fixed_16(&error, red_x);\n   ry = png_ITU_fixed_16(&error, red_y);\n   gx = png_ITU_fixed_16(&error, green_x);\n   gy = png_ITU_fixed_16(&error, green_y);\n   bx = png_ITU_fixed_16(&error, blue_x);\n   by = png_ITU_fixed_16(&error, blue_y);\n   wx = png_ITU_fixed_16(&error, white_x);\n   wy = png_ITU_fixed_16(&error, white_y);\n\n   if (error)\n   {\n      png_chunk_report(png_ptr,\n         \"mDCV chromaticities outside representable range\",\n         PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   /* Check the light level range: */\n   if (maxDL > 0x7FFFFFFFU || minDL > 0x7FFFFFFFU)\n   {\n      /* The limit is 200kcd/m2; somewhat bright but not inconceivable because\n       * human vision is said to run up to 100Mcd/m2.  The sun is about 2Gcd/m2.\n       *\n       * The reference sRGB monitor is 80cd/m2 and the limit of PQ encoding is\n       * 2kcd/m2.\n       */\n      png_chunk_report(png_ptr, \"mDCV display light level exceeds PNG limit\",\n            PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   /* All values are safe, the settings are accepted.\n    *\n    * IMPLEMENTATION NOTE: in practice the values can be checked and assigned\n    * but the result is confusing if a writing app calls png_set_mDCV more than\n    * once, the second time with an invalid value.  This approach is more\n    * obviously correct at the cost of typing and a very slight machine\n    * overhead.\n    */\n   info_ptr->mastering_red_x = rx;\n   info_ptr->mastering_red_y = ry;\n   info_ptr->mastering_green_x = gx;\n   info_ptr->mastering_green_y = gy;\n   info_ptr->mastering_blue_x = bx;\n   info_ptr->mastering_blue_y = by;\n   info_ptr->mastering_white_x = wx;\n   info_ptr->mastering_white_y = wy;\n   info_ptr->mastering_maxDL = maxDL;\n   info_ptr->mastering_minDL = minDL;\n   info_ptr->valid |= PNG_INFO_mDCV;\n}\n",
      "line_start": 224,
      "line_end": 293,
      "execution_count": 2,
      "covered_regions": 23,
      "total_regions": 44,
      "coverage_percent": 52.27,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_malloc_warn",
      "clean_name": "png_malloc_warn",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "/* This function was added at libpng version 1.2.3.  The png_malloc_warn()\n * function will issue a png_warning and return NULL instead of issuing a\n * png_error, if it fails to allocate the requested memory.\n */\nPNG_FUNCTION(png_voidp,PNGAPI\npng_malloc_warn,(png_const_structrp png_ptr, png_alloc_size_t size),\n    PNG_ALLOCATED)\n{\n   if (png_ptr != NULL)\n   {\n      png_voidp ret = png_malloc_base(png_ptr, size);\n\n      if (ret != NULL)\n         return ret;\n\n      png_warning(png_ptr, \"Out of memory\");\n   }\n\n   return NULL;\n}\n",
      "line_start": 209,
      "line_end": 224,
      "execution_count": 1132,
      "covered_regions": 11,
      "total_regions": 21,
      "coverage_percent": 52.38,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_image_read_init",
      "clean_name": "png_image_read_init",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * called, so setting up the jmp_buf is not required.  This means that anything\n * called from here must *not* call png_malloc - it has to call png_malloc_warn\n * instead so that control is returned safely back to this routine.\n */\nstatic int\npng_image_read_init(png_imagep image)\n{\n   if (image->opaque == NULL)\n   {\n      png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,\n          png_safe_error, png_safe_warning);\n\n      /* And set the rest of the structure to NULL to ensure that the various\n       * fields are consistent.\n       */\n      memset(image, 0, (sizeof *image));\n      image->version = PNG_IMAGE_VERSION;\n\n      if (png_ptr != NULL)\n      {\n         png_infop info_ptr = png_create_info_struct(png_ptr);\n\n         if (info_ptr != NULL)\n         {\n            png_controlp control = png_voidcast(png_controlp,\n                png_malloc_warn(png_ptr, (sizeof *control)));\n\n            if (control != NULL)\n            {\n               memset(control, 0, (sizeof *control));\n\n               control->png_ptr = png_ptr;\n               control->info_ptr = info_ptr;\n               control->for_write = 0;\n\n               image->opaque = control;\n               return 1;\n            }\n\n            /* Error clean up */\n            png_destroy_info_struct(png_ptr, &info_ptr);\n         }\n\n         png_destroy_read_struct(&png_ptr, NULL, NULL);\n      }\n\n      return png_image_error(image, \"png_image_read: out of memory\");\n   }\n\n   return png_image_error(image, \"png_image_read: opaque pointer not NULL\");\n}\n",
      "line_start": 1127,
      "line_end": 1173,
      "execution_count": 179,
      "covered_regions": 31,
      "total_regions": 59,
      "coverage_percent": 52.54,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_tEXt",
      "clean_name": "png_handle_tEXt",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_tEXt_SUPPORTED\n/* Note: this does not properly handle chunks that are > 64K under DOS */\nstatic png_handle_result_code /* PRIVATE */\npng_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_text  text_info;\n   png_bytep buffer;\n   png_charp key;\n   png_charp text;\n   png_uint_32 skip = 0;\n\n   png_debug(1, \"in png_handle_tEXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return handled_error;\n      }\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return handled_error;\n\n   key = (png_charp)buffer;\n   key[length] = 0;\n\n   for (text = key; *text; text++)\n      /* Empty loop to find end of key */ ;\n\n   if (text != key + length)\n      text++;\n\n   text_info.compression = PNG_TEXT_COMPRESSION_NONE;\n   text_info.key = key;\n   text_info.lang = NULL;\n   text_info.lang_key = NULL;\n   text_info.itxt_length = 0;\n   text_info.text = text;\n   text_info.text_length = strlen(text);\n\n   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) == 0)\n      return handled_ok;\n\n   png_chunk_benign_error(png_ptr, \"out of memory\");\n   return handled_error;\n}\n",
      "line_start": 2386,
      "line_end": 2451,
      "execution_count": 231,
      "covered_regions": 39,
      "total_regions": 74,
      "coverage_percent": 52.7,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png.c:png_image_free_function",
      "clean_name": "png_image_free_function",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* SIMPLIFIED READ/WRITE SUPPORT */\n#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\\\n   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)\nstatic int\npng_image_free_function(png_voidp argument)\n{\n   png_imagep image = png_voidcast(png_imagep, argument);\n   png_controlp cp = image->opaque;\n   png_control c;\n\n   /* Double check that we have a png_ptr - it should be impossible to get here\n    * without one.\n    */\n   if (cp->png_ptr == NULL)\n      return 0;\n\n   /* First free any data held in the control structure. */\n#  ifdef PNG_STDIO_SUPPORTED\n      if (cp->owned_file != 0)\n      {\n         FILE *fp = png_voidcast(FILE *, cp->png_ptr->io_ptr);\n         cp->owned_file = 0;\n\n         /* Ignore errors here. */\n         if (fp != NULL)\n         {\n            cp->png_ptr->io_ptr = NULL;\n            (void)fclose(fp);\n         }\n      }\n#  endif\n\n   /* Copy the control structure so that the original, allocated, version can be\n    * safely freed.  Notice that a png_error here stops the remainder of the\n    * cleanup, but this is probably fine because that would indicate bad memory\n    * problems anyway.\n    */\n   c = *cp;\n   image->opaque = &c;\n   png_free(c.png_ptr, cp);\n\n   /* Then the structures, calling the correct API. */\n   if (c.for_write != 0)\n   {\n#     ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED\n         png_destroy_write_struct(&c.png_ptr, &c.info_ptr);\n#     else\n         png_error(c.png_ptr, \"simplified write not supported\");\n#     endif\n   }\n   else\n   {\n#     ifdef PNG_SIMPLIFIED_READ_SUPPORTED\n         png_destroy_read_struct(&c.png_ptr, &c.info_ptr, NULL);\n#     else\n         png_error(c.png_ptr, \"simplified read not supported\");\n#     endif\n   }\n\n   /* Success. */\n   return 1;\n}\n",
      "line_start": 3955,
      "line_end": 4013,
      "execution_count": 179,
      "covered_regions": 17,
      "total_regions": 32,
      "coverage_percent": 53.12,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_filler",
      "clean_name": "png_set_filler",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": " * The filler type has changed in v0.95 to allow future 2-byte fillers\n * for 48-bit input data, as well as to avoid problems with some compilers\n * that don't like bytes as parameters.\n */\nvoid PNGAPI\npng_set_filler(png_structrp png_ptr, png_uint_32 filler, int filler_loc)\n{\n   png_debug(1, \"in png_set_filler\");\n\n   if (png_ptr == NULL)\n      return;\n\n   /* In libpng 1.6 it is possible to determine whether this is a read or write\n    * operation and therefore to do more checking here for a valid call.\n    */\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n   {\n#     ifdef PNG_READ_FILLER_SUPPORTED\n         /* On read png_set_filler is always valid, regardless of the base PNG\n          * format, because other transformations can give a format where the\n          * filler code can execute (basically an 8 or 16-bit component RGB or G\n          * format.)\n          *\n          * NOTE: usr_channels is not used by the read code!  (This has led to\n          * confusion in the past.)  The filler is only used in the read code.\n          */\n         png_ptr->filler = (png_uint_16)filler;\n#     else\n         png_app_error(png_ptr, \"png_set_filler not supported on read\");\n         PNG_UNUSED(filler) /* not used in the write case */\n         return;\n#     endif\n   }\n\n   else /* write */\n   {\n#     ifdef PNG_WRITE_FILLER_SUPPORTED\n         /* On write the usr_channels parameter must be set correctly at the\n          * start to record the number of channels in the app-supplied data.\n          */\n         switch (png_ptr->color_type)\n         {\n            case PNG_COLOR_TYPE_RGB:\n               png_ptr->usr_channels = 4;\n               break;\n\n            case PNG_COLOR_TYPE_GRAY:\n               if (png_ptr->bit_depth >= 8)\n               {\n                  png_ptr->usr_channels = 2;\n                  break;\n               }\n\n               else\n               {\n                  /* There simply isn't any code in libpng to strip out bits\n                   * from bytes when the components are less than a byte in\n                   * size!\n                   */\n                  png_app_error(png_ptr,\n                      \"png_set_filler is invalid for\"\n                      \" low bit depth gray output\");\n                  return;\n               }\n\n            default:\n               png_app_error(png_ptr,\n                   \"png_set_filler: inappropriate color type\");\n               return;\n         }\n#     else\n         png_app_error(png_ptr, \"png_set_filler not supported on write\");\n         return;\n#     endif\n   }\n\n   /* Here on success - libpng supports the operation, set the transformation\n    * and the flag to say where the filler channel is.\n    */\n   png_ptr->transformations |= PNG_FILLER;\n\n   if (filler_loc == PNG_FILLER_AFTER)\n      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;\n\n   else\n      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\n}\n",
      "line_start": 118,
      "line_end": 200,
      "execution_count": 92,
      "covered_regions": 23,
      "total_regions": 43,
      "coverage_percent": 53.49,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_zalloc",
      "clean_name": "png_zalloc",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* READ */\n\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n/* Function to allocate memory for zlib */\nPNG_FUNCTION(voidpf /* PRIVATE */,\npng_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)\n{\n   png_alloc_size_t num_bytes = size;\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   /* This check against overflow is vestigial, dating back from\n    * the old times when png_zalloc used to be an exported function.\n    * We're still keeping it here for now, as an extra-cautious\n    * prevention against programming errors inside zlib, although it\n    * should rather be a debug-time assertion instead.\n    */\n   if (size != 0 && items >= (~(png_alloc_size_t)0) / size)\n   {\n      png_warning(png_voidcast(png_structrp, png_ptr),\n                  \"Potential overflow in png_zalloc()\");\n      return NULL;\n   }\n\n   num_bytes *= items;\n   return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);\n}\n",
      "line_start": 103,
      "line_end": 126,
      "execution_count": 578,
      "covered_regions": 15,
      "total_regions": 28,
      "coverage_percent": 53.57,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_keep_unknown_chunks",
      "clean_name": "png_set_keep_unknown_chunks",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n   return count;\n}\n\nvoid PNGAPI\npng_set_keep_unknown_chunks(png_structrp png_ptr, int keep,\n    png_const_bytep chunk_list, int num_chunks_in)\n{\n   png_bytep new_list;\n   unsigned int num_chunks, old_num_chunks;\n\n   if (png_ptr == NULL)\n      return;\n\n   if (keep < 0 || keep >= PNG_HANDLE_CHUNK_LAST)\n   {\n      png_app_error(png_ptr, \"png_set_keep_unknown_chunks: invalid keep\");\n\n      return;\n   }\n\n   if (num_chunks_in <= 0)\n   {\n      png_ptr->unknown_default = keep;\n\n      /* '0' means just set the flags, so stop here */\n      if (num_chunks_in == 0)\n        return;\n   }\n\n   if (num_chunks_in < 0)\n   {\n      /* Ignore all unknown chunks and all chunks recognized by\n       * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND\n       */\n      static const png_byte chunks_to_ignore[] = {\n         98,  75,  71,  68, '\\0',  /* bKGD */\n         99,  72,  82,  77, '\\0',  /* cHRM */\n         99,  73,  67,  80, '\\0',  /* cICP */\n         99,  76,  76,  73, '\\0',  /* cLLI */\n        101,  88,  73, 102, '\\0',  /* eXIf */\n        103,  65,  77,  65, '\\0',  /* gAMA */\n        104,  73,  83,  84, '\\0',  /* hIST */\n        105,  67,  67,  80, '\\0',  /* iCCP */\n        105,  84,  88, 116, '\\0',  /* iTXt */\n        109,  68,  67,  86, '\\0',  /* mDCV */\n        111,  70,  70, 115, '\\0',  /* oFFs */\n        112,  67,  65,  76, '\\0',  /* pCAL */\n        112,  72,  89, 115, '\\0',  /* pHYs */\n        115,  66,  73,  84, '\\0',  /* sBIT */\n        115,  67,  65,  76, '\\0',  /* sCAL */\n        115,  80,  76,  84, '\\0',  /* sPLT */\n        115,  84,  69,  82, '\\0',  /* sTER */\n        115,  82,  71,  66, '\\0',  /* sRGB */\n        116,  69,  88, 116, '\\0',  /* tEXt */\n        116,  73,  77,  69, '\\0',  /* tIME */\n        122,  84,  88, 116, '\\0'   /* zTXt */\n      };\n\n      chunk_list = chunks_to_ignore;\n      num_chunks = (unsigned int)/*SAFE*/(sizeof chunks_to_ignore)/5U;\n   }\n\n   else /* num_chunks_in > 0 */\n   {\n      if (chunk_list == NULL)\n      {\n         /* Prior to 1.6.0 this was silently ignored, now it is an app_error\n          * which can be switched off.\n          */\n         png_app_error(png_ptr, \"png_set_keep_unknown_chunks: no chunk list\");\n\n         return;\n      }\n\n      num_chunks = (unsigned int)num_chunks_in;\n   }\n\n   old_num_chunks = png_ptr->num_chunk_list;\n   if (png_ptr->chunk_list == NULL)\n      old_num_chunks = 0;\n\n   /* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.\n    */\n   if (num_chunks + old_num_chunks > UINT_MAX/5)\n   {\n      png_app_error(png_ptr, \"png_set_keep_unknown_chunks: too many chunks\");\n\n      return;\n   }\n\n   /* If these chunks are being reset to the default then no more memory is\n    * required because add_one_chunk above doesn't extend the list if the 'keep'\n    * parameter is the default.\n    */\n   if (keep != 0)\n   {\n      new_list = png_voidcast(png_bytep, png_malloc(png_ptr,\n          5 * (num_chunks + old_num_chunks)));\n\n      if (old_num_chunks > 0)\n         memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);\n   }\n\n   else if (old_num_chunks > 0)\n      new_list = png_ptr->chunk_list;\n\n   else\n      new_list = NULL;\n\n   /* Add the new chunks together with each one's handling code.  If the chunk\n    * already exists the code is updated, otherwise the chunk is added to the\n    * end.  (In libpng 1.6.0 order no longer matters because this code enforces\n    * the earlier convention that the last setting is the one that is used.)\n    */\n   if (new_list != NULL)\n   {\n      png_const_bytep inlist;\n      png_bytep outlist;\n      unsigned int i;\n\n      for (i=0; i<num_chunks; ++i)\n      {\n         old_num_chunks = add_one_chunk(new_list, old_num_chunks,\n             chunk_list+5*i, keep);\n      }\n\n      /* Now remove any spurious 'default' entries. */\n      num_chunks = 0;\n      for (i=0, inlist=outlist=new_list; i<old_num_chunks; ++i, inlist += 5)\n      {\n         if (inlist[4])\n         {\n            if (outlist != inlist)\n               memcpy(outlist, inlist, 5);\n            outlist += 5;\n            ++num_chunks;\n         }\n      }\n\n      /* This means the application has removed all the specialized handling. */\n      if (num_chunks == 0)\n      {\n         if (png_ptr->chunk_list != new_list)\n            png_free(png_ptr, new_list);\n\n         new_list = NULL;\n      }\n   }\n\n   else\n      num_chunks = 0;\n\n   png_ptr->num_chunk_list = num_chunks;\n\n   if (png_ptr->chunk_list != new_list)\n   {\n      if (png_ptr->chunk_list != NULL)\n         png_free(png_ptr, png_ptr->chunk_list);\n\n      png_ptr->chunk_list = new_list;\n   }\n}\n",
      "line_start": 1528,
      "line_end": 1686,
      "execution_count": 358,
      "covered_regions": 73,
      "total_regions": 136,
      "coverage_percent": 53.68,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_init_palette_transformations",
      "clean_name": "png_init_palette_transformations",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * 'png_init_rgb_transformations' only do some flag canceling optimizations.\n * The intent is that these two routines should have palette or rgb operations\n * extracted from 'png_init_read_transformations'.\n */\nstatic void /* PRIVATE */\npng_init_palette_transformations(png_structrp png_ptr)\n{\n   /* Called to handle the (input) palette case.  In png_do_read_transformations\n    * the first step is to expand the palette if requested, so this code must\n    * take care to only make changes that are invariant with respect to the\n    * palette expansion, or only do them if there is no expansion.\n    *\n    * STRIP_ALPHA has already been handled in the caller (by setting num_trans\n    * to 0.)\n    */\n   int input_has_alpha = 0;\n   int input_has_transparency = 0;\n\n   if (png_ptr->num_trans > 0)\n   {\n      int i;\n\n      /* Ignore if all the entries are opaque (unlikely!) */\n      for (i=0; i<png_ptr->num_trans; ++i)\n      {\n         if (png_ptr->trans_alpha[i] == 255)\n            continue;\n         else if (png_ptr->trans_alpha[i] == 0)\n            input_has_transparency = 1;\n         else\n         {\n            input_has_transparency = 1;\n            input_has_alpha = 1;\n            break;\n         }\n      }\n   }\n\n   /* If no alpha we can optimize. */\n   if (input_has_alpha == 0)\n   {\n      /* Any alpha means background and associative alpha processing is\n       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA\n       * and ENCODE_ALPHA are irrelevant.\n       */\n      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n\n      if (input_has_transparency == 0)\n         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);\n   }\n\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\n   /* png_set_background handling - deals with the complexity of whether the\n    * background color is in the file format or the screen format in the case\n    * where an 'expand' will happen.\n    */\n\n   /* The following code cannot be entered in the alpha pre-multiplication case\n    * because PNG_BACKGROUND_EXPAND is cancelled below.\n    */\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&\n       (png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      {\n         png_ptr->background.red   =\n             png_ptr->palette[png_ptr->background.index].red;\n         png_ptr->background.green =\n             png_ptr->palette[png_ptr->background.index].green;\n         png_ptr->background.blue  =\n             png_ptr->palette[png_ptr->background.index].blue;\n\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\n         if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)\n         {\n            if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)\n            {\n               /* Invert the alpha channel (in tRNS) unless the pixels are\n                * going to be expanded, in which case leave it for later\n                */\n               int i, istop = png_ptr->num_trans;\n\n               for (i = 0; i < istop; i++)\n                  png_ptr->trans_alpha[i] =\n                      (png_byte)(255 - png_ptr->trans_alpha[i]);\n            }\n         }\n#endif /* READ_INVERT_ALPHA */\n      }\n   } /* background expand and (therefore) no alpha association. */\n#endif /* READ_EXPAND && READ_BACKGROUND */\n}\n",
      "line_start": 1166,
      "line_end": 1253,
      "execution_count": 132,
      "covered_regions": 36,
      "total_regions": 67,
      "coverage_percent": 53.73,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_iTXt",
      "clean_name": "png_handle_iTXt",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_iTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nstatic png_handle_result_code /* PRIVATE */\npng_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep buffer;\n   png_uint_32 prefix_length;\n\n   png_debug(1, \"in png_handle_iTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return handled_error;\n      }\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* First the keyword. */\n   for (prefix_length=0;\n      prefix_length < length && buffer[prefix_length] != 0;\n      ++prefix_length)\n      /* Empty loop */ ;\n\n   /* Perform a basic check on the keyword length here. */\n   if (prefix_length > 79 || prefix_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* Expect keyword, compression flag, compression type, language, translated\n    * keyword (both may be empty but are 0 terminated) then the text, which may\n    * be empty.\n    */\n   else if (prefix_length + 5 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[prefix_length+1] == 0 ||\n      (buffer[prefix_length+1] == 1 &&\n      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))\n   {\n      int compressed = buffer[prefix_length+1] != 0;\n      png_uint_32 language_offset, translated_keyword_offset;\n      png_alloc_size_t uncompressed_length = 0;\n\n      /* Now the language tag */\n      prefix_length += 3;\n      language_offset = prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* WARNING: the length may be invalid here, this is checked below. */\n      translated_keyword_offset = ++prefix_length;\n\n      for (; prefix_length < length && buffer[prefix_length] != 0;\n         ++prefix_length)\n         /* Empty loop */ ;\n\n      /* prefix_length should now be at the trailing '\\0' of the translated\n       * keyword, but it may already be over the end.  None of this arithmetic\n       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit\n       * systems the available allocation may overflow.\n       */\n      ++prefix_length;\n\n      if (compressed == 0 && prefix_length <= length)\n         uncompressed_length = length - prefix_length;\n\n      else if (compressed != 0 && prefix_length < length)\n      {\n         uncompressed_length = PNG_SIZE_MAX;\n\n         /* TODO: at present png_decompress_chunk imposes a single application\n          * level memory limit, this should be split to different values for\n          * iCCP and text chunks.\n          */\n         if (png_decompress_chunk(png_ptr, length, prefix_length,\n             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n            buffer = png_ptr->read_buffer;\n\n         else\n            errmsg = png_ptr->zstream.msg;\n      }\n\n      else\n         errmsg = \"truncated\";\n\n      if (errmsg == NULL)\n      {\n         png_text text;\n\n         buffer[uncompressed_length+prefix_length] = 0;\n\n         if (compressed == 0)\n            text.compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n            text.compression = PNG_ITXT_COMPRESSION_zTXt;\n\n         text.key = (png_charp)buffer;\n         text.lang = (png_charp)buffer + language_offset;\n         text.lang_key = (png_charp)buffer + translated_keyword_offset;\n         text.text = (png_charp)buffer + prefix_length;\n         text.text_length = 0;\n         text.itxt_length = uncompressed_length;\n\n         if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n            return handled_ok;\n\n         errmsg = \"out of memory\";\n      }\n   }\n\n   else\n      errmsg = \"bad compression info\";\n\n   if (errmsg != NULL)\n      png_chunk_benign_error(png_ptr, errmsg);\n   return handled_error;\n}\n",
      "line_start": 2574,
      "line_end": 2716,
      "execution_count": 226,
      "covered_regions": 92,
      "total_regions": 171,
      "coverage_percent": 53.8,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_gamma_16bit_correct",
      "clean_name": "png_gamma_16bit_correct",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return (png_byte)(value & 0xff);\n}\n\n#ifdef PNG_16BIT_SUPPORTED\npng_uint_16\npng_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)\n{\n   if (value > 0 && value < 65535)\n   {\n# ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n      /* The same (unsigned int)->(double) constraints apply here as above,\n       * however in this case the (unsigned int) to (int) conversion can\n       * overflow on an ANSI-C90 compliant system so the cast needs to ensure\n       * that this is not possible.\n       */\n      double r = floor(65535*pow((png_int_32)value/65535.,\n          gamma_val*.00001)+.5);\n      return (png_uint_16)r;\n# else\n      png_int_32 lg2 = png_log16bit(value);\n      png_fixed_point res;\n\n      if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)\n         return png_exp16bit(res);\n\n      /* Overflow. */\n      value = 0;\n# endif\n   }\n\n   return (png_uint_16)value;\n}\n",
      "line_start": 3317,
      "line_end": 3344,
      "execution_count": 8160,
      "covered_regions": 7,
      "total_regions": 13,
      "coverage_percent": 53.85,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_data",
      "clean_name": "png_read_data",
      "source_file": "/src/libpng/pngrio.c",
      "source_code": " * with very small lengths, so you should implement some kind of simple\n * buffering if you are using unbuffered reads.  This should never be asked\n * to read more than 64K on a 16-bit machine.\n */\nvoid /* PRIVATE */\npng_read_data(png_structrp png_ptr, png_bytep data, size_t length)\n{\n   png_debug1(4, \"reading %d bytes\", (int)length);\n\n   if (png_ptr->read_data_fn != NULL)\n      (*(png_ptr->read_data_fn))(png_ptr, data, length);\n\n   else\n      png_error(png_ptr, \"Call to NULL read function\");\n}\n",
      "line_start": 30,
      "line_end": 40,
      "execution_count": 6006,
      "covered_regions": 7,
      "total_regions": 13,
      "coverage_percent": 53.85,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_zTXt",
      "clean_name": "png_handle_zTXt",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_zTXt_SUPPORTED\n/* Note: this does not correctly handle chunks that are > 64K under DOS */\nstatic png_handle_result_code /* PRIVATE */\npng_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_const_charp errmsg = NULL;\n   png_bytep       buffer;\n   png_uint_32     keyword_length;\n\n   png_debug(1, \"in png_handle_zTXt\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"no space in chunk cache\");\n         return handled_error;\n      }\n   }\n#endif\n\n   /* Note, \"length\" is sufficient here; we won't be adding\n    * a null terminator later.  The limit check in png_handle_chunk should be\n    * sufficient.\n    */\n   buffer = png_read_buffer(png_ptr, length);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* TODO: also check that the keyword contents match the spec! */\n   for (keyword_length = 0;\n      keyword_length < length && buffer[keyword_length] != 0;\n      ++keyword_length)\n      /* Empty loop to find end of name */ ;\n\n   if (keyword_length > 79 || keyword_length < 1)\n      errmsg = \"bad keyword\";\n\n   /* zTXt must have some LZ data after the keyword, although it may expand to\n    * zero bytes; we need a '\\0' at the end of the keyword, the compression type\n    * then the LZ data:\n    */\n   else if (keyword_length + 3 > length)\n      errmsg = \"truncated\";\n\n   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)\n      errmsg = \"unknown compression type\";\n\n   else\n   {\n      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;\n\n      /* TODO: at present png_decompress_chunk imposes a single application\n       * level memory limit, this should be split to different values for iCCP\n       * and text chunks.\n       */\n      if (png_decompress_chunk(png_ptr, length, keyword_length+2,\n          &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)\n      {\n         png_text text;\n\n         if (png_ptr->read_buffer == NULL)\n           errmsg=\"Read failure in png_handle_zTXt\";\n         else\n         {\n            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk\n             * except for the extra compression type byte and the fact that\n             * it isn't necessarily '\\0' terminated.\n             */\n            buffer = png_ptr->read_buffer;\n            buffer[uncompressed_length+(keyword_length+2)] = 0;\n\n            text.compression = PNG_TEXT_COMPRESSION_zTXt;\n            text.key = (png_charp)buffer;\n            text.text = (png_charp)(buffer + keyword_length+2);\n            text.text_length = uncompressed_length;\n            text.itxt_length = 0;\n            text.lang = NULL;\n            text.lang_key = NULL;\n\n            if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n               return handled_ok;\n\n            errmsg = \"out of memory\";\n         }\n      }\n\n      else\n         errmsg = png_ptr->zstream.msg;\n   }\n\n   png_chunk_benign_error(png_ptr, errmsg);\n   return handled_error;\n}\n",
      "line_start": 2458,
      "line_end": 2567,
      "execution_count": 1,
      "covered_regions": 64,
      "total_regions": 118,
      "coverage_percent": 54.24,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "_Z14user_read_dataP14png_struct_defPhm",
      "clean_name": "user_read_data(png_struct_def*, unsigned char*, unsigned long)",
      "source_file": "/src/libpng/contrib/oss-fuzz/libpng_read_fuzzer.cc",
      "source_code": "    delete buf_state;\n  }\n};\n\nvoid user_read_data(png_structp png_ptr, png_bytep data, size_t length) {\n  BufState* buf_state = static_cast<BufState*>(png_get_io_ptr(png_ptr));\n  if (length > buf_state->bytes_left) {\n    png_error(png_ptr, \"read error\");\n  }\n  memcpy(data, buf_state->data, length);\n  buf_state->bytes_left -= length;\n  buf_state->data += length;\n}\n",
      "line_start": 69,
      "line_end": 77,
      "execution_count": 3097,
      "covered_regions": 6,
      "total_regions": 11,
      "coverage_percent": 54.55,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_benign_errors",
      "clean_name": "png_set_benign_errors",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#endif /* ?SET_USER_LIMITS */\n\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\nvoid PNGAPI\npng_set_benign_errors(png_structrp png_ptr, int allowed)\n{\n   png_debug(1, \"in png_set_benign_errors\");\n\n   /* If allowed is 1, png_benign_error() is treated as a warning.\n    *\n    * If allowed is 0, png_benign_error() is treated as an error (which\n    * is the default behavior if png_set_benign_errors() is not called).\n    */\n\n   if (allowed != 0)\n      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN |\n         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN;\n\n   else\n      png_ptr->flags &= ~(PNG_FLAG_BENIGN_ERRORS_WARN |\n         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN);\n}\n",
      "line_start": 1854,
      "line_end": 1872,
      "execution_count": 179,
      "covered_regions": 12,
      "total_regions": 22,
      "coverage_percent": 54.55,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_end",
      "clean_name": "png_read_end",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "/* Read the end of the PNG file.  Will not read past the end of the\n * file, will verify the end is accurate, and will read any comments\n * or time information at the end of the file, if info is not NULL.\n */\nvoid PNGAPI\npng_read_end(png_structrp png_ptr, png_inforp info_ptr)\n{\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   int keep;\n#endif\n\n   png_debug(1, \"in png_read_end\");\n\n   if (png_ptr == NULL)\n      return;\n\n   /* If png_read_end is called in the middle of reading the rows there may\n    * still be pending IDAT data and an owned zstream.  Deal with this here.\n    */\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)\n#endif\n      png_read_finish_IDAT(png_ptr);\n\n#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED\n   /* Report invalid palette index; added at libng-1.5.10 */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n       png_ptr->num_palette_max >= png_ptr->num_palette)\n      png_benign_error(png_ptr, \"Read palette index exceeding num_palette\");\n#endif\n\n   do\n   {\n      png_uint_32 length = png_read_chunk_header(png_ptr);\n      png_uint_32 chunk_name = png_ptr->chunk_name;\n\n      if (chunk_name != png_IDAT)\n      {\n         /* These flags must be set consistently for all non-IDAT chunks,\n          * including the unknown chunks.\n          */\n         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT | PNG_AFTER_IDAT;\n      }\n\n      if (chunk_name == png_IEND)\n         png_handle_chunk(png_ptr, info_ptr, length);\n\n      else if (chunk_name == png_IHDR)\n         png_handle_chunk(png_ptr, info_ptr, length);\n\n      else if (info_ptr == NULL)\n         png_crc_finish(png_ptr, length);\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\n      {\n         if (chunk_name == png_IDAT)\n         {\n            if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))\n                || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)\n               png_benign_error(png_ptr, \".Too many IDATs found\");\n         }\n         png_handle_unknown(png_ptr, info_ptr, length, keep);\n         if (chunk_name == png_PLTE)\n            png_ptr->mode |= PNG_HAVE_PLTE;\n      }\n#endif\n\n      else if (chunk_name == png_IDAT)\n      {\n         /* Zero length IDATs are legal after the last IDAT has been\n          * read, but not after other chunks have been read.  1.6 does not\n          * always read all the deflate data; specifically it cannot be relied\n          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT\n          * chunks which are longer than zero as well:\n          */\n         if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))\n             || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)\n            png_benign_error(png_ptr, \"..Too many IDATs found\");\n\n         png_crc_finish(png_ptr, length);\n      }\n\n      else\n         png_handle_chunk(png_ptr, info_ptr, length);\n   } while ((png_ptr->mode & PNG_HAVE_IEND) == 0);\n}\n",
      "line_start": 672,
      "line_end": 754,
      "execution_count": 179,
      "covered_regions": 118,
      "total_regions": 216,
      "coverage_percent": 54.63,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_cHRM",
      "clean_name": "png_handle_cHRM",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   *error = 1;\n   return 0; /* Safe */\n}\n\nstatic png_handle_result_code /* PRIVATE */\npng_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   int error = 0;\n   png_xy xy;\n   png_byte buf[32];\n\n   png_debug(1, \"in png_handle_cHRM\");\n\n   png_crc_read(png_ptr, buf, 32);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   xy.whitex = png_get_int_32_checked(buf +  0, &error);\n   xy.whitey = png_get_int_32_checked(buf +  4, &error);\n   xy.redx   = png_get_int_32_checked(buf +  8, &error);\n   xy.redy   = png_get_int_32_checked(buf + 12, &error);\n   xy.greenx = png_get_int_32_checked(buf + 16, &error);\n   xy.greeny = png_get_int_32_checked(buf + 20, &error);\n   xy.bluex  = png_get_int_32_checked(buf + 24, &error);\n   xy.bluey  = png_get_int_32_checked(buf + 28, &error);\n\n   if (error)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   /* png_set_cHRM may complain about some of the values but this doesn't matter\n    * because it was a cHRM and it did have vaguely (if, perhaps, ridiculous)\n    * values.  Ridiculousity will be checked if the values are used later.\n    */\n   png_set_cHRM_fixed(png_ptr, info_ptr, xy.whitex, xy.whitey, xy.redx, xy.redy,\n         xy.greenx, xy.greeny, xy.bluex, xy.bluey);\n\n   /* We only use 'chromaticities' for RGB to gray */\n#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n      /* There is no need to check sRGB here, cICP is NYI and iCCP is not\n       * supported so just check mDCV.\n       */\n      if (!png_has_chunk(png_ptr, mDCV))\n      {\n         png_ptr->chromaticities = xy;\n      }\n#  endif /* READ_RGB_TO_GRAY */\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1239,
      "line_end": 1288,
      "execution_count": 108,
      "covered_regions": 23,
      "total_regions": 42,
      "coverage_percent": 54.76,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_read_transform_info",
      "clean_name": "png_read_transform_info",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Modify the info structure to reflect the transformations.  The\n * info should be updated so a PNG file could be written with it,\n * assuming the transformations result in valid PNG data.\n */\nvoid /* PRIVATE */\npng_read_transform_info(png_structrp png_ptr, png_inforp info_ptr)\n{\n   png_debug(1, \"in png_read_transform_info\");\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         /* This check must match what actually happens in\n          * png_do_expand_palette; if it ever checks the tRNS chunk to see if\n          * it is all opaque we must do the same (at present it does not.)\n          */\n         if (png_ptr->num_trans > 0)\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n         else\n            info_ptr->color_type = PNG_COLOR_TYPE_RGB;\n\n         info_ptr->bit_depth = 8;\n         info_ptr->num_trans = 0;\n\n         if (png_ptr->palette == NULL)\n            png_error (png_ptr, \"Palette is NULL in indexed image\");\n      }\n      else\n      {\n         if (png_ptr->num_trans != 0)\n         {\n            if ((png_ptr->transformations & PNG_EXPAND_tRNS) != 0)\n               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\n         }\n         if (info_ptr->bit_depth < 8)\n            info_ptr->bit_depth = 8;\n\n         info_ptr->num_trans = 0;\n      }\n   }\n#endif\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\\\n   defined(PNG_READ_ALPHA_MODE_SUPPORTED)\n   /* The following is almost certainly wrong unless the background value is in\n    * the screen space!\n    */\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      info_ptr->background = png_ptr->background;\n#endif\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),\n    * however it seems that the code in png_init_read_transformations, which has\n    * been called before this from png_read_update_info->png_read_start_row\n    * sometimes does the gamma transform and cancels the flag.\n    *\n    * TODO: this is confusing.  It only changes the result of png_get_gAMA and,\n    * yes, it does return the value that the transformed data effectively has\n    * but does any app really understand this?\n    */\n   info_ptr->gamma = png_ptr->file_gamma;\n#endif\n\n   if (info_ptr->bit_depth == 16)\n   {\n#  ifdef PNG_READ_16BIT_SUPPORTED\n#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n         if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)\n            info_ptr->bit_depth = 8;\n#     endif\n\n#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n         if ((png_ptr->transformations & PNG_16_TO_8) != 0)\n            info_ptr->bit_depth = 8;\n#     endif\n\n#  else\n      /* No 16-bit support: force chopping 16-bit input down to 8, in this case\n       * the app program can chose if both APIs are available by setting the\n       * correct scaling to use.\n       */\n#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n         /* For compatibility with previous versions use the strip method by\n          * default.  This code works because if PNG_SCALE_16_TO_8 is already\n          * set the code below will do that in preference to the chop.\n          */\n         png_ptr->transformations |= PNG_16_TO_8;\n         info_ptr->bit_depth = 8;\n#     else\n\n#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n            png_ptr->transformations |= PNG_SCALE_16_TO_8;\n            info_ptr->bit_depth = 8;\n#        else\n\n            CONFIGURATION ERROR: you must enable at least one 16 to 8 method\n#        endif\n#    endif\n#endif /* !READ_16BIT */\n   }\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n      info_ptr->color_type = (png_byte)(info_ptr->color_type |\n         PNG_COLOR_MASK_COLOR);\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n      info_ptr->color_type = (png_byte)(info_ptr->color_type &\n         ~PNG_COLOR_MASK_COLOR);\n#endif\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\n   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)\n   {\n      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||\n          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&\n          png_ptr->palette_lookup != 0 && info_ptr->bit_depth == 8)\n      {\n         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&\n       info_ptr->bit_depth == 8 &&\n       info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      info_ptr->bit_depth = 16;\n   }\n#endif\n\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0 &&\n       (info_ptr->bit_depth < 8))\n      info_ptr->bit_depth = 8;\n#endif\n\n   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      info_ptr->channels = 1;\n\n   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      info_ptr->channels = 3;\n\n   else\n      info_ptr->channels = 1;\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0)\n   {\n      info_ptr->color_type = (png_byte)(info_ptr->color_type &\n         ~PNG_COLOR_MASK_ALPHA);\n      info_ptr->num_trans = 0;\n   }\n#endif\n\n   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      info_ptr->channels++;\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */\n   if ((png_ptr->transformations & PNG_FILLER) != 0 &&\n       (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||\n       info_ptr->color_type == PNG_COLOR_TYPE_GRAY))\n   {\n      info_ptr->channels++;\n      /* If adding a true alpha channel not just filler */\n      if ((png_ptr->transformations & PNG_ADD_ALPHA) != 0)\n         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;\n   }\n#endif\n\n#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \\\ndefined(PNG_READ_USER_TRANSFORM_SUPPORTED)\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n   {\n      if (png_ptr->user_transform_depth != 0)\n         info_ptr->bit_depth = png_ptr->user_transform_depth;\n\n      if (png_ptr->user_transform_channels != 0)\n         info_ptr->channels = png_ptr->user_transform_channels;\n   }\n#endif\n\n   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *\n       info_ptr->bit_depth);\n\n   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);\n\n   /* Adding in 1.5.4: cache the above value in png_struct so that we can later\n    * check in png_rowbytes that the user buffer won't get overwritten.  Note\n    * that the field is not always set - if png_read_update_info isn't called\n    * the application has to either not do any transforms or get the calculation\n    * right itself.\n    */\n   png_ptr->info_rowbytes = info_ptr->rowbytes;\n\n#ifndef PNG_READ_EXPAND_SUPPORTED\n   if (png_ptr != NULL)\n      return;\n#endif\n}\n",
      "line_start": 2058,
      "line_end": 2261,
      "execution_count": 358,
      "covered_regions": 139,
      "total_regions": 252,
      "coverage_percent": 55.16,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_PLTE",
      "clean_name": "png_set_PLTE",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_pHYs;\n}\n#endif\n\nvoid PNGAPI\npng_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n\n   png_uint_32 max_palette_length;\n\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n\n   if (num_palette < 0 || num_palette > (int) max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n\n         return;\n      }\n   }\n\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n\n   /* It may not actually be necessary to set png_ptr->palette here;\n    * we do it for backward compatibility with the way the png_handle_tRNS\n    * function used to do the allocation.\n    *\n    * 1.6.0: the above statement appears to be incorrect; something has to set\n    * the palette inside png_struct on read.\n    */\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n\n   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead\n    * of num_palette entries, in case of an invalid PNG file or incorrect\n    * call to png_set_PLTE() with too-large sample values.\n    */\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, (unsigned int)num_palette *\n          (sizeof (png_color)));\n\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}\n",
      "line_start": 740,
      "line_end": 802,
      "execution_count": 132,
      "covered_regions": 52,
      "total_regions": 94,
      "coverage_percent": 55.32,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_get_io_ptr",
      "clean_name": "png_get_io_ptr",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* This function returns a pointer to the io_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy() or png_read_destroy() are called.\n */\npng_voidp PNGAPI\npng_get_io_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return png_ptr->io_ptr;\n}\n",
      "line_start": 687,
      "line_end": 694,
      "execution_count": 3097,
      "covered_regions": 5,
      "total_regions": 9,
      "coverage_percent": 55.56,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_error_fn",
      "clean_name": "png_set_error_fn",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * of handling errors and warnings.  Note that the error function MUST NOT\n * return to the calling routine or serious problems will occur.  The return\n * method used in the default routine calls longjmp(png_ptr->jmp_buf_ptr, 1)\n */\nvoid PNGAPI\npng_set_error_fn(png_structrp png_ptr, png_voidp error_ptr,\n    png_error_ptr error_fn, png_error_ptr warning_fn)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->error_ptr = error_ptr;\n   png_ptr->error_fn = error_fn;\n#ifdef PNG_WARNINGS_SUPPORTED\n   png_ptr->warning_fn = warning_fn;\n#else\n   PNG_UNUSED(warning_fn)\n#endif\n}\n",
      "line_start": 714,
      "line_end": 728,
      "execution_count": 358,
      "covered_regions": 5,
      "total_regions": 9,
      "coverage_percent": 55.56,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_tIME",
      "clean_name": "png_handle_tIME",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_sCAL NULL\n#endif\n\n#ifdef PNG_READ_tIME_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[7];\n   png_time mod_time;\n\n   png_debug(1, \"in png_handle_tIME\");\n\n   /* TODO: what is this doing here?  It should be happened in pngread.c and\n    * pngpread.c, although it could be moved to png_handle_chunk below and\n    * thereby avoid some code duplication.\n    */\n   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      png_ptr->mode |= PNG_AFTER_IDAT;\n\n   png_crc_read(png_ptr, buf, 7);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   mod_time.second = buf[6];\n   mod_time.minute = buf[5];\n   mod_time.hour = buf[4];\n   mod_time.day = buf[3];\n   mod_time.month = buf[2];\n   mod_time.year = png_get_uint_16(buf);\n\n   png_set_tIME(png_ptr, info_ptr, &mod_time);\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 2349,
      "line_end": 2379,
      "execution_count": 2,
      "covered_regions": 20,
      "total_regions": 36,
      "coverage_percent": 55.56,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_image_finish_read",
      "clean_name": "png_image_finish_read",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "      return 1;\n   }\n}\n\nint PNGAPI\npng_image_finish_read(png_imagep image, png_const_colorp background,\n    void *buffer, png_int_32 row_stride, void *colormap)\n{\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\n   {\n      /* Check for row_stride overflow.  This check is not performed on the\n       * original PNG format because it may not occur in the output PNG format\n       * and libpng deals with the issues of reading the original.\n       */\n      unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);\n\n      /* The following checks just the 'row_stride' calculation to ensure it\n       * fits in a signed 32-bit value.  Because channels/components can be\n       * either 1 or 2 bytes in size the length of a row can still overflow 32\n       * bits; this is just to verify that the 'row_stride' argument can be\n       * represented.\n       */\n      if (image->width <= 0x7fffffffU/channels) /* no overflow */\n      {\n         png_uint_32 check;\n         png_uint_32 png_row_stride = image->width * channels;\n\n         if (row_stride == 0)\n            row_stride = (png_int_32)/*SAFE*/png_row_stride;\n\n         if (row_stride < 0)\n            check = (png_uint_32)(-row_stride);\n\n         else\n            check = (png_uint_32)row_stride;\n\n         /* This verifies 'check', the absolute value of the actual stride\n          * passed in and detects overflow in the application calculation (i.e.\n          * if the app did actually pass in a non-zero 'row_stride'.\n          */\n         if (image->opaque != NULL && buffer != NULL && check >= png_row_stride)\n         {\n            /* Now check for overflow of the image buffer calculation; this\n             * limits the whole image size to 32 bits for API compatibility with\n             * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.\n             *\n             * The PNG_IMAGE_BUFFER_SIZE macro is:\n             *\n             *    (PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)*height*(row_stride))\n             *\n             * And the component size is always 1 or 2, so make sure that the\n             * number of *bytes* that the application is saying are available\n             * does actually fit into a 32-bit number.\n             *\n             * NOTE: this will be changed in 1.7 because PNG_IMAGE_BUFFER_SIZE\n             * will be changed to use png_alloc_size_t; bigger images can be\n             * accommodated on 64-bit systems.\n             */\n            if (image->height <=\n                0xffffffffU/PNG_IMAGE_PIXEL_COMPONENT_SIZE(image->format)/check)\n            {\n               if ((image->format & PNG_FORMAT_FLAG_COLORMAP) == 0 ||\n                  (image->colormap_entries > 0 && colormap != NULL))\n               {\n                  int result;\n                  png_image_read_control display;\n\n                  memset(&display, 0, (sizeof display));\n                  display.image = image;\n                  display.buffer = buffer;\n                  display.row_stride = row_stride;\n                  display.colormap = colormap;\n                  display.background = background;\n                  display.local_row = NULL;\n\n                  /* Choose the correct 'end' routine; for the color-map case\n                   * all the setup has already been done.\n                   */\n                  if ((image->format & PNG_FORMAT_FLAG_COLORMAP) != 0)\n                     result =\n                         png_safe_execute(image,\n                             png_image_read_colormap, &display) &&\n                             png_safe_execute(image,\n                             png_image_read_colormapped, &display);\n\n                  else\n                     result =\n                        png_safe_execute(image,\n                            png_image_read_direct, &display);\n\n                  png_image_free(image);\n                  return result;\n               }\n\n               else\n                  return png_image_error(image,\n                      \"png_image_finish_read[color-map]: no color-map\");\n            }\n\n            else\n               return png_image_error(image,\n                   \"png_image_finish_read: image too large\");\n         }\n\n         else\n            return png_image_error(image,\n                \"png_image_finish_read: invalid argument\");\n      }\n\n      else\n         return png_image_error(image,\n             \"png_image_finish_read: row_stride too large\");\n   }\n\n   else if (image != NULL)\n      return png_image_error(image,\n          \"png_image_finish_read: damaged PNG_IMAGE_VERSION\");\n\n   return 0;\n}\n",
      "line_start": 4055,
      "line_end": 4170,
      "execution_count": 179,
      "covered_regions": 78,
      "total_regions": 140,
      "coverage_percent": 55.71,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_gAMA",
      "clean_name": "png_handle_gAMA",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   PNG_UNUSED(info_ptr)\n}\n\n#ifdef PNG_READ_gAMA_SUPPORTED\nstatic png_handle_result_code\npng_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_uint_32 ugamma;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_gAMA\");\n\n   png_crc_read(png_ptr, buf, 4);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   ugamma = png_get_uint_32(buf);\n\n   if (ugamma > PNG_UINT_31_MAX)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   png_set_gAMA_fixed(png_ptr, info_ptr, (png_fixed_point)/*SAFE*/ugamma);\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  gAMA is\n       * at the end of the chain so simply check for an unset value.\n       */\n      if (png_ptr->chunk_gamma == 0)\n         png_ptr->chunk_gamma = (png_fixed_point)/*SAFE*/ugamma;\n#endif /*READ_GAMMA*/\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1114,
      "line_end": 1147,
      "execution_count": 172,
      "covered_regions": 25,
      "total_regions": 44,
      "coverage_percent": 56.82,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_read_direct_scaled",
      "clean_name": "png_image_read_direct_scaled",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   }\n}\n\n/* Row reading for interlaced 16-to-8 bit depth conversion with local buffer. */\nstatic int\npng_image_read_direct_scaled(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_bytep local_row = png_voidcast(png_bytep, display->local_row);\n   png_bytep first_row = png_voidcast(png_bytep, display->first_row);\n   ptrdiff_t row_bytes = display->row_bytes;\n   int passes;\n\n   /* Handle interlacing. */\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   /* Read each pass using local_row as intermediate buffer. */\n   while (--passes >= 0)\n   {\n      png_uint_32 y = image->height;\n      png_bytep output_row = first_row;\n\n      for (; y > 0; --y)\n      {\n         /* Read into local_row (gets transformed 8-bit data). */\n         png_read_row(png_ptr, local_row, NULL);\n\n         /* Copy from local_row to user buffer. */\n         memcpy(output_row, local_row, (size_t)row_bytes);\n         output_row += row_bytes;\n      }\n   }\n\n   return 1;\n}\n",
      "line_start": 3133,
      "line_end": 3178,
      "execution_count": 5,
      "covered_regions": 24,
      "total_regions": 42,
      "coverage_percent": 57.14,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_cICP",
      "clean_name": "png_handle_cICP",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_bKGD NULL\n#endif\n\n#ifdef PNG_READ_cICP_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_cICP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_cICP\");\n\n   png_crc_read(png_ptr, buf, 4);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   png_set_cICP(png_ptr, info_ptr, buf[0], buf[1],  buf[2], buf[3]);\n\n   /* We only use 'chromaticities' for RGB to gray */\n#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n      if (!png_has_chunk(png_ptr, mDCV))\n      {\n         /* TODO: png_ptr->chromaticities = chromaticities; */\n      }\n#  endif /* READ_RGB_TO_GRAY */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  cICP is\n       * at the head so simply set the gamma if it can be determined.  If not\n       * chunk_gamma remains unchanged; sRGB and gAMA handling check it for\n       * being zero.\n       */\n      /* TODO: set png_struct::chunk_gamma when possible */\n#endif /*READ_GAMMA*/\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1898,
      "line_end": 1931,
      "execution_count": 4,
      "covered_regions": 20,
      "total_regions": 35,
      "coverage_percent": 57.14,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_resolve_file_gamma",
      "clean_name": "png_resolve_file_gamma",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif /* READ_EXPAND && READ_BACKGROUND */\n}\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\npng_fixed_point /* PRIVATE */\npng_resolve_file_gamma(png_const_structrp png_ptr)\n{\n   png_fixed_point file_gamma;\n\n   /* The file gamma is determined by these precedence rules, in this order\n    * (i.e. use the first value found):\n    *\n    *    png_set_gamma; png_struct::file_gammma if not zero, then:\n    *    png_struct::chunk_gamma if not 0 (determined the PNGv3 rules), then:\n    *    png_set_gamma; 1/png_struct::screen_gamma if not zero\n    *\n    *    0 (i.e. do no gamma handling)\n    */\n   file_gamma = png_ptr->file_gamma;\n   if (file_gamma != 0)\n      return file_gamma;\n\n   file_gamma = png_ptr->chunk_gamma;\n   if (file_gamma != 0)\n      return file_gamma;\n\n   file_gamma = png_ptr->default_gamma;\n   if (file_gamma != 0)\n      return file_gamma;\n\n   /* If png_reciprocal oveflows it returns 0 which indicates to the caller that\n    * there is no usable file gamma.  (The checks added to png_set_gamma and\n    * png_set_alpha_mode should prevent a screen_gamma which would overflow.)\n    */\n   if (png_ptr->screen_gamma != 0)\n      file_gamma = png_reciprocal(png_ptr->screen_gamma);\n\n   return file_gamma;\n}\n",
      "line_start": 1341,
      "line_end": 1375,
      "execution_count": 358,
      "covered_regions": 15,
      "total_regions": 26,
      "coverage_percent": 57.69,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_image_begin_read_from_memory",
      "clean_name": "png_image_begin_read_from_memory",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n      png_error(png_ptr, \"invalid memory read\");\n   }\n}\n\nint PNGAPI png_image_begin_read_from_memory(png_imagep image,\n    png_const_voidp memory, size_t size)\n{\n   if (image != NULL && image->version == PNG_IMAGE_VERSION)\n   {\n      if (memory != NULL && size > 0)\n      {\n         if (png_image_read_init(image) != 0)\n         {\n            /* Now set the IO functions to read from the memory buffer and\n             * store it into io_ptr.  Again do this in-place to avoid calling a\n             * libpng function that requires error handling.\n             */\n            image->opaque->memory = png_voidcast(png_const_bytep, memory);\n            image->opaque->size = size;\n            image->opaque->png_ptr->io_ptr = image;\n            image->opaque->png_ptr->read_data_fn = png_image_memory_read;\n\n            return png_safe_execute(image, png_image_read_header, image);\n         }\n      }\n\n      else\n         return png_image_error(image,\n             \"png_image_begin_read_from_memory: invalid argument\");\n   }\n\n   else if (image != NULL)\n      return png_image_error(image,\n          \"png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION\");\n\n   return 0;\n}\n",
      "line_start": 1434,
      "line_end": 1467,
      "execution_count": 179,
      "covered_regions": 26,
      "total_regions": 45,
      "coverage_percent": 57.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_reciprocal",
      "clean_name": "png_reciprocal",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return 0;\n}\n\n/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */\npng_fixed_point\npng_reciprocal(png_fixed_point a)\n{\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   double r = floor(1E10/a+.5);\n\n   if (r <= 2147483647. && r >= -2147483648.)\n      return (png_fixed_point)r;\n#else\n   png_fixed_point res;\n\n   if (png_muldiv(&res, 100000, 100000, a) != 0)\n      return res;\n#endif\n\n   return 0; /* error/overflow */\n}\n",
      "line_start": 2882,
      "line_end": 2898,
      "execution_count": 511,
      "covered_regions": 7,
      "total_regions": 12,
      "coverage_percent": 58.33,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_eXIf",
      "clean_name": "png_handle_eXIf",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_mDCV NULL\n#endif\n\n#ifdef PNG_READ_eXIf_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_bytep buffer = NULL;\n\n   png_debug(1, \"in png_handle_eXIf\");\n\n   buffer = png_read_buffer(png_ptr, length);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* PNGv3: the code used to check the byte order mark at the start for MM or\n    * II, however PNGv3 states that the the first 4 bytes should be checked.\n    * The caller ensures that there are four bytes available.\n    */\n   {\n      png_uint_32 header = png_get_uint_32(buffer);\n\n      /* These numbers are copied from the PNGv3 spec: */\n      if (header != 0x49492A00 && header != 0x4D4D002A)\n      {\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return handled_error;\n      }\n   }\n\n   png_set_eXIf_1(png_ptr, info_ptr, length, buffer);\n   return handled_ok;\n}\n",
      "line_start": 2014,
      "line_end": 2052,
      "execution_count": 1,
      "covered_regions": 28,
      "total_regions": 48,
      "coverage_percent": 58.33,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_text_2",
      "clean_name": "png_set_text_2",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   if (ret != 0)\n      png_error(png_ptr, \"Insufficient memory to store text\");\n}\n\nint /* PRIVATE */\npng_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int i;\n\n   png_debug1(1, \"in text storage function, chunk typeid = 0x%lx\",\n      png_ptr == NULL ? 0xabadca11UL : (unsigned long)png_ptr->chunk_name);\n\n   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)\n      return 0;\n\n   /* Make sure we have enough space in the \"text\" array in info_struct\n    * to hold all of the incoming text_ptr objects.  This compare can't overflow\n    * because max_text >= num_text (anyway, subtract of two positive integers\n    * can't overflow in any case.)\n    */\n   if (num_text > info_ptr->max_text - info_ptr->num_text)\n   {\n      int old_num_text = info_ptr->num_text;\n      int max_text;\n      png_textp new_text = NULL;\n\n      /* Calculate an appropriate max_text, checking for overflow. */\n      max_text = old_num_text;\n      if (num_text <= INT_MAX - max_text)\n      {\n         max_text += num_text;\n\n         /* Round up to a multiple of 8 */\n         if (max_text < INT_MAX-8)\n            max_text = (max_text + 8) & ~0x7;\n\n         else\n            max_text = INT_MAX;\n\n         /* Now allocate a new array and copy the old members in; this does all\n          * the overflow checks.\n          */\n         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,\n             info_ptr->text, old_num_text, max_text-old_num_text,\n             sizeof *new_text));\n      }\n\n      if (new_text == NULL)\n      {\n         png_chunk_report(png_ptr, \"too many text chunks\",\n             PNG_CHUNK_WRITE_ERROR);\n\n         return 1;\n      }\n\n      png_free(png_ptr, info_ptr->text);\n\n      info_ptr->text = new_text;\n      info_ptr->free_me |= PNG_FREE_TEXT;\n      info_ptr->max_text = max_text;\n      /* num_text is adjusted below as the entries are copied in */\n\n      png_debug1(3, \"allocated %d entries for info_ptr->text\", max_text);\n   }\n\n   for (i = 0; i < num_text; i++)\n   {\n      size_t text_length, key_len;\n      size_t lang_len, lang_key_len;\n      png_textp textp = &(info_ptr->text[info_ptr->num_text]);\n\n      if (text_ptr[i].key == NULL)\n          continue;\n\n      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||\n          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)\n      {\n         png_chunk_report(png_ptr, \"text compression mode is out of range\",\n             PNG_CHUNK_WRITE_ERROR);\n         continue;\n      }\n\n      key_len = strlen(text_ptr[i].key);\n\n      if (text_ptr[i].compression <= 0)\n      {\n         lang_len = 0;\n         lang_key_len = 0;\n      }\n\n      else\n#  ifdef PNG_iTXt_SUPPORTED\n      {\n         /* Set iTXt data */\n\n         if (text_ptr[i].lang != NULL)\n            lang_len = strlen(text_ptr[i].lang);\n\n         else\n            lang_len = 0;\n\n         if (text_ptr[i].lang_key != NULL)\n            lang_key_len = strlen(text_ptr[i].lang_key);\n\n         else\n            lang_key_len = 0;\n      }\n#  else /* iTXt */\n      {\n         png_chunk_report(png_ptr, \"iTXt chunk not supported\",\n             PNG_CHUNK_WRITE_ERROR);\n         continue;\n      }\n#  endif\n\n      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\\0')\n      {\n         text_length = 0;\n#  ifdef PNG_iTXt_SUPPORTED\n         if (text_ptr[i].compression > 0)\n            textp->compression = PNG_ITXT_COMPRESSION_NONE;\n\n         else\n#  endif\n            textp->compression = PNG_TEXT_COMPRESSION_NONE;\n      }\n\n      else\n      {\n         text_length = strlen(text_ptr[i].text);\n         textp->compression = text_ptr[i].compression;\n      }\n\n      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,\n          key_len + text_length + lang_len + lang_key_len + 4));\n\n      if (textp->key == NULL)\n      {\n         png_chunk_report(png_ptr, \"text chunk: out of memory\",\n             PNG_CHUNK_WRITE_ERROR);\n\n         return 1;\n      }\n\n      png_debug2(2, \"Allocated %lu bytes at %p in png_set_text\",\n          (unsigned long)(png_uint_32)\n          (key_len + lang_len + lang_key_len + text_length + 4),\n          textp->key);\n\n      memcpy(textp->key, text_ptr[i].key, key_len);\n      *(textp->key + key_len) = '\\0';\n\n      if (text_ptr[i].compression > 0)\n      {\n         textp->lang = textp->key + key_len + 1;\n         memcpy(textp->lang, text_ptr[i].lang, lang_len);\n         *(textp->lang + lang_len) = '\\0';\n         textp->lang_key = textp->lang + lang_len + 1;\n         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);\n         *(textp->lang_key + lang_key_len) = '\\0';\n         textp->text = textp->lang_key + lang_key_len + 1;\n      }\n\n      else\n      {\n         textp->lang=NULL;\n         textp->lang_key=NULL;\n         textp->text = textp->key + key_len + 1;\n      }\n\n      if (text_length != 0)\n         memcpy(textp->text, text_ptr[i].text, text_length);\n\n      *(textp->text + text_length) = '\\0';\n\n#  ifdef PNG_iTXt_SUPPORTED\n      if (textp->compression > 0)\n      {\n         textp->text_length = 0;\n         textp->itxt_length = text_length;\n      }\n\n      else\n#  endif\n      {\n         textp->text_length = text_length;\n         textp->itxt_length = 0;\n      }\n\n      info_ptr->num_text++;\n      png_debug1(3, \"transferred text chunk %d\", info_ptr->num_text);\n   }\n\n   return 0;\n}\n",
      "line_start": 924,
      "line_end": 1115,
      "execution_count": 458,
      "covered_regions": 113,
      "total_regions": 191,
      "coverage_percent": 59.16,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_handle_chunk",
      "clean_name": "png_handle_chunk",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      default: return PNG_INDEX_unknown;\n   }\n}\n\npng_handle_result_code /*PRIVATE*/\npng_handle_chunk(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   /* CSE: these things don't change, these autos are just to save typing and\n    * make the code more clear.\n    */\n   const png_uint_32 chunk_name = png_ptr->chunk_name;\n   const png_index chunk_index = png_chunk_index_from_name(chunk_name);\n\n   png_handle_result_code handled = handled_error;\n   png_const_charp errmsg = NULL;\n\n   /* Is this a known chunk?  If not there are no checks performed here;\n    * png_handle_unknown does the correct checks.  This means that the values\n    * for known but unsupported chunks in the above table are not used here\n    * however the chunks_seen fields in png_struct are still set.\n    */\n   if (chunk_index == PNG_INDEX_unknown ||\n       read_chunks[chunk_index].handler == NULL)\n   {\n      handled = png_handle_unknown(\n            png_ptr, info_ptr, length, PNG_HANDLE_CHUNK_AS_DEFAULT);\n   }\n\n   /* First check the position.   The first check is historical; the stream must\n    * start with IHDR and anything else causes libpng to give up immediately.\n    */\n   else if (chunk_index != PNG_INDEX_IHDR &&\n            (png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\"); /* NORETURN */\n\n   /* Before all the pos_before chunks, after all the pos_after chunks. */\n   else if (((png_ptr->mode & read_chunks[chunk_index].pos_before) != 0) ||\n            ((png_ptr->mode & read_chunks[chunk_index].pos_after) !=\n             read_chunks[chunk_index].pos_after))\n   {\n      errmsg = \"out of place\";\n   }\n\n   /* Now check for duplicates: duplicated critical chunks also produce a\n    * full error.\n    */\n   else if (read_chunks[chunk_index].multiple == 0 &&\n            png_file_has_chunk(png_ptr, chunk_index))\n   {\n      errmsg = \"duplicate\";\n   }\n\n   else if (length < read_chunks[chunk_index].min_length)\n      errmsg = \"too short\";\n   else\n   {\n      /* NOTE: apart from IHDR the critical chunks (PLTE, IDAT and IEND) are set\n       * up above not to do any length checks.\n       *\n       * The png_chunk_max check ensures that the variable length chunks are\n       * always checked at this point for being within the system allocation\n       * limits.\n       */\n      unsigned max_length = read_chunks[chunk_index].max_length;\n\n      switch (max_length)\n      {\n         case Limit:\n            /* png_read_chunk_header has already png_error'ed chunks with a\n             * length exceeding the 31-bit PNG limit, so just check the memory\n             * limit:\n             */\n            if (length <= png_chunk_max(png_ptr))\n               goto MeetsLimit;\n\n            errmsg = \"length exceeds libpng limit\";\n            break;\n\n         default:\n            if (length <= max_length)\n               goto MeetsLimit;\n\n            errmsg = \"too long\";\n            break;\n\n         case NoCheck:\n         MeetsLimit:\n            handled = read_chunks[chunk_index].handler(\n                  png_ptr, info_ptr, length);\n            break;\n      }\n   }\n\n   /* If there was an error or the chunk was simply skipped it is not counted as\n    * 'seen'.\n    */\n   if (errmsg != NULL)\n   {\n      if (PNG_CHUNK_CRITICAL(chunk_name)) /* stop immediately */\n         png_chunk_error(png_ptr, errmsg);\n      else /* ancillary chunk */\n      {\n         /* The chunk data is skipped: */\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, errmsg);\n      }\n   }\n\n   else if (handled >= handled_saved)\n   {\n      if (chunk_index != PNG_INDEX_unknown)\n         png_file_add_chunk(png_ptr, chunk_index);\n   }\n\n   return handled;\n}\n",
      "line_start": 3118,
      "line_end": 3229,
      "execution_count": 1642,
      "covered_regions": 74,
      "total_regions": 125,
      "coverage_percent": 59.2,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_sCAL_s",
      "clean_name": "png_set_sCAL_s",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sCAL_SUPPORTED\nvoid PNGAPI\npng_set_sCAL_s(png_const_structrp png_ptr, png_inforp info_ptr,\n    int unit, png_const_charp swidth, png_const_charp sheight)\n{\n   size_t lengthw = 0, lengthh = 0;\n\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* Double check the unit (should never get here with an invalid\n    * unit unless this is an API call.)\n    */\n   if (unit != 1 && unit != 2)\n      png_error(png_ptr, \"Invalid sCAL unit\");\n\n   if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||\n       swidth[0] == 45 /* '-' */ || !png_check_fp_string(swidth, lengthw))\n      png_error(png_ptr, \"Invalid sCAL width\");\n\n   if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||\n       sheight[0] == 45 /* '-' */ || !png_check_fp_string(sheight, lengthh))\n      png_error(png_ptr, \"Invalid sCAL height\");\n\n   info_ptr->scal_unit = (png_byte)unit;\n\n   ++lengthw;\n\n   png_debug1(3, \"allocating unit for info (%u bytes)\", (unsigned int)lengthw);\n\n   info_ptr->scal_s_width = png_voidcast(png_charp,\n       png_malloc_warn(png_ptr, lengthw));\n\n   if (info_ptr->scal_s_width == NULL)\n   {\n      png_warning(png_ptr, \"Memory allocation failed while processing sCAL\");\n\n      return;\n   }\n\n   memcpy(info_ptr->scal_s_width, swidth, lengthw);\n\n   ++lengthh;\n\n   png_debug1(3, \"allocating unit for info (%u bytes)\", (unsigned int)lengthh);\n\n   info_ptr->scal_s_height = png_voidcast(png_charp,\n       png_malloc_warn(png_ptr, lengthh));\n\n   if (info_ptr->scal_s_height == NULL)\n   {\n      png_free(png_ptr, info_ptr->scal_s_width);\n      info_ptr->scal_s_width = NULL;\n\n      png_warning(png_ptr, \"Memory allocation failed while processing sCAL\");\n      return;\n   }\n\n   memcpy(info_ptr->scal_s_height, sheight, lengthh);\n\n   info_ptr->free_me |= PNG_FREE_SCAL;\n   info_ptr->valid |= PNG_INFO_sCAL;\n}\n",
      "line_start": 599,
      "line_end": 662,
      "execution_count": 2,
      "covered_regions": 68,
      "total_regions": 114,
      "coverage_percent": 59.65,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_create_png_struct",
      "clean_name": "png_create_png_struct",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Generic function to create a png_struct for either read or write - this\n * contains the common initialization.\n */\nPNG_FUNCTION(png_structp /* PRIVATE */,\npng_create_png_struct,(png_const_charp user_png_ver, png_voidp error_ptr,\n    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,\n    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)\n{\n   png_struct create_struct;\n#  ifdef PNG_SETJMP_SUPPORTED\n      jmp_buf create_jmp_buf;\n#  endif\n\n   /* This temporary stack-allocated structure is used to provide a place to\n    * build enough context to allow the user provided memory allocator (if any)\n    * to be called.\n    */\n   memset(&create_struct, 0, (sizeof create_struct));\n\n#  ifdef PNG_USER_LIMITS_SUPPORTED\n      create_struct.user_width_max = PNG_USER_WIDTH_MAX;\n      create_struct.user_height_max = PNG_USER_HEIGHT_MAX;\n\n#     ifdef PNG_USER_CHUNK_CACHE_MAX\n      create_struct.user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;\n#     endif\n\n#     if PNG_USER_CHUNK_MALLOC_MAX > 0 /* default to compile-time limit */\n      create_struct.user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;\n\n      /* No compile-time limit, so initialize to the system limit: */\n#     elif defined PNG_MAX_MALLOC_64K /* legacy system limit */\n      create_struct.user_chunk_malloc_max = 65536U;\n\n#     else /* modern system limit SIZE_MAX (C99) */\n      create_struct.user_chunk_malloc_max = PNG_SIZE_MAX;\n#     endif\n#  endif\n\n   /* The following two API calls simply set fields in png_struct, so it is safe\n    * to do them now even though error handling is not yet set up.\n    */\n#  ifdef PNG_USER_MEM_SUPPORTED\n      png_set_mem_fn(&create_struct, mem_ptr, malloc_fn, free_fn);\n#  else\n      PNG_UNUSED(mem_ptr)\n      PNG_UNUSED(malloc_fn)\n      PNG_UNUSED(free_fn)\n#  endif\n\n   /* (*error_fn) can return control to the caller after the error_ptr is set,\n    * this will result in a memory leak unless the error_fn does something\n    * extremely sophisticated.  The design lacks merit but is implicit in the\n    * API.\n    */\n   png_set_error_fn(&create_struct, error_ptr, error_fn, warn_fn);\n\n#  ifdef PNG_SETJMP_SUPPORTED\n      if (!setjmp(create_jmp_buf))\n#  endif\n      {\n#  ifdef PNG_SETJMP_SUPPORTED\n         /* Temporarily fake out the longjmp information until we have\n          * successfully completed this function.  This only works if we have\n          * setjmp() support compiled in, but it is safe - this stuff should\n          * never happen.\n          */\n         create_struct.jmp_buf_ptr = &create_jmp_buf;\n         create_struct.jmp_buf_size = 0; /*stack allocation*/\n         create_struct.longjmp_fn = longjmp;\n#  endif\n         /* Call the general version checker (shared with read and write code):\n          */\n         if (png_user_version_check(&create_struct, user_png_ver) != 0)\n         {\n            png_structrp png_ptr = png_voidcast(png_structrp,\n                png_malloc_warn(&create_struct, (sizeof *png_ptr)));\n\n            if (png_ptr != NULL)\n            {\n               /* png_ptr->zstream holds a back-pointer to the png_struct, so\n                * this can only be done now:\n                */\n               create_struct.zstream.zalloc = png_zalloc;\n               create_struct.zstream.zfree = png_zfree;\n               create_struct.zstream.opaque = png_ptr;\n\n#              ifdef PNG_SETJMP_SUPPORTED\n               /* Eliminate the local error handling: */\n               create_struct.jmp_buf_ptr = NULL;\n               create_struct.jmp_buf_size = 0;\n               create_struct.longjmp_fn = 0;\n#              endif\n\n               *png_ptr = create_struct;\n\n               /* This is the successful return point */\n               return png_ptr;\n            }\n         }\n      }\n\n   /* A longjmp because of a bug in the application storage allocator or a\n    * simple failure to allocate the png_struct.\n    */\n   return NULL;\n}\n",
      "line_start": 257,
      "line_end": 360,
      "execution_count": 358,
      "covered_regions": 33,
      "total_regions": 55,
      "coverage_percent": 60.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_build_gamma_table",
      "clean_name": "png_build_gamma_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "#else\n#  define GAMMA_TRANSFORMS 0\n#endif\n\nvoid /* PRIVATE */\npng_build_gamma_table(png_structrp png_ptr, int bit_depth)\n{\n   png_fixed_point file_gamma, screen_gamma;\n   png_fixed_point correction;\n#  if GAMMA_TRANSFORMS\n      png_fixed_point file_to_linear, linear_to_screen;\n#  endif\n\n   png_debug(1, \"in png_build_gamma_table\");\n\n   /* Remove any existing table; this copes with multiple calls to\n    * png_read_update_info. The warning is because building the gamma tables\n    * multiple times is a performance hit - it's harmless but the ability to\n    * call png_read_update_info() multiple times is new in 1.5.6 so it seems\n    * sensible to warn if the app introduces such a hit.\n    */\n   if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)\n   {\n      png_warning(png_ptr, \"gamma table being rebuilt\");\n      png_destroy_gamma_table(png_ptr);\n   }\n\n   /* The following fields are set, finally, in png_init_read_transformations.\n    * If file_gamma is 0 (unset) nothing can be done otherwise if screen_gamma\n    * is 0 (unset) there is no gamma correction but to/from linear is possible.\n    */\n   file_gamma = png_ptr->file_gamma;\n   screen_gamma = png_ptr->screen_gamma;\n#  if GAMMA_TRANSFORMS\n      file_to_linear = png_reciprocal(file_gamma);\n#  endif\n\n   if (screen_gamma > 0)\n   {\n#     if GAMMA_TRANSFORMS\n         linear_to_screen = png_reciprocal(screen_gamma);\n#     endif\n      correction = png_reciprocal2(screen_gamma, file_gamma);\n   }\n   else /* screen gamma unknown */\n   {\n#     if GAMMA_TRANSFORMS\n         linear_to_screen = file_gamma;\n#     endif\n      correction = PNG_FP_1;\n   }\n\n   if (bit_depth <= 8)\n   {\n      png_build_8bit_table(png_ptr, &png_ptr->gamma_table, correction);\n\n#if GAMMA_TRANSFORMS\n      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)\n      {\n         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1, file_to_linear);\n\n         png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,\n            linear_to_screen);\n      }\n#endif /* GAMMA_TRANSFORMS */\n   }\n#ifdef PNG_16BIT_SUPPORTED\n   else\n   {\n      png_byte shift, sig_bit;\n\n      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      {\n         sig_bit = png_ptr->sig_bit.red;\n\n         if (png_ptr->sig_bit.green > sig_bit)\n            sig_bit = png_ptr->sig_bit.green;\n\n         if (png_ptr->sig_bit.blue > sig_bit)\n            sig_bit = png_ptr->sig_bit.blue;\n      }\n      else\n         sig_bit = png_ptr->sig_bit.gray;\n\n      /* 16-bit gamma code uses this equation:\n       *\n       *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]\n       *\n       * Where 'iv' is the input color value and 'ov' is the output value -\n       * pow(iv, gamma).\n       *\n       * Thus the gamma table consists of up to 256 256-entry tables.  The table\n       * is selected by the (8-gamma_shift) most significant of the low 8 bits\n       * of the color value then indexed by the upper 8 bits:\n       *\n       *   table[low bits][high 8 bits]\n       *\n       * So the table 'n' corresponds to all those 'iv' of:\n       *\n       *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>\n       *\n       */\n      if (sig_bit > 0 && sig_bit < 16U)\n         /* shift == insignificant bits */\n         shift = (png_byte)((16U - sig_bit) & 0xff);\n\n      else\n         shift = 0; /* keep all 16 bits */\n\n      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)\n      {\n         /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively\n          * the significant bits in the *input* when the output will\n          * eventually be 8 bits.  By default it is 11.\n          */\n         if (shift < (16U - PNG_MAX_GAMMA_8))\n            shift = (16U - PNG_MAX_GAMMA_8);\n      }\n\n      if (shift > 8U)\n         shift = 8U; /* Guarantees at least one table! */\n\n      png_ptr->gamma_shift = shift;\n\n      /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now\n       * PNG_COMPOSE).  This effectively smashed the background calculation for\n       * 16-bit output because the 8-bit table assumes the result will be\n       * reduced to 8 bits.\n       */\n      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)\n         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\n            png_reciprocal(correction));\n      else\n         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\n            correction);\n\n#  if GAMMA_TRANSFORMS\n      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)\n      {\n         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,\n            file_to_linear);\n\n         /* Notice that the '16 from 1' table should be full precision, however\n          * the lookup on this table still uses gamma_shift, so it can't be.\n          * TODO: fix this.\n          */\n         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,\n            linear_to_screen);\n      }\n#endif /* GAMMA_TRANSFORMS */\n   }\n#endif /* 16BIT */\n}\n",
      "line_start": 3612,
      "line_end": 3760,
      "execution_count": 94,
      "covered_regions": 71,
      "total_regions": 117,
      "coverage_percent": 60.68,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_info",
      "clean_name": "png_read_info",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * via png_set_sig_bytes(), and we will only check the remaining bytes\n * here.  The application can then have access to the signature bytes we\n * read if it is determined that this isn't a valid PNG file.\n */\nvoid PNGAPI\npng_read_info(png_structrp png_ptr, png_inforp info_ptr)\n{\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n   int keep;\n#endif\n\n   png_debug(1, \"in png_read_info\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* Read and check the PNG file signature. */\n   png_read_sig(png_ptr, info_ptr);\n\n   for (;;)\n   {\n      png_uint_32 length = png_read_chunk_header(png_ptr);\n      png_uint_32 chunk_name = png_ptr->chunk_name;\n\n      /* IDAT logic needs to happen here to simplify getting the two flags\n       * right.\n       */\n      if (chunk_name == png_IDAT)\n      {\n         if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n            png_chunk_error(png_ptr, \"Missing IHDR before IDAT\");\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n             (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n            png_chunk_error(png_ptr, \"Missing PLTE before IDAT\");\n\n         else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)\n            png_chunk_benign_error(png_ptr, \"Too many IDATs found\");\n\n         png_ptr->mode |= PNG_HAVE_IDAT;\n      }\n\n      else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n      {\n         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n         png_ptr->mode |= PNG_AFTER_IDAT;\n      }\n\n      if (chunk_name == png_IHDR)\n         png_handle_chunk(png_ptr, info_ptr, length);\n\n      else if (chunk_name == png_IEND)\n         png_handle_chunk(png_ptr, info_ptr, length);\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\n      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)\n      {\n         png_handle_unknown(png_ptr, info_ptr, length, keep);\n\n         if (chunk_name == png_PLTE)\n            png_ptr->mode |= PNG_HAVE_PLTE;\n\n         else if (chunk_name == png_IDAT)\n         {\n            png_ptr->idat_size = 0; /* It has been consumed */\n            break;\n         }\n      }\n#endif\n\n      else if (chunk_name == png_IDAT)\n      {\n         png_ptr->idat_size = length;\n         break;\n      }\n\n      else\n         png_handle_chunk(png_ptr, info_ptr, length);\n   }\n}\n",
      "line_start": 90,
      "line_end": 165,
      "execution_count": 358,
      "covered_regions": 121,
      "total_regions": 197,
      "coverage_percent": 61.42,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngmem.c:png_malloc_array_checked",
      "clean_name": "png_malloc_array_checked",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7\n * that arises because of the checks in png_realloc_array that are repeated in\n * png_malloc_array.\n */\nstatic png_voidp\npng_malloc_array_checked(png_const_structrp png_ptr, int nelements,\n    size_t element_size)\n{\n   png_alloc_size_t req = (png_alloc_size_t)nelements; /* known to be > 0 */\n\n   if (req <= PNG_SIZE_MAX/element_size)\n      return png_malloc_base(png_ptr, req * element_size);\n\n   /* The failure case when the request is too large */\n   return NULL;\n}\n",
      "line_start": 106,
      "line_end": 117,
      "execution_count": 232,
      "covered_regions": 8,
      "total_regions": 13,
      "coverage_percent": 61.54,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_pCAL",
      "clean_name": "png_set_pCAL",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\nvoid PNGAPI\npng_set_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,\n    int nparams, png_const_charp units, png_charpp params)\n{\n   size_t length;\n   int i;\n\n   png_debug1(1, \"in %s storage function\", \"pCAL\");\n\n   if (png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL\n       || (nparams > 0 && params == NULL))\n      return;\n\n   length = strlen(purpose) + 1;\n   png_debug1(3, \"allocating purpose for info (%lu bytes)\",\n       (unsigned long)length);\n\n   /* TODO: validate format of calibration name and unit name */\n\n   /* Check that the type matches the specification. */\n   if (type < 0 || type > 3)\n   {\n      png_chunk_report(png_ptr, \"Invalid pCAL equation type\",\n            PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   if (nparams < 0 || nparams > 255)\n   {\n      png_chunk_report(png_ptr, \"Invalid pCAL parameter count\",\n            PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   /* Validate params[nparams] */\n   for (i=0; i<nparams; ++i)\n   {\n      if (params[i] == NULL ||\n          !png_check_fp_string(params[i], strlen(params[i])))\n      {\n         png_chunk_report(png_ptr, \"Invalid format for pCAL parameter\",\n               PNG_CHUNK_WRITE_ERROR);\n         return;\n      }\n   }\n\n   info_ptr->pcal_purpose = png_voidcast(png_charp,\n       png_malloc_warn(png_ptr, length));\n\n   if (info_ptr->pcal_purpose == NULL)\n   {\n      png_chunk_report(png_ptr, \"Insufficient memory for pCAL purpose\",\n            PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   memcpy(info_ptr->pcal_purpose, purpose, length);\n\n   info_ptr->free_me |= PNG_FREE_PCAL;\n\n   png_debug(3, \"storing X0, X1, type, and nparams in info\");\n   info_ptr->pcal_X0 = X0;\n   info_ptr->pcal_X1 = X1;\n   info_ptr->pcal_type = (png_byte)type;\n   info_ptr->pcal_nparams = (png_byte)nparams;\n\n   length = strlen(units) + 1;\n   png_debug1(3, \"allocating units for info (%lu bytes)\",\n       (unsigned long)length);\n\n   info_ptr->pcal_units = png_voidcast(png_charp,\n       png_malloc_warn(png_ptr, length));\n\n   if (info_ptr->pcal_units == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory for pCAL units\");\n      return;\n   }\n\n   memcpy(info_ptr->pcal_units, units, length);\n\n   info_ptr->pcal_params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\n       (size_t)(((unsigned int)nparams + 1) * (sizeof (png_charp)))));\n\n   if (info_ptr->pcal_params == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory for pCAL params\");\n      return;\n   }\n\n   memset(info_ptr->pcal_params, 0, ((unsigned int)nparams + 1) *\n       (sizeof (png_charp)));\n\n   for (i = 0; i < nparams; i++)\n   {\n      length = strlen(params[i]) + 1;\n      png_debug2(3, \"allocating parameter %d for info (%lu bytes)\", i,\n          (unsigned long)length);\n\n      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);\n\n      if (info_ptr->pcal_params[i] == NULL)\n      {\n         png_warning(png_ptr, \"Insufficient memory for pCAL parameter\");\n         return;\n      }\n\n      memcpy(info_ptr->pcal_params[i], params[i], length);\n   }\n\n   info_ptr->valid |= PNG_INFO_pCAL;\n}\n",
      "line_start": 483,
      "line_end": 595,
      "execution_count": 2,
      "covered_regions": 98,
      "total_regions": 159,
      "coverage_percent": 61.64,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_create_info_struct",
      "clean_name": "png_create_info_struct",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return NULL;\n}\n\n/* Allocate the memory for an info_struct for the application. */\nPNG_FUNCTION(png_infop,PNGAPI\npng_create_info_struct,(png_const_structrp png_ptr),PNG_ALLOCATED)\n{\n   png_inforp info_ptr;\n\n   png_debug(1, \"in png_create_info_struct\");\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   /* Use the internal API that does not (or at least should not) error out, so\n    * that this call always returns ok.  The application typically sets up the\n    * error handling *after* creating the info_struct because this is the way it\n    * has always been done in 'example.c'.\n    */\n   info_ptr = png_voidcast(png_inforp, png_malloc_base(png_ptr,\n       (sizeof *info_ptr)));\n\n   if (info_ptr != NULL)\n      memset(info_ptr, 0, (sizeof *info_ptr));\n\n   return info_ptr;\n}\n",
      "line_start": 363,
      "line_end": 385,
      "execution_count": 537,
      "covered_regions": 13,
      "total_regions": 21,
      "coverage_percent": 61.9,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_pCAL",
      "clean_name": "png_handle_pCAL",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_pCAL_SUPPORTED\n/* Read the pCAL chunk (described in the PNG Extensions document) */\nstatic png_handle_result_code /* PRIVATE */\npng_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_int_32 X0, X1;\n   png_byte type, nparams;\n   png_bytep buffer, buf, units, endptr;\n   png_charpp params;\n   int i;\n\n   png_debug(1, \"in png_handle_pCAL\");\n   png_debug1(2, \"Allocating and reading pCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   buffer[length] = 0; /* Null terminate the last string */\n\n   png_debug(3, \"Finding end of pCAL purpose string\");\n   for (buf = buffer; *buf; buf++)\n      /* Empty loop */ ;\n\n   endptr = buffer + length;\n\n   /* We need to have at least 12 bytes after the purpose string\n    * in order to get the parameter information.\n    */\n   if (endptr - buf <= 12)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   png_debug(3, \"Reading pCAL X0, X1, type, nparams, and units\");\n   X0 = png_get_int_32((png_bytep)buf+1);\n   X1 = png_get_int_32((png_bytep)buf+5);\n   type = buf[9];\n   nparams = buf[10];\n   units = buf + 11;\n\n   png_debug(3, \"Checking pCAL equation type and number of parameters\");\n   /* Check that we have the right number of parameters for known\n    * equation types.\n    */\n   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||\n       (type == PNG_EQUATION_BASE_E && nparams != 3) ||\n       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||\n       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))\n   {\n      png_chunk_benign_error(png_ptr, \"invalid parameter count\");\n      return handled_error;\n   }\n\n   else if (type >= PNG_EQUATION_LAST)\n   {\n      png_chunk_benign_error(png_ptr, \"unrecognized equation type\");\n   }\n\n   for (buf = units; *buf; buf++)\n      /* Empty loop to move past the units string. */ ;\n\n   png_debug(3, \"Allocating pCAL parameters array\");\n\n   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,\n       nparams * (sizeof (png_charp))));\n\n   if (params == NULL)\n   {\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   /* Get pointers to the start of each parameter string. */\n   for (i = 0; i < nparams; i++)\n   {\n      buf++; /* Skip the null string terminator from previous parameter. */\n\n      png_debug1(3, \"Reading pCAL parameter %d\", i);\n\n      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)\n         /* Empty loop to move past each parameter string */ ;\n\n      /* Make sure we haven't run out of data yet */\n      if (buf > endptr)\n      {\n         png_free(png_ptr, params);\n         png_chunk_benign_error(png_ptr, \"invalid data\");\n         return handled_error;\n      }\n   }\n\n   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,\n       (png_charp)units, params);\n\n   /* TODO: BUG: png_set_pCAL calls png_chunk_report which, in this case, calls\n    * png_benign_error and that can error out.\n    *\n    * png_read_buffer needs to be allocated with space for both nparams and the\n    * parameter strings.  Not hard to do.\n    */\n   png_free(png_ptr, params);\n   return handled_ok;\n}\n",
      "line_start": 2155,
      "line_end": 2268,
      "execution_count": 2,
      "covered_regions": 118,
      "total_regions": 189,
      "coverage_percent": 62.43,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_check_fp_string",
      "clean_name": "png_check_fp_string",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n\n\n/* The same but for a complete string. */\nint\npng_check_fp_string(png_const_charp string, size_t size)\n{\n   int        state=0;\n   size_t char_index=0;\n\n   if (png_check_fp_number(string, size, &state, &char_index) != 0 &&\n      (char_index == size || string[char_index] == 0))\n      return state /* must be non-zero - see above */;\n\n   return 0; /* i.e. fail */\n}\n",
      "line_start": 2257,
      "line_end": 2268,
      "execution_count": 8,
      "covered_regions": 10,
      "total_regions": 16,
      "coverage_percent": 62.5,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_inflate",
      "clean_name": "png_inflate",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * or written, not the amount available (as in a z_stream).  The data pointers\n * are not changed, so the next input is (data+input_size) and the next\n * available output is (output+output_size).\n */\nstatic int\npng_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,\n    /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,\n    /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)\n{\n   if (png_ptr->zowner == owner) /* Else not claimed */\n   {\n      int ret;\n      png_alloc_size_t avail_out = *output_size_ptr;\n      png_uint_32 avail_in = *input_size_ptr;\n\n      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it\n       * can't even necessarily handle 65536 bytes) because the type uInt is\n       * \"16 bits or more\".  Consequently it is necessary to chunk the input to\n       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the\n       * maximum value that can be stored in a uInt.)  It is possible to set\n       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have\n       * a performance advantage, because it reduces the amount of data accessed\n       * at each step and that may give the OS more time to page it in.\n       */\n      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);\n      /* avail_in and avail_out are set below from 'size' */\n      png_ptr->zstream.avail_in = 0;\n      png_ptr->zstream.avail_out = 0;\n\n      /* Read directly into the output if it is available (this is set to\n       * a local buffer below if output is NULL).\n       */\n      if (output != NULL)\n         png_ptr->zstream.next_out = output;\n\n      do\n      {\n         uInt avail;\n         Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n\n         /* zlib INPUT BUFFER */\n         /* The setting of 'avail_in' used to be outside the loop; by setting it\n          * inside it is possible to chunk the input to zlib and simply rely on\n          * zlib to advance the 'next_in' pointer.  This allows arbitrary\n          * amounts of data to be passed through zlib at the unavoidable cost of\n          * requiring a window save (memcpy of up to 32768 output bytes)\n          * every ZLIB_IO_MAX input bytes.\n          */\n         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */\n\n         avail = ZLIB_IO_MAX;\n\n         if (avail_in < avail)\n            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */\n\n         avail_in -= avail;\n         png_ptr->zstream.avail_in = avail;\n\n         /* zlib OUTPUT BUFFER */\n         avail_out += png_ptr->zstream.avail_out; /* not written last time */\n\n         avail = ZLIB_IO_MAX; /* maximum zlib can process */\n\n         if (output == NULL)\n         {\n            /* Reset the output buffer each time round if output is NULL and\n             * make available the full buffer, up to 'remaining_space'\n             */\n            png_ptr->zstream.next_out = local_buffer;\n            if ((sizeof local_buffer) < avail)\n               avail = (sizeof local_buffer);\n         }\n\n         if (avail_out < avail)\n            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */\n\n         png_ptr->zstream.avail_out = avail;\n         avail_out -= avail;\n\n         /* zlib inflate call */\n         /* In fact 'avail_out' may be 0 at this point, that happens at the end\n          * of the read when the final LZ end code was not passed at the end of\n          * the previous chunk of input data.  Tell zlib if we have reached the\n          * end of the output buffer.\n          */\n         ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :\n             (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      } while (ret == Z_OK);\n\n      /* For safety kill the local buffer pointer now */\n      if (output == NULL)\n         png_ptr->zstream.next_out = NULL;\n\n      /* Claw back the 'size' and 'remaining_space' byte counts. */\n      avail_in += png_ptr->zstream.avail_in;\n      avail_out += png_ptr->zstream.avail_out;\n\n      /* Update the input and output sizes; the updated values are the amount\n       * consumed or written, effectively the inverse of what zlib uses.\n       */\n      if (avail_out > 0)\n         *output_size_ptr -= avail_out;\n\n      if (avail_in > 0)\n         *input_size_ptr -= avail_in;\n\n      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      /* This is a bad internal error.  The recovery assigns to the zstream msg\n       * pointer, which is not owned by the caller, but this is safe; it's only\n       * used on errors!\n       */\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n",
      "line_start": 555,
      "line_end": 671,
      "execution_count": 454,
      "covered_regions": 50,
      "total_regions": 80,
      "coverage_percent": 62.5,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_oFFs",
      "clean_name": "png_handle_oFFs",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_pHYs NULL\n#endif\n\n#ifdef PNG_READ_oFFs_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_int_32 offset_x, offset_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_oFFs\");\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   offset_x = png_get_int_32(buf);\n   offset_y = png_get_int_32(buf + 4);\n   unit_type = buf[8];\n   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 2128,
      "line_end": 2148,
      "execution_count": 2,
      "covered_regions": 35,
      "total_regions": 56,
      "coverage_percent": 62.5,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_sRGB",
      "clean_name": "png_handle_sRGB",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_cHRM NULL\n#endif\n\n#ifdef PNG_READ_sRGB_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte intent;\n\n   png_debug(1, \"in png_handle_sRGB\");\n\n   png_crc_read(png_ptr, &intent, 1);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* This checks the range of the \"rendering intent\" because it is specified in\n    * the PNG spec itself; the \"reserved\" values will result in the chunk not\n    * being accepted, just as they do with the various \"reserved\" values in\n    * IHDR.\n    */\n   if (intent > 3/*PNGv3 spec*/)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   png_set_sRGB(png_ptr, info_ptr, intent);\n   /* NOTE: png_struct::chromaticities is not set here because the RGB to gray\n    * coefficients are known without a need for the chromaticities.\n    */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n      /* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  iCCP is\n       * not supported by libpng so the only requirement is to check for cICP\n       * setting the gamma (this is NYI, but this check is safe.)\n       */\n      if (!png_has_chunk(png_ptr, cICP) || png_ptr->chunk_gamma == 0)\n         png_ptr->chunk_gamma = PNG_GAMMA_sRGB_INVERSE;\n#endif /*READ_GAMMA*/\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1294,
      "line_end": 1333,
      "execution_count": 58,
      "covered_regions": 30,
      "total_regions": 48,
      "coverage_percent": 62.5,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_cLLI_fixed",
      "clean_name": "png_set_cLLI_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* cICP */\n\n#ifdef PNG_cLLI_SUPPORTED\nvoid PNGFAPI\npng_set_cLLI_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    /* The values below are in cd/m2 (nits) and are scaled by 10,000; not\n     * 100,000 as in the case of png_fixed_point.\n     */\n    png_uint_32 maxCLL, png_uint_32 maxFALL)\n{\n   png_debug1(1, \"in %s storage function\", \"cLLI\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* Check the light level range: */\n   if (maxCLL > 0x7FFFFFFFU || maxFALL > 0x7FFFFFFFU)\n   {\n      /* The limit is 200kcd/m2; somewhat bright but not inconceivable because\n       * human vision is said to run up to 100Mcd/m2.  The sun is about 2Gcd/m2.\n       *\n       * The reference sRGB monitor is 80cd/m2 and the limit of PQ encoding is\n       * 2kcd/m2.\n       */\n      png_chunk_report(png_ptr, \"cLLI light level exceeds PNG limit\",\n            PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   info_ptr->maxCLL = maxCLL;\n   info_ptr->maxFALL = maxFALL;\n   info_ptr->valid |= PNG_INFO_cLLI;\n}\n",
      "line_start": 161,
      "line_end": 190,
      "execution_count": 2,
      "covered_regions": 20,
      "total_regions": 32,
      "coverage_percent": 62.5,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_sCAL",
      "clean_name": "png_handle_sCAL",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_sCAL_SUPPORTED\n/* Read the sCAL chunk */\nstatic png_handle_result_code /* PRIVATE */\npng_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_bytep buffer;\n   size_t i;\n   int state;\n\n   png_debug(1, \"in png_handle_sCAL\");\n   png_debug1(2, \"Allocating and reading sCAL chunk data (%u bytes)\",\n       length + 1);\n\n   buffer = png_read_buffer(png_ptr, length+1);\n\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buffer, length);\n   buffer[length] = 0; /* Null terminate the last string */\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* Validate the unit. */\n   if (buffer[0] != 1 && buffer[0] != 2)\n   {\n      png_chunk_benign_error(png_ptr, \"invalid unit\");\n      return handled_error;\n   }\n\n   /* Validate the ASCII numbers, need two ASCII numbers separated by\n    * a '\\0' and they need to fit exactly in the chunk data.\n    */\n   i = 1;\n   state = 0;\n\n   if (png_check_fp_number((png_const_charp)buffer, length, &state, &i) == 0 ||\n       i >= length || buffer[i++] != 0)\n      png_chunk_benign_error(png_ptr, \"bad width format\");\n\n   else if (PNG_FP_IS_POSITIVE(state) == 0)\n      png_chunk_benign_error(png_ptr, \"non-positive width\");\n\n   else\n   {\n      size_t heighti = i;\n\n      state = 0;\n      if (png_check_fp_number((png_const_charp)buffer, length,\n          &state, &i) == 0 || i != length)\n         png_chunk_benign_error(png_ptr, \"bad height format\");\n\n      else if (PNG_FP_IS_POSITIVE(state) == 0)\n         png_chunk_benign_error(png_ptr, \"non-positive height\");\n\n      else\n      {\n         /* This is the (only) success case. */\n         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],\n             (png_charp)buffer+1, (png_charp)buffer+heighti);\n         return handled_ok;\n      }\n   }\n\n   return handled_error;\n}\n",
      "line_start": 2275,
      "line_end": 2343,
      "execution_count": 2,
      "covered_regions": 79,
      "total_regions": 126,
      "coverage_percent": 62.7,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_realloc_array",
      "clean_name": "png_realloc_array",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "\n   return png_malloc_array_checked(png_ptr, nelements, element_size);\n}\n\nPNG_FUNCTION(png_voidp /* PRIVATE */,\npng_realloc_array,(png_const_structrp png_ptr, png_const_voidp old_array,\n    int old_elements, int add_elements, size_t element_size),PNG_ALLOCATED)\n{\n   /* These are internal errors: */\n   if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||\n      (old_array == NULL && old_elements > 0))\n      png_error(png_ptr, \"internal error: array realloc\");\n\n   /* Check for overflow on the elements count (so the caller does not have to\n    * check.)\n    */\n   if (add_elements <= INT_MAX - old_elements)\n   {\n      png_voidp new_array = png_malloc_array_checked(png_ptr,\n          old_elements+add_elements, element_size);\n\n      if (new_array != NULL)\n      {\n         /* Because png_malloc_array worked the size calculations below cannot\n          * overflow.\n          */\n         if (old_elements > 0)\n            memcpy(new_array, old_array, element_size*(unsigned)old_elements);\n\n         memset((char*)new_array + element_size*(unsigned)old_elements, 0,\n             element_size*(unsigned)add_elements);\n\n         return new_array;\n      }\n   }\n\n   return NULL; /* error */\n}\n",
      "line_start": 129,
      "line_end": 162,
      "execution_count": 232,
      "covered_regions": 27,
      "total_regions": 43,
      "coverage_percent": 62.79,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_cICP",
      "clean_name": "png_set_cICP",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n#endif /* cHRM */\n\n#ifdef PNG_cICP_SUPPORTED\nvoid PNGAPI\npng_set_cICP(png_const_structrp png_ptr, png_inforp info_ptr,\n             png_byte colour_primaries, png_byte transfer_function,\n             png_byte matrix_coefficients, png_byte video_full_range_flag)\n{\n   png_debug1(1, \"in %s storage function\", \"cICP\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->cicp_colour_primaries = colour_primaries;\n   info_ptr->cicp_transfer_function = transfer_function;\n   info_ptr->cicp_matrix_coefficients = matrix_coefficients;\n   info_ptr->cicp_video_full_range_flag = video_full_range_flag;\n\n   if (info_ptr->cicp_matrix_coefficients != 0)\n   {\n      png_warning(png_ptr, \"Invalid cICP matrix coefficients\");\n      return;\n   }\n\n   info_ptr->valid |= PNG_INFO_cICP;\n}\n",
      "line_start": 135,
      "line_end": 157,
      "execution_count": 4,
      "covered_regions": 17,
      "total_regions": 27,
      "coverage_percent": 62.96,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_row",
      "clean_name": "png_read_row",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   }\n}\n#endif /* MNG_FEATURES */\n\nvoid PNGAPI\npng_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row)\n{\n   png_row_info row_info;\n\n   if (png_ptr == NULL)\n      return;\n\n   png_debug2(1, \"in png_read_row (row %lu, pass %d)\",\n       (unsigned long)png_ptr->row_number, png_ptr->pass);\n\n   /* png_read_start_row sets the information (in particular iwidth) for this\n    * interlace pass.\n    */\n   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n      png_read_start_row(png_ptr);\n\n   /* 1.5.6: row_info moved out of png_struct to a local here. */\n   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */\n   row_info.color_type = png_ptr->color_type;\n   row_info.bit_depth = png_ptr->bit_depth;\n   row_info.channels = png_ptr->channels;\n   row_info.pixel_depth = png_ptr->pixel_depth;\n   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);\n\n#ifdef PNG_WARNINGS_SUPPORTED\n   if (png_ptr->row_number == 0 && png_ptr->pass == 0)\n   {\n   /* Check for transforms that have been set but were defined out */\n#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)\n   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)\n      png_warning(png_ptr, \"PNG_READ_INVERT_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)\n   if ((png_ptr->transformations & PNG_FILLER) != 0)\n      png_warning(png_ptr, \"PNG_READ_FILLER_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \\\n    !defined(PNG_READ_PACKSWAP_SUPPORTED)\n   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n      png_warning(png_ptr, \"PNG_READ_PACKSWAP_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)\n   if ((png_ptr->transformations & PNG_PACK) != 0)\n      png_warning(png_ptr, \"PNG_READ_PACK_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)\n   if ((png_ptr->transformations & PNG_SHIFT) != 0)\n      png_warning(png_ptr, \"PNG_READ_SHIFT_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)\n   if ((png_ptr->transformations & PNG_BGR) != 0)\n      png_warning(png_ptr, \"PNG_READ_BGR_SUPPORTED is not defined\");\n#endif\n\n#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)\n   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)\n      png_warning(png_ptr, \"PNG_READ_SWAP_SUPPORTED is not defined\");\n#endif\n   }\n#endif /* WARNINGS */\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   /* If interlaced and we do not need a new row, combine row and return.\n    * Notice that the pixels we have from previous rows have been transformed\n    * already; we can only combine like with like (transformed or\n    * untransformed) and, because of the libpng API for interlaced images, this\n    * means we must transform before de-interlacing.\n    */\n   if (png_ptr->interlaced != 0 &&\n       (png_ptr->transformations & PNG_INTERLACE) != 0)\n   {\n      switch (png_ptr->pass)\n      {\n         case 0:\n            if (png_ptr->row_number & 0x07)\n            {\n               if (dsp_row != NULL)\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         case 1:\n            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)\n            {\n               if (dsp_row != NULL)\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         case 2:\n            if ((png_ptr->row_number & 0x07) != 4)\n            {\n               if (dsp_row != NULL && (png_ptr->row_number & 4))\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         case 3:\n            if ((png_ptr->row_number & 3) || png_ptr->width < 3)\n            {\n               if (dsp_row != NULL)\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         case 4:\n            if ((png_ptr->row_number & 3) != 2)\n            {\n               if (dsp_row != NULL && (png_ptr->row_number & 2))\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         case 5:\n            if ((png_ptr->row_number & 1) || png_ptr->width < 2)\n            {\n               if (dsp_row != NULL)\n                  png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n\n         default:\n         case 6:\n            if ((png_ptr->row_number & 1) == 0)\n            {\n               png_read_finish_row(png_ptr);\n               return;\n            }\n            break;\n      }\n   }\n#endif\n\n   if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)\n      png_error(png_ptr, \"Invalid attempt to read row data\");\n\n   /* Fill the row with IDAT data: */\n   png_ptr->row_buf[0]=255; /* to force error if no data was found */\n   png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);\n\n   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)\n   {\n      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)\n         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,\n             png_ptr->prev_row + 1, png_ptr->row_buf[0]);\n      else\n         png_error(png_ptr, \"bad adaptive filter value\");\n   }\n\n   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before\n    * 1.5.6, while the buffer really is this big in current versions of libpng\n    * it may not be in the future, so this was changed just to copy the\n    * interlaced count:\n    */\n   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);\n\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&\n       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))\n   {\n      /* Intrapixel differencing */\n      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);\n   }\n#endif\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n   if (png_ptr->transformations\n#     ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\n         || png_ptr->num_palette_max >= 0\n#     endif\n      )\n      png_do_read_transformations(png_ptr, &row_info);\n#endif\n\n   /* The transformed pixel depth should match the depth now in row_info. */\n   if (png_ptr->transformed_pixel_depth == 0)\n   {\n      png_ptr->transformed_pixel_depth = row_info.pixel_depth;\n      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)\n         png_error(png_ptr, \"sequential row overflow\");\n   }\n\n   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)\n      png_error(png_ptr, \"internal sequential row size calculation error\");\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   /* Expand interlaced rows to full size */\n   if (png_ptr->interlaced != 0 &&\n      (png_ptr->transformations & PNG_INTERLACE) != 0)\n   {\n      if (png_ptr->pass < 6)\n         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,\n             png_ptr->transformations);\n\n      if (dsp_row != NULL)\n         png_combine_row(png_ptr, dsp_row, 1/*display*/);\n\n      if (row != NULL)\n         png_combine_row(png_ptr, row, 0/*row*/);\n   }\n\n   else\n#endif\n   {\n      if (row != NULL)\n         png_combine_row(png_ptr, row, -1/*ignored*/);\n\n      if (dsp_row != NULL)\n         png_combine_row(png_ptr, dsp_row, -1/*ignored*/);\n   }\n   png_read_finish_row(png_ptr);\n\n   if (png_ptr->read_row_fn != NULL)\n      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);\n\n}\n",
      "line_start": 285,
      "line_end": 523,
      "execution_count": 39076,
      "covered_regions": 193,
      "total_regions": 306,
      "coverage_percent": 63.07,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_sBIT",
      "clean_name": "png_handle_sBIT",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_gAMA NULL\n#endif\n\n#ifdef PNG_READ_sBIT_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen, i;\n   png_byte sample_depth;\n   png_byte buf[4];\n\n   png_debug(1, \"in png_handle_sBIT\");\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      truelen = 3;\n      sample_depth = 8;\n   }\n\n   else\n   {\n      truelen = png_ptr->channels;\n      sample_depth = png_ptr->bit_depth;\n   }\n\n   if (length != truelen)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"bad length\");\n      return handled_error;\n   }\n\n   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   for (i=0; i<truelen; ++i)\n   {\n      if (buf[i] == 0 || buf[i] > sample_depth)\n      {\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return handled_error;\n      }\n   }\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[1];\n      png_ptr->sig_bit.blue = buf[2];\n      png_ptr->sig_bit.alpha = buf[3];\n   }\n\n   else /* grayscale */\n   {\n      png_ptr->sig_bit.gray = buf[0];\n      png_ptr->sig_bit.red = buf[0];\n      png_ptr->sig_bit.green = buf[0];\n      png_ptr->sig_bit.blue = buf[0];\n      png_ptr->sig_bit.alpha = buf[1];\n   }\n\n   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));\n   return handled_ok;\n}\n",
      "line_start": 1153,
      "line_end": 1215,
      "execution_count": 6,
      "covered_regions": 41,
      "total_regions": 65,
      "coverage_percent": 63.08,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_check_fp_number",
      "clean_name": "png_check_fp_number",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* The following is used internally to preserve the sticky flags */\n#define png_fp_add(state, flags) ((state) |= (flags))\n#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))\n\nint /* PRIVATE */\npng_check_fp_number(png_const_charp string, size_t size, int *statep,\n    size_t *whereami)\n{\n   int state = *statep;\n   size_t i = *whereami;\n\n   while (i < size)\n   {\n      int type;\n      /* First find the type of the next character */\n      switch (string[i])\n      {\n      case 43:  type = PNG_FP_SAW_SIGN;                   break;\n      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;\n      case 46:  type = PNG_FP_SAW_DOT;                    break;\n      case 48:  type = PNG_FP_SAW_DIGIT;                  break;\n      case 49: case 50: case 51: case 52:\n      case 53: case 54: case 55: case 56:\n      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;\n      case 69:\n      case 101: type = PNG_FP_SAW_E;                      break;\n      default:  goto PNG_FP_End;\n      }\n\n      /* Now deal with this type according to the current\n       * state, the type is arranged to not overlap the\n       * bits of the PNG_FP_STATE.\n       */\n      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))\n      {\n      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:\n         if ((state & PNG_FP_SAW_ANY) != 0)\n            goto PNG_FP_End; /* not a part of the number */\n\n         png_fp_add(state, type);\n         break;\n\n      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:\n         /* Ok as trailer, ok as lead of fraction. */\n         if ((state & PNG_FP_SAW_DOT) != 0) /* two dots */\n            goto PNG_FP_End;\n\n         else if ((state & PNG_FP_SAW_DIGIT) != 0) /* trailing dot? */\n            png_fp_add(state, type);\n\n         else\n            png_fp_set(state, PNG_FP_FRACTION | type);\n\n         break;\n\n      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:\n         if ((state & PNG_FP_SAW_DOT) != 0) /* delayed fraction */\n            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);\n\n         png_fp_add(state, type | PNG_FP_WAS_VALID);\n\n         break;\n\n      case PNG_FP_INTEGER + PNG_FP_SAW_E:\n         if ((state & PNG_FP_SAW_DIGIT) == 0)\n            goto PNG_FP_End;\n\n         png_fp_set(state, PNG_FP_EXPONENT);\n\n         break;\n\n   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:\n         goto PNG_FP_End; ** no sign in fraction */\n\n   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:\n         goto PNG_FP_End; ** Because SAW_DOT is always set */\n\n      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:\n         png_fp_add(state, type | PNG_FP_WAS_VALID);\n         break;\n\n      case PNG_FP_FRACTION + PNG_FP_SAW_E:\n         /* This is correct because the trailing '.' on an\n          * integer is handled above - so we can only get here\n          * with the sequence \".E\" (with no preceding digits).\n          */\n         if ((state & PNG_FP_SAW_DIGIT) == 0)\n            goto PNG_FP_End;\n\n         png_fp_set(state, PNG_FP_EXPONENT);\n\n         break;\n\n      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:\n         if ((state & PNG_FP_SAW_ANY) != 0)\n            goto PNG_FP_End; /* not a part of the number */\n\n         png_fp_add(state, PNG_FP_SAW_SIGN);\n\n         break;\n\n   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:\n         goto PNG_FP_End; */\n\n      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:\n         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);\n\n         break;\n\n   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:\n         goto PNG_FP_End; */\n\n      default: goto PNG_FP_End; /* I.e. break 2 */\n      }\n\n      /* The character seems ok, continue. */\n      ++i;\n   }\n\nPNG_FP_End:\n   /* Here at the end, update the state and return the correct\n    * return code.\n    */\n   *statep = state;\n   *whereami = i;\n\n   return (state & PNG_FP_SAW_DIGIT) != 0;\n}\n",
      "line_start": 2130,
      "line_end": 2253,
      "execution_count": 12,
      "covered_regions": 133,
      "total_regions": 209,
      "coverage_percent": 63.64,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png.c:png_build_8bit_table",
      "clean_name": "png_build_8bit_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* Build a single 8-bit table: same as the 16-bit case but much simpler (and\n * typically much faster).  Note that libpng currently does no sBIT processing\n * (apparently contrary to the spec) so a 256-entry table is always generated.\n */\nstatic void\npng_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,\n    png_fixed_point gamma_val)\n{\n   unsigned int i;\n   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);\n\n   if (png_gamma_significant(gamma_val) != 0)\n      for (i=0; i<256; i++)\n         table[i] = png_gamma_8bit_correct(i, gamma_val);\n\n   else\n      for (i=0; i<256; ++i)\n         table[i] = (png_byte)(i & 0xff);\n}\n",
      "line_start": 3522,
      "line_end": 3536,
      "execution_count": 62,
      "covered_regions": 14,
      "total_regions": 22,
      "coverage_percent": 63.64,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngset.c:png_ITU_fixed_16",
      "clean_name": "png_ITU_fixed_16",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif /* FLOATING_POINT */\n#endif /* cLLI */\n\n#ifdef PNG_mDCV_SUPPORTED\nstatic png_uint_16\npng_ITU_fixed_16(int *error, png_fixed_point v)\n{\n   /* Return a safe uint16_t value scaled according to the ITU H273 rules for\n    * 16-bit display chromaticities.  Functions like the corresponding\n    * png_fixed() internal function with regard to errors: it's an error on\n    * write, a chunk_benign_error on read: See the definition of\n    * png_chunk_report in pngpriv.h.\n    */\n   v /= 2; /* rounds to 0 in C: avoids insignificant arithmetic errors */\n   if (v > 65535 || v < 0)\n   {\n      *error = 1;\n      return 0;\n   }\n\n   return (png_uint_16)/*SAFE*/v;\n}\n",
      "line_start": 205,
      "line_end": 222,
      "execution_count": 16,
      "covered_regions": 7,
      "total_regions": 11,
      "coverage_percent": 63.64,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_memory_read",
      "clean_name": "png_image_memory_read",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 0;\n}\n#endif /* STDIO */\n\nstatic void PNGCBAPI\npng_image_memory_read(png_structp png_ptr, png_bytep out, size_t need)\n{\n   if (png_ptr != NULL)\n   {\n      png_imagep image = png_voidcast(png_imagep, png_ptr->io_ptr);\n      if (image != NULL)\n      {\n         png_controlp cp = image->opaque;\n         if (cp != NULL)\n         {\n            png_const_bytep memory = cp->memory;\n            size_t size = cp->size;\n\n            if (memory != NULL && size >= need)\n            {\n               memcpy(out, memory, need);\n               cp->memory = memory + need;\n               cp->size = size - need;\n               return;\n            }\n\n            png_error(png_ptr, \"read beyond end of data\");\n         }\n      }\n\n      png_error(png_ptr, \"invalid memory read\");\n   }\n}\n",
      "line_start": 1405,
      "line_end": 1433,
      "execution_count": 2909,
      "covered_regions": 23,
      "total_regions": 36,
      "coverage_percent": 63.89,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_muldiv",
      "clean_name": "png_muldiv",
      "source_file": "/src/libpng/png.c",
      "source_code": " * integer (or, for a fixed point number - the standard argument - to\n * the nearest .00001).  Overflow and divide by zero are signalled in\n * the result, a boolean - true on success, false on overflow.\n */\nint /* PRIVATE */\npng_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,\n    png_int_32 divisor)\n{\n   /* Return a * times / divisor, rounded. */\n   if (divisor != 0)\n   {\n      if (a == 0 || times == 0)\n      {\n         *res = 0;\n         return 1;\n      }\n      else\n      {\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n         double r = a;\n         r *= times;\n         r /= divisor;\n         r = floor(r+.5);\n\n         /* A png_fixed_point is a 32-bit integer. */\n         if (r <= 2147483647. && r >= -2147483648.)\n         {\n            *res = (png_fixed_point)r;\n            return 1;\n         }\n#else\n         int negative = 0;\n         png_uint_32 A, T, D;\n         png_uint_32 s16, s32, s00;\n\n         if (a < 0)\n            negative = 1, A = -a;\n         else\n            A = a;\n\n         if (times < 0)\n            negative = !negative, T = -times;\n         else\n            T = times;\n\n         if (divisor < 0)\n            negative = !negative, D = -divisor;\n         else\n            D = divisor;\n\n         /* Following can't overflow because the arguments only\n          * have 31 bits each, however the result may be 32 bits.\n          */\n         s16 = (A >> 16) * (T & 0xffff) +\n                           (A & 0xffff) * (T >> 16);\n         /* Can't overflow because the a*times bit is only 30\n          * bits at most.\n          */\n         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);\n         s00 = (A & 0xffff) * (T & 0xffff);\n\n         s16 = (s16 & 0xffff) << 16;\n         s00 += s16;\n\n         if (s00 < s16)\n            ++s32; /* carry */\n\n         if (s32 < D) /* else overflow */\n         {\n            /* s32.s00 is now the 64-bit product, do a standard\n             * division, we know that s32 < D, so the maximum\n             * required shift is 31.\n             */\n            int bitshift = 32;\n            png_fixed_point result = 0; /* NOTE: signed */\n\n            while (--bitshift >= 0)\n            {\n               png_uint_32 d32, d00;\n\n               if (bitshift > 0)\n                  d32 = D >> (32-bitshift), d00 = D << bitshift;\n\n               else\n                  d32 = 0, d00 = D;\n\n               if (s32 > d32)\n               {\n                  if (s00 < d00) --s32; /* carry */\n                  s32 -= d32, s00 -= d00, result += 1<<bitshift;\n               }\n\n               else\n                  if (s32 == d32 && s00 >= d00)\n                     s32 = 0, s00 -= d00, result += 1<<bitshift;\n            }\n\n            /* Handle the rounding. */\n            if (s00 >= (D >> 1))\n               ++result;\n\n            if (negative != 0)\n               result = -result;\n\n            /* Check for overflow. */\n            if ((negative != 0 && result <= 0) ||\n                (negative == 0 && result >= 0))\n            {\n               *res = result;\n               return 1;\n            }\n         }\n#endif\n      }\n   }\n\n   return 0;\n}\n",
      "line_start": 2766,
      "line_end": 2879,
      "execution_count": 179,
      "covered_regions": 16,
      "total_regions": 25,
      "coverage_percent": 64.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:translate_gamma_flags",
      "clean_name": "translate_gamma_flags",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " *       'gamma' value to be passed as a png_fixed_point number or as one of a\n *       set of integral values for specific \"well known\" examples of transfer\n *       functions.  This is compatible with PNGv3.\n */\nstatic png_fixed_point\ntranslate_gamma_flags(png_fixed_point output_gamma, int is_screen)\n{\n   /* Check for flag values.  The main reason for having the old Mac value as a\n    * flag is that it is pretty near impossible to work out what the correct\n    * value is from Apple documentation - a working Mac system is needed to\n    * discover the value!\n    */\n   if (output_gamma == PNG_DEFAULT_sRGB ||\n      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)\n   {\n      if (is_screen != 0)\n         output_gamma = PNG_GAMMA_sRGB;\n      else\n         output_gamma = PNG_GAMMA_sRGB_INVERSE;\n   }\n\n   else if (output_gamma == PNG_GAMMA_MAC_18 ||\n      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)\n   {\n      if (is_screen != 0)\n         output_gamma = PNG_GAMMA_MAC_OLD;\n      else\n         output_gamma = PNG_GAMMA_MAC_INVERSE;\n   }\n\n   return output_gamma;\n}\n",
      "line_start": 278,
      "line_end": 305,
      "execution_count": 358,
      "covered_regions": 32,
      "total_regions": 50,
      "coverage_percent": 64.0,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_read_finish_row",
      "clean_name": "png_read_finish_row",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      (void)png_crc_finish(png_ptr, png_ptr->idat_size);\n   }\n}\n\nvoid /* PRIVATE */\npng_read_finish_row(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_read_finish_row\");\n   png_ptr->row_number++;\n   if (png_ptr->row_number < png_ptr->num_rows)\n      return;\n\n   if (png_ptr->interlaced != 0)\n   {\n      png_ptr->row_number = 0;\n\n      /* TO DO: don't do this if prev_row isn't needed (requires\n       * read-ahead of the next row's filter byte.\n       */\n      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n      do\n      {\n         png_ptr->pass++;\n\n         if (png_ptr->pass >= 7)\n            break;\n\n         png_ptr->iwidth = (png_ptr->width +\n            png_pass_inc[png_ptr->pass] - 1 -\n            png_pass_start[png_ptr->pass]) /\n            png_pass_inc[png_ptr->pass];\n\n         if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         {\n            png_ptr->num_rows = (png_ptr->height +\n                png_pass_yinc[png_ptr->pass] - 1 -\n                png_pass_ystart[png_ptr->pass]) /\n                png_pass_yinc[png_ptr->pass];\n         }\n\n         else  /* if (png_ptr->transformations & PNG_INTERLACE) */\n            break; /* libpng deinterlacing sees every row */\n\n      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);\n\n      if (png_ptr->pass < 7)\n         return;\n   }\n\n   /* Here after at the end of the last row of the last pass. */\n   png_read_finish_IDAT(png_ptr);\n}\n",
      "line_start": 4368,
      "line_end": 4416,
      "execution_count": 39076,
      "covered_regions": 29,
      "total_regions": 45,
      "coverage_percent": 64.44,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_get_uint_31",
      "clean_name": "png_get_uint_31",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "\n/* TODO: Move these arrays to a common utility module to avoid duplication. */\n#endif\n\npng_uint_32 PNGAPI\npng_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n\n   if (uval > PNG_UINT_31_MAX)\n      png_error(png_ptr, \"PNG unsigned integer out of range\");\n\n   return uval;\n}\n",
      "line_start": 40,
      "line_end": 49,
      "execution_count": 2718,
      "covered_regions": 11,
      "total_regions": 17,
      "coverage_percent": 64.71,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_tRNS",
      "clean_name": "png_handle_tRNS",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_sPLT NULL\n#endif /* READ_sPLT */\n\n#ifdef PNG_READ_tRNS_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_tRNS\");\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_byte buf[2];\n\n      if (length != 2)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return handled_error;\n      }\n\n      png_crc_read(png_ptr, buf, 2);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.gray = png_get_uint_16(buf);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      png_byte buf[6];\n\n      if (length != 6)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return handled_error;\n      }\n\n      png_crc_read(png_ptr, buf, length);\n      png_ptr->num_trans = 1;\n      png_ptr->trans_color.red = png_get_uint_16(buf);\n      png_ptr->trans_color.green = png_get_uint_16(buf + 2);\n      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);\n   }\n\n   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"out of place\");\n         return handled_error;\n      }\n\n      if (length > (unsigned int) png_ptr->num_palette ||\n         length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||\n         length == 0)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"invalid\");\n         return handled_error;\n      }\n\n      png_crc_read(png_ptr, readbuf, length);\n      png_ptr->num_trans = (png_uint_16)length;\n   }\n\n   else\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid with alpha channel\");\n      return handled_error;\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n   {\n      png_ptr->num_trans = 0;\n      return handled_error;\n   }\n\n   /* TODO: this is a horrible side effect in the palette case because the\n    * png_struct ends up with a pointer to the tRNS buffer owned by the\n    * png_info.  Fix this.\n    */\n   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,\n       &(png_ptr->trans_color));\n   return handled_ok;\n}\n",
      "line_start": 1698,
      "line_end": 1781,
      "execution_count": 124,
      "covered_regions": 86,
      "total_regions": 131,
      "coverage_percent": 65.65,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_reset_crc",
      "clean_name": "png_reset_crc",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Reset the CRC variable to 32 bits of 1's.  Care must be taken\n * in case CRC is > 32 bits to leave the top bits 0.\n */\nvoid /* PRIVATE */\npng_reset_crc(png_structrp png_ptr)\n{\n   /* The cast is safe because the crc is a 32-bit value. */\n   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);\n}\n",
      "line_start": 138,
      "line_end": 143,
      "execution_count": 2002,
      "covered_regions": 2,
      "total_regions": 3,
      "coverage_percent": 66.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_update_info",
      "clean_name": "png_read_update_info",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "}\n#endif /* SEQUENTIAL_READ */\n\n/* Optional call to update the users info_ptr structure */\nvoid PNGAPI\npng_read_update_info(png_structrp png_ptr, png_inforp info_ptr)\n{\n   png_debug(1, \"in png_read_update_info\");\n\n   if (png_ptr != NULL)\n   {\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n      {\n         png_read_start_row(png_ptr);\n\n#        ifdef PNG_READ_TRANSFORMS_SUPPORTED\n            png_read_transform_info(png_ptr, info_ptr);\n#        else\n            PNG_UNUSED(info_ptr)\n#        endif\n      }\n\n      /* New in 1.6.0 this avoids the bug of doing the initializations twice */\n      else\n         png_app_error(png_ptr,\n             \"png_read_update_info/png_start_read_image: duplicate call\");\n   }\n}\n",
      "line_start": 169,
      "line_end": 192,
      "execution_count": 358,
      "covered_regions": 16,
      "total_regions": 24,
      "coverage_percent": 66.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_read_destroy",
      "clean_name": "png_read_destroy",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "}\n#endif /* SEQUENTIAL_READ */\n\n/* Free all memory used in the read struct */\nstatic void\npng_read_destroy(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_read_destroy\");\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   png_destroy_gamma_table(png_ptr);\n#endif\n\n   png_free(png_ptr, png_ptr->big_row_buf);\n   png_ptr->big_row_buf = NULL;\n   png_free(png_ptr, png_ptr->big_prev_row);\n   png_ptr->big_prev_row = NULL;\n   png_free(png_ptr, png_ptr->read_buffer);\n   png_ptr->read_buffer = NULL;\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\n   png_free(png_ptr, png_ptr->palette_lookup);\n   png_ptr->palette_lookup = NULL;\n   png_free(png_ptr, png_ptr->quantize_index);\n   png_ptr->quantize_index = NULL;\n#endif\n\n   if ((png_ptr->free_me & PNG_FREE_PLTE) != 0)\n   {\n      png_zfree(png_ptr, png_ptr->palette);\n      png_ptr->palette = NULL;\n   }\n   png_ptr->free_me &= ~PNG_FREE_PLTE;\n\n#if defined(PNG_tRNS_SUPPORTED) || \\\n    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)\n   if ((png_ptr->free_me & PNG_FREE_TRNS) != 0)\n   {\n      png_free(png_ptr, png_ptr->trans_alpha);\n      png_ptr->trans_alpha = NULL;\n   }\n   png_ptr->free_me &= ~PNG_FREE_TRNS;\n#endif\n\n   inflateEnd(&png_ptr->zstream);\n\n#ifdef PNG_PROGRESSIVE_READ_SUPPORTED\n   png_free(png_ptr, png_ptr->save_buffer);\n   png_ptr->save_buffer = NULL;\n#endif\n\n#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) && \\\n   defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)\n   png_free(png_ptr, png_ptr->unknown_chunk.data);\n   png_ptr->unknown_chunk.data = NULL;\n#endif\n\n#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED\n   png_free(png_ptr, png_ptr->chunk_list);\n   png_ptr->chunk_list = NULL;\n#endif\n\n#if defined(PNG_READ_EXPAND_SUPPORTED) && \\\n    (defined(PNG_ARM_NEON_IMPLEMENTATION) || \\\n     defined(PNG_RISCV_RVV_IMPLEMENTATION))\n   png_free(png_ptr, png_ptr->riffled_palette);\n   png_ptr->riffled_palette = NULL;\n#endif\n\n   /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error\n    * callbacks are still set at this point.  They are required to complete the\n    * destruction of the png_struct itself.\n    */\n}\n",
      "line_start": 758,
      "line_end": 827,
      "execution_count": 358,
      "covered_regions": 42,
      "total_regions": 63,
      "coverage_percent": 66.67,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_scale_16",
      "clean_name": "png_set_scale_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * one that pngrtran does first (scale) happens.  This is necessary to allow the\n * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.\n */\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\nvoid PNGAPI\npng_set_scale_16(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_scale_16\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_SCALE_16_TO_8;\n}\n",
      "line_start": 187,
      "line_end": 196,
      "execution_count": 217,
      "covered_regions": 8,
      "total_regions": 12,
      "coverage_percent": 66.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_expand_gray_1_2_4_to_8",
      "clean_name": "png_set_expand_gray_1_2_4_to_8",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n\n/* Expand grayscale images of less than 8-bit depth to 8 bits. */\nvoid PNGAPI\npng_set_expand_gray_1_2_4_to_8(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_expand_gray_1_2_4_to_8\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_EXPAND;\n}\n",
      "line_start": 980,
      "line_end": 989,
      "execution_count": 251,
      "covered_regions": 8,
      "total_regions": 12,
      "coverage_percent": 66.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_image_read_header",
      "clean_name": "png_image_read_header",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   /* Else default to sRGB */\n   return 0;\n}\n\nstatic int\npng_image_read_header(png_voidp argument)\n{\n   png_imagep image = png_voidcast(png_imagep, argument);\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_inforp info_ptr = image->opaque->info_ptr;\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\n   png_set_benign_errors(png_ptr, 1/*warn*/);\n#endif\n   png_read_info(png_ptr, info_ptr);\n\n   /* Do this the fast way; just read directly out of png_struct. */\n   image->width = png_ptr->width;\n   image->height = png_ptr->height;\n\n   {\n      png_uint_32 format = png_image_format(png_ptr);\n\n      image->format = format;\n\n      /* Greyscale images don't (typically) have colour space information and\n       * using it is pretty much impossible, so use sRGB for grayscale (it\n       * doesn't matter r==g==b so the transform is irrelevant.)\n       */\n      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 &&\n          png_image_is_not_sRGB(png_ptr))\n         image->flags |= PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB;\n   }\n\n   /* We need the maximum number of entries regardless of the format the\n    * application sets here.\n    */\n   {\n      png_uint_32 cmap_entries;\n\n      switch (png_ptr->color_type)\n      {\n         case PNG_COLOR_TYPE_GRAY:\n            cmap_entries = 1U << png_ptr->bit_depth;\n            break;\n\n         case PNG_COLOR_TYPE_PALETTE:\n            cmap_entries = (png_uint_32)png_ptr->num_palette;\n            break;\n\n         default:\n            cmap_entries = 256;\n            break;\n      }\n\n      if (cmap_entries > 256)\n         cmap_entries = 256;\n\n      image->colormap_entries = cmap_entries;\n   }\n\n   return 1;\n}\n",
      "line_start": 1275,
      "line_end": 1333,
      "execution_count": 179,
      "covered_regions": 33,
      "total_regions": 49,
      "coverage_percent": 67.35,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_init_gamma_values",
      "clean_name": "png_init_gamma_values",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n   return file_gamma;\n}\n\nstatic int\npng_init_gamma_values(png_structrp png_ptr)\n{\n   /* The following temporary indicates if overall gamma correction is\n    * required.\n    */\n   int gamma_correction = 0;\n   png_fixed_point file_gamma, screen_gamma;\n\n   /* Resolve the file_gamma.  See above: if png_ptr::screen_gamma is set\n    * file_gamma will always be set here:\n    */\n   file_gamma = png_resolve_file_gamma(png_ptr);\n   screen_gamma = png_ptr->screen_gamma;\n\n   if (file_gamma > 0) /* file has been set */\n   {\n      if (screen_gamma > 0) /* screen set too */\n         gamma_correction = png_gamma_threshold(file_gamma, screen_gamma);\n\n      else\n         /* Assume the output matches the input; a long time default behavior\n          * of libpng, although the standard has nothing to say about this.\n          */\n         screen_gamma = png_reciprocal(file_gamma);\n   }\n\n   else /* both unset, prevent corrections: */\n      file_gamma = screen_gamma = PNG_FP_1;\n\n   png_ptr->file_gamma = file_gamma;\n   png_ptr->screen_gamma = screen_gamma;\n   return gamma_correction;\n\n}\n",
      "line_start": 1377,
      "line_end": 1411,
      "execution_count": 358,
      "covered_regions": 17,
      "total_regions": 25,
      "coverage_percent": 68.0,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_reciprocal2",
      "clean_name": "png_reciprocal2",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return 0; /* overflow */\n}\n#endif /* FLOATING_ARITHMETIC */\n\npng_fixed_point\npng_reciprocal2(png_fixed_point a, png_fixed_point b)\n{\n   /* The required result is 1/a * 1/b; the following preserves accuracy. */\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   if (a != 0 && b != 0)\n   {\n      double r = 1E15/a;\n      r /= b;\n      r = floor(r+.5);\n\n      if (r <= 2147483647. && r >= -2147483648.)\n         return (png_fixed_point)r;\n   }\n#else\n   /* This may overflow because the range of png_fixed_point isn't symmetric,\n    * but this API is only used for the product of file and screen gamma so it\n    * doesn't matter that the smallest number it can produce is 1/21474, not\n    * 1/100000\n    */\n   png_fixed_point res = png_product2(a, b);\n\n   if (res != 0)\n      return png_reciprocal(res);\n#endif\n\n   return 0; /* overflow */\n}\n",
      "line_start": 2948,
      "line_end": 2975,
      "execution_count": 94,
      "covered_regions": 13,
      "total_regions": 19,
      "coverage_percent": 68.42,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_cLLI",
      "clean_name": "png_handle_cLLI",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_cICP NULL\n#endif\n\n#ifdef PNG_READ_cLLI_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_cLLI(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[8];\n\n   png_debug(1, \"in png_handle_cLLI\");\n\n   png_crc_read(png_ptr, buf, 8);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* The error checking happens here, this puts it in just one place: */\n   png_set_cLLI_fixed(png_ptr, info_ptr, png_get_uint_32(buf),\n         png_get_uint_32(buf+4));\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1937,
      "line_end": 1954,
      "execution_count": 2,
      "covered_regions": 22,
      "total_regions": 32,
      "coverage_percent": 68.75,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_handle_pHYs",
      "clean_name": "png_handle_pHYs",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_hIST NULL\n#endif\n\n#ifdef PNG_READ_pHYs_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[9];\n   png_uint_32 res_x, res_y;\n   int unit_type;\n\n   png_debug(1, \"in png_handle_pHYs\");\n\n   png_crc_read(png_ptr, buf, 9);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   res_x = png_get_uint_32(buf);\n   res_y = png_get_uint_32(buf + 4);\n   unit_type = buf[8];\n   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 2102,
      "line_end": 2122,
      "execution_count": 2,
      "covered_regions": 22,
      "total_regions": 32,
      "coverage_percent": 68.75,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_gamma_8bit_correct",
      "clean_name": "png_gamma_8bit_correct",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n#endif /* 16BIT */\n#endif /* FLOATING_ARITHMETIC */\n\npng_byte\npng_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)\n{\n   if (value > 0 && value < 255)\n   {\n#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n         /* 'value' is unsigned, ANSI-C90 requires the compiler to correctly\n          * convert this to a floating point value.  This includes values that\n          * would overflow if 'value' were to be converted to 'int'.\n          *\n          * Apparently GCC, however, does an intermediate conversion to (int)\n          * on some (ARM) but not all (x86) platforms, possibly because of\n          * hardware FP limitations.  (E.g. if the hardware conversion always\n          * assumes the integer register contains a signed value.)  This results\n          * in ANSI-C undefined behavior for large values.\n          *\n          * Other implementations on the same machine might actually be ANSI-C90\n          * conformant and therefore compile spurious extra code for the large\n          * values.\n          *\n          * We can be reasonably sure that an unsigned to float conversion\n          * won't be faster than an int to float one.  Therefore this code\n          * assumes responsibility for the undefined behavior, which it knows\n          * can't happen because of the check above.\n          *\n          * Note the argument to this routine is an (unsigned int) because, on\n          * 16-bit platforms, it is assigned a value which might be out of\n          * range for an (int); that would result in undefined behavior in the\n          * caller if the *argument* ('value') were to be declared (int).\n          */\n         double r = floor(255*pow((int)/*SAFE*/value/255.,gamma_val*.00001)+.5);\n         return (png_byte)r;\n#     else\n         png_int_32 lg2 = png_log8bit(value);\n         png_fixed_point res;\n\n         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)\n            return png_exp8bit(res);\n\n         /* Overflow. */\n         value = 0;\n#     endif\n   }\n\n   return (png_byte)(value & 0xff);\n}\n",
      "line_start": 3269,
      "line_end": 3314,
      "execution_count": 15872,
      "covered_regions": 9,
      "total_regions": 13,
      "coverage_percent": 69.23,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_do_scale_16_to_8",
      "clean_name": "png_do_scale_16_to_8",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n/* Scale rows of bit depth 16 down to 8 accurately */\nstatic void\npng_do_scale_16_to_8(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_scale_16_to_8\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep sp = row; /* source */\n      png_bytep dp = row; /* destination */\n      png_bytep ep = sp + row_info->rowbytes; /* end+1 */\n\n      while (sp < ep)\n      {\n         /* The input is an array of 16-bit components, these must be scaled to\n          * 8 bits each.  For a 16-bit value V the required value (from the PNG\n          * specification) is:\n          *\n          *    (V * 255) / 65535\n          *\n          * This reduces to round(V / 257), or floor((V + 128.5)/257)\n          *\n          * Represent V as the two byte value vhi.vlo.  Make a guess that the\n          * result is the top byte of V, vhi, then the correction to this value\n          * is:\n          *\n          *    error = floor(((V-vhi.vhi) + 128.5) / 257)\n          *          = floor(((vlo-vhi) + 128.5) / 257)\n          *\n          * This can be approximated using integer arithmetic (and a signed\n          * shift):\n          *\n          *    error = (vlo-vhi+128) >> 8;\n          *\n          * The approximate differs from the exact answer only when (vlo-vhi) is\n          * 128; it then gives a correction of +1 when the exact correction is\n          * 0.  This gives 128 errors.  The exact answer (correct for all 16-bit\n          * input values) is:\n          *\n          *    error = (vlo-vhi+128)*65535 >> 24;\n          *\n          * An alternative arithmetic calculation which also gives no errors is:\n          *\n          *    (V * 255 + 32895) >> 16\n          */\n\n         png_int_32 tmp = *sp++; /* must be signed! */\n         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;\n         *dp++ = (png_byte)tmp;\n      }\n\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_info->width * row_info->channels;\n   }\n}\n",
      "line_start": 2507,
      "line_end": 2561,
      "execution_count": 20722,
      "covered_regions": 9,
      "total_regions": 13,
      "coverage_percent": 69.23,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_read_filter_row_avg",
      "clean_name": "png_read_filter_row_avg",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_avg(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   size_t istop = row_info->rowbytes - bpp;\n\n   for (i = 0; i < bpp; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         ((int)(*pp++) / 2 )) & 0xff);\n\n      rp++;\n   }\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) +\n         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);\n\n      rp++;\n   }\n}\n",
      "line_start": 3999,
      "line_end": 4024,
      "execution_count": 78,
      "covered_regions": 9,
      "total_regions": 13,
      "coverage_percent": 69.23,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_read_chunk_header",
      "clean_name": "png_read_chunk_header",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "\n/* Read the chunk header (length + type name).\n * Put the type name into png_ptr->chunk_name, and return the length.\n */\npng_uint_32 /* PRIVATE */\npng_read_chunk_header(png_structrp png_ptr)\n{\n   png_byte buf[8];\n   png_uint_32 chunk_name, length;\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;\n#endif\n\n   /* Read the length and the chunk name.  png_struct::chunk_name is immediately\n    * updated even if they are detectably wrong.  This aids error message\n    * handling by allowing png_chunk_error to be used.\n    */\n   png_read_data(png_ptr, buf, 8);\n   length = png_get_uint_31(png_ptr, buf);\n   png_ptr->chunk_name = chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n\n   /* Reset the crc and run it over the chunk name. */\n   png_reset_crc(png_ptr);\n   png_calculate_crc(png_ptr, buf + 4, 4);\n\n   png_debug2(0, \"Reading chunk typeid = 0x%lx, length = %lu\",\n       (unsigned long)png_ptr->chunk_name, (unsigned long)length);\n\n   /* Sanity check the length (first by <= 0x80) and the chunk name.  An error\n    * here indicates a broken stream and libpng has no recovery from this.\n    */\n   if (buf[0] >= 0x80U)\n      png_chunk_error(png_ptr, \"bad header (invalid length)\");\n\n   /* Check to see if chunk name is valid. */\n   if (!check_chunk_name(chunk_name))\n      png_chunk_error(png_ptr, \"bad header (invalid type)\");\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;\n#endif\n\n   return length;\n}\n",
      "line_start": 182,
      "line_end": 222,
      "execution_count": 2002,
      "covered_regions": 37,
      "total_regions": 53,
      "coverage_percent": 69.81,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_calloc",
      "clean_name": "png_calloc",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": " * it not to.  See zconf.h and png.h for more information.  zlib does\n * need to allocate exactly 64K, so whatever you call here must\n * have the ability to do that.\n */\nPNG_FUNCTION(png_voidp,PNGAPI\npng_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)\n{\n   png_voidp ret;\n\n   ret = png_malloc(png_ptr, size);\n\n   if (ret != NULL)\n      memset(ret, 0, size);\n\n   return ret;\n}\n",
      "line_start": 48,
      "line_end": 59,
      "execution_count": 222,
      "covered_regions": 7,
      "total_regions": 10,
      "coverage_percent": 70.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_zlib_inflate",
      "clean_name": "png_zlib_inflate",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * certain circumstances, libpng may end up displaying an invalid image, in\n * contrast to implementations that call zlib in the normal way (e.g. libpng\n * 1.5).\n */\nint /* PRIVATE */\npng_zlib_inflate(png_structrp png_ptr, int flush)\n{\n   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)\n   {\n      if ((*png_ptr->zstream.next_in >> 4) > 7)\n      {\n         png_ptr->zstream.msg = \"invalid window size (libpng)\";\n         return Z_DATA_ERROR;\n      }\n\n      png_ptr->zstream_start = 0;\n   }\n\n   return inflate(&png_ptr->zstream, flush);\n}\n",
      "line_start": 524,
      "line_end": 539,
      "execution_count": 28436,
      "covered_regions": 12,
      "total_regions": 17,
      "coverage_percent": 70.59,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_packing",
      "clean_name": "png_set_packing",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n/* Turn on pixel packing */\nvoid PNGAPI\npng_set_packing(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_packing\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth < 8)\n   {\n      png_ptr->transformations |= PNG_PACK;\n#     ifdef PNG_WRITE_SUPPORTED\n         png_ptr->usr_bit_depth = 8;\n#     endif\n   }\n}\n",
      "line_start": 48,
      "line_end": 63,
      "execution_count": 179,
      "covered_regions": 12,
      "total_regions": 17,
      "coverage_percent": 70.59,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_eXIf_1",
      "clean_name": "png_set_eXIf_1",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "  PNG_UNUSED(info_ptr)\n  PNG_UNUSED(exif)\n}\n\nvoid PNGAPI\npng_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 num_exif, png_bytep exif)\n{\n   png_bytep new_exif;\n\n   png_debug1(1, \"in %s storage function\", \"eXIf\");\n\n   if (png_ptr == NULL || info_ptr == NULL ||\n       (png_ptr->mode & PNG_WROTE_eXIf) != 0)\n      return;\n\n   new_exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr, num_exif));\n\n   if (new_exif == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory for eXIf chunk data\");\n      return;\n   }\n\n   memcpy(new_exif, exif, (size_t)num_exif);\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);\n\n   info_ptr->num_exif = num_exif;\n   info_ptr->exif = new_exif;\n   info_ptr->free_me |= PNG_FREE_EXIF;\n   info_ptr->valid |= PNG_INFO_eXIf;\n}\n",
      "line_start": 327,
      "line_end": 355,
      "execution_count": 1,
      "covered_regions": 32,
      "total_regions": 45,
      "coverage_percent": 71.11,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_bKGD",
      "clean_name": "png_handle_bKGD",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_tRNS NULL\n#endif\n\n#ifdef PNG_READ_bKGD_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int truelen;\n   png_byte buf[6];\n   png_color_16 background;\n\n   png_debug(1, \"in png_handle_bKGD\");\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"out of place\");\n         return handled_error;\n      }\n\n      truelen = 1;\n   }\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      truelen = 6;\n\n   else\n      truelen = 2;\n\n   if (length != truelen)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   png_crc_read(png_ptr, buf, truelen);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* We convert the index value into RGB components so that we can allow\n    * arbitrary RGB values for background when we have transparency, and\n    * so it is easy to determine the RGB values of the background color\n    * from the info_ptr struct.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      background.index = buf[0];\n\n      if (info_ptr != NULL && info_ptr->num_palette != 0)\n      {\n         if (buf[0] >= info_ptr->num_palette)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid index\");\n            return handled_error;\n         }\n\n         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;\n         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;\n         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;\n      }\n\n      else\n         background.red = background.green = background.blue = 0;\n\n      background.gray = 0;\n   }\n\n   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[1] >= (unsigned int)(1 << png_ptr->bit_depth))\n         {\n            png_chunk_benign_error(png_ptr, \"invalid gray level\");\n            return handled_error;\n         }\n      }\n\n      background.index = 0;\n      background.red =\n      background.green =\n      background.blue =\n      background.gray = png_get_uint_16(buf);\n   }\n\n   else\n   {\n      if (png_ptr->bit_depth <= 8)\n      {\n         if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)\n         {\n            png_chunk_benign_error(png_ptr, \"invalid color\");\n            return handled_error;\n         }\n      }\n\n      background.index = 0;\n      background.red = png_get_uint_16(buf);\n      background.green = png_get_uint_16(buf + 2);\n      background.blue = png_get_uint_16(buf + 4);\n      background.gray = 0;\n   }\n\n   png_set_bKGD(png_ptr, info_ptr, &background);\n   return handled_ok;\n}\n",
      "line_start": 1787,
      "line_end": 1892,
      "execution_count": 24,
      "covered_regions": 114,
      "total_regions": 160,
      "coverage_percent": 71.25,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_expand",
      "clean_name": "png_set_expand",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Expand paletted images to RGB, expand grayscale images of\n * less than 8-bit depth to 8-bit depth, and expand tRNS chunks\n * to alpha channels.\n */\nvoid PNGAPI\npng_set_expand(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_expand\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 938,
      "line_end": 947,
      "execution_count": 358,
      "covered_regions": 10,
      "total_regions": 14,
      "coverage_percent": 71.43,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_tRNS_to_alpha",
      "clean_name": "png_set_tRNS_to_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   png_ptr->transformations |= PNG_EXPAND;\n}\n\n/* Expand tRNS chunks to alpha channels. */\nvoid PNGAPI\npng_set_tRNS_to_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_tRNS_to_alpha\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 992,
      "line_end": 1001,
      "execution_count": 179,
      "covered_regions": 10,
      "total_regions": 14,
      "coverage_percent": 71.43,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_gray_to_rgb",
      "clean_name": "png_set_gray_to_rgb",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\nvoid PNGAPI\npng_set_gray_to_rgb(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_gray_to_rgb\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   /* Because rgb must be 8 bits or more: */\n   png_set_expand_gray_1_2_4_to_8(png_ptr);\n   png_ptr->transformations |= PNG_GRAY_TO_RGB;\n}\n",
      "line_start": 1021,
      "line_end": 1032,
      "execution_count": 251,
      "covered_regions": 10,
      "total_regions": 14,
      "coverage_percent": 71.43,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_create_read_struct_2",
      "clean_name": "png_create_read_struct_2",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n/* Alternate create PNG structure for reading, and allocate any memory\n * needed.\n */\nPNG_FUNCTION(png_structp,PNGAPI\npng_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,\n    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,\n    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)\n{\n   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,\n       error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);\n#endif /* USER_MEM */\n\n   if (png_ptr != NULL)\n   {\n      png_ptr->mode = PNG_IS_READ_STRUCT;\n\n      /* Added in libpng-1.6.0; this can be used to detect a read structure if\n       * required (it will be zero in a write structure.)\n       */\n#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n         png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;\n#     endif\n\n#     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED\n         png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;\n\n         /* In stable builds only warn if an application error can be completely\n          * handled.\n          */\n#        if PNG_RELEASE_BUILD\n            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;\n#        endif\n#     endif\n\n      /* TODO: delay this, it can be done in png_init_io (if the app doesn't\n       * do it itself) avoiding setting the default function if it is not\n       * required.\n       */\n      png_set_read_fn(png_ptr, NULL, NULL);\n   }\n\n   return png_ptr;\n}\n",
      "line_start": 39,
      "line_end": 78,
      "execution_count": 358,
      "covered_regions": 18,
      "total_regions": 25,
      "coverage_percent": 72.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_IHDR",
      "clean_name": "png_handle_IHDR",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif /* READ_iCCP */\n\n/* CHUNK HANDLING */\n/* Read and check the IDHR chunk */\nstatic png_handle_result_code\npng_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_byte buf[13];\n   png_uint_32 width, height;\n   int bit_depth, color_type, compression_type, filter_type;\n   int interlace_type;\n\n   png_debug(1, \"in png_handle_IHDR\");\n\n   /* Length and position are checked by the caller. */\n\n   png_ptr->mode |= PNG_HAVE_IHDR;\n\n   png_crc_read(png_ptr, buf, 13);\n   png_crc_finish(png_ptr, 0);\n\n   width = png_get_uint_31(png_ptr, buf);\n   height = png_get_uint_31(png_ptr, buf + 4);\n   bit_depth = buf[8];\n   color_type = buf[9];\n   compression_type = buf[10];\n   filter_type = buf[11];\n   interlace_type = buf[12];\n\n   /* Set internal variables */\n   png_ptr->width = width;\n   png_ptr->height = height;\n   png_ptr->bit_depth = (png_byte)bit_depth;\n   png_ptr->interlaced = (png_byte)interlace_type;\n   png_ptr->color_type = (png_byte)color_type;\n#ifdef PNG_MNG_FEATURES_SUPPORTED\n   png_ptr->filter_type = (png_byte)filter_type;\n#endif\n   png_ptr->compression_type = (png_byte)compression_type;\n\n   /* Find number of channels */\n   switch (png_ptr->color_type)\n   {\n      default: /* invalid, png_set_IHDR calls png_error */\n      case PNG_COLOR_TYPE_GRAY:\n      case PNG_COLOR_TYPE_PALETTE:\n         png_ptr->channels = 1;\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n         png_ptr->channels = 3;\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         png_ptr->channels = 2;\n         break;\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         png_ptr->channels = 4;\n         break;\n   }\n\n   /* Set up other useful info */\n   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);\n   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);\n   png_debug1(3, \"bit_depth = %d\", png_ptr->bit_depth);\n   png_debug1(3, \"channels = %d\", png_ptr->channels);\n   png_debug1(3, \"rowbytes = %lu\", (unsigned long)png_ptr->rowbytes);\n\n   /* Rely on png_set_IHDR to completely validate the data and call png_error if\n    * it's wrong.\n    */\n   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,\n       color_type, interlace_type, compression_type, filter_type);\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 900,
      "line_end": 973,
      "execution_count": 358,
      "covered_regions": 55,
      "total_regions": 76,
      "coverage_percent": 72.37,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png.c:png_build_16to8_table",
      "clean_name": "png_build_16to8_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* NOTE: this function expects the *inverse* of the overall gamma transformation\n * required.\n */\nstatic void\npng_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,\n    unsigned int shift, png_fixed_point gamma_val)\n{\n   unsigned int num = 1U << (8U - shift);\n   unsigned int max = (1U << (16U - shift))-1U;\n   unsigned int i;\n   png_uint_32 last;\n\n   png_uint_16pp table = *ptable =\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\n\n   /* 'num' is the number of tables and also the number of low bits of low\n    * bits of the input 16-bit value used to select a table.  Each table is\n    * itself indexed by the high 8 bits of the value.\n    */\n   for (i = 0; i < num; i++)\n      table[i] = (png_uint_16p)png_malloc(png_ptr,\n          256 * (sizeof (png_uint_16)));\n\n   /* 'gamma_val' is set to the reciprocal of the value calculated above, so\n    * pow(out,g) is an *input* value.  'last' is the last input value set.\n    *\n    * In the loop 'i' is used to find output values.  Since the output is\n    * 8-bit there are only 256 possible values.  The tables are set up to\n    * select the closest possible output value for each input by finding\n    * the input value at the boundary between each pair of output values\n    * and filling the table up to that boundary with the lower output\n    * value.\n    *\n    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit\n    * values the code below uses a 16-bit value in i; the values start at\n    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last\n    * entries are filled with 255).  Start i at 128 and fill all 'last'\n    * table entries <= 'max'\n    */\n   last = 0;\n   for (i = 0; i < 255; ++i) /* 8-bit output value */\n   {\n      /* Find the corresponding maximum input value */\n      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */\n\n      /* Find the boundary value in 16 bits: */\n      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);\n\n      /* Adjust (round) to (16-shift) bits: */\n      bound = (bound * max + 32768U)/65535U + 1U;\n\n      while (last < bound)\n      {\n         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;\n         last++;\n      }\n   }\n\n   /* And fill in the final entries. */\n   while (last < (num << 8))\n   {\n      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;\n      last++;\n   }\n}\n",
      "line_start": 3454,
      "line_end": 3515,
      "execution_count": 32,
      "covered_regions": 21,
      "total_regions": 29,
      "coverage_percent": 72.41,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_malloc_base",
      "clean_name": "png_malloc_base",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": " * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.\n * Checking and error handling must happen outside this routine; it returns NULL\n * if the allocation cannot be done (for any reason.)\n */\nPNG_FUNCTION(png_voidp /* PRIVATE */,\npng_malloc_base,(png_const_structrp png_ptr, png_alloc_size_t size),\n    PNG_ALLOCATED)\n{\n   /* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS\n    * allocators have also been removed in 1.6.0, so any 16-bit system now has\n    * to implement a user memory handler.  This checks to be sure it isn't\n    * called with big numbers.\n    */\n#  ifdef PNG_MAX_MALLOC_64K\n      /* This is support for legacy systems which had segmented addressing\n       * limiting the maximum allocation size to 65536.  It takes precedence\n       * over PNG_SIZE_MAX which is set to 65535 on true 16-bit systems.\n       *\n       * TODO: libpng-1.8: finally remove both cases.\n       */\n      if (size > 65536U) return NULL;\n#  endif\n\n   /* This is checked too because the system malloc call below takes a (size_t).\n    */\n   if (size > PNG_SIZE_MAX) return NULL;\n\n#  ifdef PNG_USER_MEM_SUPPORTED\n      if (png_ptr != NULL && png_ptr->malloc_fn != NULL)\n         return png_ptr->malloc_fn(png_constcast(png_structrp,png_ptr), size);\n#  else\n      PNG_UNUSED(png_ptr)\n#  endif\n\n   /* Use the system malloc */\n   return malloc((size_t)/*SAFE*/size); /* checked for truncation above */\n}\n",
      "line_start": 66,
      "line_end": 98,
      "execution_count": 5085,
      "covered_regions": 19,
      "total_regions": 26,
      "coverage_percent": 73.08,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_read_filter_row_paeth_1byte_pixel",
      "clean_name": "png_read_filter_row_paeth_1byte_pixel",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   png_bytep rp_end = row + row_info->rowbytes;\n   int a, c;\n\n   /* First pixel/byte */\n   c = *prev_row++;\n   a = *row + c;\n   *row++ = (png_byte)a;\n\n   /* Remainder */\n   while (row < rp_end)\n   {\n      int b, pa, pb, pc, p;\n\n      a &= 0xff; /* From previous iteration or start */\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      /* Find the best predictor, the least of pa, pb, pc favoring the earlier\n       * ones in the case of a tie.\n       */\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      /* Calculate the current pixel in a, and move the previous row pixel to c\n       * for the next time round the loop\n       */\n      c = b;\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n",
      "line_start": 4026,
      "line_end": 4075,
      "execution_count": 122,
      "covered_regions": 22,
      "total_regions": 30,
      "coverage_percent": 73.33,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_read_filter_row_paeth_multibyte_pixel",
      "clean_name": "png_read_filter_row_paeth_multibyte_pixel",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp_end = row + bpp;\n\n   /* Process the first pixel in the row completely (this is the same as 'up'\n    * because there is only one candidate predictor for the first row).\n    */\n   while (row < rp_end)\n   {\n      int a = *row + *prev_row++;\n      *row++ = (png_byte)a;\n   }\n\n   /* Remainder */\n   rp_end = rp_end + (row_info->rowbytes - bpp);\n\n   while (row < rp_end)\n   {\n      int a, b, c, pa, pb, pc, p;\n\n      c = *(prev_row - bpp);\n      a = *(row - bpp);\n      b = *prev_row++;\n\n      p = b - c;\n      pc = a - c;\n\n#ifdef PNG_USE_ABS\n      pa = abs(p);\n      pb = abs(pc);\n      pc = abs(p + pc);\n#else\n      pa = p < 0 ? -p : p;\n      pb = pc < 0 ? -pc : pc;\n      pc = (p + pc) < 0 ? -(p + pc) : p + pc;\n#endif\n\n      if (pb < pa)\n      {\n         pa = pb; a = b;\n      }\n      if (pc < pa) a = c;\n\n      a += *row;\n      *row++ = (png_byte)a;\n   }\n}\n",
      "line_start": 4077,
      "line_end": 4126,
      "execution_count": 996,
      "covered_regions": 25,
      "total_regions": 34,
      "coverage_percent": 73.53,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_cHRM_fixed",
      "clean_name": "png_set_cHRM_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_cHRM_SUPPORTED\nvoid PNGFAPI\npng_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,\n    png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,\n    png_fixed_point blue_x, png_fixed_point blue_y)\n{\n   png_debug1(1, \"in %s storage function\", \"cHRM fixed\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->cHRM.redx = red_x;\n   info_ptr->cHRM.redy = red_y;\n   info_ptr->cHRM.greenx = green_x;\n   info_ptr->cHRM.greeny = green_y;\n   info_ptr->cHRM.bluex = blue_x;\n   info_ptr->cHRM.bluey = blue_y;\n   info_ptr->cHRM.whitex = white_x;\n   info_ptr->cHRM.whitey = white_y;\n\n   info_ptr->valid |= PNG_INFO_cHRM;\n}\n",
      "line_start": 38,
      "line_end": 59,
      "execution_count": 108,
      "covered_regions": 14,
      "total_regions": 19,
      "coverage_percent": 73.68,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_chunk_index_from_name",
      "clean_name": "png_chunk_index_from_name",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  undef PNG_CHUNK\n};\n\n\nstatic png_index\npng_chunk_index_from_name(png_uint_32 chunk_name)\n{\n   /* For chunk png_cHNK return PNG_INDEX_cHNK.  Return PNG_INDEX_unknown if\n    * chunk_name is not known.  Notice that in a particular build \"known\" does\n    * not necessarily mean \"supported\", although the inverse applies.\n    */\n   switch (chunk_name)\n   {\n#     define PNG_CHUNK(cHNK, index)\\\n         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; /* == index */\n\n      PNG_KNOWN_CHUNKS\n\n#     undef PNG_CHUNK\n\n      default: return PNG_INDEX_unknown;\n   }\n}\n",
      "line_start": 3098,
      "line_end": 3116,
      "execution_count": 1642,
      "covered_regions": 421,
      "total_regions": 569,
      "coverage_percent": 73.99,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_destroy_info_struct",
      "clean_name": "png_destroy_info_struct",
      "source_file": "/src/libpng/png.c",
      "source_code": " * internally to implement the png_info release part of the 'struct' destroy\n * APIs.  This ensures that all possible approaches free the same data (all of\n * it).\n */\nvoid PNGAPI\npng_destroy_info_struct(png_const_structrp png_ptr, png_infopp info_ptr_ptr)\n{\n   png_inforp info_ptr = NULL;\n\n   png_debug(1, \"in png_destroy_info_struct\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (info_ptr_ptr != NULL)\n      info_ptr = *info_ptr_ptr;\n\n   if (info_ptr != NULL)\n   {\n      /* Do this first in case of an error below; if the app implements its own\n       * memory management this can lead to png_free calling png_error, which\n       * will abort this routine and return control to the app error handler.\n       * An infinite loop may result if it then tries to free the same info\n       * ptr.\n       */\n      *info_ptr_ptr = NULL;\n\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);\n      memset(info_ptr, 0, (sizeof *info_ptr));\n      png_free(png_ptr, info_ptr);\n   }\n}\n",
      "line_start": 395,
      "line_end": 422,
      "execution_count": 716,
      "covered_regions": 23,
      "total_regions": 31,
      "coverage_percent": 74.19,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_read_start_row",
      "clean_name": "png_read_start_row",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   png_read_finish_IDAT(png_ptr);\n}\n#endif /* SEQUENTIAL_READ */\n\nvoid /* PRIVATE */\npng_read_start_row(png_structrp png_ptr)\n{\n   unsigned int max_pixel_depth;\n   size_t row_bytes;\n\n   png_debug(1, \"in png_read_start_row\");\n\n#ifdef PNG_READ_TRANSFORMS_SUPPORTED\n   png_init_read_transformations(png_ptr);\n#endif\n   if (png_ptr->interlaced != 0)\n   {\n      if ((png_ptr->transformations & PNG_INTERLACE) == 0)\n         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -\n             png_pass_ystart[0]) / png_pass_yinc[0];\n\n      else\n         png_ptr->num_rows = png_ptr->height;\n\n      png_ptr->iwidth = (png_ptr->width +\n          png_pass_inc[png_ptr->pass] - 1 -\n          png_pass_start[png_ptr->pass]) /\n          png_pass_inc[png_ptr->pass];\n   }\n\n   else\n   {\n      png_ptr->num_rows = png_ptr->height;\n      png_ptr->iwidth = png_ptr->width;\n   }\n\n   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;\n\n   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of\n    * calculations to calculate the final pixel depth, then\n    * png_do_read_transforms actually does the transforms.  This means that the\n    * code which effectively calculates this value is actually repeated in three\n    * separate places.  They must all match.  Innocent changes to the order of\n    * transformations can and will break libpng in a way that causes memory\n    * overwrites.\n    *\n    * TODO: fix this.\n    */\n#ifdef PNG_READ_PACK_SUPPORTED\n   if ((png_ptr->transformations & PNG_PACK) != 0 && png_ptr->bit_depth < 8)\n      max_pixel_depth = 8;\n#endif\n\n#ifdef PNG_READ_EXPAND_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 24;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth < 8)\n            max_pixel_depth = 8;\n\n         if (png_ptr->num_trans != 0)\n            max_pixel_depth *= 2;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)\n      {\n         if (png_ptr->num_trans != 0)\n         {\n            max_pixel_depth *= 4;\n            max_pixel_depth /= 3;\n         }\n      }\n   }\n#endif\n\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)\n   {\n#  ifdef PNG_READ_EXPAND_SUPPORTED\n      /* In fact it is an error if it isn't supported, but checking is\n       * the safe way.\n       */\n      if ((png_ptr->transformations & PNG_EXPAND) != 0)\n      {\n         if (png_ptr->bit_depth < 16)\n            max_pixel_depth *= 2;\n      }\n      else\n#  endif\n      png_ptr->transformations &= ~PNG_EXPAND_16;\n   }\n#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n   if ((png_ptr->transformations & (PNG_FILLER)) != 0)\n   {\n      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (max_pixel_depth <= 8)\n            max_pixel_depth = 16;\n\n         else\n            max_pixel_depth = 32;\n      }\n\n      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||\n         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (max_pixel_depth <= 32)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n   }\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n   {\n      if (\n#ifdef PNG_READ_EXPAND_SUPPORTED\n          (png_ptr->num_trans != 0 &&\n          (png_ptr->transformations & PNG_EXPAND) != 0) ||\n#endif\n#ifdef PNG_READ_FILLER_SUPPORTED\n          (png_ptr->transformations & (PNG_FILLER)) != 0 ||\n#endif\n          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         if (max_pixel_depth <= 16)\n            max_pixel_depth = 32;\n\n         else\n            max_pixel_depth = 64;\n      }\n\n      else\n      {\n         if (max_pixel_depth <= 8)\n         {\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n               max_pixel_depth = 32;\n\n            else\n               max_pixel_depth = 24;\n         }\n\n         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            max_pixel_depth = 64;\n\n         else\n            max_pixel_depth = 48;\n      }\n   }\n#endif\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \\\ndefined(PNG_USER_TRANSFORM_PTR_SUPPORTED)\n   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)\n   {\n      unsigned int user_pixel_depth = png_ptr->user_transform_depth *\n         png_ptr->user_transform_channels;\n\n      if (user_pixel_depth > max_pixel_depth)\n         max_pixel_depth = user_pixel_depth;\n   }\n#endif\n\n   /* This value is stored in png_struct and double checked in the row read\n    * code.\n    */\n   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;\n   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */\n\n   /* Align the width on the next larger 8 pixels.  Mainly used\n    * for interlacing\n    */\n   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));\n   /* Calculate the maximum bytes needed, adding a byte and a pixel\n    * for safety's sake\n    */\n   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +\n       1 + ((max_pixel_depth + 7) >> 3U);\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (row_bytes > (png_uint_32)65536L)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n#endif\n\n   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)\n   {\n      png_free(png_ptr, png_ptr->big_row_buf);\n      png_free(png_ptr, png_ptr->big_prev_row);\n\n      if (png_ptr->interlaced != 0)\n         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,\n             row_bytes + 48);\n\n      else\n         png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n      png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);\n\n#ifdef PNG_ALIGNED_MEMORY_SUPPORTED\n      /* Use 16-byte aligned memory for row_buf with at least 16 bytes\n       * of padding before and after row_buf; treat prev_row similarly.\n       * NOTE: the alignment is to the start of the pixels, one beyond the start\n       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this\n       * was incorrect; the filter byte was aligned, which had the exact\n       * opposite effect of that intended.\n       */\n      {\n         png_bytep temp = png_ptr->big_row_buf + 32;\n         size_t extra = (size_t)temp & 0x0f;\n         png_ptr->row_buf = temp - extra - 1/*filter byte*/;\n\n         temp = png_ptr->big_prev_row + 32;\n         extra = (size_t)temp & 0x0f;\n         png_ptr->prev_row = temp - extra - 1/*filter byte*/;\n      }\n#else\n      /* Use 31 bytes of padding before and 17 bytes after row_buf. */\n      png_ptr->row_buf = png_ptr->big_row_buf + 31;\n      png_ptr->prev_row = png_ptr->big_prev_row + 31;\n#endif\n      png_ptr->old_big_row_buf_size = row_bytes + 48;\n   }\n\n#ifdef PNG_MAX_MALLOC_64K\n   if (png_ptr->rowbytes > 65535)\n      png_error(png_ptr, \"This image requires a row greater than 64KB\");\n\n#endif\n   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))\n      png_error(png_ptr, \"Row has too many bytes to allocate in memory\");\n\n   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);\n\n   png_debug1(3, \"width = %u,\", png_ptr->width);\n   png_debug1(3, \"height = %u,\", png_ptr->height);\n   png_debug1(3, \"iwidth = %u,\", png_ptr->iwidth);\n   png_debug1(3, \"num_rows = %u,\", png_ptr->num_rows);\n   png_debug1(3, \"rowbytes = %lu,\", (unsigned long)png_ptr->rowbytes);\n   png_debug1(3, \"irowbytes = %lu\",\n       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);\n\n   /* The sequential reader needs a buffer for IDAT, but the progressive reader\n    * does not, so free the read buffer now regardless; the sequential reader\n    * reallocates it on demand.\n    */\n   if (png_ptr->read_buffer != NULL)\n   {\n      png_bytep buffer = png_ptr->read_buffer;\n\n      png_ptr->read_buffer_size = 0;\n      png_ptr->read_buffer = NULL;\n      png_free(png_ptr, buffer);\n   }\n\n   /* Finally claim the zstream for the inflate of the IDAT data, use the bits\n    * value from the stream (note that this will result in a fatal error if the\n    * IDAT stream has a bogus deflate header window_bits value, but this should\n    * not be happening any longer!)\n    */\n   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)\n      png_error(png_ptr, png_ptr->zstream.msg);\n\n   png_ptr->flags |= PNG_FLAG_ROW_INIT;\n}\n",
      "line_start": 4419,
      "line_end": 4694,
      "execution_count": 358,
      "covered_regions": 233,
      "total_regions": 312,
      "coverage_percent": 74.68,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_destroy_png_struct",
      "clean_name": "png_destroy_png_struct",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "#include \"pngpriv.h\"\n\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n/* Free a png_struct */\nvoid /* PRIVATE */\npng_destroy_png_struct(png_structrp png_ptr)\n{\n   if (png_ptr != NULL)\n   {\n      /* png_free might call png_error and may certainly call\n       * png_get_mem_ptr, so fake a temporary png_struct to support this.\n       */\n      png_struct dummy_struct = *png_ptr;\n      memset(png_ptr, 0, (sizeof *png_ptr));\n      png_free(&dummy_struct, png_ptr);\n\n#     ifdef PNG_SETJMP_SUPPORTED\n         /* We may have a jmp_buf left to deallocate. */\n         png_free_jmpbuf(&dummy_struct);\n#     endif\n   }\n}\n",
      "line_start": 23,
      "line_end": 40,
      "execution_count": 358,
      "covered_regions": 9,
      "total_regions": 12,
      "coverage_percent": 75.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_crc_read",
      "clean_name": "png_crc_read",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   return length;\n}\n\n/* Read data, and (optionally) run it through the CRC. */\nvoid /* PRIVATE */\npng_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_read_data(png_ptr, buf, length);\n   png_calculate_crc(png_ptr, buf, length);\n}\n",
      "line_start": 225,
      "line_end": 233,
      "execution_count": 1823,
      "covered_regions": 9,
      "total_regions": 12,
      "coverage_percent": 75.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrtran.c:png_do_expand_palette",
      "clean_name": "png_do_expand_palette",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_EXPAND_SUPPORTED\n/* Expands a palette row to an RGB or RGBA row depending\n * upon whether you supply trans and num_trans.\n */\nstatic void\npng_do_expand_palette(png_structrp png_ptr, png_row_infop row_info,\n    png_bytep row, png_const_colorp palette, png_const_bytep trans_alpha,\n    int num_trans)\n{\n   int shift, value;\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_expand_palette\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)\n   {\n      if (row_info->bit_depth < 8)\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               sp = row + (size_t)((row_width - 1) >> 3);\n               dp = row + (size_t)row_width - 1;\n               shift = 7 - (int)((row_width + 7) & 0x07);\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((*sp >> shift) & 0x01)\n                     *dp = 1;\n\n                  else\n                     *dp = 0;\n\n                  if (shift == 7)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift++;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n               sp = row + (size_t)((row_width - 1) >> 2);\n               dp = row + (size_t)row_width - 1;\n               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x03;\n                  *dp = (png_byte)value;\n                  if (shift == 6)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 2;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 4:\n            {\n               sp = row + (size_t)((row_width - 1) >> 1);\n               dp = row + (size_t)row_width - 1;\n               shift = (int)((row_width & 0x01) << 2);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x0f;\n                  *dp = (png_byte)value;\n                  if (shift == 4)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 4;\n\n                  dp--;\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n         row_info->bit_depth = 8;\n         row_info->pixel_depth = 8;\n         row_info->rowbytes = row_width;\n      }\n\n      if (row_info->bit_depth == 8)\n      {\n         {\n            if (num_trans > 0)\n            {\n               sp = row + (size_t)row_width - 1;\n               dp = row + ((size_t)row_width << 2) - 1;\n\n               i = 0;\n#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE\n               if (png_ptr->riffled_palette != NULL)\n               {\n                  /* The RGBA optimization works with png_ptr->bit_depth == 8\n                   * but sometimes row_info->bit_depth has been changed to 8.\n                   * In these cases, the palette hasn't been riffled.\n                   */\n                  i = png_do_expand_palette_rgba8_neon(png_ptr, row_info, row,\n                      &sp, &dp);\n               }\n#else\n               PNG_UNUSED(png_ptr)\n#endif\n\n               for (; i < row_width; i++)\n               {\n                  if ((int)(*sp) >= num_trans)\n                     *dp-- = 0xff;\n                  else\n                     *dp-- = trans_alpha[*sp];\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 32;\n               row_info->rowbytes = row_width * 4;\n               row_info->color_type = 6;\n               row_info->channels = 4;\n            }\n\n            else\n            {\n               sp = row + (size_t)row_width - 1;\n               dp = row + (size_t)(row_width * 3) - 1;\n               i = 0;\n#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE\n               i = png_do_expand_palette_rgb8_neon(png_ptr, row_info, row,\n                   &sp, &dp);\n#else\n               PNG_UNUSED(png_ptr)\n#endif\n\n               for (; i < row_width; i++)\n               {\n                  *dp-- = palette[*sp].blue;\n                  *dp-- = palette[*sp].green;\n                  *dp-- = palette[*sp].red;\n                  sp--;\n               }\n\n               row_info->bit_depth = 8;\n               row_info->pixel_depth = 24;\n               row_info->rowbytes = row_width * 3;\n               row_info->color_type = 2;\n               row_info->channels = 3;\n            }\n         }\n      }\n   }\n}\n",
      "line_start": 4327,
      "line_end": 4496,
      "execution_count": 3662,
      "covered_regions": 79,
      "total_regions": 105,
      "coverage_percent": 75.24,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_add_alpha",
      "clean_name": "png_set_add_alpha",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;\n}\n\n/* Added to libpng-1.2.7 */\nvoid PNGAPI\npng_set_add_alpha(png_structrp png_ptr, png_uint_32 filler, int filler_loc)\n{\n   png_debug(1, \"in png_set_add_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_set_filler(png_ptr, filler, filler_loc);\n   /* The above may fail to do anything. */\n   if ((png_ptr->transformations & PNG_FILLER) != 0)\n      png_ptr->transformations |= PNG_ADD_ALPHA;\n}\n",
      "line_start": 203,
      "line_end": 215,
      "execution_count": 92,
      "covered_regions": 16,
      "total_regions": 21,
      "coverage_percent": 76.19,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_get_rowbytes",
      "clean_name": "png_get_rowbytes",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\nsize_t PNGAPI\npng_get_rowbytes(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->rowbytes;\n\n   return 0;\n}\n",
      "line_start": 39,
      "line_end": 46,
      "execution_count": 184,
      "covered_regions": 10,
      "total_regions": 13,
      "coverage_percent": 76.92,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_free_default",
      "clean_name": "png_free_default",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "   else\n      png_free_default(png_ptr, ptr);\n}\n\nPNG_FUNCTION(void,PNGAPI\npng_free_default,(png_const_structrp png_ptr, png_voidp ptr),PNG_DEPRECATED)\n{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n#endif /* USER_MEM */\n\n   free(ptr);\n}\n",
      "line_start": 243,
      "line_end": 251,
      "execution_count": 2717,
      "covered_regions": 10,
      "total_regions": 13,
      "coverage_percent": 76.92,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_image_skip_unused_chunks",
      "clean_name": "png_image_skip_unused_chunks",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "/* Utility function to skip chunks that are not used by the simplified image\n * read functions and an appropriate macro to call it.\n */\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\nstatic void\npng_image_skip_unused_chunks(png_structrp png_ptr)\n{\n   /* Prepare the reader to ignore all recognized chunks whose data will not\n    * be used, i.e., all chunks recognized by libpng except for those\n    * involved in basic image reading:\n    *\n    *    IHDR, PLTE, IDAT, IEND\n    *\n    * Or image data handling:\n    *\n    *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.\n    *\n    * This provides a small performance improvement and eliminates any\n    * potential vulnerability to security problems in the unused chunks.\n    *\n    * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored\n    * too.  This allows the simplified API to be compiled without iCCP support.\n    */\n   {\n         static const png_byte chunks_to_process[] = {\n            98,  75,  71,  68, '\\0',  /* bKGD */\n            99,  72,  82,  77, '\\0',  /* cHRM */\n            99,  73,  67,  80, '\\0',  /* cICP */\n           103,  65,  77,  65, '\\0',  /* gAMA */\n           109,  68,  67,  86, '\\0',  /* mDCV */\n           115,  66,  73,  84, '\\0',  /* sBIT */\n           115,  82,  71,  66, '\\0',  /* sRGB */\n         };\n\n       /* Ignore unknown chunks and all other chunks except for the\n        * IHDR, PLTE, tRNS, IDAT, and IEND chunks.\n        */\n       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,\n           NULL, -1);\n\n       /* But do not ignore image data handling chunks */\n       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,\n           chunks_to_process, (int)/*SAFE*/(sizeof chunks_to_process)/5);\n   }\n}\n",
      "line_start": 1473,
      "line_end": 1513,
      "execution_count": 179,
      "covered_regions": 10,
      "total_regions": 13,
      "coverage_percent": 76.92,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_tRNS",
      "clean_name": "png_set_tRNS",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\nvoid PNGAPI\npng_set_tRNS(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)\n{\n   png_debug1(1, \"in %s storage function\", \"tRNS\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n\n      return;\n\n   if (trans_alpha != NULL)\n   {\n       /* It may not actually be necessary to set png_ptr->trans_alpha here;\n        * we do it for backward compatibility with the way the png_handle_tRNS\n        * function used to do the allocation.\n        *\n        * 1.6.0: The above statement is incorrect; png_handle_tRNS effectively\n        * relies on png_set_tRNS storing the information in png_struct\n        * (otherwise it won't be there for the code in pngrtran.c).\n        */\n\n       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);\n\n       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)\n       {\n         /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */\n          info_ptr->trans_alpha = png_voidcast(png_bytep,\n              png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));\n          memcpy(info_ptr->trans_alpha, trans_alpha, (size_t)num_trans);\n\n          info_ptr->free_me |= PNG_FREE_TRNS;\n          info_ptr->valid |= PNG_INFO_tRNS;\n       }\n       png_ptr->trans_alpha = info_ptr->trans_alpha;\n   }\n\n   if (trans_color != NULL)\n   {\n#ifdef PNG_WARNINGS_SUPPORTED\n      if (info_ptr->bit_depth < 16)\n      {\n         int sample_max = (1 << info_ptr->bit_depth) - 1;\n\n         if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&\n             trans_color->gray > sample_max) ||\n             (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\n             (trans_color->red > sample_max ||\n             trans_color->green > sample_max ||\n             trans_color->blue > sample_max)))\n            png_warning(png_ptr,\n                \"tRNS chunk has out-of-range samples for bit_depth\");\n      }\n#endif\n\n      info_ptr->trans_color = *trans_color;\n\n      if (num_trans == 0)\n         num_trans = 1;\n   }\n\n   info_ptr->num_trans = (png_uint_16)num_trans;\n\n   if (num_trans != 0)\n   {\n      info_ptr->free_me |= PNG_FREE_TRNS;\n      info_ptr->valid |= PNG_INFO_tRNS;\n   }\n}\n",
      "line_start": 1145,
      "line_end": 1212,
      "execution_count": 124,
      "covered_regions": 73,
      "total_regions": 94,
      "coverage_percent": 77.66,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_get_IHDR",
      "clean_name": "png_get_IHDR",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n#endif\n\npng_uint_32 PNGAPI\npng_get_IHDR(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *width, png_uint_32 *height, int *bit_depth,\n    int *color_type, int *interlace_type, int *compression_type,\n    int *filter_type)\n{\n   png_debug1(1, \"in %s retrieval function\", \"IHDR\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return 0;\n\n   if (width != NULL)\n       *width = info_ptr->width;\n\n   if (height != NULL)\n       *height = info_ptr->height;\n\n   if (bit_depth != NULL)\n       *bit_depth = info_ptr->bit_depth;\n\n   if (color_type != NULL)\n       *color_type = info_ptr->color_type;\n\n   if (compression_type != NULL)\n      *compression_type = info_ptr->compression_type;\n\n   if (filter_type != NULL)\n      *filter_type = info_ptr->filter_type;\n\n   if (interlace_type != NULL)\n      *interlace_type = info_ptr->interlace_type;\n\n   /* This is redundant if we can be sure that the info_ptr values were all\n    * assigned in png_set_IHDR().  We do the check anyhow in case an\n    * application has ignored our advice not to mess with the members\n    * of info_ptr directly.\n    */\n   png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height,\n       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\n       info_ptr->compression_type, info_ptr->filter_type);\n\n   return 1;\n}\n",
      "line_start": 938,
      "line_end": 980,
      "execution_count": 179,
      "covered_regions": 42,
      "total_regions": 54,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_read_filter_row_sub",
      "clean_name": "png_read_filter_row_sub",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n}\n#endif /* READ_INTERLACING */\n\nstatic void\npng_read_filter_row_sub(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;\n   png_bytep rp = row + bpp;\n\n   PNG_UNUSED(prev_row)\n\n   for (i = bpp; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);\n      rp++;\n   }\n}\n",
      "line_start": 3965,
      "line_end": 3981,
      "execution_count": 644,
      "covered_regions": 7,
      "total_regions": 9,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_read_buffer",
      "clean_name": "png_read_buffer",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * enough (or if it is not allocated).  The routine returns a pointer to the\n * buffer; if an error occurs and 'warn' is set the routine returns NULL, else\n * it will call png_error on failure.\n */\nstatic png_bytep\npng_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size)\n{\n   png_bytep buffer = png_ptr->read_buffer;\n\n   if (new_size > png_chunk_max(png_ptr)) return NULL;\n\n   if (buffer != NULL && new_size > png_ptr->read_buffer_size)\n   {\n      png_ptr->read_buffer = NULL;\n      png_ptr->read_buffer_size = 0;\n      png_free(png_ptr, buffer);\n      buffer = NULL;\n   }\n\n   if (buffer == NULL)\n   {\n      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));\n\n      if (buffer != NULL)\n      {\n#        ifndef PNG_NO_MEMZERO /* for detecting UIM bugs **only** */\n            memset(buffer, 0, new_size); /* just in case */\n#        endif\n         png_ptr->read_buffer = buffer;\n         png_ptr->read_buffer_size = new_size;\n      }\n   }\n\n   return buffer;\n}\n",
      "line_start": 375,
      "line_end": 405,
      "execution_count": 823,
      "covered_regions": 28,
      "total_regions": 36,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_gAMA_fixed",
      "clean_name": "png_set_gAMA_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* eXIf */\n\n#ifdef PNG_gAMA_SUPPORTED\nvoid PNGFAPI\npng_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_fixed_point file_gamma)\n{\n   png_debug1(1, \"in %s storage function\", \"gAMA\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->gamma = file_gamma;\n   info_ptr->valid |= PNG_INFO_gAMA;\n}\n",
      "line_start": 359,
      "line_end": 370,
      "execution_count": 172,
      "covered_regions": 14,
      "total_regions": 18,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_oFFs",
      "clean_name": "png_set_oFFs",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\n}\n\n#ifdef PNG_oFFs_SUPPORTED\nvoid PNGAPI\npng_set_oFFs(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_int_32 offset_x, png_int_32 offset_y, int unit_type)\n{\n   png_debug1(1, \"in %s storage function\", \"oFFs\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->x_offset = offset_x;\n   info_ptr->y_offset = offset_y;\n   info_ptr->offset_unit_type = (png_byte)unit_type;\n   info_ptr->valid |= PNG_INFO_oFFs;\n}\n",
      "line_start": 466,
      "line_end": 479,
      "execution_count": 2,
      "covered_regions": 14,
      "total_regions": 18,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_pHYs",
      "clean_name": "png_set_pHYs",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif\n#endif\n\n#ifdef PNG_pHYs_SUPPORTED\nvoid PNGAPI\npng_set_pHYs(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 res_x, png_uint_32 res_y, int unit_type)\n{\n   png_debug1(1, \"in %s storage function\", \"pHYs\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->x_pixels_per_unit = res_x;\n   info_ptr->y_pixels_per_unit = res_y;\n   info_ptr->phys_unit_type = (png_byte)unit_type;\n   info_ptr->valid |= PNG_INFO_pHYs;\n}\n",
      "line_start": 724,
      "line_end": 737,
      "execution_count": 2,
      "covered_regions": 14,
      "total_regions": 18,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_sRGB",
      "clean_name": "png_set_sRGB",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sRGB_SUPPORTED\nvoid PNGAPI\npng_set_sRGB(png_const_structrp png_ptr, png_inforp info_ptr, int srgb_intent)\n{\n   png_debug1(1, \"in %s storage function\", \"sRGB\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->rendering_intent = srgb_intent;\n   info_ptr->valid |= PNG_INFO_sRGB;\n}\n",
      "line_start": 820,
      "line_end": 830,
      "execution_count": 58,
      "covered_regions": 14,
      "total_regions": 18,
      "coverage_percent": 77.78,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngset.c:add_one_chunk",
      "clean_name": "add_one_chunk",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED\nstatic unsigned int\nadd_one_chunk(png_bytep list, unsigned int count, png_const_bytep add, int keep)\n{\n   unsigned int i;\n\n   /* Utility function: update the 'keep' state of a chunk if it is already in\n    * the list, otherwise add it to the list.\n    */\n   for (i=0; i<count; ++i, list += 5)\n   {\n      if (memcmp(list, add, 4) == 0)\n      {\n         list[4] = (png_byte)keep;\n\n         return count;\n      }\n   }\n\n   if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)\n   {\n      ++count;\n      memcpy(list, add, 4);\n      list[4] = (png_byte)keep;\n   }\n\n   return count;\n}\n",
      "line_start": 1500,
      "line_end": 1526,
      "execution_count": 5012,
      "covered_regions": 15,
      "total_regions": 19,
      "coverage_percent": 78.95,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_set_IHDR",
      "clean_name": "png_set_IHDR",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_hIST;\n}\n#endif\n\nvoid PNGAPI\npng_set_IHDR(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_uint_32 width, png_uint_32 height, int bit_depth,\n    int color_type, int interlace_type, int compression_type,\n    int filter_type)\n{\n   png_debug1(1, \"in %s storage function\", \"IHDR\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   info_ptr->width = width;\n   info_ptr->height = height;\n   info_ptr->bit_depth = (png_byte)bit_depth;\n   info_ptr->color_type = (png_byte)color_type;\n   info_ptr->compression_type = (png_byte)compression_type;\n   info_ptr->filter_type = (png_byte)filter_type;\n   info_ptr->interlace_type = (png_byte)interlace_type;\n\n   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,\n       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,\n       info_ptr->compression_type, info_ptr->filter_type);\n\n   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      info_ptr->channels = 1;\n\n   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      info_ptr->channels = 3;\n\n   else\n      info_ptr->channels = 1;\n\n   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      info_ptr->channels++;\n\n   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);\n\n   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);\n}\n",
      "line_start": 425,
      "line_end": 463,
      "execution_count": 358,
      "covered_regions": 42,
      "total_regions": 53,
      "coverage_percent": 79.25,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_calculate_crc",
      "clean_name": "png_calculate_crc",
      "source_file": "/src/libpng/png.c",
      "source_code": " * much data to this routine as the largest single buffer size.  We\n * also check that this data will actually be used before going to the\n * trouble of calculating it.\n */\nvoid /* PRIVATE */\npng_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, size_t length)\n{\n   int need_crc = 1;\n\n   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n\n   else /* critical */\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n         need_crc = 0;\n   }\n\n   /* 'uLong' is defined in zlib.h as unsigned long; this means that on some\n    * systems it is a 64-bit value.  crc32, however, returns 32 bits so the\n    * following cast is safe.  'uInt' may be no more than 16 bits, so it is\n    * necessary to perform a loop here.\n    */\n   if (need_crc != 0 && length > 0)\n   {\n      uLong crc = png_ptr->crc; /* Should never issue a warning */\n\n      do\n      {\n         uInt safe_length = (uInt)length;\n#ifndef __COVERITY__\n         if (safe_length == 0)\n            safe_length = (uInt)-1; /* evil, but safe */\n#endif\n\n         crc = crc32(crc, ptr, safe_length);\n\n         /* The following should never issue compiler warnings; if they do the\n          * target system has characteristics that will probably violate other\n          * assumptions within the libpng code.\n          */\n         ptr += safe_length;\n         length -= safe_length;\n      }\n      while (length > 0);\n\n      /* And the following is always safe because the crc is only 32 bits. */\n      png_ptr->crc = (png_uint_32)crc;\n   }\n}\n",
      "line_start": 150,
      "line_end": 199,
      "execution_count": 3825,
      "covered_regions": 35,
      "total_regions": 44,
      "coverage_percent": 79.55,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_destroy_read_struct",
      "clean_name": "png_destroy_read_struct",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "    */\n}\n\n/* Free all memory used by the read */\nvoid PNGAPI\npng_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,\n    png_infopp end_info_ptr_ptr)\n{\n   png_structrp png_ptr = NULL;\n\n   png_debug(1, \"in png_destroy_read_struct\");\n\n   if (png_ptr_ptr != NULL)\n      png_ptr = *png_ptr_ptr;\n\n   if (png_ptr == NULL)\n      return;\n\n   /* libpng 1.6.0: use the API to destroy info structs to ensure consistent\n    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.\n    * The extra was, apparently, unnecessary yet this hides memory leak bugs.\n    */\n   png_destroy_info_struct(png_ptr, end_info_ptr_ptr);\n   png_destroy_info_struct(png_ptr, info_ptr_ptr);\n\n   *png_ptr_ptr = NULL;\n   png_read_destroy(png_ptr);\n   png_destroy_png_struct(png_ptr);\n}\n",
      "line_start": 830,
      "line_end": 854,
      "execution_count": 537,
      "covered_regions": 21,
      "total_regions": 26,
      "coverage_percent": 80.77,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_tIME",
      "clean_name": "png_set_tIME",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tIME_SUPPORTED\nvoid PNGAPI\npng_set_tIME(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_timep mod_time)\n{\n   png_debug1(1, \"in %s storage function\", \"tIME\");\n\n   if (png_ptr == NULL || info_ptr == NULL || mod_time == NULL ||\n       (png_ptr->mode & PNG_WROTE_tIME) != 0)\n      return;\n\n   if (mod_time->month == 0   || mod_time->month > 12  ||\n       mod_time->day   == 0   || mod_time->day   > 31  ||\n       mod_time->hour  > 23   || mod_time->minute > 59 ||\n       mod_time->second > 60)\n   {\n      png_warning(png_ptr, \"Ignoring invalid time value\");\n\n      return;\n   }\n\n   info_ptr->mod_time = *mod_time;\n   info_ptr->valid |= PNG_INFO_tIME;\n}\n",
      "line_start": 1119,
      "line_end": 1141,
      "execution_count": 2,
      "covered_regions": 46,
      "total_regions": 56,
      "coverage_percent": 82.14,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_bKGD",
      "clean_name": "png_set_bKGD",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n\n#ifdef PNG_bKGD_SUPPORTED\nvoid PNGAPI\npng_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_color_16p background)\n{\n   png_debug1(1, \"in %s storage function\", \"bKGD\");\n\n   if (png_ptr == NULL || info_ptr == NULL || background == NULL)\n      return;\n\n   info_ptr->background = *background;\n   info_ptr->valid |= PNG_INFO_bKGD;\n}\n",
      "line_start": 23,
      "line_end": 34,
      "execution_count": 24,
      "covered_regions": 19,
      "total_regions": 23,
      "coverage_percent": 82.61,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_sBIT",
      "clean_name": "png_set_sBIT",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_PLTE;\n}\n\n#ifdef PNG_sBIT_SUPPORTED\nvoid PNGAPI\npng_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_color_8p sig_bit)\n{\n   png_debug1(1, \"in %s storage function\", \"sBIT\");\n\n   if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)\n      return;\n\n   info_ptr->sig_bit = *sig_bit;\n   info_ptr->valid |= PNG_INFO_sBIT;\n}\n",
      "line_start": 805,
      "line_end": 816,
      "execution_count": 6,
      "covered_regions": 19,
      "total_regions": 23,
      "coverage_percent": 82.61,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_handle_mDCV",
      "clean_name": "png_handle_mDCV",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_cLLI NULL\n#endif\n\n#ifdef PNG_READ_mDCV_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_mDCV(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   png_xy chromaticities;\n   png_byte buf[24];\n\n   png_debug(1, \"in png_handle_mDCV\");\n\n   png_crc_read(png_ptr, buf, 24);\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   /* The error checking happens here, this puts it in just one place.  The\n    * odd /50000 scaling factor makes it more difficult but the (x.y) values are\n    * only two bytes so a <<1 is safe.\n    *\n    * WARNING: the PNG specification defines the cHRM chunk to **start** with\n    * the white point (x,y).  The W3C PNG v3 specification puts the white point\n    * **after* R,G,B.  The x,y values in mDCV are also scaled by 50,000 and\n    * stored in just two bytes, whereas those in cHRM are scaled by 100,000 and\n    * stored in four bytes.  This is very, very confusing.  These APIs remove\n    * the confusion by copying the existing, well established, API.\n    */\n   chromaticities.redx   = png_get_uint_16(buf+ 0U) << 1; /* red x */\n   chromaticities.redy   = png_get_uint_16(buf+ 2U) << 1; /* red y */\n   chromaticities.greenx = png_get_uint_16(buf+ 4U) << 1; /* green x */\n   chromaticities.greeny = png_get_uint_16(buf+ 6U) << 1; /* green y */\n   chromaticities.bluex  = png_get_uint_16(buf+ 8U) << 1; /* blue x */\n   chromaticities.bluey  = png_get_uint_16(buf+10U) << 1; /* blue y */\n   chromaticities.whitex = png_get_uint_16(buf+12U) << 1; /* white x */\n   chromaticities.whitey = png_get_uint_16(buf+14U) << 1; /* white y */\n\n   png_set_mDCV_fixed(png_ptr, info_ptr,\n         chromaticities.whitex, chromaticities.whitey,\n         chromaticities.redx, chromaticities.redy,\n         chromaticities.greenx, chromaticities.greeny,\n         chromaticities.bluex, chromaticities.bluey,\n         png_get_uint_32(buf+16U), /* peak luminance */\n         png_get_uint_32(buf+20U));/* minimum perceivable luminance */\n\n   /* We only use 'chromaticities' for RGB to gray */\n#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n      png_ptr->chromaticities = chromaticities;\n#  endif /* READ_RGB_TO_GRAY */\n\n   return handled_ok;\n   PNG_UNUSED(length)\n}\n",
      "line_start": 1960,
      "line_end": 2008,
      "execution_count": 2,
      "covered_regions": 62,
      "total_regions": 75,
      "coverage_percent": 82.67,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_expand",
      "clean_name": "png_do_expand",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n/* If the bit depth < 8, it is expanded to 8.  Also, if the already\n * expanded transparency value is supplied, an alpha channel is built.\n */\nstatic void\npng_do_expand(png_row_infop row_info, png_bytep row,\n    png_const_color_16p trans_color)\n{\n   int shift, value;\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_expand\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      unsigned int gray = trans_color != NULL ? trans_color->gray : 0;\n\n      if (row_info->bit_depth < 8)\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               gray = (gray & 0x01) * 0xff;\n               sp = row + (size_t)((row_width - 1) >> 3);\n               dp = row + (size_t)row_width - 1;\n               shift = 7 - (int)((row_width + 7) & 0x07);\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((*sp >> shift) & 0x01)\n                     *dp = 0xff;\n\n                  else\n                     *dp = 0;\n\n                  if (shift == 7)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift++;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n               gray = (gray & 0x03) * 0x55;\n               sp = row + (size_t)((row_width - 1) >> 2);\n               dp = row + (size_t)row_width - 1;\n               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x03;\n                  *dp = (png_byte)(value | (value << 2) | (value << 4) |\n                     (value << 6));\n                  if (shift == 6)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift += 2;\n\n                  dp--;\n               }\n               break;\n            }\n\n            case 4:\n            {\n               gray = (gray & 0x0f) * 0x11;\n               sp = row + (size_t)((row_width - 1) >> 1);\n               dp = row + (size_t)row_width - 1;\n               shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);\n               for (i = 0; i < row_width; i++)\n               {\n                  value = (*sp >> shift) & 0x0f;\n                  *dp = (png_byte)(value | (value << 4));\n                  if (shift == 4)\n                  {\n                     shift = 0;\n                     sp--;\n                  }\n\n                  else\n                     shift = 4;\n\n                  dp--;\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n\n         row_info->bit_depth = 8;\n         row_info->pixel_depth = 8;\n         row_info->rowbytes = row_width;\n      }\n\n      if (trans_color != NULL)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            gray = gray & 0xff;\n            sp = row + (size_t)row_width - 1;\n            dp = row + ((size_t)row_width << 1) - 1;\n\n            for (i = 0; i < row_width; i++)\n            {\n               if ((*sp & 0xffU) == gray)\n                  *dp-- = 0;\n\n               else\n                  *dp-- = 0xff;\n\n               *dp-- = *sp--;\n            }\n         }\n\n         else if (row_info->bit_depth == 16)\n         {\n            unsigned int gray_high = (gray >> 8) & 0xff;\n            unsigned int gray_low = gray & 0xff;\n            sp = row + row_info->rowbytes - 1;\n            dp = row + (row_info->rowbytes << 1) - 1;\n            for (i = 0; i < row_width; i++)\n            {\n               if ((*(sp - 1) & 0xffU) == gray_high &&\n                   (*(sp) & 0xffU) == gray_low)\n               {\n                  *dp-- = 0;\n                  *dp-- = 0;\n               }\n\n               else\n               {\n                  *dp-- = 0xff;\n                  *dp-- = 0xff;\n               }\n\n               *dp-- = *sp--;\n               *dp-- = *sp--;\n            }\n         }\n\n         row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n         row_info->channels = 2;\n         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,\n             row_width);\n      }\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_RGB &&\n       trans_color != NULL)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         png_byte red = (png_byte)(trans_color->red & 0xff);\n         png_byte green = (png_byte)(trans_color->green & 0xff);\n         png_byte blue = (png_byte)(trans_color->blue & 0xff);\n         sp = row + (size_t)row_info->rowbytes - 1;\n         dp = row + ((size_t)row_width << 2) - 1;\n         for (i = 0; i < row_width; i++)\n         {\n            if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)\n               *dp-- = 0;\n\n            else\n               *dp-- = 0xff;\n\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n         }\n      }\n      else if (row_info->bit_depth == 16)\n      {\n         png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);\n         png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);\n         png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);\n         png_byte red_low = (png_byte)(trans_color->red & 0xff);\n         png_byte green_low = (png_byte)(trans_color->green & 0xff);\n         png_byte blue_low = (png_byte)(trans_color->blue & 0xff);\n         sp = row + row_info->rowbytes - 1;\n         dp = row + ((size_t)row_width << 3) - 1;\n         for (i = 0; i < row_width; i++)\n         {\n            if (*(sp - 5) == red_high &&\n                *(sp - 4) == red_low &&\n                *(sp - 3) == green_high &&\n                *(sp - 2) == green_low &&\n                *(sp - 1) == blue_high &&\n                *(sp    ) == blue_low)\n            {\n               *dp-- = 0;\n               *dp-- = 0;\n            }\n\n            else\n            {\n               *dp-- = 0xff;\n               *dp-- = 0xff;\n            }\n\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n            *dp-- = *sp--;\n         }\n      }\n      row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n      row_info->channels = 4;\n      row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n}\n",
      "line_start": 4501,
      "line_end": 4724,
      "execution_count": 24318,
      "covered_regions": 167,
      "total_regions": 201,
      "coverage_percent": 83.08,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_read_filter_row_up",
      "clean_name": "png_read_filter_row_up",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      rp++;\n   }\n}\n\nstatic void\npng_read_filter_row_up(png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row)\n{\n   size_t i;\n   size_t istop = row_info->rowbytes;\n   png_bytep rp = row;\n   png_const_bytep pp = prev_row;\n\n   for (i = 0; i < istop; i++)\n   {\n      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);\n      rp++;\n   }\n}\n",
      "line_start": 3983,
      "line_end": 3997,
      "execution_count": 20924,
      "covered_regions": 5,
      "total_regions": 6,
      "coverage_percent": 83.33,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:png_init_filter_functions",
      "clean_name": "png_init_filter_functions",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      *row++ = (png_byte)a;\n   }\n}\n\nstatic void\npng_init_filter_functions(png_structrp pp)\n   /* This function is called once for every PNG image (except for PNG images\n    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the\n    * implementations required to reverse the filtering of PNG rows.  Reversing\n    * the filter is the first transformation performed on the row data.  It is\n    * performed in place, therefore an implementation can be selected based on\n    * the image pixel format.  If the implementation depends on image width then\n    * take care to ensure that it works correctly if the image is interlaced -\n    * interlacing causes the actual row width to vary.\n    */\n{\n   unsigned int bpp = (pp->pixel_depth + 7) >> 3;\n\n   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;\n   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;\n   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;\n   if (bpp == 1)\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_1byte_pixel;\n   else\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth_multibyte_pixel;\n\n#ifdef PNG_FILTER_OPTIMIZATIONS\n   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to\n    * call to install hardware optimizations for the above functions; simply\n    * replace whatever elements of the pp->read_filter[] array with a hardware\n    * specific (or, for that matter, generic) optimization.\n    *\n    * To see an example of this examine what configure.ac does when\n    * --enable-arm-neon is specified on the command line.\n    */\n   PNG_FILTER_OPTIMIZATIONS(pp, bpp);\n#endif\n}\n",
      "line_start": 4128,
      "line_end": 4163,
      "execution_count": 196,
      "covered_regions": 16,
      "total_regions": 19,
      "coverage_percent": 84.21,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngread.c:png_image_format",
      "clean_name": "png_image_format",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return png_image_error(image, \"png_image_read: opaque pointer not NULL\");\n}\n\n/* Utility to find the base format of a PNG file from a png_struct. */\nstatic png_uint_32\npng_image_format(png_structrp png_ptr)\n{\n   png_uint_32 format = 0;\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)\n      format |= PNG_FORMAT_FLAG_COLOR;\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      format |= PNG_FORMAT_FLAG_ALPHA;\n\n   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS\n    * sets the png_struct fields; that's all we are interested in here.  The\n    * precise interaction with an app call to png_set_tRNS and PNG file reading\n    * is unclear.\n    */\n   else if (png_ptr->num_trans > 0)\n      format |= PNG_FORMAT_FLAG_ALPHA;\n\n   if (png_ptr->bit_depth == 16)\n      format |= PNG_FORMAT_FLAG_LINEAR;\n\n   if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE) != 0)\n      format |= PNG_FORMAT_FLAG_COLORMAP;\n\n   return format;\n}\n",
      "line_start": 1176,
      "line_end": 1202,
      "execution_count": 358,
      "covered_regions": 34,
      "total_regions": 40,
      "coverage_percent": 85.0,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_do_gray_to_rgb",
      "clean_name": "png_do_gray_to_rgb",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n/* Expand grayscale files to RGB, with or without alpha */\nstatic void\npng_do_gray_to_rgb(png_row_infop row_info, png_bytep row)\n{\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_gray_to_rgb\");\n\n   if (row_info->bit_depth >= 8 &&\n       (row_info->color_type & PNG_COLOR_MASK_COLOR) == 0)\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This changes G to RGB */\n            png_bytep sp = row + (size_t)row_width - 1;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *sp;\n               *(dp--) = *sp;\n               *(dp--) = *(sp--);\n            }\n         }\n\n         else\n         {\n            /* This changes GG to RRGGBB */\n            png_bytep sp = row + (size_t)row_width * 2 - 1;\n            png_bytep dp = sp  + (size_t)row_width * 4;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n            }\n         }\n      }\n\n      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n      {\n         if (row_info->bit_depth == 8)\n         {\n            /* This changes GA to RGBA */\n            png_bytep sp = row + (size_t)row_width * 2 - 1;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *(sp--);\n               *(dp--) = *sp;\n               *(dp--) = *sp;\n               *(dp--) = *(sp--);\n            }\n         }\n\n         else\n         {\n            /* This changes GGAA to RRGGBBAA */\n            png_bytep sp = row + (size_t)row_width * 4 - 1;\n            png_bytep dp = sp  + (size_t)row_width * 4;\n            for (i = 0; i < row_width; i++)\n            {\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *sp;\n               *(dp--) = *(sp - 1);\n               *(dp--) = *(sp--);\n               *(dp--) = *(sp--);\n            }\n         }\n      }\n      row_info->channels = (png_byte)(row_info->channels + 2);\n      row_info->color_type |= PNG_COLOR_MASK_COLOR;\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n          row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n}\n",
      "line_start": 2978,
      "line_end": 3061,
      "execution_count": 19222,
      "covered_regions": 57,
      "total_regions": 67,
      "coverage_percent": 85.07,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_create_read_struct",
      "clean_name": "png_create_read_struct",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n#ifdef PNG_READ_SUPPORTED\n\n/* Create a PNG structure for reading, and allocate any memory needed. */\nPNG_FUNCTION(png_structp,PNGAPI\npng_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,\n    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)\n{\n#ifndef PNG_USER_MEM_SUPPORTED\n   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,\n        error_fn, warn_fn, NULL, NULL, NULL);\n#else\n   return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,\n        warn_fn, NULL, NULL, NULL);\n}\n",
      "line_start": 24,
      "line_end": 34,
      "execution_count": 358,
      "covered_regions": 6,
      "total_regions": 7,
      "coverage_percent": 85.71,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_interlace_handling",
      "clean_name": "png_set_interlace_handling",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_INTERLACING_SUPPORTED) || \\\n    defined(PNG_WRITE_INTERLACING_SUPPORTED)\nint PNGAPI\npng_set_interlace_handling(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_interlace handling\");\n\n   if (png_ptr != 0 && png_ptr->interlaced != 0)\n   {\n      png_ptr->transformations |= PNG_INTERLACE;\n      return 7;\n   }\n\n   return 1;\n}\n",
      "line_start": 97,
      "line_end": 109,
      "execution_count": 358,
      "covered_regions": 13,
      "total_regions": 15,
      "coverage_percent": 86.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_chunk_unknown_handling",
      "clean_name": "png_chunk_unknown_handling",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n\n#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) ||\\\n   defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)\nint /* PRIVATE */\npng_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)\n{\n   png_byte chunk_string[5];\n\n   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);\n   return png_handle_as_unknown(png_ptr, chunk_string);\n}\n",
      "line_start": 962,
      "line_end": 969,
      "execution_count": 1642,
      "covered_regions": 7,
      "total_regions": 8,
      "coverage_percent": 87.5,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngrutil.c:png_crc_error",
      "clean_name": "png_crc_error",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "\n/* Compare the CRC stored in the PNG file with that calculated by libpng from\n * the data it has read thus far.\n */\nstatic int\npng_crc_error(png_structrp png_ptr, int handle_as_ancillary)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n\n   /* There are four flags two for ancillary and two for critical chunks.  The\n    * default setting of these flags is all zero.\n    *\n    * PNG_FLAG_CRC_ANCILLARY_USE\n    * PNG_FLAG_CRC_ANCILLARY_NOWARN\n    *  USE+NOWARN: no CRC calculation (implemented here), else;\n    *  NOWARN:     png_chunk_error on error (implemented in png_crc_finish)\n    *  else:       png_chunk_warning on error (implemented in png_crc_finish)\n    *              This is the default.\n    *\n    *    I.e. NOWARN without USE produces png_chunk_error.  The default setting\n    *    where neither are set does the same thing.\n    *\n    * PNG_FLAG_CRC_CRITICAL_USE\n    * PNG_FLAG_CRC_CRITICAL_IGNORE\n    *  IGNORE: no CRC calculation (implemented here), else;\n    *  USE:    png_chunk_warning on error (implemented in png_crc_finish)\n    *  else:   png_chunk_error on error (implemented in png_crc_finish)\n    *          This is the default.\n    *\n    * This arose because of original mis-implementation and has persisted for\n    * compatibility reasons.\n    *\n    * TODO: the flag names are internal so maybe this can be changed to\n    * something comprehensible.\n    */\n   if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n\n   else /* critical */\n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n         need_crc = 0;\n   }\n\n#ifdef PNG_IO_STATE_SUPPORTED\n   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n#endif\n\n   /* The chunk CRC must be serialized in a single I/O call. */\n   png_read_data(png_ptr, crc_bytes, 4);\n\n   if (need_crc != 0)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return crc != png_ptr->crc;\n   }\n\n   else\n      return 0;\n}\n",
      "line_start": 238,
      "line_end": 299,
      "execution_count": 2002,
      "covered_regions": 45,
      "total_regions": 51,
      "coverage_percent": 88.24,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrutil.c:check_chunk_name",
      "clean_name": "check_chunk_name",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * Do this using the bit-whacking approach from contrib/tools/pngfix.c\n *\n * Copied from libpng 1.7.\n */\nstatic int\ncheck_chunk_name(png_uint_32 name)\n{\n   png_uint_32 t;\n\n   /* Remove bit 5 from all but the reserved byte; this means\n    * every 8-bit unit must be in the range 65-90 to be valid.\n    * So bit 5 must be zero, bit 6 must be set and bit 7 zero.\n    */\n   name &= ~PNG_U32(32,32,0,32);\n   t = (name & ~0x1f1f1f1fU) ^ 0x40404040U;\n\n   /* Subtract 65 for each 8-bit quantity, this must not\n    * overflow and each byte must then be in the range 0-25.\n    */\n   name -= PNG_U32(65,65,65,65);\n   t |= name;\n\n   /* Subtract 26, handling the overflow which should set the\n    * top three bits of each byte.\n    */\n   name -= PNG_U32(25,25,25,26);\n   t |= ~name;\n\n   return (t & 0xe0e0e0e0U) == 0U;\n}\n",
      "line_start": 152,
      "line_end": 177,
      "execution_count": 2002,
      "covered_regions": 31,
      "total_regions": 35,
      "coverage_percent": 88.57,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_read_filter_row",
      "clean_name": "png_read_filter_row",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   PNG_FILTER_OPTIMIZATIONS(pp, bpp);\n#endif\n}\n\nvoid /* PRIVATE */\npng_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,\n    png_const_bytep prev_row, int filter)\n{\n   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define\n    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic\n    * implementations.  See png_init_filter_functions above.\n    */\n   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)\n   {\n      if (pp->read_filter[0] == NULL)\n         png_init_filter_functions(pp);\n\n      pp->read_filter[filter-1](row_info, row, prev_row);\n   }\n}\n",
      "line_start": 4165,
      "line_end": 4180,
      "execution_count": 22764,
      "covered_regions": 16,
      "total_regions": 18,
      "coverage_percent": 88.89,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:png_image_is_not_sRGB",
      "clean_name": "png_image_is_not_sRGB",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "/* Do the main body of a 'png_image_begin_read' function; read the PNG file\n * header and fill in all the information.  This is executed in a safe context,\n * unlike the init routine above.\n */\nstatic int\npng_image_is_not_sRGB(png_const_structrp png_ptr)\n{\n   /* Does the colorspace **not** match sRGB?  The flag is only set if the\n    * answer can be determined reliably.\n    *\n    * png_struct::chromaticities always exists since the simplified API\n    * requires rgb-to-gray.  The mDCV, cICP and cHRM chunks may all set it to\n    * a non-sRGB value, so it needs to be checked but **only** if one of\n    * those chunks occured in the file.\n    */\n   /* Highest priority: check to be safe. */\n   if (png_has_chunk(png_ptr, cICP) || png_has_chunk(png_ptr, mDCV))\n      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n\n   /* If the image is marked as sRGB then it is... */\n   if (png_has_chunk(png_ptr, sRGB))\n      return 0;\n\n   /* Last stop: cHRM, must check: */\n   if (png_has_chunk(png_ptr, cHRM))\n      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n\n   /* Else default to sRGB */\n   return 0;\n}\n",
      "line_start": 1248,
      "line_end": 1273,
      "execution_count": 107,
      "covered_regions": 39,
      "total_regions": 43,
      "coverage_percent": 90.7,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "pngrtran.c:png_gamma_threshold",
      "clean_name": "png_gamma_threshold",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* In the case of gamma transformations only do transformations on images where\n * the [file] gamma and screen_gamma are not close reciprocals, otherwise it\n * slows things down slightly, and also needlessly introduces small errors.\n */\nstatic int /* PRIVATE */\npng_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)\n{\n   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma\n    * correction as a difference of the overall transform from 1.0\n    *\n    * We want to compare the threshold with s*f - 1, if we get\n    * overflow here it is because of wacky gamma values so we\n    * turn on processing anyway.\n    */\n   png_fixed_point gtest;\n   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||\n       png_gamma_significant(gtest);\n}\n",
      "line_start": 1141,
      "line_end": 1154,
      "execution_count": 179,
      "covered_regions": 10,
      "total_regions": 11,
      "coverage_percent": 90.91,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "png_free",
      "clean_name": "png_free",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "\n/* Free a pointer allocated by png_malloc().  If ptr is NULL, return\n * without taking any action.\n */\nvoid PNGAPI\npng_free(png_const_structrp png_ptr, png_voidp ptr)\n{\n   if (png_ptr == NULL || ptr == NULL)\n      return;\n\n#ifdef PNG_USER_MEM_SUPPORTED\n   if (png_ptr->free_fn != NULL)\n      png_ptr->free_fn(png_constcast(png_structrp,png_ptr), ptr);\n\n   else\n      png_free_default(png_ptr, ptr);\n}\n",
      "line_start": 229,
      "line_end": 241,
      "execution_count": 9014,
      "covered_regions": 22,
      "total_regions": 24,
      "coverage_percent": 91.67,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_gamma_significant",
      "clean_name": "png_gamma_significant",
      "source_file": "/src/libpng/png.c",
      "source_code": "#ifdef PNG_READ_GAMMA_SUPPORTED\n/* This is the shared test on whether a gamma value is 'significant' - whether\n * it is worth doing gamma correction.\n */\nint /* PRIVATE */\npng_gamma_significant(png_fixed_point gamma_val)\n{\n   /* sRGB:       1/2.2 == 0.4545(45)\n    * AdobeRGB:   1/(2+51/256) ~= 0.45471 5dp\n    *\n    * So the correction from AdobeRGB to sRGB (output) is:\n    *\n    *    2.2/(2+51/256) == 1.00035524\n    *\n    * I.e. vanishly small (<4E-4) but still detectable in 16-bit linear (+/-\n    * 23).  Note that the Adobe choice seems to be something intended to give an\n    * exact number with 8 binary fractional digits - it is the closest to 2.2\n    * that is possible a base 2 .8p representation.\n    */\n   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||\n       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;\n}\n",
      "line_start": 2905,
      "line_end": 2922,
      "execution_count": 599,
      "covered_regions": 13,
      "total_regions": 14,
      "coverage_percent": 92.86,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_image_free",
      "clean_name": "png_image_free",
      "source_file": "/src/libpng/png.c",
      "source_code": "   /* Success. */\n   return 1;\n}\n\nvoid PNGAPI\npng_image_free(png_imagep image)\n{\n   /* Safely call the real function, but only if doing so is safe at this point\n    * (if not inside an error handling context).  Otherwise assume\n    * png_safe_execute will call this API after the return.\n    */\n   if (image != NULL && image->opaque != NULL &&\n      image->opaque->error_buf == NULL)\n   {\n      png_image_free_function(image);\n      image->opaque = NULL;\n   }\n}\n",
      "line_start": 4015,
      "line_end": 4028,
      "execution_count": 179,
      "covered_regions": 16,
      "total_regions": 17,
      "coverage_percent": 94.12,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "pngread.c:chromaticities_match_sRGB",
      "clean_name": "chromaticities_match_sRGB",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return format;\n}\n\nstatic int\nchromaticities_match_sRGB(const png_xy *xy)\n{\n#  define sRGB_TOLERANCE 1000\n   static const png_xy sRGB_xy = /* From ITU-R BT.709-3 */\n   {\n      /* color      x       y */\n      /* red   */ 64000, 33000,\n      /* green */ 30000, 60000,\n      /* blue  */ 15000,  6000,\n      /* white */ 31270, 32900\n   };\n\n   if (PNG_OUT_OF_RANGE(xy->whitex, sRGB_xy.whitex,sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->whitey, sRGB_xy.whitey,sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->redx,   sRGB_xy.redx,  sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->redy,   sRGB_xy.redy,  sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->greenx, sRGB_xy.greenx,sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->greeny, sRGB_xy.greeny,sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->bluex,  sRGB_xy.bluex, sRGB_TOLERANCE) ||\n       PNG_OUT_OF_RANGE(xy->bluey,  sRGB_xy.bluey, sRGB_TOLERANCE))\n      return 0;\n   return 1;\n}\n",
      "line_start": 1204,
      "line_end": 1227,
      "execution_count": 30,
      "covered_regions": 58,
      "total_regions": 60,
      "coverage_percent": 96.67,
      "is_covered": true,
      "is_static": true
    },
    {
      "name": "_Z12default_freeP14png_struct_defPv",
      "clean_name": "default_free(png_struct_def*, void*)",
      "source_file": "/src/libpng/contrib/oss-fuzz/libpng_read_fuzzer.cc",
      "source_code": "\n  return malloc(size);\n}\n\nvoid default_free(png_structp, png_voidp ptr) {\n  return free(ptr);\n}\n",
      "line_start": 91,
      "line_end": 93,
      "execution_count": 2368,
      "covered_regions": 1,
      "total_regions": 1,
      "coverage_percent": 100.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_zfree",
      "clean_name": "png_zfree",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);\n}\n\n/* Function to free memory for zlib */\nvoid /* PRIVATE */\npng_zfree(voidpf png_ptr, voidpf ptr)\n{\n   png_free(png_voidcast(png_const_structrp,png_ptr), ptr);\n}\n",
      "line_start": 129,
      "line_end": 133,
      "execution_count": 578,
      "covered_regions": 5,
      "total_regions": 5,
      "coverage_percent": 100.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_set_mem_fn",
      "clean_name": "png_set_mem_fn",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "#ifdef PNG_USER_MEM_SUPPORTED\n/* This function is called when the application wants to use another method\n * of allocating and freeing memory.\n */\nvoid PNGAPI\npng_set_mem_fn(png_structrp png_ptr, png_voidp mem_ptr, png_malloc_ptr\n  malloc_fn, png_free_ptr free_fn)\n{\n   if (png_ptr != NULL)\n   {\n      png_ptr->mem_ptr = mem_ptr;\n      png_ptr->malloc_fn = malloc_fn;\n      png_ptr->free_fn = free_fn;\n   }\n}\n",
      "line_start": 257,
      "line_end": 267,
      "execution_count": 537,
      "covered_regions": 5,
      "total_regions": 5,
      "coverage_percent": 100.0,
      "is_covered": true,
      "is_static": false
    },
    {
      "name": "png_crc_finish",
      "clean_name": "png_crc_finish",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "\n   return 0;\n}\n\nint /* PRIVATE */\npng_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n{\n   return png_crc_finish_critical(png_ptr, skip, 0/*critical handling*/);\n}\n",
      "line_start": 359,
      "line_end": 363,
      "execution_count": 1691,
      "covered_regions": 1,
      "total_regions": 1,
      "coverage_percent": 100.0,
      "is_covered": true,
      "is_static": false
    }
  ]
}