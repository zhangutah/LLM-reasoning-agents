{
  "project": "libpng",
  "model": "gpt-5-mini",
  "total_scored": 235,
  "high_value": 48,
  "functions": [
    {
      "name": "png_read_png",
      "clean_name": "png_read_png",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n#ifdef PNG_INFO_IMAGE_SUPPORTED\nvoid PNGAPI\npng_read_png(png_structrp png_ptr, png_inforp info_ptr,\n    int transforms, voidp params)\n{\n   png_debug(1, \"in png_read_png\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   /* png_read_info() gives us all of the information from the\n    * PNG file before the first IDAT (image data chunk).\n    */\n   png_read_info(png_ptr, info_ptr);\n   if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))\n      png_error(png_ptr, \"Image is too high to process with png_read_png()\");\n\n   /* -------------- image transformations start here ------------------- */\n   /* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM\n    * is not implemented.  This will only happen in de-configured (non-default)\n    * libpng builds.  The results can be unexpected - png_read_png may return\n    * short or mal-formed rows because the transform is skipped.\n    */\n\n   /* Tell libpng to strip 16-bit/color files down to 8 bits per color.\n    */\n   if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)\n      /* Added at libpng-1.5.4. \"strip_16\" produces the same result that it\n       * did in earlier versions, while \"scale_16\" is now more accurate.\n       */\n#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n      png_set_scale_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SCALE_16 not supported\");\n#endif\n\n   /* If both SCALE and STRIP are required pngrtran will effectively cancel the\n    * latter by doing SCALE first.  This is ok and allows apps not to check for\n    * which is supported to get the right answer.\n    */\n   if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n      png_set_strip_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_16 not supported\");\n#endif\n\n   /* Strip alpha bytes from the input data without combining with\n    * the background (not recommended).\n    */\n   if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n      png_set_strip_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_STRIP_ALPHA not supported\");\n#endif\n\n   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single\n    * byte into separate bytes (useful for paletted and grayscale images).\n    */\n   if ((transforms & PNG_TRANSFORM_PACKING) != 0)\n#ifdef PNG_READ_PACK_SUPPORTED\n      png_set_packing(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKING not supported\");\n#endif\n\n   /* Change the order of packed pixels to least significant bit first\n    * (not useful if you are using png_set_packing).\n    */\n   if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n      png_set_packswap(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_PACKSWAP not supported\");\n#endif\n\n   /* Expand paletted colors into true RGB triplets\n    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel\n    * Expand paletted or RGB images with transparency to full alpha\n    * channels so the data will be available as RGBA quartets.\n    */\n   if ((transforms & PNG_TRANSFORM_EXPAND) != 0)\n#ifdef PNG_READ_EXPAND_SUPPORTED\n      png_set_expand(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND not supported\");\n#endif\n\n   /* We don't handle background color or gamma transformation or quantizing.\n    */\n\n   /* Invert monochrome files to have 0 as white and 1 as black\n    */\n   if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)\n#ifdef PNG_READ_INVERT_SUPPORTED\n      png_set_invert_mono(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_MONO not supported\");\n#endif\n\n   /* If you want to shift the pixel values from the range [0,255] or\n    * [0,65535] to the original [0,7] or [0,31], or whatever range the\n    * colors were originally in:\n    */\n   if ((transforms & PNG_TRANSFORM_SHIFT) != 0)\n#ifdef PNG_READ_SHIFT_SUPPORTED\n      if ((info_ptr->valid & PNG_INFO_sBIT) != 0)\n         png_set_shift(png_ptr, &info_ptr->sig_bit);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SHIFT not supported\");\n#endif\n\n   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */\n   if ((transforms & PNG_TRANSFORM_BGR) != 0)\n#ifdef PNG_READ_BGR_SUPPORTED\n      png_set_bgr(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_BGR not supported\");\n#endif\n\n   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */\n   if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\n      png_set_swap_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ALPHA not supported\");\n#endif\n\n   /* Swap bytes of 16-bit files to least significant byte first */\n   if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)\n#ifdef PNG_READ_SWAP_SUPPORTED\n      png_set_swap(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_SWAP_ENDIAN not supported\");\n#endif\n\n/* Added at libpng-1.2.41 */\n   /* Invert the alpha channel from opacity to transparency */\n   if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\n      png_set_invert_alpha(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_INVERT_ALPHA not supported\");\n#endif\n\n/* Added at libpng-1.2.41 */\n   /* Expand grayscale image to RGB */\n   if ((transforms & PNG_TRANSFORM_GRAY_TO_RGB) != 0)\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n      png_set_gray_to_rgb(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_GRAY_TO_RGB not supported\");\n#endif\n\n/* Added at libpng-1.5.4 */\n   if ((transforms & PNG_TRANSFORM_EXPAND_16) != 0)\n#ifdef PNG_READ_EXPAND_16_SUPPORTED\n      png_set_expand_16(png_ptr);\n#else\n      png_app_error(png_ptr, \"PNG_TRANSFORM_EXPAND_16 not supported\");\n#endif\n\n   /* We don't handle adding filler bytes */\n\n   /* We use png_read_image and rely on that for interlace handling, but we also\n    * call png_read_update_info therefore must turn on interlace handling now:\n    */\n   (void)png_set_interlace_handling(png_ptr);\n\n   /* Optional call to gamma correct and add the background to the palette\n    * and update info structure.  REQUIRED if you are expecting libpng to\n    * update the palette for you (i.e., you selected such a transform above).\n    */\n   png_read_update_info(png_ptr, info_ptr);\n\n   /* -------------- image transformations end here ------------------- */\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n   if (info_ptr->row_pointers == NULL)\n   {\n      png_uint_32 iptr;\n\n      info_ptr->row_pointers = png_voidcast(png_bytepp, png_malloc(png_ptr,\n          info_ptr->height * (sizeof (png_bytep))));\n\n      for (iptr=0; iptr<info_ptr->height; iptr++)\n         info_ptr->row_pointers[iptr] = NULL;\n\n      info_ptr->free_me |= PNG_FREE_ROWS;\n\n      for (iptr = 0; iptr < info_ptr->height; iptr++)\n         info_ptr->row_pointers[iptr] = png_voidcast(png_bytep,\n             png_malloc(png_ptr, info_ptr->rowbytes));\n   }\n\n   png_read_image(png_ptr, info_ptr->row_pointers);\n   info_ptr->valid |= PNG_INFO_IDAT;\n\n   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */\n   png_read_end(png_ptr, info_ptr);\n\n   PNG_UNUSED(params)\n}\n",
      "line_start": 868,
      "line_end": 1070,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 190,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Reads and parses complex external input (PNG files) via png_read_info/png_read_image, performs memory allocations and buffer manipulation based on untrusted image dimensions and rowbytes, contains many transform-dependent branches and input-dependent loops \u2014 high potential for memory safety, integer overflow and logic bugs, making it a critical fuzzing target."
    },
    {
      "name": "png_combine_row",
      "clean_name": "png_combine_row",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * depending on the 'display' value; if 'display' is true then the whole row\n * (dp) is filled from the start by replicating the available pixels.  If\n * 'display' is false only those pixels present in the pass are filled in.\n */\nvoid /* PRIVATE */\npng_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)\n{\n   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;\n   png_const_bytep sp = png_ptr->row_buf + 1;\n   png_alloc_size_t row_width = png_ptr->width;\n   unsigned int pass = png_ptr->pass;\n   png_bytep end_ptr = 0;\n   png_byte end_byte = 0;\n   unsigned int end_mask;\n\n   png_debug(1, \"in png_combine_row\");\n\n   /* Added in 1.5.6: it should not be possible to enter this routine until at\n    * least one row has been read from the PNG data and transformed.\n    */\n   if (pixel_depth == 0)\n      png_error(png_ptr, \"internal row logic error\");\n\n   /* Added in 1.5.4: the pixel depth should match the information returned by\n    * any call to png_read_update_info at this point.  Do not continue if we got\n    * this wrong.\n    */\n   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=\n          PNG_ROWBYTES(pixel_depth, row_width))\n      png_error(png_ptr, \"internal row size calculation error\");\n\n   /* Don't expect this to ever happen: */\n   if (row_width == 0)\n      png_error(png_ptr, \"internal row width error\");\n\n   /* Preserve the last byte in cases where only part of it will be overwritten,\n    * the multiply below may overflow, we don't care because ANSI-C guarantees\n    * we get the low bits.\n    */\n   end_mask = (pixel_depth * row_width) & 7;\n   if (end_mask != 0)\n   {\n      /* end_ptr == NULL is a flag to say do nothing */\n      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;\n      end_byte = *end_ptr;\n#     ifdef PNG_READ_PACKSWAP_SUPPORTED\n      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n         /* little-endian byte */\n         end_mask = (unsigned int)(0xff << end_mask);\n\n      else /* big-endian byte */\n#     endif\n      end_mask = 0xff >> end_mask;\n      /* end_mask is now the bits to *keep* from the destination row */\n   }\n\n   /* For non-interlaced images this reduces to a memcpy(). A memcpy()\n    * will also happen if interlacing isn't supported or if the application\n    * does not call png_set_interlace_handling().  In the latter cases the\n    * caller just gets a sequence of the unexpanded rows from each interlace\n    * pass.\n    */\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if (png_ptr->interlaced != 0 &&\n       (png_ptr->transformations & PNG_INTERLACE) != 0 &&\n       pass < 6 && (display == 0 ||\n       /* The following copies everything for 'display' on passes 0, 2 and 4. */\n       (display == 1 && (pass & 1) != 0)))\n   {\n      /* Narrow images may have no bits in a pass; the caller should handle\n       * this, but this test is cheap:\n       */\n      if (row_width <= PNG_PASS_START_COL(pass))\n         return;\n\n      if (pixel_depth < 8)\n      {\n         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit\n          * into 32 bits, then a single loop over the bytes using the four byte\n          * values in the 32-bit mask can be used.  For the 'display' option the\n          * expanded mask may also not require any masking within a byte.  To\n          * make this work the PACKSWAP option must be taken into account - it\n          * simply requires the pixels to be reversed in each byte.\n          *\n          * The 'regular' case requires a mask for each of the first 6 passes,\n          * the 'display' case does a copy for the even passes in the range\n          * 0..6.  This has already been handled in the test above.\n          *\n          * The masks are arranged as four bytes with the first byte to use in\n          * the lowest bits (little-endian) regardless of the order (PACKSWAP or\n          * not) of the pixels in each byte.\n          *\n          * NOTE: the whole of this logic depends on the caller of this function\n          * only calling it on rows appropriate to the pass.  This function only\n          * understands the 'x' logic; the 'y' logic is handled by the caller.\n          *\n          * The following defines allow generation of compile time constant bit\n          * masks for each pixel depth and each possibility of swapped or not\n          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,\n          * is in the range 0..7; and the result is 1 if the pixel is to be\n          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'\n          * for the block method.\n          *\n          * With some compilers a compile time expression of the general form:\n          *\n          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)\n          *\n          * Produces warnings with values of 'shift' in the range 33 to 63\n          * because the right hand side of the ?: expression is evaluated by\n          * the compiler even though it isn't used.  Microsoft Visual C (various\n          * versions) and the Intel C compiler are known to do this.  To avoid\n          * this the following macros are used in 1.5.6.  This is a temporary\n          * solution to avoid destabilizing the code during the release process.\n          */\n#        if PNG_USE_COMPILE_TIME_MASKS\n#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))\n#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))\n#        else\n#           define PNG_LSR(x,s) ((x)>>(s))\n#           define PNG_LSL(x,s) ((x)<<(s))\n#        endif\n#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)\n#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\\\n           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)\n\n         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is\n          * little endian - the first pixel is at bit 0 - however the extra\n          * parameter 's' can be set to cause the mask position to be swapped\n          * within each byte, to match the PNG format.  This is done by XOR of\n          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.\n          */\n#        define PIXEL_MASK(p,x,d,s) \\\n            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))\n\n         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.\n          */\n#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)\n\n         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp\n          * cases the result needs replicating, for the 4-bpp case the above\n          * generates a full 32 bits.\n          */\n#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))\n\n#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\\\n            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\\\n            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)\n\n#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\\\n            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\\\n            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)\n\n#if PNG_USE_COMPILE_TIME_MASKS\n         /* Utility macros to construct all the masks for a depth/swap\n          * combination.  The 's' parameter says whether the format is PNG\n          * (big endian bytes) or not.  Only the three odd-numbered passes are\n          * required for the display/block algorithm.\n          */\n#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\\\n            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }\n\n#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }\n\n#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))\n\n         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and\n          * then pass:\n          */\n         static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }\n         };\n\n         /* display_mask has only three entries for the odd passes, so index by\n          * pass>>1.\n          */\n         static const png_uint_32 display_mask[2][3][3] =\n         {\n            /* Little-endian byte masks for PACKSWAP */\n            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },\n            /* Normal (big-endian byte) masks - PNG format */\n            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }\n         };\n\n#        define MASK(pass,depth,display,png)\\\n            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\\\n               row_mask[png][DEPTH_INDEX(depth)][pass])\n\n#else /* !PNG_USE_COMPILE_TIME_MASKS */\n         /* This is the runtime alternative: it seems unlikely that this will\n          * ever be either smaller or faster than the compile time approach.\n          */\n#        define MASK(pass,depth,display,png)\\\n            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))\n#endif /* !USE_COMPILE_TIME_MASKS */\n\n         /* Use the appropriate mask to copy the required bits.  In some cases\n          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is\n          * the number of pixels, but the code copies bytes, so it is necessary\n          * to special case the end.\n          */\n         png_uint_32 pixels_per_byte = 8 / pixel_depth;\n         png_uint_32 mask;\n\n#        ifdef PNG_READ_PACKSWAP_SUPPORTED\n         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)\n            mask = MASK(pass, pixel_depth, display, 0);\n\n         else\n#        endif\n         mask = MASK(pass, pixel_depth, display, 1);\n\n         for (;;)\n         {\n            png_uint_32 m;\n\n            /* It doesn't matter in the following if png_uint_32 has more than\n             * 32 bits because the high bits always match those in m<<24; it is,\n             * however, essential to use OR here, not +, because of this.\n             */\n            m = mask;\n            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */\n            m &= 0xff;\n\n            if (m != 0) /* something to copy */\n            {\n               if (m != 0xff)\n                  *dp = (png_byte)((*dp & ~m) | (*sp & m));\n               else\n                  *dp = *sp;\n            }\n\n            /* NOTE: this may overwrite the last byte with garbage if the image\n             * is not an exact number of bytes wide; libpng has always done\n             * this.\n             */\n            if (row_width <= pixels_per_byte)\n               break; /* May need to restore part of the last byte */\n\n            row_width -= pixels_per_byte;\n            ++dp;\n            ++sp;\n         }\n      }\n\n      else /* pixel_depth >= 8 */\n      {\n         unsigned int bytes_to_copy, bytes_to_jump;\n\n         /* Validate the depth - it must be a multiple of 8 */\n         if (pixel_depth & 7)\n            png_error(png_ptr, \"invalid user transform pixel depth\");\n\n         pixel_depth >>= 3; /* now in bytes */\n         row_width *= pixel_depth;\n\n         /* Regardless of pass number the Adam 7 interlace always results in a\n          * fixed number of pixels to copy then to skip.  There may be a\n          * different number of pixels to skip at the start though.\n          */\n         {\n            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;\n\n            row_width -= offset;\n            dp += offset;\n            sp += offset;\n         }\n\n         /* Work out the bytes to copy. */\n         if (display != 0)\n         {\n            /* When doing the 'block' algorithm the pixel in the pass gets\n             * replicated to adjacent pixels.  This is why the even (0,2,4,6)\n             * passes are skipped above - the entire expanded row is copied.\n             */\n            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;\n\n            /* But don't allow this number to exceed the actual row width. */\n            if (bytes_to_copy > row_width)\n               bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n         }\n\n         else /* normal row; Adam7 only ever gives us one pixel to copy. */\n            bytes_to_copy = pixel_depth;\n\n         /* In Adam7 there is a constant offset between where the pixels go. */\n         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;\n\n         /* And simply copy these bytes.  Some optimization is possible here,\n          * depending on the value of 'bytes_to_copy'.  Special case the low\n          * byte counts, which we know to be frequent.\n          *\n          * Notice that these cases all 'return' rather than 'break' - this\n          * avoids an unnecessary test on whether to restore the last byte\n          * below.\n          */\n         switch (bytes_to_copy)\n         {\n            case 1:\n               for (;;)\n               {\n                  *dp = *sp;\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  dp += bytes_to_jump;\n                  sp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            case 2:\n               /* There is a possibility of a partial copy at the end here; this\n                * slows the code down somewhat.\n                */\n               do\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n               while (row_width > 1);\n\n               /* And there can only be one byte left at this point: */\n               *dp = *sp;\n               return;\n\n            case 3:\n               /* This can only be the RGB case, so each copy is exactly one\n                * pixel and it is not necessary to check for a partial copy.\n                */\n               for (;;)\n               {\n                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n               }\n\n            default:\n#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE\n               /* Check for double byte alignment and, if possible, use a\n                * 16-bit copy.  Don't attempt this for narrow images - ones that\n                * are less than an interlace panel wide.  Don't attempt it for\n                * wide bytes_to_copy either - use the memcpy there.\n                */\n               if (bytes_to_copy < 16 /*else use memcpy*/ &&\n                   png_isaligned(dp, png_uint_16) &&\n                   png_isaligned(sp, png_uint_16) &&\n                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&\n                   bytes_to_jump % (sizeof (png_uint_16)) == 0)\n               {\n                  /* Everything is aligned for png_uint_16 copies, but try for\n                   * png_uint_32 first.\n                   */\n                  if (png_isaligned(dp, png_uint_32) &&\n                      png_isaligned(sp, png_uint_32) &&\n                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&\n                      bytes_to_jump % (sizeof (png_uint_32)) == 0)\n                  {\n                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);\n                     png_const_uint_32p sp32 = png_aligncastconst(\n                         png_const_uint_32p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                         (sizeof (png_uint_32));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp32++ = *sp32++;\n                           c -= (sizeof (png_uint_32));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp32 += skip;\n                        sp32 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* Get to here when the row_width truncates the final copy.\n                      * There will be 1-3 bytes left to copy, so don't try the\n                      * 16-bit loop below.\n                      */\n                     dp = (png_bytep)dp32;\n                     sp = (png_const_bytep)sp32;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n\n                  /* Else do it in 16-bit quantities, but only if the size is\n                   * not too large.\n                   */\n                  else\n                  {\n                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);\n                     png_const_uint_16p sp16 = png_aligncastconst(\n                        png_const_uint_16p, sp);\n                     size_t skip = (bytes_to_jump-bytes_to_copy) /\n                        (sizeof (png_uint_16));\n\n                     do\n                     {\n                        size_t c = bytes_to_copy;\n                        do\n                        {\n                           *dp16++ = *sp16++;\n                           c -= (sizeof (png_uint_16));\n                        }\n                        while (c > 0);\n\n                        if (row_width <= bytes_to_jump)\n                           return;\n\n                        dp16 += skip;\n                        sp16 += skip;\n                        row_width -= bytes_to_jump;\n                     }\n                     while (bytes_to_copy <= row_width);\n\n                     /* End of row - 1 byte left, bytes_to_copy > row_width: */\n                     dp = (png_bytep)dp16;\n                     sp = (png_const_bytep)sp16;\n                     do\n                        *dp++ = *sp++;\n                     while (--row_width > 0);\n                     return;\n                  }\n               }\n#endif /* ALIGN_TYPE code */\n\n               /* The true default - use a memcpy: */\n               for (;;)\n               {\n                  memcpy(dp, sp, bytes_to_copy);\n\n                  if (row_width <= bytes_to_jump)\n                     return;\n\n                  sp += bytes_to_jump;\n                  dp += bytes_to_jump;\n                  row_width -= bytes_to_jump;\n                  if (bytes_to_copy > row_width)\n                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;\n               }\n         }\n\n         /* NOT REACHED*/\n      } /* pixel_depth >= 8 */\n\n      /* Here if pixel_depth < 8 to check 'end_ptr' below. */\n   }\n   else\n#endif /* READ_INTERLACING */\n\n   /* If here then the switch above wasn't used so just memcpy the whole row\n    * from the temporary row buffer (notice that this overwrites the end of the\n    * destination row if it is a partial byte.)\n    */\n   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));\n\n   /* Restore the overwritten bits from the last byte if necessary. */\n   if (end_ptr != NULL)\n      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n",
      "line_start": 3238,
      "line_end": 3719,
      "execution_count": 27980,
      "covered_regions": 128,
      "total_regions": 4830,
      "coverage_percent": 2.65,
      "is_covered": true,
      "is_static": false,
      "score": 10.0,
      "reason": "Processes complex external input (PNG row/interlace logic), performs many raw memory operations (memcpy, pointer writes, byte/word copies), has high cyclomatic complexity and numerous branches/loops with input-dependent bounds and masks \u2014 high likelihood of memory-corruption bugs, making it a critical fuzz target."
    },
    {
      "name": "png_icc_check_header",
      "clean_name": "png_icc_check_header",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_header(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length,\n   png_const_bytep profile/* first 132 bytes only */, int color_type)\n{\n   png_uint_32 temp;\n\n   /* Length check; this cannot be ignored in this code because profile_length\n    * is used later to check the tag table, so even if the profile seems over\n    * long profile_length from the caller must be correct.  The caller can fix\n    * this up on read or write by just passing in the profile header length.\n    */\n   temp = png_get_uint_32(profile);\n   if (temp != profile_length)\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"length does not match profile\");\n\n   temp = (png_uint_32) (*(profile+8));\n   if (temp > 3 && (profile_length & 3))\n      return png_icc_profile_error(png_ptr, name, profile_length,\n          \"invalid length\");\n\n   temp = png_get_uint_32(profile+128); /* tag count: 12 bytes/tag */\n   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */\n      profile_length < 132+12*temp) /* truncated tag table */\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"tag count too large\");\n\n   /* The 'intent' must be valid or we can't store it, ICC limits the intent to\n    * 16 bits.\n    */\n   temp = png_get_uint_32(profile+64);\n   if (temp >= 0xffff) /* The ICC limit */\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"invalid rendering intent\");\n\n   /* This is just a warning because the profile may be valid in future\n    * versions.\n    */\n   if (temp >= PNG_sRGB_INTENT_LAST)\n      (void)png_icc_profile_error(png_ptr, name, temp,\n          \"intent outside defined range\");\n\n   /* At this point the tag table can't be checked because it hasn't necessarily\n    * been loaded; however, various header fields can be checked.  These checks\n    * are for values permitted by the PNG spec in an ICC profile; the PNG spec\n    * restricts the profiles that can be passed in an iCCP chunk (they must be\n    * appropriate to processing PNG data!)\n    */\n\n   /* Data checks (could be skipped).  These checks must be independent of the\n    * version number; however, the version number doesn't accommodate changes in\n    * the header fields (just the known tags and the interpretation of the\n    * data.)\n    */\n   temp = png_get_uint_32(profile+36); /* signature 'ascp' */\n   if (temp != 0x61637370)\n      return png_icc_profile_error(png_ptr, name, temp,\n          \"invalid signature\");\n\n   /* Currently the PCS illuminant/adopted white point (the computational\n    * white point) are required to be D50,\n    * however the profile contains a record of the illuminant so perhaps ICC\n    * expects to be able to change this in the future (despite the rationale in\n    * the introduction for using a fixed PCS adopted white.)  Consequently the\n    * following is just a warning.\n    */\n   if (memcmp(profile+68, D50_nCIEXYZ, 12) != 0)\n      (void)png_icc_profile_error(png_ptr, name, 0/*no tag value*/,\n          \"PCS illuminant is not D50\");\n\n   /* The PNG spec requires this:\n    * \"If the iCCP chunk is present, the image samples conform to the colour\n    * space represented by the embedded ICC profile as defined by the\n    * International Color Consortium [ICC]. The colour space of the ICC profile\n    * shall be an RGB colour space for colour images (PNG colour types 2, 3, and\n    * 6), or a greyscale colour space for greyscale images (PNG colour types 0\n    * and 4).\"\n    *\n    * This checking code ensures the embedded profile (on either read or write)\n    * conforms to the specification requirements.  Notice that an ICC 'gray'\n    * color-space profile contains the information to transform the monochrome\n    * data to XYZ or L*a*b (according to which PCS the profile uses) and this\n    * should be used in preference to the standard libpng K channel replication\n    * into R, G and B channels.\n    *\n    * Previously it was suggested that an RGB profile on grayscale data could be\n    * handled.  However it it is clear that using an RGB profile in this context\n    * must be an error - there is no specification of what it means.  Thus it is\n    * almost certainly more correct to ignore the profile.\n    */\n   temp = png_get_uint_32(profile+16); /* data colour space field */\n   switch (temp)\n   {\n      case 0x52474220: /* 'RGB ' */\n         if ((color_type & PNG_COLOR_MASK_COLOR) == 0)\n            return png_icc_profile_error(png_ptr, name, temp,\n                \"RGB color space not permitted on grayscale PNG\");\n         break;\n\n      case 0x47524159: /* 'GRAY' */\n         if ((color_type & PNG_COLOR_MASK_COLOR) != 0)\n            return png_icc_profile_error(png_ptr, name, temp,\n                \"Gray color space not permitted on RGB PNG\");\n         break;\n\n      default:\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"invalid ICC profile color space\");\n   }\n\n   /* It is up to the application to check that the profile class matches the\n    * application requirements; the spec provides no guidance, but it's pretty\n    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer\n    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these\n    * cases.  Issue an error for device link or abstract profiles - these don't\n    * contain the records necessary to transform the color-space to anything\n    * other than the target device (and not even that for an abstract profile).\n    * Profiles of these classes may not be embedded in images.\n    */\n   temp = png_get_uint_32(profile+12); /* profile/device class */\n   switch (temp)\n   {\n      case 0x73636e72: /* 'scnr' */\n      case 0x6d6e7472: /* 'mntr' */\n      case 0x70727472: /* 'prtr' */\n      case 0x73706163: /* 'spac' */\n         /* All supported */\n         break;\n\n      case 0x61627374: /* 'abst' */\n         /* May not be embedded in an image */\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"invalid embedded Abstract ICC profile\");\n\n      case 0x6c696e6b: /* 'link' */\n         /* DeviceLink profiles cannot be interpreted in a non-device specific\n          * fashion, if an app uses the AToB0Tag in the profile the results are\n          * undefined unless the result is sent to the intended device,\n          * therefore a DeviceLink profile should not be found embedded in a\n          * PNG.\n          */\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected DeviceLink ICC profile class\");\n\n      case 0x6e6d636c: /* 'nmcl' */\n         /* A NamedColor profile is also device specific, however it doesn't\n          * contain an AToB0 tag that is open to misinterpretation.  Almost\n          * certainly it will fail the tests below.\n          */\n         (void)png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected NamedColor ICC profile class\");\n         break;\n\n      default:\n         /* To allow for future enhancements to the profile accept unrecognized\n          * profile classes with a warning, these then hit the test below on the\n          * tag content to ensure they are backward compatible with one of the\n          * understood profiles.\n          */\n         (void)png_icc_profile_error(png_ptr, name, temp,\n             \"unrecognized ICC profile class\");\n         break;\n   }\n\n   /* For any profile other than a device link one the PCS must be encoded\n    * either in XYZ or Lab.\n    */\n   temp = png_get_uint_32(profile+20);\n   switch (temp)\n   {\n      case 0x58595a20: /* 'XYZ ' */\n      case 0x4c616220: /* 'Lab ' */\n         break;\n\n      default:\n         return png_icc_profile_error(png_ptr, name, temp,\n             \"unexpected ICC PCS encoding\");\n   }\n\n   return 1;\n}\n",
      "line_start": 1610,
      "line_end": 1791,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 142,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses a complex external file structure (ICC profile header) from untrusted bytes, performs many input-dependent memory reads and a memcmp, and contains multiple branches/switches and validation checks. High value as a fuzz target to find parsing and bounds/logic issues."
    },
    {
      "name": "pngread.c:png_image_read_colormap",
      "clean_name": "png_image_read_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "/* Return a palette index to the above palette given three 8-bit sRGB values. */\n#define PNG_RGB_INDEX(r,g,b) \\\n   ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))\n\nstatic int\npng_image_read_colormap(png_voidp argument)\n{\n   png_image_read_control *display =\n      png_voidcast(png_image_read_control*, argument);\n   png_imagep image = display->image;\n\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_uint_32 output_format = image->format;\n   int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) != 0 ?\n      P_LINEAR : P_sRGB;\n\n   unsigned int cmap_entries;\n   unsigned int output_processing;        /* Output processing option */\n   unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */\n\n   /* Background information; the background color and the index of this color\n    * in the color-map if it exists (else 256).\n    */\n   unsigned int background_index = 256;\n   png_uint_32 back_r, back_g, back_b;\n\n   /* Flags to accumulate things that need to be done to the input. */\n   int expand_tRNS = 0;\n\n   /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is\n    * very difficult to do, the results look awful, and it is difficult to see\n    * what possible use it is because the application can't control the\n    * color-map.\n    */\n   if (((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0 ||\n         png_ptr->num_trans > 0) /* alpha in input */ &&\n      ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0) /* no alpha in output */)\n   {\n      if (output_encoding == P_LINEAR) /* compose on black */\n         back_b = back_g = back_r = 0;\n\n      else if (display->background == NULL /* no way to remove it */)\n         png_error(png_ptr,\n             \"background color must be supplied to remove alpha/transparency\");\n\n      /* Get a copy of the background color (this avoids repeating the checks\n       * below.)  The encoding is 8-bit sRGB or 16-bit linear, depending on the\n       * output format.\n       */\n      else\n      {\n         back_g = display->background->green;\n         if ((output_format & PNG_FORMAT_FLAG_COLOR) != 0)\n         {\n            back_r = display->background->red;\n            back_b = display->background->blue;\n         }\n         else\n            back_b = back_r = back_g;\n      }\n   }\n\n   else if (output_encoding == P_LINEAR)\n      back_b = back_r = back_g = 65535;\n\n   else\n      back_b = back_r = back_g = 255;\n\n   /* Default the input file gamma if required - this is necessary because\n    * libpng assumes that if no gamma information is present the data is in the\n    * output format, but the simplified API deduces the gamma from the input\n    * format.  The 'default' gamma value is also set by png_set_alpha_mode, but\n    * this is happening before any such call, so:\n    *\n    * TODO: should be an internal API and all this code should be copied into a\n    * single common gamma+colorspace file.\n    */\n   if (png_ptr->bit_depth == 16 &&\n      (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n      png_ptr->default_gamma = PNG_GAMMA_LINEAR;\n\n   else\n      png_ptr->default_gamma = PNG_GAMMA_sRGB_INVERSE;\n\n   /* Decide what to do based on the PNG color type of the input data.  The\n    * utility function png_create_colormap_entry deals with most aspects of the\n    * output transformations; this code works out how to produce bytes of\n    * color-map entries from the original format.\n    */\n   switch (png_ptr->color_type)\n   {\n      case PNG_COLOR_TYPE_GRAY:\n         if (png_ptr->bit_depth <= 8)\n         {\n            /* There at most 256 colors in the output, regardless of\n             * transparency.\n             */\n            unsigned int step, i, val, trans = 256/*ignore*/, back_alpha = 0;\n\n            cmap_entries = 1U << png_ptr->bit_depth;\n            if (cmap_entries > image->colormap_entries)\n               png_error(png_ptr, \"gray[8] color-map: too few entries\");\n\n            step = 255 / (cmap_entries - 1);\n            output_processing = PNG_CMAP_NONE;\n\n            /* If there is a tRNS chunk then this either selects a transparent\n             * value or, if the output has no alpha, the background color.\n             */\n            if (png_ptr->num_trans > 0)\n            {\n               trans = png_ptr->trans_color.gray;\n\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0)\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\n            }\n\n            /* png_create_colormap_entry just takes an RGBA and writes the\n             * corresponding color-map entry using the format from 'image',\n             * including the required conversion to sRGB or linear as\n             * appropriate.  The input values are always either sRGB (if the\n             * gamma correction flag is 0) or 0..255 scaled file encoded values\n             * (if the function must gamma correct them).\n             */\n            for (i=val=0; i<cmap_entries; ++i, val += step)\n            {\n               /* 'i' is a file value.  While this will result in duplicated\n                * entries for 8-bit non-sRGB encoded files it is necessary to\n                * have non-gamma corrected values to do tRNS handling.\n                */\n               if (i != trans)\n                  png_create_colormap_entry(display, i, val, val, val, 255,\n                      P_FILE/*8-bit with file gamma*/);\n\n               /* Else this entry is transparent.  The colors don't matter if\n                * there is an alpha channel (back_alpha == 0), but it does no\n                * harm to pass them in; the values are not set above so this\n                * passes in white.\n                *\n                * NOTE: this preserves the full precision of the application\n                * supplied background color when it is used.\n                */\n               else\n                  png_create_colormap_entry(display, i, back_r, back_g, back_b,\n                      back_alpha, output_encoding);\n            }\n\n            /* We need libpng to preserve the original encoding. */\n            data_encoding = P_FILE;\n\n            /* The rows from libpng, while technically gray values, are now also\n             * color-map indices; however, they may need to be expanded to 1\n             * byte per pixel.  This is what png_set_packing does (i.e., it\n             * unpacks the bit values into bytes.)\n             */\n            if (png_ptr->bit_depth < 8)\n               png_set_packing(png_ptr);\n         }\n\n         else /* bit depth is 16 */\n         {\n            /* The 16-bit input values can be converted directly to 8-bit gamma\n             * encoded values; however, if a tRNS chunk is present 257 color-map\n             * entries are required.  This means that the extra entry requires\n             * special processing; add an alpha channel, sacrifice gray level\n             * 254 and convert transparent (alpha==0) entries to that.\n             *\n             * Use libpng to chop the data to 8 bits.  Convert it to sRGB at the\n             * same time to minimize quality loss.  If a tRNS chunk is present\n             * this means libpng must handle it too; otherwise it is impossible\n             * to do the exact match on the 16-bit value.\n             *\n             * If the output has no alpha channel *and* the background color is\n             * gray then it is possible to let libpng handle the substitution by\n             * ensuring that the corresponding gray level matches the background\n             * color exactly.\n             */\n            data_encoding = P_sRGB;\n\n            if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n               png_error(png_ptr, \"gray[16] color-map: too few entries\");\n\n            cmap_entries = (unsigned int)make_gray_colormap(display);\n\n            if (png_ptr->num_trans > 0)\n            {\n               unsigned int back_alpha;\n\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n                  back_alpha = 0;\n\n               else\n               {\n                  if (back_r == back_g && back_g == back_b)\n                  {\n                     /* Background is gray; no special processing will be\n                      * required.\n                      */\n                     png_color_16 c;\n                     png_uint_32 gray = back_g;\n\n                     if (output_encoding == P_LINEAR)\n                     {\n                        gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                        /* And make sure the corresponding palette entry\n                         * matches.\n                         */\n                        png_create_colormap_entry(display, gray, back_g, back_g,\n                            back_g, 65535, P_LINEAR);\n                     }\n\n                     /* The background passed to libpng, however, must be the\n                      * sRGB value.\n                      */\n                     c.index = 0; /*unused*/\n                     c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n                     /* NOTE: does this work without expanding tRNS to alpha?\n                      * It should be the color->gray case below apparently\n                      * doesn't.\n                      */\n                     png_set_background_fixed(png_ptr, &c,\n                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                         0/*gamma: not used*/);\n\n                     output_processing = PNG_CMAP_NONE;\n                     break;\n                  }\n#ifdef __COVERITY__\n                 /* Coverity claims that output_encoding cannot be 2 (P_LINEAR)\n                  * here.\n                  */\n                  back_alpha = 255;\n#else\n                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;\n#endif\n               }\n\n               /* output_processing means that the libpng-processed row will be\n                * 8-bit GA and it has to be processing to single byte color-map\n                * values.  Entry 254 is replaced by either a completely\n                * transparent entry or by the background color at full\n                * precision (and the background color is not a simple gray\n                * level in this case.)\n                */\n               expand_tRNS = 1;\n               output_processing = PNG_CMAP_TRANS;\n               background_index = 254;\n\n               /* And set (overwrite) color-map entry 254 to the actual\n                * background color at full precision.\n                */\n               png_create_colormap_entry(display, 254, back_r, back_g, back_b,\n                   back_alpha, output_encoding);\n            }\n\n            else\n               output_processing = PNG_CMAP_NONE;\n         }\n         break;\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n         /* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum\n          * of 65536 combinations.  If, however, the alpha channel is to be\n          * removed there are only 256 possibilities if the background is gray.\n          * (Otherwise there is a subset of the 65536 possibilities defined by\n          * the triangle between black, white and the background color.)\n          *\n          * Reduce 16-bit files to 8-bit and sRGB encode the result.  No need to\n          * worry about tRNS matching - tRNS is ignored if there is an alpha\n          * channel.\n          */\n         data_encoding = P_sRGB;\n\n         if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n         {\n            if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n               png_error(png_ptr, \"gray+alpha color-map: too few entries\");\n\n            cmap_entries = (unsigned int)make_ga_colormap(display);\n\n            background_index = PNG_CMAP_GA_BACKGROUND;\n            output_processing = PNG_CMAP_GA;\n         }\n\n         else /* alpha is removed */\n         {\n            /* Alpha must be removed as the PNG data is processed when the\n             * background is a color because the G and A channels are\n             * independent and the vector addition (non-parallel vectors) is a\n             * 2-D problem.\n             *\n             * This can be reduced to the same algorithm as above by making a\n             * colormap containing gray levels (for the opaque grays), a\n             * background entry (for a transparent pixel) and a set of four six\n             * level color values, one set for each intermediate alpha value.\n             * See the comments in make_ga_colormap for how this works in the\n             * per-pixel processing.\n             *\n             * If the background is gray, however, we only need a 256 entry gray\n             * level color map.  It is sufficient to make the entry generated\n             * for the background color be exactly the color specified.\n             */\n            if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0 ||\n               (back_r == back_g && back_g == back_b))\n            {\n               /* Background is gray; no special processing will be required. */\n               png_color_16 c;\n               png_uint_32 gray = back_g;\n\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"gray-alpha color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_gray_colormap(display);\n\n               if (output_encoding == P_LINEAR)\n               {\n                  gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                  /* And make sure the corresponding palette entry matches. */\n                  png_create_colormap_entry(display, gray, back_g, back_g,\n                      back_g, 65535, P_LINEAR);\n               }\n\n               /* The background passed to libpng, however, must be the sRGB\n                * value.\n                */\n               c.index = 0; /*unused*/\n               c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n               png_set_background_fixed(png_ptr, &c,\n                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                   0/*gamma: not used*/);\n\n               output_processing = PNG_CMAP_NONE;\n            }\n\n            else\n            {\n               png_uint_32 i, a;\n\n               /* This is the same as png_make_ga_colormap, above, except that\n                * the entries are all opaque.\n                */\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"ga-alpha color-map: too few entries\");\n\n               i = 0;\n               while (i < 231)\n               {\n                  png_uint_32 gray = (i * 256 + 115) / 231;\n                  png_create_colormap_entry(display, i++, gray, gray, gray,\n                      255, P_sRGB);\n               }\n\n               /* NOTE: this preserves the full precision of the application\n                * background color.\n                */\n               background_index = i;\n               png_create_colormap_entry(display, i++, back_r, back_g, back_b,\n#ifdef __COVERITY__\n                   /* Coverity claims that output_encoding\n                    * cannot be 2 (P_LINEAR) here.\n                    */ 255U,\n#else\n                    output_encoding == P_LINEAR ? 65535U : 255U,\n#endif\n                    output_encoding);\n\n               /* For non-opaque input composite on the sRGB background - this\n                * requires inverting the encoding for each component.  The input\n                * is still converted to the sRGB encoding because this is a\n                * reasonable approximate to the logarithmic curve of human\n                * visual sensitivity, at least over the narrow range which PNG\n                * represents.  Consequently 'G' is always sRGB encoded, while\n                * 'A' is linear.  We need the linear background colors.\n                */\n               if (output_encoding == P_sRGB) /* else already linear */\n               {\n                  /* This may produce a value not exactly matching the\n                   * background, but that's ok because these numbers are only\n                   * used when alpha != 0\n                   */\n                  back_r = png_sRGB_table[back_r];\n                  back_g = png_sRGB_table[back_g];\n                  back_b = png_sRGB_table[back_b];\n               }\n\n               for (a=1; a<5; ++a)\n               {\n                  unsigned int g;\n\n                  /* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled\n                   * by an 8-bit alpha value (0..255).\n                   */\n                  png_uint_32 alpha = 51 * a;\n                  png_uint_32 back_rx = (255-alpha) * back_r;\n                  png_uint_32 back_gx = (255-alpha) * back_g;\n                  png_uint_32 back_bx = (255-alpha) * back_b;\n\n                  for (g=0; g<6; ++g)\n                  {\n                     png_uint_32 gray = png_sRGB_table[g*51] * alpha;\n\n                     png_create_colormap_entry(display, i++,\n                         PNG_sRGB_FROM_LINEAR(gray + back_rx),\n                         PNG_sRGB_FROM_LINEAR(gray + back_gx),\n                         PNG_sRGB_FROM_LINEAR(gray + back_bx), 255, P_sRGB);\n                  }\n               }\n\n               cmap_entries = i;\n               output_processing = PNG_CMAP_GA;\n            }\n         }\n         break;\n\n      case PNG_COLOR_TYPE_RGB:\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n         /* Exclude the case where the output is gray; we can always handle this\n          * with the cases above.\n          */\n         if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0)\n         {\n            /* The color-map will be grayscale, so we may as well convert the\n             * input RGB values to a simple grayscale and use the grayscale\n             * code above.\n             *\n             * NOTE: calling this apparently damages the recognition of the\n             * transparent color in background color handling; call\n             * png_set_tRNS_to_alpha before png_set_background_fixed.\n             */\n            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE, -1,\n                -1);\n            data_encoding = P_sRGB;\n\n            /* The output will now be one or two 8-bit gray or gray+alpha\n             * channels.  The more complex case arises when the input has alpha.\n             */\n            if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n               png_ptr->num_trans > 0) &&\n               (output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n            {\n               /* Both input and output have an alpha channel, so no background\n                * processing is required; just map the GA bytes to the right\n                * color-map entry.\n                */\n               expand_tRNS = 1;\n\n               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb[ga] color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_ga_colormap(display);\n               background_index = PNG_CMAP_GA_BACKGROUND;\n               output_processing = PNG_CMAP_GA;\n            }\n\n            else\n            {\n               const png_fixed_point gamma = png_resolve_file_gamma(png_ptr);\n\n               /* Either the input or the output has no alpha channel, so there\n                * will be no non-opaque pixels in the color-map; it will just be\n                * grayscale.\n                */\n               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb[gray] color-map: too few entries\");\n\n               /* Ideally this code would use libpng to do the gamma correction,\n                * but if an input alpha channel is to be removed we will hit the\n                * libpng bug in gamma+compose+rgb-to-gray (the double gamma\n                * correction bug).  Fix this by dropping the gamma correction in\n                * this case and doing it in the palette; this will result in\n                * duplicate palette entries, but that's better than the\n                * alternative of double gamma correction.\n                *\n                * NOTE: PNGv3: check the resolved result of all the potentially\n                * different colour space chunks.\n                */\n               if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n                  png_ptr->num_trans > 0) &&\n                  png_gamma_not_sRGB(gamma) != 0)\n               {\n                  cmap_entries = (unsigned int)make_gray_file_colormap(display);\n                  data_encoding = P_FILE;\n               }\n\n               else\n                  cmap_entries = (unsigned int)make_gray_colormap(display);\n\n               /* But if the input has alpha or transparency it must be removed\n                */\n               if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n                  png_ptr->num_trans > 0)\n               {\n                  png_color_16 c;\n                  png_uint_32 gray = back_g;\n\n                  /* We need to ensure that the application background exists in\n                   * the colormap and that completely transparent pixels map to\n                   * it.  Achieve this simply by ensuring that the entry\n                   * selected for the background really is the background color.\n                   */\n                  if (data_encoding == P_FILE) /* from the fixup above */\n                  {\n                     /* The app supplied a gray which is in output_encoding, we\n                      * need to convert it to a value of the input (P_FILE)\n                      * encoding then set this palette entry to the required\n                      * output encoding.\n                      */\n                     if (output_encoding == P_sRGB)\n                        gray = png_sRGB_table[gray]; /* now P_LINEAR */\n\n                     gray = PNG_DIV257(png_gamma_16bit_correct(gray, gamma));\n                        /* now P_FILE */\n\n                     /* And make sure the corresponding palette entry contains\n                      * exactly the required sRGB value.\n                      */\n                     png_create_colormap_entry(display, gray, back_g, back_g,\n                         back_g, 0/*unused*/, output_encoding);\n                  }\n\n                  else if (output_encoding == P_LINEAR)\n                  {\n                     gray = PNG_sRGB_FROM_LINEAR(gray * 255);\n\n                     /* And make sure the corresponding palette entry matches.\n                      */\n                     png_create_colormap_entry(display, gray, back_g, back_g,\n                        back_g, 0/*unused*/, P_LINEAR);\n                  }\n\n                  /* The background passed to libpng, however, must be the\n                   * output (normally sRGB) value.\n                   */\n                  c.index = 0; /*unused*/\n                  c.gray = c.red = c.green = c.blue = (png_uint_16)gray;\n\n                  /* NOTE: the following is apparently a bug in libpng. Without\n                   * it the transparent color recognition in\n                   * png_set_background_fixed seems to go wrong.\n                   */\n                  expand_tRNS = 1;\n                  png_set_background_fixed(png_ptr, &c,\n                      PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                      0/*gamma: not used*/);\n               }\n\n               output_processing = PNG_CMAP_NONE;\n            }\n         }\n\n         else /* output is color */\n         {\n            /* We could use png_quantize here so long as there is no transparent\n             * color or alpha; png_quantize ignores alpha.  Easier overall just\n             * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.\n             * Consequently we always want libpng to produce sRGB data.\n             */\n            data_encoding = P_sRGB;\n\n            /* Is there any transparency or alpha? */\n            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||\n               png_ptr->num_trans > 0)\n            {\n               /* Is there alpha in the output too?  If so all four channels are\n                * processed into a special RGB cube with alpha support.\n                */\n               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)\n               {\n                  png_uint_32 r;\n\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\n                     png_error(png_ptr, \"rgb+alpha color-map: too few entries\");\n\n                  cmap_entries = (unsigned int)make_rgb_colormap(display);\n\n                  /* Add a transparent entry. */\n                  png_create_colormap_entry(display, cmap_entries, 255, 255,\n                      255, 0, P_sRGB);\n\n                  /* This is stored as the background index for the processing\n                   * algorithm.\n                   */\n                  background_index = cmap_entries++;\n\n                  /* Add 27 r,g,b entries each with alpha 0.5. */\n                  for (r=0; r<256; r = (r << 1) | 0x7f)\n                  {\n                     png_uint_32 g;\n\n                     for (g=0; g<256; g = (g << 1) | 0x7f)\n                     {\n                        png_uint_32 b;\n\n                        /* This generates components with the values 0, 127 and\n                         * 255\n                         */\n                        for (b=0; b<256; b = (b << 1) | 0x7f)\n                           png_create_colormap_entry(display, cmap_entries++,\n                               r, g, b, 128, P_sRGB);\n                     }\n                  }\n\n                  expand_tRNS = 1;\n                  output_processing = PNG_CMAP_RGB_ALPHA;\n               }\n\n               else\n               {\n                  /* Alpha/transparency must be removed.  The background must\n                   * exist in the color map (achieved by setting adding it after\n                   * the 666 color-map).  If the standard processing code will\n                   * pick up this entry automatically that's all that is\n                   * required; libpng can be called to do the background\n                   * processing.\n                   */\n                  unsigned int sample_size =\n                     PNG_IMAGE_SAMPLE_SIZE(output_format);\n                  png_uint_32 r, g, b; /* sRGB background */\n\n                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)\n                     png_error(png_ptr, \"rgb-alpha color-map: too few entries\");\n\n                  cmap_entries = (unsigned int)make_rgb_colormap(display);\n\n                  png_create_colormap_entry(display, cmap_entries, back_r,\n                      back_g, back_b, 0/*unused*/, output_encoding);\n\n                  if (output_encoding == P_LINEAR)\n                  {\n                     r = PNG_sRGB_FROM_LINEAR(back_r * 255);\n                     g = PNG_sRGB_FROM_LINEAR(back_g * 255);\n                     b = PNG_sRGB_FROM_LINEAR(back_b * 255);\n                  }\n\n                  else\n                  {\n                     r = back_r;\n                     g = back_g;\n                     b = back_g;\n                  }\n\n                  /* Compare the newly-created color-map entry with the one the\n                   * PNG_CMAP_RGB algorithm will use.  If the two entries don't\n                   * match, add the new one and set this as the background\n                   * index.\n                   */\n                  if (memcmp((png_const_bytep)display->colormap +\n                      sample_size * cmap_entries,\n                      (png_const_bytep)display->colormap +\n                          sample_size * PNG_RGB_INDEX(r,g,b),\n                     sample_size) != 0)\n                  {\n                     /* The background color must be added. */\n                     background_index = cmap_entries++;\n\n                     /* Add 27 r,g,b entries each with created by composing with\n                      * the background at alpha 0.5.\n                      */\n                     for (r=0; r<256; r = (r << 1) | 0x7f)\n                     {\n                        for (g=0; g<256; g = (g << 1) | 0x7f)\n                        {\n                           /* This generates components with the values 0, 127\n                            * and 255\n                            */\n                           for (b=0; b<256; b = (b << 1) | 0x7f)\n                              png_create_colormap_entry(display, cmap_entries++,\n                                  png_colormap_compose(display, r, P_sRGB, 128,\n                                      back_r, output_encoding),\n                                  png_colormap_compose(display, g, P_sRGB, 128,\n                                      back_g, output_encoding),\n                                  png_colormap_compose(display, b, P_sRGB, 128,\n                                      back_b, output_encoding),\n                                  0/*unused*/, output_encoding);\n                        }\n                     }\n\n                     expand_tRNS = 1;\n                     output_processing = PNG_CMAP_RGB_ALPHA;\n                  }\n\n                  else /* background color is in the standard color-map */\n                  {\n                     png_color_16 c;\n\n                     c.index = 0; /*unused*/\n                     c.red = (png_uint_16)back_r;\n                     c.gray = c.green = (png_uint_16)back_g;\n                     c.blue = (png_uint_16)back_b;\n\n                     png_set_background_fixed(png_ptr, &c,\n                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,\n                         0/*gamma: not used*/);\n\n                     output_processing = PNG_CMAP_RGB;\n                  }\n               }\n            }\n\n            else /* no alpha or transparency in the input */\n            {\n               /* Alpha in the output is irrelevant, simply map the opaque input\n                * pixels to the 6x6x6 color-map.\n                */\n               if (PNG_RGB_COLORMAP_ENTRIES > image->colormap_entries)\n                  png_error(png_ptr, \"rgb color-map: too few entries\");\n\n               cmap_entries = (unsigned int)make_rgb_colormap(display);\n               output_processing = PNG_CMAP_RGB;\n            }\n         }\n         break;\n\n      case PNG_COLOR_TYPE_PALETTE:\n         /* It's already got a color-map.  It may be necessary to eliminate the\n          * tRNS entries though.\n          */\n         {\n            unsigned int num_trans = png_ptr->num_trans;\n            png_const_bytep trans = num_trans > 0 ? png_ptr->trans_alpha : NULL;\n            png_const_colorp colormap = png_ptr->palette;\n            int do_background = trans != NULL &&\n               (output_format & PNG_FORMAT_FLAG_ALPHA) == 0;\n            unsigned int i;\n\n            /* Just in case: */\n            if (trans == NULL)\n               num_trans = 0;\n\n            output_processing = PNG_CMAP_NONE;\n            data_encoding = P_FILE; /* Don't change from color-map indices */\n            cmap_entries = (unsigned int)png_ptr->num_palette;\n            if (cmap_entries > 256)\n               cmap_entries = 256;\n\n            if (cmap_entries > (unsigned int)image->colormap_entries)\n               png_error(png_ptr, \"palette color-map: too few entries\");\n\n            for (i=0; i < cmap_entries; ++i)\n            {\n               if (do_background != 0 && i < num_trans && trans[i] < 255)\n               {\n                  if (trans[i] == 0)\n                     png_create_colormap_entry(display, i, back_r, back_g,\n                         back_b, 0, output_encoding);\n\n                  else\n                  {\n                     /* Must compose the PNG file color in the color-map entry\n                      * on the sRGB color in 'back'.\n                      */\n                     png_create_colormap_entry(display, i,\n                         png_colormap_compose(display, colormap[i].red,\n                             P_FILE, trans[i], back_r, output_encoding),\n                         png_colormap_compose(display, colormap[i].green,\n                             P_FILE, trans[i], back_g, output_encoding),\n                         png_colormap_compose(display, colormap[i].blue,\n                             P_FILE, trans[i], back_b, output_encoding),\n                         output_encoding == P_LINEAR ? trans[i] * 257U :\n                             trans[i],\n                         output_encoding);\n                  }\n               }\n\n               else\n                  png_create_colormap_entry(display, i, colormap[i].red,\n                      colormap[i].green, colormap[i].blue,\n                      i < num_trans ? trans[i] : 255U, P_FILE/*8-bit*/);\n            }\n\n            /* The PNG data may have indices packed in fewer than 8 bits, it\n             * must be expanded if so.\n             */\n            if (png_ptr->bit_depth < 8)\n               png_set_packing(png_ptr);\n         }\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid PNG color type\");\n         /*NOT REACHED*/\n   }\n\n   /* Now deal with the output processing */\n   if (expand_tRNS != 0 && png_ptr->num_trans > 0 &&\n       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) == 0)\n      png_set_tRNS_to_alpha(png_ptr);\n\n   switch (data_encoding)\n   {\n      case P_sRGB:\n         /* Change to 8-bit sRGB */\n         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);\n         /* FALLTHROUGH */\n\n      case P_FILE:\n         if (png_ptr->bit_depth > 8)\n            png_set_scale_16(png_ptr);\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(png_ptr, \"bad data option (internal error)\");\n#endif\n   }\n\n   if (cmap_entries > 256 || cmap_entries > image->colormap_entries)\n      png_error(png_ptr, \"color map overflow (BAD internal error)\");\n\n   image->colormap_entries = cmap_entries;\n\n   /* Double check using the recorded background index */\n   switch (output_processing)\n   {\n      case PNG_CMAP_NONE:\n         if (background_index != PNG_CMAP_NONE_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_GA:\n         if (background_index != PNG_CMAP_GA_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_TRANS:\n         if (background_index >= cmap_entries ||\n            background_index != PNG_CMAP_TRANS_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_RGB:\n         if (background_index != PNG_CMAP_RGB_BACKGROUND)\n            goto bad_background;\n         break;\n\n      case PNG_CMAP_RGB_ALPHA:\n         if (background_index != PNG_CMAP_RGB_ALPHA_BACKGROUND)\n            goto bad_background;\n         break;\n\n      default:\n         png_error(png_ptr, \"bad processing option (internal error)\");\n\n      bad_background:\n         png_error(png_ptr, \"bad background index (internal error)\");\n   }\n\n   display->colormap_processing = (int)output_processing;\n\n   return 1/*ok*/;\n}\n",
      "line_start": 1959,
      "line_end": 2809,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 964,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses complex external input (PNG color types/metadata), has extensive branching and loops driven by input fields (bit_depth, color_type, num_trans, palette size), and performs buffer/colormap writes and memcmp/composition calls on untrusted data. High complexity and many code paths make it a strong fuzz target (no crypto/auth so not 10)."
    },
    {
      "name": "pngread.c:png_create_colormap_entry",
      "clean_name": "png_create_colormap_entry",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must\n * be 8-bit.\n */\nstatic void\npng_create_colormap_entry(png_image_read_control *display,\n    png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,\n    png_uint_32 alpha, int encoding)\n{\n   png_imagep image = display->image;\n   int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) != 0 ?\n       P_LINEAR : P_sRGB;\n   int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&\n       (red != green || green != blue);\n\n   if (ip > 255)\n      png_error(image->opaque->png_ptr, \"color-map index out of range\");\n\n   /* Update the cache with whether the file gamma is significantly different\n    * from sRGB.\n    */\n   if (encoding == P_FILE)\n   {\n      if (display->file_encoding == P_NOTSET)\n         set_file_encoding(display);\n\n      /* Note that the cached value may be P_FILE too, but if it is then the\n       * gamma_to_linear member has been set.\n       */\n      encoding = display->file_encoding;\n   }\n\n   if (encoding == P_FILE)\n   {\n      png_fixed_point g = display->gamma_to_linear;\n\n      red = png_gamma_16bit_correct(red*257, g);\n      green = png_gamma_16bit_correct(green*257, g);\n      blue = png_gamma_16bit_correct(blue*257, g);\n\n      if (convert_to_Y != 0 || output_encoding == P_LINEAR)\n      {\n         alpha *= 257;\n         encoding = P_LINEAR;\n      }\n\n      else\n      {\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\n         encoding = P_sRGB;\n      }\n   }\n\n   else if (encoding == P_LINEAR8)\n   {\n      /* This encoding occurs quite frequently in test cases because PngSuite\n       * includes a gAMA 1.0 chunk with most images.\n       */\n      red *= 257;\n      green *= 257;\n      blue *= 257;\n      alpha *= 257;\n      encoding = P_LINEAR;\n   }\n\n   else if (encoding == P_sRGB &&\n       (convert_to_Y  != 0 || output_encoding == P_LINEAR))\n   {\n      /* The values are 8-bit sRGB values, but must be converted to 16-bit\n       * linear.\n       */\n      red = png_sRGB_table[red];\n      green = png_sRGB_table[green];\n      blue = png_sRGB_table[blue];\n      alpha *= 257;\n      encoding = P_LINEAR;\n   }\n\n   /* This is set if the color isn't gray but the output is. */\n   if (encoding == P_LINEAR)\n   {\n      if (convert_to_Y != 0)\n      {\n         /* NOTE: these values are copied from png_do_rgb_to_gray */\n         png_uint_32 y = (png_uint_32)6968 * red  + (png_uint_32)23434 * green +\n            (png_uint_32)2366 * blue;\n\n         if (output_encoding == P_LINEAR)\n            y = (y + 16384) >> 15;\n\n         else\n         {\n            /* y is scaled by 32768, we need it scaled by 255: */\n            y = (y + 128) >> 8;\n            y *= 255;\n            y = PNG_sRGB_FROM_LINEAR((y + 64) >> 7);\n            alpha = PNG_DIV257(alpha);\n            encoding = P_sRGB;\n         }\n\n         blue = red = green = y;\n      }\n\n      else if (output_encoding == P_sRGB)\n      {\n         red = PNG_sRGB_FROM_LINEAR(red * 255);\n         green = PNG_sRGB_FROM_LINEAR(green * 255);\n         blue = PNG_sRGB_FROM_LINEAR(blue * 255);\n         alpha = PNG_DIV257(alpha);\n         encoding = P_sRGB;\n      }\n   }\n\n   if (encoding != output_encoding)\n      png_error(image->opaque->png_ptr, \"bad encoding (internal error)\");\n\n   /* Store the value. */\n   {\n#     ifdef PNG_FORMAT_AFIRST_SUPPORTED\n         int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&\n            (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;\n#     else\n#        define afirst 0\n#     endif\n#     ifdef PNG_FORMAT_BGR_SUPPORTED\n         int bgr = (image->format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;\n#     else\n#        define bgr 0\n#     endif\n\n      if (output_encoding == P_LINEAR)\n      {\n         png_uint_16p entry = png_voidcast(png_uint_16p, display->colormap);\n\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\n\n         /* The linear 16-bit values must be pre-multiplied by the alpha channel\n          * value, if less than 65535 (this is, effectively, composite on black\n          * if the alpha channel is removed.)\n          */\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\n         {\n            case 4:\n               entry[afirst ? 0 : 3] = (png_uint_16)alpha;\n               /* FALLTHROUGH */\n\n            case 3:\n               if (alpha < 65535)\n               {\n                  if (alpha > 0)\n                  {\n                     blue = (blue * alpha + 32767U)/65535U;\n                     green = (green * alpha + 32767U)/65535U;\n                     red = (red * alpha + 32767U)/65535U;\n                  }\n\n                  else\n                     red = green = blue = 0;\n               }\n               entry[afirst + (2 ^ bgr)] = (png_uint_16)blue;\n               entry[afirst + 1] = (png_uint_16)green;\n               entry[afirst + bgr] = (png_uint_16)red;\n               break;\n\n            case 2:\n               entry[1 ^ afirst] = (png_uint_16)alpha;\n               /* FALLTHROUGH */\n\n            case 1:\n               if (alpha < 65535)\n               {\n                  if (alpha > 0)\n                     green = (green * alpha + 32767U)/65535U;\n\n                  else\n                     green = 0;\n               }\n               entry[afirst] = (png_uint_16)green;\n               break;\n\n            default:\n               break;\n         }\n      }\n\n      else /* output encoding is P_sRGB */\n      {\n         png_bytep entry = png_voidcast(png_bytep, display->colormap);\n\n         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);\n\n         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))\n         {\n            case 4:\n               entry[afirst ? 0 : 3] = (png_byte)alpha;\n               /* FALLTHROUGH */\n            case 3:\n               entry[afirst + (2 ^ bgr)] = (png_byte)blue;\n               entry[afirst + 1] = (png_byte)green;\n               entry[afirst + bgr] = (png_byte)red;\n               break;\n\n            case 2:\n               entry[1 ^ afirst] = (png_byte)alpha;\n               /* FALLTHROUGH */\n            case 1:\n               entry[afirst] = (png_byte)green;\n               break;\n\n            default:\n               break;\n         }\n      }\n\n#     ifdef afirst\n#        undef afirst\n#     endif\n#     ifdef bgr\n#        undef bgr\n#     endif\n   }\n}\n",
      "line_start": 1631,
      "line_end": 1850,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 303,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Processes external PNG palette data and performs many memory writes into display->colormap based on an input index and format flags. It contains extensive branching and complex color/gamma/alpha conversions (type scaling, premultiplication, encoding switches) making it rich in input-dependent code paths and a likely source of memory/logic bugs (buffer/overflow/incorrect conversions). High-value fuzz target."
    },
    {
      "name": "pngread.c:png_image_read_and_map",
      "clean_name": "png_image_read_and_map",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 1/*ok*/;\n}\n\n/* The final part of the color-map read called from png_image_finish_read. */\nstatic int\npng_image_read_and_map(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   int passes;\n\n   /* Called when the libpng data must be transformed into the color-mapped\n    * form.  There is a local row buffer in display->local and this routine must\n    * do the interlace handling.\n    */\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   {\n      png_uint_32  height = image->height;\n      png_uint_32  width = image->width;\n      int          proc = display->colormap_processing;\n      png_bytep    first_row = png_voidcast(png_bytep, display->first_row);\n      ptrdiff_t    step_row = display->row_bytes;\n      int pass;\n\n      for (pass = 0; pass < passes; ++pass)\n      {\n         unsigned int     startx, stepx, stepy;\n         png_uint_32      y;\n\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n         {\n            /* The row may be empty for a short image: */\n            if (PNG_PASS_COLS(width, pass) == 0)\n               continue;\n\n            startx = PNG_PASS_START_COL(pass);\n            stepx = PNG_PASS_COL_OFFSET(pass);\n            y = PNG_PASS_START_ROW(pass);\n            stepy = PNG_PASS_ROW_OFFSET(pass);\n         }\n\n         else\n         {\n            y = 0;\n            startx = 0;\n            stepx = stepy = 1;\n         }\n\n         for (; y<height; y += stepy)\n         {\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\n            png_bytep outrow = first_row + y * step_row;\n            png_const_bytep end_row = outrow + width;\n\n            /* Read read the libpng data into the temporary buffer. */\n            png_read_row(png_ptr, inrow, NULL);\n\n            /* Now process the row according to the processing option, note\n             * that the caller verifies that the format of the libpng output\n             * data is as required.\n             */\n            outrow += startx;\n            switch (proc)\n            {\n               case PNG_CMAP_GA:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     /* The data is always in the PNG order */\n                     unsigned int gray = *inrow++;\n                     unsigned int alpha = *inrow++;\n                     unsigned int entry;\n\n                     /* NOTE: this code is copied as a comment in\n                      * make_ga_colormap above.  Please update the\n                      * comment if you change this code!\n                      */\n                     if (alpha > 229) /* opaque */\n                     {\n                        entry = (231 * gray + 128) >> 8;\n                     }\n                     else if (alpha < 26) /* transparent */\n                     {\n                        entry = 231;\n                     }\n                     else /* partially opaque */\n                     {\n                        entry = 226 + 6 * PNG_DIV51(alpha) + PNG_DIV51(gray);\n                     }\n\n                     *outrow = (png_byte)entry;\n                  }\n                  break;\n\n               case PNG_CMAP_TRANS:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     png_byte gray = *inrow++;\n                     png_byte alpha = *inrow++;\n\n                     if (alpha == 0)\n                        *outrow = PNG_CMAP_TRANS_BACKGROUND;\n\n                     else if (gray != PNG_CMAP_TRANS_BACKGROUND)\n                        *outrow = gray;\n\n                     else\n                        *outrow = (png_byte)(PNG_CMAP_TRANS_BACKGROUND+1);\n                  }\n                  break;\n\n               case PNG_CMAP_RGB:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     *outrow = PNG_RGB_INDEX(inrow[0], inrow[1], inrow[2]);\n                     inrow += 3;\n                  }\n                  break;\n\n               case PNG_CMAP_RGB_ALPHA:\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     unsigned int alpha = inrow[3];\n\n                     /* Because the alpha entries only hold alpha==0.5 values\n                      * split the processing at alpha==0.25 (64) and 0.75\n                      * (196).\n                      */\n\n                     if (alpha >= 196)\n                        *outrow = PNG_RGB_INDEX(inrow[0], inrow[1],\n                            inrow[2]);\n\n                     else if (alpha < 64)\n                        *outrow = PNG_CMAP_RGB_ALPHA_BACKGROUND;\n\n                     else\n                     {\n                        /* Likewise there are three entries for each of r, g\n                         * and b.  We could select the entry by popcount on\n                         * the top two bits on those architectures that\n                         * support it, this is what the code below does,\n                         * crudely.\n                         */\n                        unsigned int back_i = PNG_CMAP_RGB_ALPHA_BACKGROUND+1;\n\n                        /* Here are how the values map:\n                         *\n                         * 0x00 .. 0x3f -> 0\n                         * 0x40 .. 0xbf -> 1\n                         * 0xc0 .. 0xff -> 2\n                         *\n                         * So, as above with the explicit alpha checks, the\n                         * breakpoints are at 64 and 196.\n                         */\n                        if (inrow[0] & 0x80) back_i += 9; /* red */\n                        if (inrow[0] & 0x40) back_i += 9;\n                        if (inrow[0] & 0x80) back_i += 3; /* green */\n                        if (inrow[0] & 0x40) back_i += 3;\n                        if (inrow[0] & 0x80) back_i += 1; /* blue */\n                        if (inrow[0] & 0x40) back_i += 1;\n\n                        *outrow = (png_byte)back_i;\n                     }\n\n                     inrow += 4;\n                  }\n                  break;\n\n               default:\n                  break;\n            }\n         }\n      }\n   }\n\n   return 1;\n}\n",
      "line_start": 2812,
      "line_end": 2999,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 218,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Processes complex external input (PNG image rows), performs pointer arithmetic and buffer writes on untrusted data, contains multiple branches (different colormap modes) and interlace/loop logic with input-dependent bounds \u2014 high value as a fuzz target for finding memory/logic bugs."
    },
    {
      "name": "pngread.c:png_image_read_composite",
      "clean_name": "png_image_read_composite",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return 1;\n}\n\n/* Just the row reading part of png_image_read. */\nstatic int\npng_image_read_composite(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   int passes;\n\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   {\n      png_uint_32  height = image->height;\n      png_uint_32  width = image->width;\n      ptrdiff_t    step_row = display->row_bytes;\n      unsigned int channels =\n          (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ? 3 : 1;\n      int pass;\n\n      for (pass = 0; pass < passes; ++pass)\n      {\n         unsigned int     startx, stepx, stepy;\n         png_uint_32      y;\n\n         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n         {\n            /* The row may be empty for a short image: */\n            if (PNG_PASS_COLS(width, pass) == 0)\n               continue;\n\n            startx = PNG_PASS_START_COL(pass) * channels;\n            stepx = PNG_PASS_COL_OFFSET(pass) * channels;\n            y = PNG_PASS_START_ROW(pass);\n            stepy = PNG_PASS_ROW_OFFSET(pass);\n         }\n\n         else\n         {\n            y = 0;\n            startx = 0;\n            stepx = channels;\n            stepy = 1;\n         }\n\n         for (; y<height; y += stepy)\n         {\n            png_bytep inrow = png_voidcast(png_bytep, display->local_row);\n            png_bytep outrow;\n            png_const_bytep end_row;\n\n            /* Read the row, which is packed: */\n            png_read_row(png_ptr, inrow, NULL);\n\n            outrow = png_voidcast(png_bytep, display->first_row);\n            outrow += y * step_row;\n            end_row = outrow + width * channels;\n\n            /* Now do the composition on each pixel in this row. */\n            outrow += startx;\n            for (; outrow < end_row; outrow += stepx)\n            {\n               png_byte alpha = inrow[channels];\n\n               if (alpha > 0) /* else no change to the output */\n               {\n                  unsigned int c;\n\n                  for (c=0; c<channels; ++c)\n                  {\n                     png_uint_32 component = inrow[c];\n\n                     if (alpha < 255) /* else just use component */\n                     {\n                        /* This is PNG_OPTIMIZED_ALPHA, the component value\n                         * is a linear 8-bit value.  Combine this with the\n                         * current outrow[c] value which is sRGB encoded.\n                         * Arithmetic here is 16-bits to preserve the output\n                         * values correctly.\n                         */\n                        component *= 257*255; /* =65535 */\n                        component += (255-alpha)*png_sRGB_table[outrow[c]];\n\n                        /* So 'component' is scaled by 255*65535 and is\n                         * therefore appropriate for the sRGB to linear\n                         * conversion table.\n                         */\n                        component = PNG_sRGB_FROM_LINEAR(component);\n                     }\n\n                     outrow[c] = (png_byte)component;\n                  }\n               }\n\n               inrow += channels+1; /* components and alpha channel */\n            }\n         }\n      }\n   }\n\n   return 1;\n}\n",
      "line_start": 3181,
      "line_end": 3293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 123,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This is part of PNG decoding: it consumes external/untrusted image data (via png_read_row) and performs pointer arithmetic, buffer writes, per-pixel composition, table lookups and type conversions. It contains multiple nested loops and interlace-dependent branching, so memory-safety and logic bugs here are high-impact and make it a critical fuzz target."
    },
    {
      "name": "pngread.c:png_image_read_background",
      "clean_name": "png_image_read_background",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * correction.  The fix-up is to prevent the PNG_COMPOSITE operation from\n * happening inside libpng, so this routine sees an 8 or 16-bit gray+alpha\n * row and handles the removal or pre-multiplication of the alpha channel.\n */\nstatic int\npng_image_read_background(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_structrp png_ptr = image->opaque->png_ptr;\n   png_inforp info_ptr = image->opaque->info_ptr;\n   png_uint_32 height = image->height;\n   png_uint_32 width = image->width;\n   int pass, passes;\n\n   /* Double check the convoluted logic below.  We expect to get here with\n    * libpng doing rgb to gray and gamma correction but background processing\n    * left to the png_image_read_background function.  The rows libpng produce\n    * might be 8 or 16-bit but should always have two channels; gray plus alpha.\n    */\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\n      png_error(png_ptr, \"lost rgb to gray\");\n\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      png_error(png_ptr, \"unexpected compose\");\n\n   if (png_get_channels(png_ptr, info_ptr) != 2)\n      png_error(png_ptr, \"lost/gained channels\");\n\n   /* Expect the 8-bit case to always remove the alpha channel */\n   if ((image->format & PNG_FORMAT_FLAG_LINEAR) == 0 &&\n      (image->format & PNG_FORMAT_FLAG_ALPHA) != 0)\n      png_error(png_ptr, \"unexpected 8-bit transformation\");\n\n   switch (png_ptr->interlaced)\n   {\n      case PNG_INTERLACE_NONE:\n         passes = 1;\n         break;\n\n      case PNG_INTERLACE_ADAM7:\n         passes = PNG_INTERLACE_ADAM7_PASSES;\n         break;\n\n      default:\n         png_error(png_ptr, \"unknown interlace type\");\n   }\n\n   /* Use direct access to info_ptr here because otherwise the simplified API\n    * would require PNG_EASY_ACCESS_SUPPORTED (just for this.)  Note this is\n    * checking the value after libpng expansions, not the original value in the\n    * PNG.\n    */\n   switch (info_ptr->bit_depth)\n   {\n      case 8:\n         /* 8-bit sRGB gray values with an alpha channel; the alpha channel is\n          * to be removed by composing on a background: either the row if\n          * display->background is NULL or display->background->green if not.\n          * Unlike the code above ALPHA_OPTIMIZED has *not* been done.\n          */\n         {\n            png_bytep first_row = png_voidcast(png_bytep, display->first_row);\n            ptrdiff_t step_row = display->row_bytes;\n\n            for (pass = 0; pass < passes; ++pass)\n            {\n               unsigned int     startx, stepx, stepy;\n               png_uint_32      y;\n\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n               {\n                  /* The row may be empty for a short image: */\n                  if (PNG_PASS_COLS(width, pass) == 0)\n                     continue;\n\n                  startx = PNG_PASS_START_COL(pass);\n                  stepx = PNG_PASS_COL_OFFSET(pass);\n                  y = PNG_PASS_START_ROW(pass);\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\n               }\n\n               else\n               {\n                  y = 0;\n                  startx = 0;\n                  stepx = stepy = 1;\n               }\n\n               if (display->background == NULL)\n               {\n                  for (; y<height; y += stepy)\n                  {\n                     png_bytep inrow = png_voidcast(png_bytep,\n                         display->local_row);\n                     png_bytep outrow = first_row + y * step_row;\n                     png_const_bytep end_row = outrow + width;\n\n                     /* Read the row, which is packed: */\n                     png_read_row(png_ptr, inrow, NULL);\n\n                     /* Now do the composition on each pixel in this row. */\n                     outrow += startx;\n                     for (; outrow < end_row; outrow += stepx)\n                     {\n                        png_byte alpha = inrow[1];\n\n                        if (alpha > 0) /* else no change to the output */\n                        {\n                           png_uint_32 component = inrow[0];\n\n                           if (alpha < 255) /* else just use component */\n                           {\n                              /* Since PNG_OPTIMIZED_ALPHA was not set it is\n                               * necessary to invert the sRGB transfer\n                               * function and multiply the alpha out.\n                               */\n                              component = png_sRGB_table[component] * alpha;\n                              component += png_sRGB_table[outrow[0]] *\n                                 (255-alpha);\n                              component = PNG_sRGB_FROM_LINEAR(component);\n                           }\n\n                           outrow[0] = (png_byte)component;\n                        }\n\n                        inrow += 2; /* gray and alpha channel */\n                     }\n                  }\n               }\n\n               else /* constant background value */\n               {\n                  png_byte background8 = display->background->green;\n                  png_uint_16 background = png_sRGB_table[background8];\n\n                  for (; y<height; y += stepy)\n                  {\n                     png_bytep inrow = png_voidcast(png_bytep,\n                         display->local_row);\n                     png_bytep outrow = first_row + y * step_row;\n                     png_const_bytep end_row = outrow + width;\n\n                     /* Read the row, which is packed: */\n                     png_read_row(png_ptr, inrow, NULL);\n\n                     /* Now do the composition on each pixel in this row. */\n                     outrow += startx;\n                     for (; outrow < end_row; outrow += stepx)\n                     {\n                        png_byte alpha = inrow[1];\n\n                        if (alpha > 0) /* else use background */\n                        {\n                           png_uint_32 component = inrow[0];\n\n                           if (alpha < 255) /* else just use component */\n                           {\n                              component = png_sRGB_table[component] * alpha;\n                              component += background * (255-alpha);\n                              component = PNG_sRGB_FROM_LINEAR(component);\n                           }\n\n                           outrow[0] = (png_byte)component;\n                        }\n\n                        else\n                           outrow[0] = background8;\n\n                        inrow += 2; /* gray and alpha channel */\n                     }\n                  }\n               }\n            }\n         }\n         break;\n\n      case 16:\n         /* 16-bit linear with pre-multiplied alpha; the pre-multiplication must\n          * still be done and, maybe, the alpha channel removed.  This code also\n          * handles the alpha-first option.\n          */\n         {\n            png_uint_16p first_row = png_voidcast(png_uint_16p,\n                display->first_row);\n            /* The division by two is safe because the caller passed in a\n             * stride which was multiplied by 2 (below) to get row_bytes.\n             */\n            ptrdiff_t    step_row = display->row_bytes / 2;\n            unsigned int preserve_alpha = (image->format &\n                PNG_FORMAT_FLAG_ALPHA) != 0;\n            unsigned int outchannels = 1U+preserve_alpha;\n            int swap_alpha = 0;\n\n#           ifdef PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED\n               if (preserve_alpha != 0 &&\n                   (image->format & PNG_FORMAT_FLAG_AFIRST) != 0)\n                  swap_alpha = 1;\n#           endif\n\n            for (pass = 0; pass < passes; ++pass)\n            {\n               unsigned int     startx, stepx, stepy;\n               png_uint_32      y;\n\n               /* The 'x' start and step are adjusted to output components here.\n                */\n               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)\n               {\n                  /* The row may be empty for a short image: */\n                  if (PNG_PASS_COLS(width, pass) == 0)\n                     continue;\n\n                  startx = PNG_PASS_START_COL(pass) * outchannels;\n                  stepx = PNG_PASS_COL_OFFSET(pass) * outchannels;\n                  y = PNG_PASS_START_ROW(pass);\n                  stepy = PNG_PASS_ROW_OFFSET(pass);\n               }\n\n               else\n               {\n                  y = 0;\n                  startx = 0;\n                  stepx = outchannels;\n                  stepy = 1;\n               }\n\n               for (; y<height; y += stepy)\n               {\n                  png_const_uint_16p inrow;\n                  png_uint_16p outrow = first_row + y*step_row;\n                  png_uint_16p end_row = outrow + width * outchannels;\n\n                  /* Read the row, which is packed: */\n                  png_read_row(png_ptr, png_voidcast(png_bytep,\n                      display->local_row), NULL);\n                  inrow = png_voidcast(png_const_uint_16p, display->local_row);\n\n                  /* Now do the pre-multiplication on each pixel in this row.\n                   */\n                  outrow += startx;\n                  for (; outrow < end_row; outrow += stepx)\n                  {\n                     png_uint_32 component = inrow[0];\n                     png_uint_16 alpha = inrow[1];\n\n                     if (alpha > 0) /* else 0 */\n                     {\n                        if (alpha < 65535) /* else just use component */\n                        {\n                           component *= alpha;\n                           component += 32767;\n                           component /= 65535;\n                        }\n                     }\n\n                     else\n                        component = 0;\n\n                     outrow[swap_alpha] = (png_uint_16)component;\n                     if (preserve_alpha != 0)\n                        outrow[1 ^ swap_alpha] = alpha;\n\n                     inrow += 2; /* components and alpha channel */\n                  }\n               }\n            }\n         }\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(png_ptr, \"unexpected bit depth\");\n#endif\n   }\n\n   return 1;\n}\n",
      "line_start": 3308,
      "line_end": 3582,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 313,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "High-value fuzz target: part of PNG decoding that processes external image data (rows), does memory reads/writes on untrusted data (inrow/outrow), has multiple branches (bit depths, interlace passes, background/no-background, alpha handling), loops with input-dependent bounds (width/height/passes) and performs non-trivial data transformations (sRGB table use, premultiplication). These factors make it likely to contain exploitable parsing/logic bugs and worth critical-priority fuzzing."
    },
    {
      "name": "png_set_quantize",
      "clean_name": "png_set_quantize",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "} png_dsort;\ntypedef png_dsort *   png_dsortp;\ntypedef png_dsort * * png_dsortpp;\n\nvoid PNGAPI\npng_set_quantize(png_structrp png_ptr, png_colorp palette,\n    int num_palette, int maximum_colors, png_const_uint_16p histogram,\n    int full_quantize)\n{\n   png_debug(1, \"in png_set_quantize\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_QUANTIZE;\n\n   if (full_quantize == 0)\n   {\n      int i;\n\n      /* Initialize the array to index colors.\n       *\n       * Ensure quantize_index can fit 256 elements (PNG_MAX_PALETTE_LENGTH)\n       * rather than num_palette elements. This is to prevent buffer overflows\n       * caused by malformed PNG files with out-of-range palette indices.\n       *\n       * Be careful to avoid leaking memory. Applications are allowed to call\n       * this function more than once per png_struct.\n       */\n      png_free(png_ptr, png_ptr->quantize_index);\n      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,\n          PNG_MAX_PALETTE_LENGTH);\n      for (i = 0; i < PNG_MAX_PALETTE_LENGTH; i++)\n         png_ptr->quantize_index[i] = (png_byte)i;\n   }\n\n   if (num_palette > maximum_colors)\n   {\n      if (histogram != NULL)\n      {\n         /* This is easy enough, just throw out the least used colors.\n          * Perhaps not the best solution, but good enough.\n          */\n\n         png_bytep quantize_sort;\n         int i, j;\n\n         /* Initialize the local array to sort colors. */\n         quantize_sort = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n         for (i = 0; i < num_palette; i++)\n            quantize_sort[i] = (png_byte)i;\n\n         /* Find the least used palette entries by starting a\n          * bubble sort, and running it until we have sorted\n          * out enough colors.  Note that we don't care about\n          * sorting all the colors, just finding which are\n          * least used.\n          */\n\n         for (i = num_palette - 1; i >= maximum_colors; i--)\n         {\n            int done; /* To stop early if the list is pre-sorted */\n\n            done = 1;\n            for (j = 0; j < i; j++)\n            {\n               if (histogram[quantize_sort[j]]\n                   < histogram[quantize_sort[j + 1]])\n               {\n                  png_byte t;\n\n                  t = quantize_sort[j];\n                  quantize_sort[j] = quantize_sort[j + 1];\n                  quantize_sort[j + 1] = t;\n                  done = 0;\n               }\n            }\n\n            if (done != 0)\n               break;\n         }\n\n         /* Swap the palette around, and set up a table, if necessary */\n         if (full_quantize != 0)\n         {\n            j = num_palette;\n\n            /* Put all the useful colors within the max, but don't\n             * move the others.\n             */\n            for (i = 0; i < maximum_colors; i++)\n            {\n               if ((int)quantize_sort[i] >= maximum_colors)\n               {\n                  do\n                     j--;\n                  while ((int)quantize_sort[j] >= maximum_colors);\n\n                  palette[i] = palette[j];\n               }\n            }\n         }\n         else\n         {\n            j = num_palette;\n\n            /* Move all the used colors inside the max limit, and\n             * develop a translation table.\n             */\n            for (i = 0; i < maximum_colors; i++)\n            {\n               /* Only move the colors we need to */\n               if ((int)quantize_sort[i] >= maximum_colors)\n               {\n                  png_color tmp_color;\n\n                  do\n                     j--;\n                  while ((int)quantize_sort[j] >= maximum_colors);\n\n                  tmp_color = palette[j];\n                  palette[j] = palette[i];\n                  palette[i] = tmp_color;\n                  /* Indicate where the color went */\n                  png_ptr->quantize_index[j] = (png_byte)i;\n                  png_ptr->quantize_index[i] = (png_byte)j;\n               }\n            }\n\n            /* Find closest color for those colors we are not using */\n            for (i = 0; i < num_palette; i++)\n            {\n               if ((int)png_ptr->quantize_index[i] >= maximum_colors)\n               {\n                  int min_d, k, min_k, d_index;\n\n                  /* Find the closest color to one we threw out */\n                  d_index = png_ptr->quantize_index[i];\n                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);\n                  for (k = 1, min_k = 0; k < maximum_colors; k++)\n                  {\n                     int d;\n\n                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);\n\n                     if (d < min_d)\n                     {\n                        min_d = d;\n                        min_k = k;\n                     }\n                  }\n                  /* Point to closest color */\n                  png_ptr->quantize_index[i] = (png_byte)min_k;\n               }\n            }\n         }\n         png_free(png_ptr, quantize_sort);\n      }\n      else\n      {\n         /* This is much harder to do simply (and quickly).  Perhaps\n          * we need to go through a median cut routine, but those\n          * don't always behave themselves with only a few colors\n          * as input.  So we will just find the closest two colors,\n          * and throw out one of them (chosen somewhat randomly).\n          * [We don't understand this at all, so if someone wants to\n          *  work on improving it, be our guest - AED, GRP]\n          */\n         int i;\n         int max_d;\n         int num_new_palette;\n         png_dsortp t;\n         png_dsortpp hash;\n\n         t = NULL;\n\n         /* Initialize palette index arrays */\n         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,\n             (png_alloc_size_t)num_palette);\n\n         /* Initialize the sort array */\n         for (i = 0; i < num_palette; i++)\n         {\n            png_ptr->index_to_palette[i] = (png_byte)i;\n            png_ptr->palette_to_index[i] = (png_byte)i;\n         }\n\n         hash = (png_dsortpp)png_calloc(png_ptr, (png_alloc_size_t)(769 *\n             (sizeof (png_dsortp))));\n\n         num_new_palette = num_palette;\n\n         /* Initial wild guess at how far apart the farthest pixel\n          * pair we will be eliminating will be.  Larger\n          * numbers mean more areas will be allocated, Smaller\n          * numbers run the risk of not saving enough data, and\n          * having to do this all over again.\n          *\n          * I have not done extensive checking on this number.\n          */\n         max_d = 96;\n\n         while (num_new_palette > maximum_colors)\n         {\n            for (i = 0; i < num_new_palette - 1; i++)\n            {\n               int j;\n\n               for (j = i + 1; j < num_new_palette; j++)\n               {\n                  int d;\n\n                  d = PNG_COLOR_DIST(palette[i], palette[j]);\n\n                  if (d <= max_d)\n                  {\n\n                     t = (png_dsortp)png_malloc_warn(png_ptr,\n                         (png_alloc_size_t)(sizeof (png_dsort)));\n\n                     if (t == NULL)\n                         break;\n\n                     t->next = hash[d];\n                     t->left = (png_byte)i;\n                     t->right = (png_byte)j;\n                     hash[d] = t;\n                  }\n               }\n               if (t == NULL)\n                  break;\n            }\n\n            if (t != NULL)\n            for (i = 0; i <= max_d; i++)\n            {\n               if (hash[i] != NULL)\n               {\n                  png_dsortp p;\n\n                  for (p = hash[i]; p; p = p->next)\n                  {\n                     if ((int)png_ptr->index_to_palette[p->left]\n                         < num_new_palette &&\n                         (int)png_ptr->index_to_palette[p->right]\n                         < num_new_palette)\n                     {\n                        int j, next_j;\n\n                        if (num_new_palette & 0x01)\n                        {\n                           j = p->left;\n                           next_j = p->right;\n                        }\n                        else\n                        {\n                           j = p->right;\n                           next_j = p->left;\n                        }\n\n                        num_new_palette--;\n                        palette[png_ptr->index_to_palette[j]]\n                            = palette[num_new_palette];\n                        if (full_quantize == 0)\n                        {\n                           int k;\n\n                           for (k = 0; k < num_palette; k++)\n                           {\n                              if (png_ptr->quantize_index[k] ==\n                                  png_ptr->index_to_palette[j])\n                                 png_ptr->quantize_index[k] =\n                                     png_ptr->index_to_palette[next_j];\n\n                              if ((int)png_ptr->quantize_index[k] ==\n                                  num_new_palette)\n                                 png_ptr->quantize_index[k] =\n                                     png_ptr->index_to_palette[j];\n                           }\n                        }\n\n                        png_ptr->index_to_palette[png_ptr->palette_to_index\n                            [num_new_palette]] = png_ptr->index_to_palette[j];\n\n                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]\n                            = png_ptr->palette_to_index[num_new_palette];\n\n                        png_ptr->index_to_palette[j] =\n                            (png_byte)num_new_palette;\n\n                        png_ptr->palette_to_index[num_new_palette] =\n                            (png_byte)j;\n                     }\n                     if (num_new_palette <= maximum_colors)\n                        break;\n                  }\n                  if (num_new_palette <= maximum_colors)\n                     break;\n               }\n            }\n\n            for (i = 0; i < 769; i++)\n            {\n               if (hash[i] != NULL)\n               {\n                  png_dsortp p = hash[i];\n                  while (p)\n                  {\n                     t = p->next;\n                     png_free(png_ptr, p);\n                     p = t;\n                  }\n               }\n               hash[i] = 0;\n            }\n            max_d += 96;\n         }\n         png_free(png_ptr, hash);\n         png_free(png_ptr, png_ptr->palette_to_index);\n         png_free(png_ptr, png_ptr->index_to_palette);\n         png_ptr->palette_to_index = NULL;\n         png_ptr->index_to_palette = NULL;\n      }\n      num_palette = maximum_colors;\n   }\n   if (png_ptr->palette == NULL)\n   {\n      png_ptr->palette = palette;\n   }\n   png_ptr->num_palette = (png_uint_16)num_palette;\n\n   if (full_quantize != 0)\n   {\n      int i;\n      png_bytep distance;\n      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +\n          PNG_QUANTIZE_BLUE_BITS;\n      int num_red = (1 << PNG_QUANTIZE_RED_BITS);\n      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);\n      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);\n      size_t num_entries = ((size_t)1 << total_bits);\n\n      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,\n          (png_alloc_size_t)(num_entries));\n\n      distance = (png_bytep)png_malloc(png_ptr, (png_alloc_size_t)num_entries);\n\n      memset(distance, 0xff, num_entries);\n\n      for (i = 0; i < num_palette; i++)\n      {\n         int ir, ig, ib;\n         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));\n         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));\n         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));\n\n         for (ir = 0; ir < num_red; ir++)\n         {\n            /* int dr = abs(ir - r); */\n            int dr = ((ir > r) ? ir - r : r - ir);\n            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +\n                PNG_QUANTIZE_GREEN_BITS));\n\n            for (ig = 0; ig < num_green; ig++)\n            {\n               /* int dg = abs(ig - g); */\n               int dg = ((ig > g) ? ig - g : g - ig);\n               int dt = dr + dg;\n               int dm = ((dr > dg) ? dr : dg);\n               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);\n\n               for (ib = 0; ib < num_blue; ib++)\n               {\n                  int d_index = index_g | ib;\n                  /* int db = abs(ib - b); */\n                  int db = ((ib > b) ? ib - b : b - ib);\n                  int dmax = ((dm > db) ? dm : db);\n                  int d = dmax + dt + db;\n\n                  if (d < (int)distance[d_index])\n                  {\n                     distance[d_index] = (png_byte)d;\n                     png_ptr->palette_lookup[d_index] = (png_byte)i;\n                  }\n               }\n            }\n         }\n      }\n\n      png_free(png_ptr, distance);\n   }\n}\n",
      "line_start": 488,
      "line_end": 878,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 341,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This function processes external PNG palette/histogram data (structured, attacker-controlled), performs many memory operations and allocations, has deep nested loops and complex branching (sorting, hash/list management, remapping), and contains multiple input-dependent bounds. That makes it a high-value fuzz target with a high risk surface for memory/logic bugs."
    },
    {
      "name": "pngrtran.c:png_do_rgb_to_gray",
      "clean_name": "png_do_rgb_to_gray",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " *  the API takes just red and green coefficients the blue coefficient is\n *  calculated to make the sum 32768.  This will result in different rounding\n *  to that used above.\n */\nstatic int\npng_do_rgb_to_gray(png_structrp png_ptr, png_row_infop row_info, png_bytep row)\n{\n   int rgb_error = 0;\n\n   png_debug(1, \"in png_do_rgb_to_gray\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_PALETTE) == 0 &&\n       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;\n      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;\n      png_uint_32 bc = 32768 - rc - gc;\n      png_uint_32 row_width = row_info->width;\n      int have_alpha = (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;\n\n      if (row_info->bit_depth == 8)\n      {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n         /* Notice that gamma to/from 1 are not necessarily inverses (if\n          * there is an overall gamma correction).  Prior to 1.5.5 this code\n          * checked the linearized values for equality; this doesn't match\n          * the documentation, the original values must be checked.\n          */\n         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte red   = *(sp++);\n               png_byte green = *(sp++);\n               png_byte blue  = *(sp++);\n\n               if (red != green || red != blue)\n               {\n                  red = png_ptr->gamma_to_1[red];\n                  green = png_ptr->gamma_to_1[green];\n                  blue = png_ptr->gamma_to_1[blue];\n\n                  rgb_error |= 1;\n                  *(dp++) = png_ptr->gamma_from_1[\n                      (rc*red + gc*green + bc*blue + 16384)>>15];\n               }\n\n               else\n               {\n                  /* If there is no overall correction the table will not be\n                   * set.\n                   */\n                  if (png_ptr->gamma_table != NULL)\n                     red = png_ptr->gamma_table[red];\n\n                  *(dp++) = red;\n               }\n\n               if (have_alpha != 0)\n                  *(dp++) = *(sp++);\n            }\n         }\n         else\n#endif\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_byte red   = *(sp++);\n               png_byte green = *(sp++);\n               png_byte blue  = *(sp++);\n\n               if (red != green || red != blue)\n               {\n                  rgb_error |= 1;\n                  /* NOTE: this is the historical approach which simply\n                   * truncates the results.\n                   */\n                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);\n               }\n\n               else\n                  *(dp++) = red;\n\n               if (have_alpha != 0)\n                  *(dp++) = *(sp++);\n            }\n         }\n      }\n\n      else /* RGB bit_depth == 16 */\n      {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_uint_16 red, green, blue, w;\n               png_byte hi,lo;\n\n               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));\n\n               if (red == green && red == blue)\n               {\n                  if (png_ptr->gamma_16_table != NULL)\n                     w = png_ptr->gamma_16_table[(red & 0xff)\n                         >> png_ptr->gamma_shift][red >> 8];\n\n                  else\n                     w = red;\n               }\n\n               else\n               {\n                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red & 0xff)\n                      >> png_ptr->gamma_shift][red>>8];\n                  png_uint_16 green_1 =\n                      png_ptr->gamma_16_to_1[(green & 0xff) >>\n                      png_ptr->gamma_shift][green>>8];\n                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue & 0xff)\n                      >> png_ptr->gamma_shift][blue>>8];\n                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1\n                      + bc*blue_1 + 16384)>>15);\n                  w = png_ptr->gamma_16_from_1[(gray16 & 0xff) >>\n                      png_ptr->gamma_shift][gray16 >> 8];\n                  rgb_error |= 1;\n               }\n\n               *(dp++) = (png_byte)((w>>8) & 0xff);\n               *(dp++) = (png_byte)(w & 0xff);\n\n               if (have_alpha != 0)\n               {\n                  *(dp++) = *(sp++);\n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n         else\n#endif\n         {\n            png_bytep sp = row;\n            png_bytep dp = row;\n            png_uint_32 i;\n\n            for (i = 0; i < row_width; i++)\n            {\n               png_uint_16 red, green, blue, gray16;\n               png_byte hi,lo;\n\n               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));\n               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));\n\n               if (red != green || red != blue)\n                  rgb_error |= 1;\n\n               /* From 1.5.5 in the 16-bit case do the accurate conversion even\n                * in the 'fast' case - this is because this is where the code\n                * ends up when handling linear 16-bit data.\n                */\n               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>\n                  15);\n               *(dp++) = (png_byte)((gray16 >> 8) & 0xff);\n               *(dp++) = (png_byte)(gray16 & 0xff);\n\n               if (have_alpha != 0)\n               {\n                  *(dp++) = *(sp++);\n                  *(dp++) = *(sp++);\n               }\n            }\n         }\n      }\n\n      row_info->channels = (png_byte)(row_info->channels - 2);\n      row_info->color_type = (png_byte)(row_info->color_type &\n          ~PNG_COLOR_MASK_COLOR);\n      row_info->pixel_depth = (png_byte)(row_info->channels *\n          row_info->bit_depth);\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n   }\n   return rgb_error;\n}\n",
      "line_start": 3117,
      "line_end": 3309,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 147,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Converts PNG RGB rows to gray \u2014 parses complex external input and performs in-place memory reads/writes, multiple branches (8/16-bit, gamma/no-gamma, alpha), loops bounded by row_info->width and many type conversions. High potential for memory/logic bugs so a critical fuzz target."
    },
    {
      "name": "pngrtran.c:png_do_compose",
      "clean_name": "png_do_compose",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Replace any alpha or transparency with the supplied background color.\n * \"background\" is already in the screen gamma, while \"background_1\" is\n * at a gamma of 1.0.  Paletted files have already been taken care of.\n */\nstatic void\npng_do_compose(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\n{\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   png_const_bytep gamma_table = png_ptr->gamma_table;\n   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;\n   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;\n   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;\n   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;\n   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;\n   int gamma_shift = png_ptr->gamma_shift;\n   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;\n#endif\n\n   png_bytep sp;\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n   int shift;\n\n   png_debug(1, \"in png_do_compose\");\n\n   switch (row_info->color_type)\n   {\n      case PNG_COLOR_TYPE_GRAY:\n      {\n         switch (row_info->bit_depth)\n         {\n            case 1:\n            {\n               sp = row;\n               shift = 7;\n               for (i = 0; i < row_width; i++)\n               {\n                  if ((png_uint_16)((*sp >> shift) & 0x01)\n                     == png_ptr->trans_color.gray)\n                  {\n                     unsigned int tmp = *sp & (0x7f7f >> (7 - shift));\n                     tmp |=\n                         (unsigned int)(png_ptr->background.gray << shift);\n                     *sp = (png_byte)(tmp & 0xff);\n                  }\n\n                  if (shift == 0)\n                  {\n                     shift = 7;\n                     sp++;\n                  }\n\n                  else\n                     shift--;\n               }\n               break;\n            }\n\n            case 2:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  shift = 6;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x03)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |=\n                           (unsigned int)png_ptr->background.gray << shift;\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     else\n                     {\n                        unsigned int p = (*sp >> shift) & 0x03;\n                        unsigned int g = (gamma_table [p | (p << 2) |\n                            (p << 4) | (p << 6)] >> 6) & 0x03;\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |= (unsigned int)(g << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 6;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 2;\n                  }\n               }\n\n               else\n#endif\n               {\n                  sp = row;\n                  shift = 6;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x03)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));\n                        tmp |=\n                            (unsigned int)png_ptr->background.gray << shift;\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 6;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 2;\n                  }\n               }\n               break;\n            }\n\n            case 4:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  shift = 4;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x0f)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |=\n                           (unsigned int)(png_ptr->background.gray << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     else\n                     {\n                        unsigned int p = (*sp >> shift) & 0x0f;\n                        unsigned int g = (gamma_table[p | (p << 4)] >> 4) &\n                           0x0f;\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |= (unsigned int)(g << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 4;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 4;\n                  }\n               }\n\n               else\n#endif\n               {\n                  sp = row;\n                  shift = 4;\n                  for (i = 0; i < row_width; i++)\n                  {\n                     if ((png_uint_16)((*sp >> shift) & 0x0f)\n                         == png_ptr->trans_color.gray)\n                     {\n                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));\n                        tmp |=\n                           (unsigned int)(png_ptr->background.gray << shift);\n                        *sp = (png_byte)(tmp & 0xff);\n                     }\n\n                     if (shift == 0)\n                     {\n                        shift = 4;\n                        sp++;\n                     }\n\n                     else\n                        shift -= 4;\n                  }\n               }\n               break;\n            }\n\n            case 8:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_table != NULL)\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp++)\n                  {\n                     if (*sp == png_ptr->trans_color.gray)\n                        *sp = (png_byte)png_ptr->background.gray;\n\n                     else\n                        *sp = gamma_table[*sp];\n                  }\n               }\n               else\n#endif\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp++)\n                  {\n                     if (*sp == png_ptr->trans_color.gray)\n                        *sp = (png_byte)png_ptr->background.gray;\n                  }\n               }\n               break;\n            }\n\n            case 16:\n            {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n               if (gamma_16 != NULL)\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp += 2)\n                  {\n                     png_uint_16 v;\n\n                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                     if (v == png_ptr->trans_color.gray)\n                     {\n                        /* Background is already in screen gamma */\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray\n                             & 0xff);\n                     }\n\n                     else\n                     {\n                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                        *sp = (png_byte)((v >> 8) & 0xff);\n                        *(sp + 1) = (png_byte)(v & 0xff);\n                     }\n                  }\n               }\n               else\n#endif\n               {\n                  sp = row;\n                  for (i = 0; i < row_width; i++, sp += 2)\n                  {\n                     png_uint_16 v;\n\n                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                     if (v == png_ptr->trans_color.gray)\n                     {\n                        *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                        *(sp + 1) = (png_byte)(png_ptr->background.gray\n                             & 0xff);\n                     }\n                  }\n               }\n               break;\n            }\n\n            default:\n               break;\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_RGB:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 3)\n               {\n                  if (*sp == png_ptr->trans_color.red &&\n                      *(sp + 1) == png_ptr->trans_color.green &&\n                      *(sp + 2) == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else\n                  {\n                     *sp = gamma_table[*sp];\n                     *(sp + 1) = gamma_table[*(sp + 1)];\n                     *(sp + 2) = gamma_table[*(sp + 2)];\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 3)\n               {\n                  if (*sp == png_ptr->trans_color.red &&\n                      *(sp + 1) == png_ptr->trans_color.green &&\n                      *(sp + 2) == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n               }\n            }\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 6)\n               {\n                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                      + *(sp + 5));\n\n                  if (r == png_ptr->trans_color.red &&\n                      g == png_ptr->trans_color.green &&\n                      b == png_ptr->trans_color.blue)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 6)\n               {\n                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n\n                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                      + *(sp + 5));\n\n                  if (r == png_ptr->trans_color.red &&\n                      g == png_ptr->trans_color.green &&\n                      b == png_ptr->trans_color.blue)\n                  {\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_GRAY_ALPHA:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\n                gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 2)\n               {\n                  png_uint_16 a = *(sp + 1);\n\n                  if (a == 0xff)\n                     *sp = gamma_table[*sp];\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)png_ptr->background.gray;\n                  }\n\n                  else\n                  {\n                     png_byte v, w;\n\n                     v = gamma_to_1[*sp];\n                     png_composite(w, v, a, png_ptr->background_1.gray);\n                     if (optimize == 0)\n                        w = gamma_from_1[w];\n                     *sp = w;\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 2)\n               {\n                  png_byte a = *(sp + 1);\n\n                  if (a == 0)\n                     *sp = (png_byte)png_ptr->background.gray;\n\n                  else if (a < 0xff)\n                     png_composite(*sp, *sp, a, png_ptr->background.gray);\n               }\n            }\n         }\n         else /* if (png_ptr->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\n                gamma_16_to_1 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  if (a == (png_uint_16)0xffff)\n                  {\n                     png_uint_16 v;\n\n                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 g, v, w;\n\n                     g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\n                     png_composite_16(v, g, a, png_ptr->background_1.gray);\n                     if (optimize != 0)\n                        w = v;\n                     else\n                        w = gamma_16_from_1[(v & 0xff) >>\n                            gamma_shift][v >> 8];\n                     *sp = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(w & 0xff);\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)\n                      + *(sp + 3));\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)((png_ptr->background.gray >> 8)\n                             & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);\n                  }\n\n                  else if (a < 0xffff)\n                  {\n                     png_uint_16 g, v;\n\n                     g = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n                     png_composite_16(v, g, a, png_ptr->background.gray);\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      case PNG_COLOR_TYPE_RGB_ALPHA:\n      {\n         if (row_info->bit_depth == 8)\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&\n                gamma_table != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_byte a = *(sp + 3);\n\n                  if (a == 0xff)\n                  {\n                     *sp = gamma_table[*sp];\n                     *(sp + 1) = gamma_table[*(sp + 1)];\n                     *(sp + 2) = gamma_table[*(sp + 2)];\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else\n                  {\n                     png_byte v, w;\n\n                     v = gamma_to_1[*sp];\n                     png_composite(w, v, a, png_ptr->background_1.red);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *sp = w;\n\n                     v = gamma_to_1[*(sp + 1)];\n                     png_composite(w, v, a, png_ptr->background_1.green);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *(sp + 1) = w;\n\n                     v = gamma_to_1[*(sp + 2)];\n                     png_composite(w, v, a, png_ptr->background_1.blue);\n                     if (optimize == 0) w = gamma_from_1[w];\n                     *(sp + 2) = w;\n                  }\n               }\n            }\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 4)\n               {\n                  png_byte a = *(sp + 3);\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)png_ptr->background.red;\n                     *(sp + 1) = (png_byte)png_ptr->background.green;\n                     *(sp + 2) = (png_byte)png_ptr->background.blue;\n                  }\n\n                  else if (a < 0xff)\n                  {\n                     png_composite(*sp, *sp, a, png_ptr->background.red);\n\n                     png_composite(*(sp + 1), *(sp + 1), a,\n                         png_ptr->background.green);\n\n                     png_composite(*(sp + 2), *(sp + 2), a,\n                         png_ptr->background.blue);\n                  }\n               }\n            }\n         }\n         else /* if (row_info->bit_depth == 16) */\n         {\n#ifdef PNG_READ_GAMMA_SUPPORTED\n            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&\n                gamma_16_to_1 != NULL)\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 8)\n               {\n                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\n                      << 8) + (png_uint_16)(*(sp + 7)));\n\n                  if (a == (png_uint_16)0xffff)\n                  {\n                     png_uint_16 v;\n\n                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n\n                  else if (a == 0)\n                  {\n                     /* Background is already in screen gamma */\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else\n                  {\n                     png_uint_16 v, w;\n\n                     v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];\n                     png_composite_16(w, v, a, png_ptr->background_1.red);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n                     *sp = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(w & 0xff);\n\n                     v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];\n                     png_composite_16(w, v, a, png_ptr->background_1.green);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n\n                     *(sp + 2) = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(w & 0xff);\n\n                     v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];\n                     png_composite_16(w, v, a, png_ptr->background_1.blue);\n                     if (optimize == 0)\n                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>\n                             8];\n\n                     *(sp + 4) = (png_byte)((w >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(w & 0xff);\n                  }\n               }\n            }\n\n            else\n#endif\n            {\n               sp = row;\n               for (i = 0; i < row_width; i++, sp += 8)\n               {\n                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))\n                      << 8) + (png_uint_16)(*(sp + 7)));\n\n                  if (a == 0)\n                  {\n                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);\n                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)\n                             & 0xff);\n                     *(sp + 3) = (png_byte)(png_ptr->background.green\n                             & 0xff);\n                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)\n                             & 0xff);\n                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);\n                  }\n\n                  else if (a < 0xffff)\n                  {\n                     png_uint_16 v;\n\n                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));\n                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)\n                         + *(sp + 3));\n                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)\n                         + *(sp + 5));\n\n                     png_composite_16(v, r, a, png_ptr->background.red);\n                     *sp = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 1) = (png_byte)(v & 0xff);\n\n                     png_composite_16(v, g, a, png_ptr->background.green);\n                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 3) = (png_byte)(v & 0xff);\n\n                     png_composite_16(v, b, a, png_ptr->background.blue);\n                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);\n                     *(sp + 5) = (png_byte)(v & 0xff);\n                  }\n               }\n            }\n         }\n         break;\n      }\n\n      default:\n         break;\n   }\n}\n",
      "line_start": 3318,
      "line_end": 4052,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 564,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "High-value fuzz target: processes untrusted image row bytes with many memory reads/writes and pointer arithmetic, large number of branches (color types, bit depths, gamma paths), loops driven by external row_width, and complex data transformations (gamma/alpha compositing). High cyclomatic complexity and multiple code paths make it likely to uncover memory-corruption or logic bugs."
    },
    {
      "name": "pngrutil.c:png_handle_iCCP",
      "clean_name": "png_handle_iCCP",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_sRGB NULL\n#endif /* READ_sRGB */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle profiles that are > 64K under DOS */\n{\n   png_const_charp errmsg = NULL; /* error message output, or no error */\n   int finished = 0; /* crc checked */\n\n   png_debug(1, \"in png_handle_iCCP\");\n\n   /* PNGv3: allow PNG files with both sRGB and iCCP because the PNG spec only\n    * ever said that there \"should\" be only one, not \"shall\" and the PNGv3\n    * colour chunk precedence rules give a handling for this case anyway.\n    */\n   {\n      uInt read_length, keyword_length;\n      char keyword[81];\n\n      /* Find the keyword; the keyword plus separator and compression method\n       * bytes can be at most 81 characters long.\n       */\n      read_length = 81; /* maximum */\n      if (read_length > length)\n         read_length = (uInt)/*SAFE*/length;\n\n      png_crc_read(png_ptr, (png_bytep)keyword, read_length);\n      length -= read_length;\n\n      if (length < LZ77Min)\n      {\n         png_crc_finish(png_ptr, length);\n         png_chunk_benign_error(png_ptr, \"too short\");\n         return handled_error;\n      }\n\n      keyword_length = 0;\n      while (keyword_length < 80 && keyword_length < read_length &&\n         keyword[keyword_length] != 0)\n         ++keyword_length;\n\n      /* TODO: make the keyword checking common */\n      if (keyword_length >= 1 && keyword_length <= 79)\n      {\n         /* We only understand '0' compression - deflate - so if we get a\n          * different value we can't safely decode the chunk.\n          */\n         if (keyword_length+1 < read_length &&\n            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)\n         {\n            read_length -= keyword_length+2;\n\n            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)\n            {\n               Byte profile_header[132]={0};\n               Byte local_buffer[PNG_INFLATE_BUF_SIZE];\n               png_alloc_size_t size = (sizeof profile_header);\n\n               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);\n               png_ptr->zstream.avail_in = read_length;\n               (void)png_inflate_read(png_ptr, local_buffer,\n                   (sizeof local_buffer), &length, profile_header, &size,\n                   0/*finish: don't, because the output is too small*/);\n\n               if (size == 0)\n               {\n                  /* We have the ICC profile header; do the basic header checks.\n                   */\n                  png_uint_32 profile_length = png_get_uint_32(profile_header);\n\n                  if (png_icc_check_length(png_ptr, keyword, profile_length) !=\n                      0)\n                  {\n                     /* The length is apparently ok, so we can check the 132\n                      * byte header.\n                      */\n                     if (png_icc_check_header(png_ptr, keyword, profile_length,\n                              profile_header, png_ptr->color_type) != 0)\n                     {\n                        /* Now read the tag table; a variable size buffer is\n                         * needed at this point, allocate one for the whole\n                         * profile.  The header check has already validated\n                         * that none of this stuff will overflow.\n                         */\n                        png_uint_32 tag_count =\n                           png_get_uint_32(profile_header + 128);\n                        png_bytep profile = png_read_buffer(png_ptr,\n                              profile_length);\n\n                        if (profile != NULL)\n                        {\n                           memcpy(profile, profile_header,\n                               (sizeof profile_header));\n\n                           size = 12 * tag_count;\n\n                           (void)png_inflate_read(png_ptr, local_buffer,\n                               (sizeof local_buffer), &length,\n                               profile + (sizeof profile_header), &size, 0);\n\n                           /* Still expect a buffer error because we expect\n                            * there to be some tag data!\n                            */\n                           if (size == 0)\n                           {\n                              if (png_icc_check_tag_table(png_ptr,\n                                       keyword, profile_length, profile) != 0)\n                              {\n                                 /* The profile has been validated for basic\n                                  * security issues, so read the whole thing in.\n                                  */\n                                 size = profile_length - (sizeof profile_header)\n                                     - 12 * tag_count;\n\n                                 (void)png_inflate_read(png_ptr, local_buffer,\n                                     (sizeof local_buffer), &length,\n                                     profile + (sizeof profile_header) +\n                                     12 * tag_count, &size, 1/*finish*/);\n\n                                 if (length > 0 && !(png_ptr->flags &\n                                     PNG_FLAG_BENIGN_ERRORS_WARN))\n                                    errmsg = \"extra compressed data\";\n\n                                 /* But otherwise allow extra data: */\n                                 else if (size == 0)\n                                 {\n                                    if (length > 0)\n                                    {\n                                       /* This can be handled completely, so\n                                        * keep going.\n                                        */\n                                       png_chunk_warning(png_ptr,\n                                           \"extra compressed data\");\n                                    }\n\n                                    png_crc_finish(png_ptr, length);\n                                    finished = 1;\n\n                                    /* Steal the profile for info_ptr. */\n                                    if (info_ptr != NULL)\n                                    {\n                                       png_free_data(png_ptr, info_ptr,\n                                           PNG_FREE_ICCP, 0);\n\n                                       info_ptr->iccp_name = png_voidcast(char*,\n                                           png_malloc_base(png_ptr,\n                                           keyword_length+1));\n                                       if (info_ptr->iccp_name != NULL)\n                                       {\n                                          memcpy(info_ptr->iccp_name, keyword,\n                                              keyword_length+1);\n                                          info_ptr->iccp_proflen =\n                                              profile_length;\n                                          info_ptr->iccp_profile = profile;\n                                          png_ptr->read_buffer = NULL; /*steal*/\n                                          info_ptr->free_me |= PNG_FREE_ICCP;\n                                          info_ptr->valid |= PNG_INFO_iCCP;\n                                       }\n\n                                       else\n                                          errmsg = \"out of memory\";\n                                    }\n\n                                    /* else the profile remains in the read\n                                     * buffer which gets reused for subsequent\n                                     * chunks.\n                                     */\n\n                                    if (errmsg == NULL)\n                                    {\n                                       png_ptr->zowner = 0;\n                                       return handled_ok;\n                                    }\n                                 }\n                                 if (errmsg == NULL)\n                                    errmsg = png_ptr->zstream.msg;\n                              }\n                              /* else png_icc_check_tag_table output an error */\n                           }\n                           else /* profile truncated */\n                              errmsg = png_ptr->zstream.msg;\n                        }\n\n                        else\n                           errmsg = \"out of memory\";\n                     }\n\n                     /* else png_icc_check_header output an error */\n                  }\n\n                  /* else png_icc_check_length output an error */\n               }\n\n               else /* profile truncated */\n                  errmsg = png_ptr->zstream.msg;\n\n               /* Release the stream */\n               png_ptr->zowner = 0;\n            }\n\n            else /* png_inflate_claim failed */\n               errmsg = png_ptr->zstream.msg;\n         }\n\n         else\n            errmsg = \"bad compression method\"; /* or missing */\n      }\n\n      else\n         errmsg = \"bad keyword\";\n   }\n\n   /* Failure: the reason is in 'errmsg' */\n   if (finished == 0)\n      png_crc_finish(png_ptr, length);\n\n   if (errmsg != NULL) /* else already output */\n      png_chunk_benign_error(png_ptr, errmsg);\n\n   return handled_error;\n}\n",
      "line_start": 1339,
      "line_end": 1557,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 213,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses untrusted iCCP chunk including keyword and deflate-compressed ICC profile; uses zlib inflate, variable-size allocations driven by profile_length/tag_count, memcpy and buffer manipulation, and contains many branches/validation paths. High complexity and memory operations on attacker-controlled data make it a critical fuzz target."
    },
    {
      "name": "pngrutil.c:png_inflate_read",
      "clean_name": "png_inflate_read",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#ifdef PNG_READ_iCCP_SUPPORTED\n/* Perform a partial read and decompress, producing 'avail_out' bytes and\n * reading from the current chunk as required.\n */\nstatic int\npng_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,\n    png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,\n    int finish)\n{\n   if (png_ptr->zowner == png_ptr->chunk_name)\n   {\n      int ret;\n\n      /* next_in and avail_in must have been initialized by the caller. */\n      png_ptr->zstream.next_out = next_out;\n      png_ptr->zstream.avail_out = 0; /* set in the loop */\n\n      do\n      {\n         if (png_ptr->zstream.avail_in == 0)\n         {\n            if (read_size > *chunk_bytes)\n               read_size = (uInt)*chunk_bytes;\n            *chunk_bytes -= read_size;\n\n            if (read_size > 0)\n               png_crc_read(png_ptr, read_buffer, read_size);\n\n            png_ptr->zstream.next_in = read_buffer;\n            png_ptr->zstream.avail_in = read_size;\n         }\n\n         if (png_ptr->zstream.avail_out == 0)\n         {\n            uInt avail = ZLIB_IO_MAX;\n            if (avail > *out_size)\n               avail = (uInt)*out_size;\n            *out_size -= avail;\n\n            png_ptr->zstream.avail_out = avail;\n         }\n\n         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all\n          * the available output is produced; this allows reading of truncated\n          * streams.\n          */\n         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?\n             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));\n      }\n      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));\n\n      *out_size += png_ptr->zstream.avail_out;\n      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */\n\n      /* Ensure the error message pointer is always set: */\n      png_zstream_error(png_ptr, ret);\n      return ret;\n   }\n\n   else\n   {\n      png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zstream unclaimed\");\n      return Z_STREAM_ERROR;\n   }\n}\n",
      "line_start": 835,
      "line_end": 895,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This function consumes and decompresses external PNG chunk data (iCCP), calls into zlib inflate, and performs explicit buffer and memory operations (next_in/next_out, avail_in/avail_out, crc read). It has looping and branching driven by untrusted input (chunk_bytes, read_size, out_size) and nontrivial control flow (flush modes, return handling), making it a high-risk, high-value fuzz target for discovering memory/streaming decompression bugs."
    },
    {
      "name": "pngrutil.c:png_handle_sPLT",
      "clean_name": "png_handle_sPLT",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_iCCP NULL\n#endif /* READ_iCCP */\n\n#ifdef PNG_READ_sPLT_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n/* Note: this does not properly handle chunks that are > 64K under DOS */\n{\n   png_bytep entry_start, buffer;\n   png_sPLT_t new_palette;\n   png_sPLT_entryp pp;\n   png_uint_32 data_length;\n   int entry_size, i;\n   png_uint_32 skip = 0;\n   png_uint_32 dl;\n   size_t max_dl;\n\n   png_debug(1, \"in png_handle_sPLT\");\n\n#ifdef PNG_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_cache_max != 0)\n   {\n      if (png_ptr->user_chunk_cache_max == 1)\n      {\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n\n      if (--png_ptr->user_chunk_cache_max == 1)\n      {\n         png_warning(png_ptr, \"No space in chunk cache for sPLT\");\n         png_crc_finish(png_ptr, length);\n         return handled_error;\n      }\n   }\n#endif\n\n   buffer = png_read_buffer(png_ptr, length+1);\n   if (buffer == NULL)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of memory\");\n      return handled_error;\n   }\n\n\n   /* WARNING: this may break if size_t is less than 32 bits; it is assumed\n    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a\n    * potential breakage point if the types in pngconf.h aren't exactly right.\n    */\n   png_crc_read(png_ptr, buffer, length);\n\n   if (png_crc_finish(png_ptr, skip) != 0)\n      return handled_error;\n\n   buffer[length] = 0;\n\n   for (entry_start = buffer; *entry_start; entry_start++)\n      /* Empty loop to find end of name */ ;\n\n   ++entry_start;\n\n   /* A sample depth should follow the separator, and we should be on it  */\n   if (length < 2U || entry_start > buffer + (length - 2U))\n   {\n      png_warning(png_ptr, \"malformed sPLT chunk\");\n      return handled_error;\n   }\n\n   new_palette.depth = *entry_start++;\n   entry_size = (new_palette.depth == 8 ? 6 : 10);\n   /* This must fit in a png_uint_32 because it is derived from the original\n    * chunk data length.\n    */\n   data_length = length - (png_uint_32)(entry_start - buffer);\n\n   /* Integrity-check the data length */\n   if ((data_length % (unsigned int)entry_size) != 0)\n   {\n      png_warning(png_ptr, \"sPLT chunk has bad length\");\n      return handled_error;\n   }\n\n   dl = (png_uint_32)(data_length / (unsigned int)entry_size);\n   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));\n\n   if (dl > max_dl)\n   {\n      png_warning(png_ptr, \"sPLT chunk too long\");\n      return handled_error;\n   }\n\n   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);\n\n   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,\n       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));\n\n   if (new_palette.entries == NULL)\n   {\n      png_warning(png_ptr, \"sPLT chunk requires too much memory\");\n      return handled_error;\n   }\n\n   for (i = 0; i < new_palette.nentries; i++)\n   {\n      pp = new_palette.entries + i;\n\n      if (new_palette.depth == 8)\n      {\n         pp->red = *entry_start++;\n         pp->green = *entry_start++;\n         pp->blue = *entry_start++;\n         pp->alpha = *entry_start++;\n      }\n\n      else\n      {\n         pp->red   = png_get_uint_16(entry_start); entry_start += 2;\n         pp->green = png_get_uint_16(entry_start); entry_start += 2;\n         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;\n         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;\n      }\n\n      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;\n   }\n\n   /* Discard all chunk data except the name and stash that */\n   new_palette.name = (png_charp)buffer;\n\n   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);\n\n   png_free(png_ptr, new_palette.entries);\n   return handled_ok;\n}\n",
      "line_start": 1563,
      "line_end": 1692,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 148,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses external PNG sPLT chunk (untrusted file data), performs memory allocations and per-entry parsing (byte and 16-bit reads), has loops with input-dependent bounds, multiple code paths (8- vs 16-bit depth) and several integrity/size checks \u2014 high-value fuzz target. Not security/crypto-critical enough for a 10."
    },
    {
      "name": "png_do_check_palette_indexes",
      "clean_name": "png_do_check_palette_indexes",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \\\n    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)\n/* Added at libpng-1.5.10 */\nvoid /* PRIVATE */\npng_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)\n{\n   png_debug(1, \"in png_do_check_palette_indexes\");\n\n   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&\n      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */\n   {\n      /* Calculations moved outside switch in an attempt to stop different\n       * compiler warnings.  'padding' is in *bits* within the last byte, it is\n       * an 'int' because pixel_depth becomes an 'int' in the expression below,\n       * and this calculation is used because it avoids warnings that other\n       * forms produced on either GCC or MSVC.\n       */\n      int padding = PNG_PADBITS(row_info->pixel_depth, row_info->width);\n      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            /* in this case, all bytes must be 0 so we don't need\n             * to unpack the pixels except for the rightmost one.\n             */\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              if ((*rp >> padding) != 0)\n                 png_ptr->num_palette_max = 1;\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 2:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 2) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 6) & 0x03);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 4:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n              int i = ((*rp >> padding) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              i = (((*rp >> padding) >> 4) & 0x0f);\n\n              if (i > png_ptr->num_palette_max)\n                 png_ptr->num_palette_max = i;\n\n              padding = 0;\n            }\n\n            break;\n         }\n\n         case 8:\n         {\n            for (; rp > png_ptr->row_buf; rp--)\n            {\n               if (*rp > png_ptr->num_palette_max)\n                  png_ptr->num_palette_max = (int) *rp;\n            }\n\n            break;\n         }\n\n         default:\n            break;\n      }\n   }\n}\n",
      "line_start": 699,
      "line_end": 798,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 87,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Processes structured external input (PNG row bytes) with pointer arithmetic, bit-level extraction and conditional updates; contains loops whose bounds come from row_info (external data), branching by bit_depth, and direct memory reads from an untrusted buffer (potential for OOB/logic bugs). High-value fuzz target for finding parsing and memory-handling issues."
    },
    {
      "name": "png_do_read_interlace",
      "clean_name": "png_do_read_interlace",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));\n}\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\nvoid /* PRIVATE */\npng_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,\n    png_uint_32 transformations /* Because these may affect the byte layout */)\n{\n   png_debug(1, \"in png_do_read_interlace\");\n   if (row != NULL && row_info != NULL)\n   {\n      png_uint_32 final_width;\n\n      final_width = row_info->width * png_pass_inc[pass];\n\n      switch (row_info->pixel_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 3);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_byte v;\n            png_uint_32 i;\n            int j;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n                sshift = ((row_info->width + 7) & 0x07);\n                dshift = ((final_width + 7) & 0x07);\n                s_start = 7;\n                s_end = 0;\n                s_inc = -1;\n            }\n\n            else\n#endif\n            {\n                sshift = 7 - ((row_info->width + 7) & 0x07);\n                dshift = 7 - ((final_width + 7) & 0x07);\n                s_start = 0;\n                s_end = 7;\n                s_inc = 1;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               v = (png_byte)((*sp >> sshift) & 0x01);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 2:\n         {\n            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);\n            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 3) & 0x03) << 1);\n               dshift = (((final_width + 3) & 0x03) << 1);\n               s_start = 6;\n               s_end = 0;\n               s_inc = -2;\n            }\n\n            else\n#endif\n            {\n               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);\n               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);\n               s_start = 0;\n               s_end = 6;\n               s_inc = 2;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v;\n               int j;\n\n               v = (png_byte)((*sp >> sshift) & 0x03);\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);\n            png_bytep dp = row + (size_t)((final_width - 1) >> 1);\n            unsigned int sshift, dshift;\n            unsigned int s_start, s_end;\n            int s_inc;\n            png_uint_32 i;\n            int jstop = (int)png_pass_inc[pass];\n\n#ifdef PNG_READ_PACKSWAP_SUPPORTED\n            if ((transformations & PNG_PACKSWAP) != 0)\n            {\n               sshift = (((row_info->width + 1) & 0x01) << 2);\n               dshift = (((final_width + 1) & 0x01) << 2);\n               s_start = 4;\n               s_end = 0;\n               s_inc = -4;\n            }\n\n            else\n#endif\n            {\n               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);\n               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);\n               s_start = 0;\n               s_end = 4;\n               s_inc = 4;\n            }\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);\n               int j;\n\n               for (j = 0; j < jstop; j++)\n               {\n                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));\n                  tmp |= (unsigned int)(v << dshift);\n                  *dp = (png_byte)(tmp & 0xff);\n\n                  if (dshift == s_end)\n                  {\n                     dshift = s_start;\n                     dp--;\n                  }\n\n                  else\n                     dshift = (unsigned int)((int)dshift + s_inc);\n               }\n\n               if (sshift == s_end)\n               {\n                  sshift = s_start;\n                  sp--;\n               }\n\n               else\n                  sshift = (unsigned int)((int)sshift + s_inc);\n            }\n            break;\n         }\n\n         default:\n         {\n            size_t pixel_bytes = (row_info->pixel_depth >> 3);\n\n            png_bytep sp = row + (size_t)(row_info->width - 1)\n                * pixel_bytes;\n\n            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;\n\n            int jstop = (int)png_pass_inc[pass];\n            png_uint_32 i;\n\n            for (i = 0; i < row_info->width; i++)\n            {\n               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */\n               int j;\n\n               memcpy(v, sp, pixel_bytes);\n\n               for (j = 0; j < jstop; j++)\n               {\n                  memcpy(dp, v, pixel_bytes);\n                  dp -= pixel_bytes;\n               }\n\n               sp -= pixel_bytes;\n            }\n            break;\n         }\n      }\n\n      row_info->width = final_width;\n      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);\n   }\n#ifndef PNG_READ_PACKSWAP_SUPPORTED\n   PNG_UNUSED(transformations)  /* Silence compiler warning */\n#endif\n}\n",
      "line_start": 3722,
      "line_end": 3962,
      "execution_count": 2984,
      "covered_regions": 27,
      "total_regions": 147,
      "coverage_percent": 18.37,
      "is_covered": true,
      "is_static": false,
      "score": 9.0,
      "reason": "Handles parsing/reassembly of interlaced PNG row data (complex external input). Performs pointer arithmetic, bit-level operations and memcpy on buffers using bounds derived from row_info->width, pass and transformations; contains multiple branches for different pixel depths and pack-swap handling and loops with input-dependent limits. High potential for OOB/logic errors \u2014 excellent fuzz target."
    },
    {
      "name": "png_init_read_transformations",
      "clean_name": "png_init_read_transformations",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n}\n#endif /* READ_GAMMA */\n\nvoid /* PRIVATE */\npng_init_read_transformations(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_init_read_transformations\");\n\n   /* This internal function is called from png_read_start_row in pngrutil.c\n    * and it is called before the 'rowbytes' calculation is done, so the code\n    * in here can change or update the transformations flags.\n    *\n    * First do updates that do not depend on the details of the PNG image data\n    * being processed.\n    */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds\n    * png_set_alpha_mode and this is another source for a default file gamma so\n    * the test needs to be performed later - here.  In addition prior to 1.5.4\n    * the tests were repeated for the PALETTE color type here - this is no\n    * longer necessary (and doesn't seem to have been necessary before.)\n    *\n    * PNGv3: the new mandatory precedence/priority rules for colour space chunks\n    * are handled here (by calling the above function).\n    *\n    * Turn the gamma transformation on or off as appropriate.  Notice that\n    * PNG_GAMMA just refers to the file->screen correction.  Alpha composition\n    * may independently cause gamma correction because it needs linear data\n    * (e.g. if the file has a gAMA chunk but the screen gamma hasn't been\n    * specified.)  In any case this flag may get turned off in the code\n    * immediately below if the transform can be handled outside the row loop.\n    */\n   if (png_init_gamma_values(png_ptr) != 0)\n      png_ptr->transformations |= PNG_GAMMA;\n\n   else\n      png_ptr->transformations &= ~PNG_GAMMA;\n#endif\n\n   /* Certain transformations have the effect of preventing other\n    * transformations that happen afterward in png_do_read_transformations;\n    * resolve the interdependencies here.  From the code of\n    * png_do_read_transformations the order is:\n    *\n    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)\n    *  2) PNG_STRIP_ALPHA (if no compose)\n    *  3) PNG_RGB_TO_GRAY\n    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY\n    *  5) PNG_COMPOSE\n    *  6) PNG_GAMMA\n    *  7) PNG_STRIP_ALPHA (if compose)\n    *  8) PNG_ENCODE_ALPHA\n    *  9) PNG_SCALE_16_TO_8\n    * 10) PNG_16_TO_8\n    * 11) PNG_QUANTIZE (converts to palette)\n    * 12) PNG_EXPAND_16\n    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY\n    * 14) PNG_INVERT_MONO\n    * 15) PNG_INVERT_ALPHA\n    * 16) PNG_SHIFT\n    * 17) PNG_PACK\n    * 18) PNG_BGR\n    * 19) PNG_PACKSWAP\n    * 20) PNG_FILLER (includes PNG_ADD_ALPHA)\n    * 21) PNG_SWAP_ALPHA\n    * 22) PNG_SWAP_BYTES\n    * 23) PNG_USER_TRANSFORM [must be last]\n    */\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) == 0)\n   {\n      /* Stripping the alpha channel happens immediately after the 'expand'\n       * transformations, before all other transformation, so it cancels out\n       * the alpha handling.  It has the side effect negating the effect of\n       * PNG_EXPAND_tRNS too:\n       */\n      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |\n         PNG_EXPAND_tRNS);\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n\n      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen\n       * so transparency information would remain just so long as it wasn't\n       * expanded.  This produces unexpected API changes if the set of things\n       * that do PNG_EXPAND_tRNS changes (perfectly possible given the\n       * documentation - which says ask for what you want, accept what you\n       * get.)  This makes the behavior consistent from 1.5.4:\n       */\n      png_ptr->num_trans = 0;\n   }\n#endif /* STRIP_ALPHA supported, no COMPOSE */\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA\n    * settings will have no effect.\n    */\n   if (png_gamma_significant(png_ptr->screen_gamma) == 0)\n   {\n      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n   }\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n   /* Make sure the coefficients for the rgb to gray conversion are set\n    * appropriately.\n    */\n   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n      png_set_rgb_coefficients(png_ptr);\n#endif\n\n#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED\n#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)\n   /* Detect gray background and attempt to enable optimization for\n    * gray --> RGB case.\n    *\n    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or\n    * RGB_ALPHA (in which case need_expand is superfluous anyway), the\n    * background color might actually be gray yet not be flagged as such.\n    * This is not a problem for the current code, which uses\n    * PNG_BACKGROUND_IS_GRAY only to decide when to do the\n    * png_do_gray_to_rgb() transformation.\n    *\n    * TODO: this code needs to be revised to avoid the complexity and\n    * interdependencies.  The color type of the background should be recorded in\n    * png_set_background, along with the bit depth, then the code has a record\n    * of exactly what color space the background is currently in.\n    */\n   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0)\n   {\n      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if\n       * the file was grayscale the background value is gray.\n       */\n      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\n   }\n\n   else if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n   {\n      /* PNG_COMPOSE: png_set_background was called with need_expand false,\n       * so the color is in the color space of the output or png_set_alpha_mode\n       * was called and the color is black.  Ignore RGB_TO_GRAY because that\n       * happens before GRAY_TO_RGB.\n       */\n      if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)\n      {\n         if (png_ptr->background.red == png_ptr->background.green &&\n             png_ptr->background.red == png_ptr->background.blue)\n         {\n            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;\n            png_ptr->background.gray = png_ptr->background.red;\n         }\n      }\n   }\n#endif /* READ_EXPAND && READ_BACKGROUND */\n#endif /* READ_GRAY_TO_RGB */\n\n   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations\n    * can be performed directly on the palette, and some (such as rgb to gray)\n    * can be optimized inside the palette.  This is particularly true of the\n    * composite (background and alpha) stuff, which can be pretty much all done\n    * in the palette even if the result is expanded to RGB or gray afterward.\n    *\n    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and\n    * earlier and the palette stuff is actually handled on the first row.  This\n    * leads to the reported bug that the palette returned by png_get_PLTE is not\n    * updated.\n    */\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      png_init_palette_transformations(png_ptr);\n\n   else\n      png_init_rgb_transformations(png_ptr);\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\n   defined(PNG_READ_EXPAND_16_SUPPORTED)\n   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&\n       png_ptr->bit_depth != 16)\n   {\n      /* TODO: fix this.  Because the expand_16 operation is after the compose\n       * handling the background color must be 8, not 16, bits deep, but the\n       * application will supply a 16-bit value so reduce it here.\n       *\n       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at\n       * present, so that case is ok (until do_expand_16 is moved.)\n       *\n       * NOTE: this discards the low 16 bits of the user supplied background\n       * color, but until expand_16 works properly there is no choice!\n       */\n#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))\n      CHOP(png_ptr->background.red);\n      CHOP(png_ptr->background.green);\n      CHOP(png_ptr->background.blue);\n      CHOP(png_ptr->background.gray);\n#     undef CHOP\n   }\n#endif /* READ_BACKGROUND && READ_EXPAND_16 */\n\n#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \\\n   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \\\n   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))\n   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) != 0 &&\n       (png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&\n       png_ptr->bit_depth == 16)\n   {\n      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per\n       * component this will also happen after PNG_COMPOSE and so the background\n       * color must be pre-expanded here.\n       *\n       * TODO: fix this too.\n       */\n      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);\n      png_ptr->background.green =\n         (png_uint_16)(png_ptr->background.green * 257);\n      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);\n      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);\n   }\n#endif\n\n   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the\n    * background support (see the comments in scripts/pnglibconf.dfa), this\n    * allows pre-multiplication of the alpha channel to be implemented as\n    * compositing on black.  This is probably sub-optimal and has been done in\n    * 1.5.4 betas simply to enable external critique and testing (i.e. to\n    * implement the new API quickly, without lots of internal changes.)\n    */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\n      /* Includes ALPHA_MODE */\n      png_ptr->background_1 = png_ptr->background;\n#  endif\n\n   /* This needs to change - in the palette image case a whole set of tables are\n    * built when it would be quicker to just calculate the correct value for\n    * each palette entry directly.  Also, the test is too tricky - why check\n    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that\n    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the\n    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction\n    * the gamma tables will not be built even if composition is required on a\n    * gamma encoded value.\n    *\n    * In 1.5.4 this is addressed below by an additional check on the individual\n    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the\n    * tables.\n    */\n   if ((png_ptr->transformations & PNG_GAMMA) != 0 ||\n       ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0 &&\n        (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n         png_gamma_significant(png_ptr->screen_gamma) != 0)) ||\n        ((png_ptr->transformations & PNG_COMPOSE) != 0 &&\n         (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n          png_gamma_significant(png_ptr->screen_gamma) != 0\n#  ifdef PNG_READ_BACKGROUND_SUPPORTED\n         || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE &&\n           png_gamma_significant(png_ptr->background_gamma) != 0)\n#  endif\n        )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&\n       png_gamma_significant(png_ptr->screen_gamma) != 0))\n   {\n      png_build_gamma_table(png_ptr, png_ptr->bit_depth);\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n      if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n      {\n         /* Issue a warning about this combination: because RGB_TO_GRAY is\n          * optimized to do the gamma transform if present yet do_background has\n          * to do the same thing if both options are set a\n          * double-gamma-correction happens.  This is true in all versions of\n          * libpng to date.\n          */\n         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)\n            png_warning(png_ptr,\n                \"libpng does not support gamma+background+rgb_to_gray\");\n\n         if ((png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) != 0)\n         {\n            /* We don't get to here unless there is a tRNS chunk with non-opaque\n             * entries - see the checking code at the start of this function.\n             */\n            png_color back, back_1;\n            png_colorp palette = png_ptr->palette;\n            int num_palette = png_ptr->num_palette;\n            int i;\n            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)\n            {\n\n               back.red = png_ptr->gamma_table[png_ptr->background.red];\n               back.green = png_ptr->gamma_table[png_ptr->background.green];\n               back.blue = png_ptr->gamma_table[png_ptr->background.blue];\n\n               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];\n               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];\n               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];\n            }\n            else\n            {\n               png_fixed_point g, gs;\n\n               switch (png_ptr->background_gamma_type)\n               {\n                  case PNG_BACKGROUND_GAMMA_SCREEN:\n                     g = (png_ptr->screen_gamma);\n                     gs = PNG_FP_1;\n                     break;\n\n                  case PNG_BACKGROUND_GAMMA_FILE:\n                     g = png_reciprocal(png_ptr->file_gamma);\n                     gs = png_reciprocal2(png_ptr->file_gamma,\n                         png_ptr->screen_gamma);\n                     break;\n\n                  case PNG_BACKGROUND_GAMMA_UNIQUE:\n                     g = png_reciprocal(png_ptr->background_gamma);\n                     gs = png_reciprocal2(png_ptr->background_gamma,\n                         png_ptr->screen_gamma);\n                     break;\n                  default:\n                     g = PNG_FP_1;    /* back_1 */\n                     gs = PNG_FP_1;   /* back */\n                     break;\n               }\n\n               if (png_gamma_significant(gs) != 0)\n               {\n                  back.red = png_gamma_8bit_correct(png_ptr->background.red,\n                      gs);\n                  back.green = png_gamma_8bit_correct(png_ptr->background.green,\n                      gs);\n                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,\n                      gs);\n               }\n\n               else\n               {\n                  back.red   = (png_byte)png_ptr->background.red;\n                  back.green = (png_byte)png_ptr->background.green;\n                  back.blue  = (png_byte)png_ptr->background.blue;\n               }\n\n               if (png_gamma_significant(g) != 0)\n               {\n                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,\n                      g);\n                  back_1.green = png_gamma_8bit_correct(\n                      png_ptr->background.green, g);\n                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,\n                      g);\n               }\n\n               else\n               {\n                  back_1.red   = (png_byte)png_ptr->background.red;\n                  back_1.green = (png_byte)png_ptr->background.green;\n                  back_1.blue  = (png_byte)png_ptr->background.blue;\n               }\n            }\n\n            for (i = 0; i < num_palette; i++)\n            {\n               if (i < (int)png_ptr->num_trans &&\n                   png_ptr->trans_alpha[i] != 0xff)\n               {\n                  if (png_ptr->trans_alpha[i] == 0)\n                  {\n                     palette[i] = back;\n                  }\n                  else /* if (png_ptr->trans_alpha[i] != 0xff) */\n                  {\n                     if ((png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0)\n                     {\n                        /* Premultiply only:\n                         * component = round((component * alpha) / 255)\n                         */\n                        png_uint_32 component;\n\n                        component = png_ptr->gamma_to_1[palette[i].red];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].red = png_ptr->gamma_from_1[component];\n\n                        component = png_ptr->gamma_to_1[palette[i].green];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].green = png_ptr->gamma_from_1[component];\n\n                        component = png_ptr->gamma_to_1[palette[i].blue];\n                        component =\n                            (component * png_ptr->trans_alpha[i] + 128) / 255;\n                        palette[i].blue = png_ptr->gamma_from_1[component];\n                     }\n                     else\n                     {\n                        /* Composite with background color:\n                         * component =\n                         *    alpha * component + (1 - alpha) * background\n                         */\n                        png_byte v, w;\n\n                        v = png_ptr->gamma_to_1[palette[i].red];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.red);\n                        palette[i].red = png_ptr->gamma_from_1[w];\n\n                        v = png_ptr->gamma_to_1[palette[i].green];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.green);\n                        palette[i].green = png_ptr->gamma_from_1[w];\n\n                        v = png_ptr->gamma_to_1[palette[i].blue];\n                        png_composite(w, v,\n                            png_ptr->trans_alpha[i], back_1.blue);\n                        palette[i].blue = png_ptr->gamma_from_1[w];\n                     }\n                  }\n               }\n               else\n               {\n                  palette[i].red = png_ptr->gamma_table[palette[i].red];\n                  palette[i].green = png_ptr->gamma_table[palette[i].green];\n                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];\n               }\n            }\n\n            /* Prevent the transformations being done again.\n             *\n             * NOTE: this is highly dubious; it removes the transformations in\n             * place.  This seems inconsistent with the general treatment of the\n             * transformations elsewhere.\n             */\n            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);\n         } /* color_type == PNG_COLOR_TYPE_PALETTE */\n\n         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */\n         else /* color_type != PNG_COLOR_TYPE_PALETTE */\n         {\n            int gs_sig, g_sig;\n            png_fixed_point g = PNG_FP_1;  /* Correction to linear */\n            png_fixed_point gs = PNG_FP_1; /* Correction to screen */\n\n            switch (png_ptr->background_gamma_type)\n            {\n               case PNG_BACKGROUND_GAMMA_SCREEN:\n                  g = png_ptr->screen_gamma;\n                  /* gs = PNG_FP_1; */\n                  break;\n\n               case PNG_BACKGROUND_GAMMA_FILE:\n                  g = png_reciprocal(png_ptr->file_gamma);\n                  gs = png_reciprocal2(png_ptr->file_gamma,\n                      png_ptr->screen_gamma);\n                  break;\n\n               case PNG_BACKGROUND_GAMMA_UNIQUE:\n                  g = png_reciprocal(png_ptr->background_gamma);\n                  gs = png_reciprocal2(png_ptr->background_gamma,\n                      png_ptr->screen_gamma);\n                  break;\n\n               default:\n                  png_error(png_ptr, \"invalid background gamma type\");\n            }\n\n            g_sig = png_gamma_significant(g);\n            gs_sig = png_gamma_significant(gs);\n\n            if (g_sig != 0)\n               png_ptr->background_1.gray = png_gamma_correct(png_ptr,\n                   png_ptr->background.gray, g);\n\n            if (gs_sig != 0)\n               png_ptr->background.gray = png_gamma_correct(png_ptr,\n                   png_ptr->background.gray, gs);\n\n            if ((png_ptr->background.red != png_ptr->background.green) ||\n                (png_ptr->background.red != png_ptr->background.blue) ||\n                (png_ptr->background.red != png_ptr->background.gray))\n            {\n               /* RGB or RGBA with color background */\n               if (g_sig != 0)\n               {\n                  png_ptr->background_1.red = png_gamma_correct(png_ptr,\n                      png_ptr->background.red, g);\n\n                  png_ptr->background_1.green = png_gamma_correct(png_ptr,\n                      png_ptr->background.green, g);\n\n                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,\n                      png_ptr->background.blue, g);\n               }\n\n               if (gs_sig != 0)\n               {\n                  png_ptr->background.red = png_gamma_correct(png_ptr,\n                      png_ptr->background.red, gs);\n\n                  png_ptr->background.green = png_gamma_correct(png_ptr,\n                      png_ptr->background.green, gs);\n\n                  png_ptr->background.blue = png_gamma_correct(png_ptr,\n                      png_ptr->background.blue, gs);\n               }\n            }\n\n            else\n            {\n               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */\n               png_ptr->background_1.red = png_ptr->background_1.green\n                   = png_ptr->background_1.blue = png_ptr->background_1.gray;\n\n               png_ptr->background.red = png_ptr->background.green\n                   = png_ptr->background.blue = png_ptr->background.gray;\n            }\n\n            /* The background is now in screen gamma: */\n            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;\n         } /* color_type != PNG_COLOR_TYPE_PALETTE */\n      }/* png_ptr->transformations & PNG_BACKGROUND */\n\n      else\n      /* Transformation does not include PNG_BACKGROUND */\n#endif /* READ_BACKGROUND */\n      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */\n         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||\n         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)\n#endif\n         )\n      {\n         png_colorp palette = png_ptr->palette;\n         int num_palette = png_ptr->num_palette;\n         int i;\n\n         /* NOTE: there are other transformations that should probably be in\n          * here too.\n          */\n         for (i = 0; i < num_palette; i++)\n         {\n            palette[i].red = png_ptr->gamma_table[palette[i].red];\n            palette[i].green = png_ptr->gamma_table[palette[i].green];\n            palette[i].blue = png_ptr->gamma_table[palette[i].blue];\n         }\n\n         /* Done the gamma correction. */\n         png_ptr->transformations &= ~PNG_GAMMA;\n      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */\n   }\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   else\n#endif\n#endif /* READ_GAMMA */\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n   /* No GAMMA transformation (see the hanging else 4 lines above) */\n   if ((png_ptr->transformations & PNG_COMPOSE) != 0 &&\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\n   {\n      int i;\n      int istop = (int)png_ptr->num_trans;\n      png_color back;\n      png_colorp palette = png_ptr->palette;\n\n      back.red   = (png_byte)png_ptr->background.red;\n      back.green = (png_byte)png_ptr->background.green;\n      back.blue  = (png_byte)png_ptr->background.blue;\n\n      for (i = 0; i < istop; i++)\n      {\n         if (png_ptr->trans_alpha[i] == 0)\n         {\n            palette[i] = back;\n         }\n\n         else if (png_ptr->trans_alpha[i] != 0xff)\n         {\n            /* The png_composite() macro is defined in png.h */\n            png_composite(palette[i].red, palette[i].red,\n                png_ptr->trans_alpha[i], back.red);\n\n            png_composite(palette[i].green, palette[i].green,\n                png_ptr->trans_alpha[i], back.green);\n\n            png_composite(palette[i].blue, palette[i].blue,\n                png_ptr->trans_alpha[i], back.blue);\n         }\n      }\n\n      png_ptr->transformations &= ~PNG_COMPOSE;\n   }\n#endif /* READ_BACKGROUND */\n\n#ifdef PNG_READ_SHIFT_SUPPORTED\n   if ((png_ptr->transformations & PNG_SHIFT) != 0 &&\n       (png_ptr->transformations & PNG_EXPAND) == 0 &&\n       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))\n   {\n      int i;\n      int istop = png_ptr->num_palette;\n      int shift = 8 - png_ptr->sig_bit.red;\n\n      png_ptr->transformations &= ~PNG_SHIFT;\n\n      /* significant bits can be in the range 1 to 7 for a meaningful result, if\n       * the number of significant bits is 0 then no shift is done (this is an\n       * error condition which is silently ignored.)\n       */\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].red;\n\n            component >>= shift;\n            png_ptr->palette[i].red = (png_byte)component;\n         }\n\n      shift = 8 - png_ptr->sig_bit.green;\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].green;\n\n            component >>= shift;\n            png_ptr->palette[i].green = (png_byte)component;\n         }\n\n      shift = 8 - png_ptr->sig_bit.blue;\n      if (shift > 0 && shift < 8)\n         for (i=0; i<istop; ++i)\n         {\n            int component = png_ptr->palette[i].blue;\n\n            component >>= shift;\n            png_ptr->palette[i].blue = (png_byte)component;\n         }\n   }\n#endif /* READ_SHIFT */\n}\n",
      "line_start": 1414,
      "line_end": 2052,
      "execution_count": 358,
      "covered_regions": 134,
      "total_regions": 613,
      "coverage_percent": 21.86,
      "is_covered": true,
      "is_static": false,
      "score": 9.0,
      "reason": "This routine is high-value for fuzzing: it processes structured external input (PNG state derived from file chunks), performs many memory/array mutations (palette, gamma tables, background fields), contains numerous conditional branches and loops whose bounds come from png_ptr fields (num_palette, num_trans, bit_depth, transformations flags), and has complex interdependent logic. Any inconsistencies from earlier parsing could lead to out-of-bounds or logic errors, so it warrants critical fuzzing priority."
    },
    {
      "name": "pngrtran.c:png_do_read_filler",
      "clean_name": "png_do_read_filler",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_FILLER_SUPPORTED\n/* Add filler channel if we have RGB color */\nstatic void\npng_do_read_filler(png_row_infop row_info, png_bytep row,\n    png_uint_32 filler, png_uint_32 flags)\n{\n   png_uint_32 i;\n   png_uint_32 row_width = row_info->width;\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n   png_byte hi_filler = (png_byte)(filler>>8);\n#endif\n   png_byte lo_filler = (png_byte)filler;\n\n   png_debug(1, \"in png_do_read_filler\");\n\n   if (\n       row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from G to GX */\n            png_bytep sp = row + (size_t)row_width;\n            png_bytep dp =  sp + (size_t)row_width;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            row_info->channels = 2;\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n\n         else\n         {\n            /* This changes the data from G to XG */\n            png_bytep sp = row + (size_t)row_width;\n            png_bytep dp = sp  + (size_t)row_width;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n            }\n            row_info->channels = 2;\n            row_info->pixel_depth = 16;\n            row_info->rowbytes = row_width * 2;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from GG to GGXX */\n            png_bytep sp = row + (size_t)row_width * 2;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            *(--dp) = hi_filler;\n            row_info->channels = 2;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n\n         else\n         {\n            /* This changes the data from GG to XXGG */\n            png_bytep sp = row + (size_t)row_width * 2;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n            }\n            row_info->channels = 2;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n      }\n#endif\n   } /* COLOR_TYPE == GRAY */\n   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from RGB to RGBX */\n            png_bytep sp = row + (size_t)row_width * 3;\n            png_bytep dp = sp  + (size_t)row_width;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            row_info->channels = 4;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n\n         else\n         {\n            /* This changes the data from RGB to XRGB */\n            png_bytep sp = row + (size_t)row_width * 3;\n            png_bytep dp = sp + (size_t)row_width;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n            }\n            row_info->channels = 4;\n            row_info->pixel_depth = 32;\n            row_info->rowbytes = row_width * 4;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)\n         {\n            /* This changes the data from RRGGBB to RRGGBBXX */\n            png_bytep sp = row + (size_t)row_width * 6;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 1; i < row_width; i++)\n            {\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n            }\n            *(--dp) = lo_filler;\n            *(--dp) = hi_filler;\n            row_info->channels = 4;\n            row_info->pixel_depth = 64;\n            row_info->rowbytes = row_width * 8;\n         }\n\n         else\n         {\n            /* This changes the data from RRGGBB to XXRRGGBB */\n            png_bytep sp = row + (size_t)row_width * 6;\n            png_bytep dp = sp  + (size_t)row_width * 2;\n            for (i = 0; i < row_width; i++)\n            {\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = *(--sp);\n               *(--dp) = lo_filler;\n               *(--dp) = hi_filler;\n            }\n\n            row_info->channels = 4;\n            row_info->pixel_depth = 64;\n            row_info->rowbytes = row_width * 8;\n         }\n      }\n#endif\n   } /* COLOR_TYPE == RGB */\n}\n",
      "line_start": 2791,
      "line_end": 2973,
      "execution_count": 7005,
      "covered_regions": 27,
      "total_regions": 111,
      "coverage_percent": 24.32,
      "is_covered": true,
      "is_static": true,
      "score": 9.0,
      "reason": "High-value fuzz target: transforms image row buffers based on external inputs (row, row_info, filler, flags), with many branches (color type, bit depth, flags), loops whose bounds depend on row_width, and extensive manual pointer arithmetic/write operations (potential OOB). Moderate-high cyclomatic complexity and direct memory manipulation make it likely to reveal crashes/security bugs."
    },
    {
      "name": "png_XYZ_from_xy",
      "clean_name": "png_XYZ_from_xy",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 0;\n}\n\nint /* PRIVATE */\npng_XYZ_from_xy(png_XYZ *XYZ, const png_xy *xy)\n{\n   /* NOTE: returns 0 on success, 1 means error. */\n   png_fixed_point red_inverse, green_inverse, blue_scale;\n   png_fixed_point left, right, denominator;\n\n   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically\n    * have end points with 0 tristimulus values (these are impossible end\n    * points, but they are used to cover the possible colors).  We check\n    * xy->whitey against 5, not 0, to avoid a possible integer overflow.\n    *\n    * The limits here will *not* accept ACES AP0, where bluey is -7700\n    * (-0.0770) because the PNG spec itself requires the xy values to be\n    * unsigned.  whitey is also required to be 5 or more to avoid overflow.\n    *\n    * Instead the upper limits have been relaxed to accomodate ACES AP1 where\n    * redz ends up as -600 (-0.006).  ProPhotoRGB was already \"in range.\"\n    * The new limit accomodates the AP0 and AP1 ranges for z but not AP0 redy.\n    */\n   const png_fixed_point fpLimit = PNG_FP_1+(PNG_FP_1/10);\n   if (xy->redx   < 0 || xy->redx > fpLimit) return 1;\n   if (xy->redy   < 0 || xy->redy > fpLimit-xy->redx) return 1;\n   if (xy->greenx < 0 || xy->greenx > fpLimit) return 1;\n   if (xy->greeny < 0 || xy->greeny > fpLimit-xy->greenx) return 1;\n   if (xy->bluex  < 0 || xy->bluex > fpLimit) return 1;\n   if (xy->bluey  < 0 || xy->bluey > fpLimit-xy->bluex) return 1;\n   if (xy->whitex < 0 || xy->whitex > fpLimit) return 1;\n   if (xy->whitey < 5 || xy->whitey > fpLimit-xy->whitex) return 1;\n\n   /* The reverse calculation is more difficult because the original tristimulus\n    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8\n    * derived values were recorded in the cHRM chunk;\n    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and\n    * therefore an arbitrary ninth value has to be introduced to undo the\n    * original transformations.\n    *\n    * Think of the original end-points as points in (X,Y,Z) space.  The\n    * chromaticity values (c) have the property:\n    *\n    *           C\n    *   c = ---------\n    *       X + Y + Z\n    *\n    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the\n    * three chromaticity values (x,y,z) for each end-point obey the\n    * relationship:\n    *\n    *   x + y + z = 1\n    *\n    * This describes the plane in (X,Y,Z) space that intersects each axis at the\n    * value 1.0; call this the chromaticity plane.  Thus the chromaticity\n    * calculation has scaled each end-point so that it is on the x+y+z=1 plane\n    * and chromaticity is the intersection of the vector from the origin to the\n    * (X,Y,Z) value with the chromaticity plane.\n    *\n    * To fully invert the chromaticity calculation we would need the three\n    * end-point scale factors, (red-scale, green-scale, blue-scale), but these\n    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and\n    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have\n    * given all three of the scale factors since:\n    *\n    *    color-C = color-c * color-scale\n    *    white-C = red-C + green-C + blue-C\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\n    *\n    * But cHRM records only white-x and white-y, so we have lost the white scale\n    * factor:\n    *\n    *    white-C = white-c*white-scale\n    *\n    * To handle this the inverse transformation makes an arbitrary assumption\n    * about white-scale:\n    *\n    *    Assume: white-Y = 1.0\n    *    Hence:  white-scale = 1/white-y\n    *    Or:     red-Y + green-Y + blue-Y = 1.0\n    *\n    * Notice the last statement of the assumption gives an equation in three of\n    * the nine values we want to calculate.  8 more equations come from the\n    * above routine as summarised at the top above (the chromaticity\n    * calculation):\n    *\n    *    Given: color-x = color-X / (color-X + color-Y + color-Z)\n    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0\n    *\n    * This is 9 simultaneous equations in the 9 variables \"color-C\" and can be\n    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix\n    * determinants, however this is not as bad as it seems because only 28 of\n    * the total of 90 terms in the various matrices are non-zero.  Nevertheless\n    * Cramer's rule is notoriously numerically unstable because the determinant\n    * calculation involves the difference of large, but similar, numbers.  It is\n    * difficult to be sure that the calculation is stable for real world values\n    * and it is certain that it becomes unstable where the end points are close\n    * together.\n    *\n    * So this code uses the perhaps slightly less optimal but more\n    * understandable and totally obvious approach of calculating color-scale.\n    *\n    * This algorithm depends on the precision in white-scale and that is\n    * (1/white-y), so we can immediately see that as white-y approaches 0 the\n    * accuracy inherent in the cHRM chunk drops off substantially.\n    *\n    * libpng arithmetic: a simple inversion of the above equations\n    * ------------------------------------------------------------\n    *\n    *    white_scale = 1/white-y\n    *    white-X = white-x * white-scale\n    *    white-Y = 1.0\n    *    white-Z = (1 - white-x - white-y) * white_scale\n    *\n    *    white-C = red-C + green-C + blue-C\n    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale\n    *\n    * This gives us three equations in (red-scale,green-scale,blue-scale) where\n    * all the coefficients are now known:\n    *\n    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale\n    *       = white-x/white-y\n    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1\n    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale\n    *       = (1 - white-x - white-y)/white-y\n    *\n    * In the last equation color-z is (1 - color-x - color-y) so we can add all\n    * three equations together to get an alternative third:\n    *\n    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale\n    *\n    * So now we have a Cramer's rule solution where the determinants are just\n    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve\n    * multiplication of three coefficients so we can't guarantee to avoid\n    * overflow in the libpng fixed point representation.  Using Cramer's rule in\n    * floating point is probably a good choice here, but it's not an option for\n    * fixed point.  Instead proceed to simplify the first two equations by\n    * eliminating what is likely to be the largest value, blue-scale:\n    *\n    *    blue-scale = white-scale - red-scale - green-scale\n    *\n    * Hence:\n    *\n    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =\n    *                (white-x - blue-x)*white-scale\n    *\n    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =\n    *                1 - blue-y*white-scale\n    *\n    * And now we can trivially solve for (red-scale,green-scale):\n    *\n    *    green-scale =\n    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale\n    *                -----------------------------------------------------------\n    *                                  green-x - blue-x\n    *\n    *    red-scale =\n    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale\n    *                ---------------------------------------------------------\n    *                                  red-y - blue-y\n    *\n    * Hence:\n    *\n    *    red-scale =\n    *          ( (green-x - blue-x) * (white-y - blue-y) -\n    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y\n    * -------------------------------------------------------------------------\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\n    *\n    *    green-scale =\n    *          ( (red-y - blue-y) * (white-x - blue-x) -\n    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y\n    * -------------------------------------------------------------------------\n    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)\n    *\n    * Accuracy:\n    * The input values have 5 decimal digits of accuracy.\n    *\n    * In the previous implementation the values were all in the range 0 < value\n    * < 1, so simple products are in the same range but may need up to 10\n    * decimal digits to preserve the original precision and avoid underflow.\n    * Because we are using a 32-bit signed representation we cannot match this;\n    * the best is a little over 9 decimal digits, less than 10.\n    *\n    * This range has now been extended to allow values up to 1.1, or 110,000 in\n    * fixed point.\n    *\n    * The approach used here is to preserve the maximum precision within the\n    * signed representation.  Because the red-scale calculation above uses the\n    * difference between two products of values that must be in the range\n    * -1.1..+1.1 it is sufficient to divide the product by 8;\n    * ceil(121,000/32767*2).  The factor is irrelevant in the calculation\n    * because it is applied to both numerator and denominator.\n    *\n    * Note that the values of the differences of the products of the\n    * chromaticities in the above equations tend to be small, for example for\n    * the sRGB chromaticities they are:\n    *\n    * red numerator:    -0.04751\n    * green numerator:  -0.08788\n    * denominator:      -0.2241 (without white-y multiplication)\n    *\n    *  The resultant Y coefficients from the chromaticities of some widely used\n    *  color space definitions are (to 15 decimal places):\n    *\n    *  sRGB\n    *    0.212639005871510 0.715168678767756 0.072192315360734\n    *  Kodak ProPhoto\n    *    0.288071128229293 0.711843217810102 0.000085653960605\n    *  Adobe RGB\n    *    0.297344975250536 0.627363566255466 0.075291458493998\n    *  Adobe Wide Gamut RGB\n    *    0.258728243040113 0.724682314948566 0.016589442011321\n    */\n   {\n      int error = 0;\n\n      /* By the argument above overflow should be impossible here, however the\n       * code now simply returns a failure code.  The xy subtracts in the\n       * arguments to png_muldiv are *not* checked for overflow because the\n       * checks at the start guarantee they are in the range 0..110000 and\n       * png_fixed_point is a 32-bit signed number.\n       */\n      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 8) ==\n            0)\n         return 1;\n      denominator = png_fp_sub(left, right, &error);\n      if (error) return 1;\n\n      /* Now find the red numerator. */\n      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 8) ==\n            0)\n         return 1;\n\n      /* Overflow is possible here and it indicates an extreme set of PNG cHRM\n       * chunk values.  This calculation actually returns the reciprocal of the\n       * scale value because this allows us to delay the multiplication of\n       * white-y into the denominator, which tends to produce a small number.\n       */\n      if (png_muldiv(&red_inverse, xy->whitey, denominator,\n                     png_fp_sub(left, right, &error)) == 0 || error ||\n          red_inverse <= xy->whitey /* r+g+b scales = white scale */)\n         return 1;\n\n      /* Similarly for green_inverse: */\n      if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 8) == 0)\n         return 1;\n      if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n         return 1;\n      if (png_muldiv(&green_inverse, xy->whitey, denominator,\n                     png_fp_sub(left, right, &error)) == 0 || error ||\n          green_inverse <= xy->whitey)\n         return 1;\n\n      /* And the blue scale, the checks above guarantee this can't overflow but\n       * it can still produce 0 for extreme cHRM values.\n       */\n      blue_scale = png_fp_sub(png_fp_sub(png_reciprocal(xy->whitey),\n                                         png_reciprocal(red_inverse), &error),\n                              png_reciprocal(green_inverse), &error);\n      if (error || blue_scale <= 0)\n         return 1;\n   }\n\n   /* And fill in the png_XYZ.  Again the subtracts are safe because of the\n    * checks on the xy values at the start (the subtracts just calculate the\n    * corresponding z values.)\n    */\n   if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,\n       red_inverse) == 0)\n      return 1;\n\n   if (png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->green_Z, PNG_FP_1 - xy->greenx - xy->greeny, PNG_FP_1,\n       green_inverse) == 0)\n      return 1;\n\n   if (png_muldiv(&XYZ->blue_X, xy->bluex, blue_scale, PNG_FP_1) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->blue_Y, xy->bluey, blue_scale, PNG_FP_1) == 0)\n      return 1;\n   if (png_muldiv(&XYZ->blue_Z, PNG_FP_1 - xy->bluex - xy->bluey, blue_scale,\n       PNG_FP_1) == 0)\n      return 1;\n\n   return 0; /*success*/\n}\n",
      "line_start": 1199,
      "line_end": 1493,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 255,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Consumes structured external input (PNG cHRM chromaticities) and performs many input-dependent numeric transformations/validations (fixed-point mul/div, reciprocals), with numerous branches and error paths. While it does not perform raw memory copies, the arithmetic is complex and prone to overflow/divide-by-zero/numeric instability, making it a high-value fuzz target."
    },
    {
      "name": "png_icc_check_tag_table",
      "clean_name": "png_icc_check_tag_table",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_tag_table(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length,\n   png_const_bytep profile /* header plus whole tag table */)\n{\n   png_uint_32 tag_count = png_get_uint_32(profile+128);\n   png_uint_32 itag;\n   png_const_bytep tag = profile+132; /* The first tag */\n\n   /* First scan all the tags in the table and add bits to the icc_info value\n    * (temporarily in 'tags').\n    */\n   for (itag=0; itag < tag_count; ++itag, tag += 12)\n   {\n      png_uint_32 tag_id = png_get_uint_32(tag+0);\n      png_uint_32 tag_start = png_get_uint_32(tag+4); /* must be aligned */\n      png_uint_32 tag_length = png_get_uint_32(tag+8);/* not padded */\n\n      /* The ICC specification does not exclude zero length tags, therefore the\n       * start might actually be anywhere if there is no data, but this would be\n       * a clear abuse of the intent of the standard so the start is checked for\n       * being in range.  All defined tag types have an 8 byte header - a 4 byte\n       * type signature then 0.\n       */\n\n      /* This is a hard error; potentially it can cause read outside the\n       * profile.\n       */\n      if (tag_start > profile_length || tag_length > profile_length - tag_start)\n         return png_icc_profile_error(png_ptr, name, tag_id,\n             \"ICC profile tag outside profile\");\n\n      if ((tag_start & 3) != 0)\n      {\n         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this; it is\n          * only a warning here because libpng does not care about the\n          * alignment.\n          */\n         (void)png_icc_profile_error(png_ptr, name, tag_id,\n             \"ICC profile tag start not a multiple of 4\");\n      }\n   }\n\n   return 1; /* success, maybe with warnings */\n}\n",
      "line_start": 1793,
      "line_end": 1837,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured external input (ICC profile tag table) and iterates based on an untrusted tag_count; performs input-dependent bounds checks and reads multi-byte fields from the profile. There is potential for out-of-bounds/overflow issues (insufficient checks for overall table size and header length), so it is a high-value fuzz target for discovering memory-read/validation bugs."
    },
    {
      "name": "png_ascii_from_fp",
      "clean_name": "png_ascii_from_fp",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n/* Function to format a floating point value in ASCII with a given\n * precision.\n */\nvoid /* PRIVATE */\npng_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, size_t size,\n    double fp, unsigned int precision)\n{\n   /* We use standard functions from math.h, but not printf because\n    * that would require stdio.  The caller must supply a buffer of\n    * sufficient size or we will png_error.  The tests on size and\n    * the space in ascii[] consumed are indicated below.\n    */\n   if (precision < 1)\n      precision = DBL_DIG;\n\n   /* Enforce the limit of the implementation precision too. */\n   if (precision > DBL_DIG+1)\n      precision = DBL_DIG+1;\n\n   /* Basic sanity checks */\n   if (size >= precision+5) /* See the requirements below. */\n   {\n      if (fp < 0)\n      {\n         fp = -fp;\n         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */\n         --size;\n      }\n\n      if (fp >= DBL_MIN && fp <= DBL_MAX)\n      {\n         int exp_b10;   /* A base 10 exponent */\n         double base;   /* 10^exp_b10 */\n\n         /* First extract a base 10 exponent of the number,\n          * the calculation below rounds down when converting\n          * from base 2 to base 10 (multiply by log10(2) -\n          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to\n          * be increased.  Note that the arithmetic shift\n          * performs a floor() unlike C arithmetic - using a\n          * C multiply would break the following for negative\n          * exponents.\n          */\n         (void)frexp(fp, &exp_b10); /* exponent to base 2 */\n\n         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */\n\n         /* Avoid underflow here. */\n         base = png_pow10(exp_b10); /* May underflow */\n\n         while (base < DBL_MIN || base < fp)\n         {\n            /* And this may overflow. */\n            double test = png_pow10(exp_b10+1);\n\n            if (test <= DBL_MAX)\n            {\n               ++exp_b10; base = test;\n            }\n\n            else\n               break;\n         }\n\n         /* Normalize fp and correct exp_b10, after this fp is in the\n          * range [.1,1) and exp_b10 is both the exponent and the digit\n          * *before* which the decimal point should be inserted\n          * (starting with 0 for the first digit).  Note that this\n          * works even if 10^exp_b10 is out of range because of the\n          * test on DBL_MAX above.\n          */\n         fp /= base;\n         while (fp >= 1)\n         {\n            fp /= 10; ++exp_b10;\n         }\n\n         /* Because of the code above fp may, at this point, be\n          * less than .1, this is ok because the code below can\n          * handle the leading zeros this generates, so no attempt\n          * is made to correct that here.\n          */\n\n         {\n            unsigned int czero, clead, cdigits;\n            char exponent[10];\n\n            /* Allow up to two leading zeros - this will not lengthen\n             * the number compared to using E-n.\n             */\n            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */\n            {\n               czero = 0U-exp_b10; /* PLUS 2 digits: TOTAL 3 */\n               exp_b10 = 0;      /* Dot added below before first output. */\n            }\n            else\n               czero = 0;    /* No zeros to add */\n\n            /* Generate the digit list, stripping trailing zeros and\n             * inserting a '.' before a digit if the exponent is 0.\n             */\n            clead = czero; /* Count of leading zeros */\n            cdigits = 0;   /* Count of digits in list. */\n\n            do\n            {\n               double d;\n\n               fp *= 10;\n               /* Use modf here, not floor and subtract, so that\n                * the separation is done in one step.  At the end\n                * of the loop don't break the number into parts so\n                * that the final digit is rounded.\n                */\n               if (cdigits+czero+1 < precision+clead)\n                  fp = modf(fp, &d);\n\n               else\n               {\n                  d = floor(fp + .5);\n\n                  if (d > 9)\n                  {\n                     /* Rounding up to 10, handle that here. */\n                     if (czero > 0)\n                     {\n                        --czero; d = 1;\n                        if (cdigits == 0) --clead;\n                     }\n                     else\n                     {\n                        while (cdigits > 0 && d > 9)\n                        {\n                           int ch = *--ascii;\n\n                           if (exp_b10 != (-1))\n                              ++exp_b10;\n\n                           else if (ch == 46)\n                           {\n                              ch = *--ascii; ++size;\n                              /* Advance exp_b10 to '1', so that the\n                               * decimal point happens after the\n                               * previous digit.\n                               */\n                              exp_b10 = 1;\n                           }\n\n                           --cdigits;\n                           d = ch - 47;  /* I.e. 1+(ch-48) */\n                        }\n\n                        /* Did we reach the beginning? If so adjust the\n                         * exponent but take into account the leading\n                         * decimal point.\n                         */\n                        if (d > 9)  /* cdigits == 0 */\n                        {\n                           if (exp_b10 == (-1))\n                           {\n                              /* Leading decimal point (plus zeros?), if\n                               * we lose the decimal point here it must\n                               * be reentered below.\n                               */\n                              int ch = *--ascii;\n\n                              if (ch == 46)\n                              {\n                                 ++size; exp_b10 = 1;\n                              }\n\n                              /* Else lost a leading zero, so 'exp_b10' is\n                               * still ok at (-1)\n                               */\n                           }\n                           else\n                              ++exp_b10;\n\n                           /* In all cases we output a '1' */\n                           d = 1;\n                        }\n                     }\n                  }\n                  fp = 0; /* Guarantees termination below. */\n               }\n\n               if (d == 0)\n               {\n                  ++czero;\n                  if (cdigits == 0) ++clead;\n               }\n               else\n               {\n                  /* Included embedded zeros in the digit count. */\n                  cdigits += czero - clead;\n                  clead = 0;\n\n                  while (czero > 0)\n                  {\n                     /* exp_b10 == (-1) means we just output the decimal\n                      * place - after the DP don't adjust 'exp_b10' any\n                      * more!\n                      */\n                     if (exp_b10 != (-1))\n                     {\n                        if (exp_b10 == 0)\n                        {\n                           *ascii++ = 46; --size;\n                        }\n                        /* PLUS 1: TOTAL 4 */\n                        --exp_b10;\n                     }\n                     *ascii++ = 48; --czero;\n                  }\n\n                  if (exp_b10 != (-1))\n                  {\n                     if (exp_b10 == 0)\n                     {\n                        *ascii++ = 46; --size; /* counted above */\n                     }\n\n                     --exp_b10;\n                  }\n                  *ascii++ = (char)(48 + (int)d); ++cdigits;\n               }\n            }\n            while (cdigits+czero < precision+clead && fp > DBL_MIN);\n\n            /* The total output count (max) is now 4+precision */\n\n            /* Check for an exponent, if we don't need one we are\n             * done and just need to terminate the string.  At this\n             * point, exp_b10==(-1) is effectively a flag: it got\n             * to '-1' because of the decrement, after outputting\n             * the decimal point above. (The exponent required is\n             * *not* -1.)\n             */\n            if (exp_b10 >= (-1) && exp_b10 <= 2)\n            {\n               /* The following only happens if we didn't output the\n                * leading zeros above for negative exponent, so this\n                * doesn't add to the digit requirement.  Note that the\n                * two zeros here can only be output if the two leading\n                * zeros were *not* output, so this doesn't increase\n                * the output count.\n                */\n               while (exp_b10-- > 0) *ascii++ = 48;\n\n               *ascii = 0;\n\n               /* Total buffer requirement (including the '\\0') is\n                * 5+precision - see check at the start.\n                */\n               return;\n            }\n\n            /* Here if an exponent is required, adjust size for\n             * the digits we output but did not count.  The total\n             * digit output here so far is at most 1+precision - no\n             * decimal point and no leading or trailing zeros have\n             * been output.\n             */\n            size -= cdigits;\n\n            *ascii++ = 69; --size;    /* 'E': PLUS 1 TOTAL 2+precision */\n\n            /* The following use of an unsigned temporary avoids ambiguities in\n             * the signed arithmetic on exp_b10 and permits GCC at least to do\n             * better optimization.\n             */\n            {\n               unsigned int uexp_b10;\n\n               if (exp_b10 < 0)\n               {\n                  *ascii++ = 45; --size; /* '-': PLUS 1 TOTAL 3+precision */\n                  uexp_b10 = 0U-exp_b10;\n               }\n\n               else\n                  uexp_b10 = 0U+exp_b10;\n\n               cdigits = 0;\n\n               while (uexp_b10 > 0)\n               {\n                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);\n                  uexp_b10 /= 10;\n               }\n            }\n\n            /* Need another size check here for the exponent digits, so\n             * this need not be considered above.\n             */\n            if (size > cdigits)\n            {\n               while (cdigits > 0) *ascii++ = exponent[--cdigits];\n\n               *ascii = 0;\n\n               return;\n            }\n         }\n      }\n      else if (!(fp >= DBL_MIN))\n      {\n         *ascii++ = 48; /* '0' */\n         *ascii = 0;\n         return;\n      }\n      else\n      {\n         *ascii++ = 105; /* 'i' */\n         *ascii++ = 110; /* 'n' */\n         *ascii++ = 102; /* 'f' */\n         *ascii = 0;\n         return;\n      }\n   }\n\n   /* Here on buffer too small. */\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\n}\n",
      "line_start": 2313,
      "line_end": 2633,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 210,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: complex, high\u2011branching float-to-ASCII formatting with many loops and rounding paths driven by external inputs (fp, precision, size). Performs direct buffer writes and arithmetic/type conversions (frexp, modf, pow10), so edge cases (NaN/Inf, extreme exponents, rounding) and buffer-size logic can expose bugs. Not a parser of external file formats, so not top critical, but still high priority."
    },
    {
      "name": "png_read_image",
      "clean_name": "png_read_image",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * each pass of a interlaced image, use png_read_rows() instead.\n *\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\n */\nvoid PNGAPI\npng_read_image(png_structrp png_ptr, png_bytepp image)\n{\n   png_uint_32 i, image_height;\n   int pass, j;\n   png_bytepp rp;\n\n   png_debug(1, \"in png_read_image\");\n\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_READ_INTERLACING_SUPPORTED\n   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n   {\n      pass = png_set_interlace_handling(png_ptr);\n      /* And make sure transforms are initialized. */\n      png_start_read_image(png_ptr);\n   }\n   else\n   {\n      if (png_ptr->interlaced != 0 &&\n          (png_ptr->transformations & PNG_INTERLACE) == 0)\n      {\n         /* Caller called png_start_read_image or png_read_update_info without\n          * first turning on the PNG_INTERLACE transform.  We can fix this here,\n          * but the caller should do it!\n          */\n         png_warning(png_ptr, \"Interlace handling should be turned on when \"\n             \"using png_read_image\");\n         /* Make sure this is set correctly */\n         png_ptr->num_rows = png_ptr->height;\n      }\n\n      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in\n       * the above error case.\n       */\n      pass = png_set_interlace_handling(png_ptr);\n   }\n#else\n   if (png_ptr->interlaced)\n      png_error(png_ptr,\n          \"Cannot read interlaced image -- interlace handler disabled\");\n\n   pass = 1;\n#endif\n\n   image_height=png_ptr->height;\n\n   for (j = 0; j < pass; j++)\n   {\n      rp = image;\n      for (i = 0; i < image_height; i++)\n      {\n         png_read_row(png_ptr, *rp, NULL);\n         rp++;\n      }\n   }\n}\n",
      "line_start": 606,
      "line_end": 664,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it drives parsing of complex external input (PNG image data) via png_read_row, uses input-dependent loop bounds (image_height and interlace passes), and exercises multiple code paths (interlaced vs non-interlaced). While the function itself is small and delegates the heavy lifting, calling it exercises memory operations and buffer handling in the PNG read pipeline, making it a strong high-priority target."
    },
    {
      "name": "pngread.c:png_image_read_colormapped",
      "clean_name": "png_image_read_colormapped",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return 1;\n}\n\nstatic int\npng_image_read_colormapped(png_voidp argument)\n{\n   png_image_read_control *display = png_voidcast(png_image_read_control*,\n       argument);\n   png_imagep image = display->image;\n   png_controlp control = image->opaque;\n   png_structrp png_ptr = control->png_ptr;\n   png_inforp info_ptr = control->info_ptr;\n\n   int passes = 0; /* As a flag */\n\n   PNG_SKIP_CHUNKS(png_ptr);\n\n   /* Update the 'info' structure and make sure the result is as required; first\n    * make sure to turn on the interlace handling if it will be required\n    * (because it can't be turned on *after* the call to png_read_update_info!)\n    */\n   if (display->colormap_processing == PNG_CMAP_NONE)\n      passes = png_set_interlace_handling(png_ptr);\n\n   png_read_update_info(png_ptr, info_ptr);\n\n   /* The expected output can be deduced from the colormap_processing option. */\n   switch (display->colormap_processing)\n   {\n      case PNG_CMAP_NONE:\n         /* Output must be one channel and one byte per pixel, the output\n          * encoding can be anything.\n          */\n         if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||\n            info_ptr->color_type == PNG_COLOR_TYPE_GRAY) &&\n            info_ptr->bit_depth == 8)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_TRANS:\n      case PNG_CMAP_GA:\n         /* Output must be two channels and the 'G' one must be sRGB, the latter\n          * can be checked with an exact number because it should have been set\n          * to this number above!\n          */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 256)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_RGB:\n         /* Output must be 8-bit sRGB encoded RGB */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 216)\n            break;\n\n         goto bad_output;\n\n      case PNG_CMAP_RGB_ALPHA:\n         /* Output must be 8-bit sRGB encoded RGBA */\n         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n            info_ptr->bit_depth == 8 &&\n            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&\n            image->colormap_entries == 244 /* 216 + 1 + 27 */)\n            break;\n\n         goto bad_output;\n\n      default:\n      bad_output:\n         png_error(png_ptr, \"bad color-map processing (internal error)\");\n   }\n\n   /* Now read the rows.  Do this here if it is possible to read directly into\n    * the output buffer, otherwise allocate a local row buffer of the maximum\n    * size libpng requires and call the relevant processing routine safely.\n    */\n   {\n      png_voidp first_row = display->buffer;\n      ptrdiff_t row_bytes = display->row_stride;\n\n      /* The following expression is designed to work correctly whether it gives\n       * a signed or an unsigned result.\n       */\n      if (row_bytes < 0)\n      {\n         char *ptr = png_voidcast(char*, first_row);\n         ptr += (image->height-1) * (-row_bytes);\n         first_row = png_voidcast(png_voidp, ptr);\n      }\n\n      display->first_row = first_row;\n      display->row_bytes = row_bytes;\n   }\n\n   if (passes == 0)\n   {\n      int result;\n      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n\n      display->local_row = row;\n      result = png_safe_execute(image, png_image_read_and_map, display);\n      display->local_row = NULL;\n      png_free(png_ptr, row);\n\n      return result;\n   }\n\n   else\n   {\n      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;\n\n      while (--passes >= 0)\n      {\n         png_uint_32      y = image->height;\n         png_bytep        row = png_voidcast(png_bytep, display->first_row);\n\n         for (; y > 0; --y)\n         {\n            png_read_row(png_ptr, row, NULL);\n            row += row_bytes;\n         }\n      }\n\n      return 1;\n   }\n}\n",
      "line_start": 3001,
      "line_end": 3130,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 189,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Orchestrates reading/mapping of PNG colormapped images: validates color/bit-depth/gamma, performs pointer arithmetic and allocations, loops over image->height with input-dependent row_bytes and calls png_read_row/png_image_read_and_map. It processes complex structured external input and performs memory operations on untrusted data, making it a high-priority fuzz target."
    },
    {
      "name": "pngrtran.c:png_do_encode_alpha",
      "clean_name": "png_do_encode_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Encode the alpha channel to the output gamma (the input channel is always\n * linear.)  Called only with color types that have an alpha channel.  Needs the\n * from_1 tables.\n */\nstatic void\npng_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structrp png_ptr)\n{\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_encode_alpha\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep table = png_ptr->gamma_from_1;\n\n         if (table != NULL)\n         {\n            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;\n\n            /* The alpha channel is the last component: */\n            row += step - 1;\n\n            for (; row_width > 0; --row_width, row += step)\n               *row = table[*row];\n\n            return;\n         }\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         png_uint_16pp table = png_ptr->gamma_16_from_1;\n         int gamma_shift = png_ptr->gamma_shift;\n\n         if (table != NULL)\n         {\n            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;\n\n            /* The alpha channel is the last component: */\n            row += step - 2;\n\n            for (; row_width > 0; --row_width, row += step)\n            {\n               png_uint_16 v;\n\n               v = table[*(row + 1) >> gamma_shift][*row];\n               *row = (png_byte)((v >> 8) & 0xff);\n               *(row + 1) = (png_byte)(v & 0xff);\n            }\n\n            return;\n         }\n      }\n   }\n\n   /* Only get to here if called with a weird row_info; no harm has been done,\n    * so just issue a warning.\n    */\n   png_warning(png_ptr, \"png_do_encode_alpha: unexpected call\");\n}\n",
      "line_start": 4263,
      "line_end": 4320,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes structured external image data (PNG rows), performs memory reads/writes and pointer arithmetic on untrusted buffers, uses table lookups and has multiple code paths (8- and 16-bit, color/gray). Loops are driven by external row_width and there are non-trivial transformations (gamma tables, shifts). Not full file parsing but still high risk for buffer/indexing bugs, so high priority for fuzzing."
    },
    {
      "name": "pngrtran.c:png_do_chop",
      "clean_name": "png_do_chop",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\nstatic void\n/* Simply discard the low byte.  This was the default behavior prior\n * to libpng-1.5.4.\n */\npng_do_chop(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_chop\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep sp = row; /* source */\n      png_bytep dp = row; /* destination */\n      png_bytep ep = sp + row_info->rowbytes; /* end+1 */\n\n      while (sp < ep)\n      {\n         *dp++ = *sp;\n         sp += 2; /* skip low byte */\n      }\n\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_info->width * row_info->channels;\n   }\n}\n",
      "line_start": 2568,
      "line_end": 2589,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Processes structured external input (PNG row) and performs in-place memory manipulation (pointer arithmetic, copying/skipping bytes) with a loop whose bounds depend on row_info->rowbytes. Moderate complexity with multiple code paths (runs only for 16-bit rows) and a realistic source of memory-corruption bugs if row_info is inconsistent with the buffer \u2014 a good high-priority fuzz target."
    },
    {
      "name": "pngrtran.c:png_do_quantize",
      "clean_name": "png_do_quantize",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_QUANTIZE_SUPPORTED\nstatic void\npng_do_quantize(png_row_infop row_info, png_bytep row,\n    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)\n{\n   png_bytep sp, dp;\n   png_uint_32 i;\n   png_uint_32 row_width=row_info->width;\n\n   png_debug(1, \"in png_do_quantize\");\n\n   if (row_info->bit_depth == 8)\n   {\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n\n            /* This looks real messy, but the compiler will reduce\n             * it down to a reasonable formula.  For example, with\n             * 5 bits per color, we get:\n             * p = (((r >> 3) & 0x1f) << 10) |\n             *    (((g >> 3) & 0x1f) << 5) |\n             *    ((b >> 3) & 0x1f);\n             */\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n                (PNG_QUANTIZE_BLUE_BITS)) |\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n\n      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&\n         palette_lookup != NULL)\n      {\n         int r, g, b, p;\n         sp = row;\n         dp = row;\n         for (i = 0; i < row_width; i++)\n         {\n            r = *sp++;\n            g = *sp++;\n            b = *sp++;\n            sp++;\n\n            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &\n                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<\n                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |\n                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &\n                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<\n                (PNG_QUANTIZE_BLUE_BITS)) |\n                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &\n                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));\n\n            *dp++ = palette_lookup[p];\n         }\n\n         row_info->color_type = PNG_COLOR_TYPE_PALETTE;\n         row_info->channels = 1;\n         row_info->pixel_depth = row_info->bit_depth;\n         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);\n      }\n\n      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&\n         quantize_lookup)\n      {\n         sp = row;\n\n         for (i = 0; i < row_width; i++, sp++)\n         {\n            *sp = quantize_lookup[*sp];\n         }\n      }\n   }\n}\n",
      "line_start": 4761,
      "line_end": 4851,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 129,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Processes untrusted pixel data with in-place memory reads/writes and lookup indexing; contains multiple branches (color types) and input-dependent loops. Moderate-to-high complexity and clear potential for memory/indexing issues, making it a strong/high-priority fuzz target though it is not a full-format parser or crypto path."
    },
    {
      "name": "pngrtran.c:png_do_expand_16",
      "clean_name": "png_do_expand_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_EXPAND_16_SUPPORTED\n/* If the bit depth is 8 and the color type is not a palette type expand the\n * whole row to 16 bits.  Has no effect otherwise.\n */\nstatic void\npng_do_expand_16(png_row_infop row_info, png_bytep row)\n{\n   if (row_info->bit_depth == 8 &&\n      row_info->color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      /* The row have a sequence of bytes containing [0..255] and we need\n       * to turn it into another row containing [0..65535], to do this we\n       * calculate:\n       *\n       *  (input / 255) * 65535\n       *\n       *  Which happens to be exactly input * 257 and this can be achieved\n       *  simply by byte replication in place (copying backwards).\n       */\n      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */\n      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */\n      while (dp > sp)\n      {\n         dp[-2] = dp[-1] = *--sp; dp -= 2;\n      }\n\n      row_info->rowbytes *= 2;\n      row_info->bit_depth = 16;\n      row_info->pixel_depth = (png_byte)(row_info->channels * 16);\n   }\n}\n",
      "line_start": 4731,
      "line_end": 4757,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Transforms untrusted PNG row data in-place using pointer/byte-copying with loop bounds derived from row_info->rowbytes. It performs memory operations on external input and has input-dependent loop bounds, making it a good high-priority fuzz target (though the function itself is simple and low-branching)."
    },
    {
      "name": "pngrtran.c:png_do_read_invert_alpha",
      "clean_name": "png_do_read_invert_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED\nstatic void\npng_do_read_invert_alpha(png_row_infop row_info, png_bytep row)\n{\n   png_uint_32 row_width;\n   png_debug(1, \"in png_do_read_invert_alpha\");\n\n   row_width = row_info->width;\n   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         /* This inverts the alpha channel in RGBA */\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n\n/*          This does nothing:\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            We can replace it with:\n*/\n            sp-=3;\n            dp=sp;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This inverts the alpha channel in RRGGBBAA */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = (png_byte)(255 - *(--sp));\n\n/*          This does nothing:\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            We can replace it with:\n*/\n            sp-=6;\n            dp=sp;\n         }\n      }\n#endif\n   }\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         /* This inverts the alpha channel in GA */\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = *(--sp);\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      else\n      {\n         /* This inverts the alpha channel in GGAA */\n         png_bytep sp  = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            *(--dp) = (png_byte)(255 - *(--sp));\n            *(--dp) = (png_byte)(255 - *(--sp));\n/*\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n*/\n            sp-=2;\n            dp=sp;\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 2689,
      "line_end": 2786,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Processes structured external input (PNG image rows) with multiple branches by color type/bit depth, contains loops whose bounds come from row_info->width, and does low-level memory operations and pointer arithmetic on untrusted buffers \u2014 a good high\u2011priority fuzz target though not handling crypto/authentication."
    },
    {
      "name": "pngrtran.c:png_do_unshift",
      "clean_name": "png_do_unshift",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * pixels back to their significant bits values.  Thus, if you have\n * a row of bit depth 8, but only 5 are significant, this will shift\n * the values back to 0 through 31.\n */\nstatic void\npng_do_unshift(png_row_infop row_info, png_bytep row,\n    png_const_color_8p sig_bits)\n{\n   int color_type;\n\n   png_debug(1, \"in png_do_unshift\");\n\n   /* The palette case has already been handled in the _init routine. */\n   color_type = row_info->color_type;\n\n   if (color_type != PNG_COLOR_TYPE_PALETTE)\n   {\n      int shift[4];\n      int channels = 0;\n      int bit_depth = row_info->bit_depth;\n\n      if ((color_type & PNG_COLOR_MASK_COLOR) != 0)\n      {\n         shift[channels++] = bit_depth - sig_bits->red;\n         shift[channels++] = bit_depth - sig_bits->green;\n         shift[channels++] = bit_depth - sig_bits->blue;\n      }\n\n      else\n      {\n         shift[channels++] = bit_depth - sig_bits->gray;\n      }\n\n      if ((color_type & PNG_COLOR_MASK_ALPHA) != 0)\n      {\n         shift[channels++] = bit_depth - sig_bits->alpha;\n      }\n\n      {\n         int c, have_shift;\n\n         for (c = have_shift = 0; c < channels; ++c)\n         {\n            /* A shift of more than the bit depth is an error condition but it\n             * gets ignored here.\n             */\n            if (shift[c] <= 0 || shift[c] >= bit_depth)\n               shift[c] = 0;\n\n            else\n               have_shift = 1;\n         }\n\n         if (have_shift == 0)\n            return;\n      }\n\n      switch (bit_depth)\n      {\n         default:\n         /* Must be 1bpp gray: should not be here! */\n            /* NOTREACHED */\n            break;\n\n         case 2:\n         /* Must be 2bpp gray */\n         /* assert(channels == 1 && shift[0] == 1) */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n\n            while (bp < bp_end)\n            {\n               int b = (*bp >> 1) & 0x55;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n         case 4:\n         /* Must be 4bpp gray */\n         /* assert(channels == 1) */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int gray_shift = shift[0];\n            int mask =  0xf >> gray_shift;\n\n            mask |= mask << 4;\n\n            while (bp < bp_end)\n            {\n               int b = (*bp >> gray_shift) & mask;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n         case 8:\n         /* Single byte components, G, GA, RGB, RGBA */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int channel = 0;\n\n            while (bp < bp_end)\n            {\n               int b = *bp >> shift[channel];\n               if (++channel >= channels)\n                  channel = 0;\n               *bp++ = (png_byte)b;\n            }\n            break;\n         }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n         case 16:\n         /* Double byte components, G, GA, RGB, RGBA */\n         {\n            png_bytep bp = row;\n            png_bytep bp_end = bp + row_info->rowbytes;\n            int channel = 0;\n\n            while (bp < bp_end)\n            {\n               int value = (bp[0] << 8) + bp[1];\n\n               value >>= shift[channel];\n               if (++channel >= channels)\n                  channel = 0;\n               *bp++ = (png_byte)(value >> 8);\n               *bp++ = (png_byte)value;\n            }\n            break;\n         }\n#endif\n      }\n   }\n}\n",
      "line_start": 2368,
      "line_end": 2502,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 96,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value target: it processes untrusted PNG row bytes in-place and performs many memory operations and bit-level transformations across multiple bit depths and color/channel branches. Loops use external rowbytes and channels derived from color_type/sig_bits, giving multiple code paths and potential for buffer/logic issues \u2014 suitable for high-priority fuzzing."
    },
    {
      "name": "pngrtran.c:png_do_read_swap_alpha",
      "clean_name": "png_do_read_swap_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED\nstatic void\npng_do_read_swap_alpha(png_row_infop row_info, png_bytep row)\n{\n   png_uint_32 row_width = row_info->width;\n\n   png_debug(1, \"in png_do_read_swap_alpha\");\n\n   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n   {\n      /* This converts from RGBA to ARGB */\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This converts from RRGGBBAA to AARRGGBB */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save[2];\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save[0] = *(--sp);\n            save[1] = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save[0];\n            *(--dp) = save[1];\n         }\n      }\n#endif\n   }\n\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n   {\n      /* This converts from GA to AG */\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save;\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save;\n         }\n      }\n\n#ifdef PNG_READ_16BIT_SUPPORTED\n      /* This converts from GGAA to AAGG */\n      else\n      {\n         png_bytep sp = row + row_info->rowbytes;\n         png_bytep dp = sp;\n         png_byte save[2];\n         png_uint_32 i;\n\n         for (i = 0; i < row_width; i++)\n         {\n            save[0] = *(--sp);\n            save[1] = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = *(--sp);\n            *(--dp) = save[0];\n            *(--dp) = save[1];\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 2593,
      "line_end": 2685,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: this function processes structured PNG row data and performs in-place memory operations (byte-level pointer arithmetic, memcpy-like swaps) on externally supplied buffers. Control-flow depends on untrusted fields (color_type, bit_depth, rowbytes, width) and contains loops with input-dependent bounds and multiple branches (RGBA vs GA, 8 vs 16 bit). These characteristics make it likely to reveal buffer/underflow, pointer arithmetic, and logic bugs, so it is high priority for fuzzing."
    },
    {
      "name": "pngrutil.c:png_cache_unknown_chunk",
      "clean_name": "png_cache_unknown_chunk",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED\n/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */\nstatic int\npng_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)\n{\n   const png_alloc_size_t limit = png_chunk_max(png_ptr);\n\n   if (png_ptr->unknown_chunk.data != NULL)\n   {\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n   if (length <= limit)\n   {\n      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);\n      /* The following is safe because of the PNG_SIZE_MAX init above */\n      png_ptr->unknown_chunk.size = (size_t)length/*SAFE*/;\n      /* 'mode' is a flag array, only the bottom four bits matter here */\n      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;\n\n      if (length == 0)\n         png_ptr->unknown_chunk.data = NULL;\n\n      else\n      {\n         /* Do a 'warn' here - it is handled below. */\n         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,\n             png_malloc_warn(png_ptr, length));\n      }\n   }\n\n   if (png_ptr->unknown_chunk.data == NULL && length > 0)\n   {\n      /* This is benign because we clean up correctly */\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"unknown chunk exceeds memory limits\");\n      return 0;\n   }\n\n   else\n   {\n      if (length > 0)\n         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);\n      png_crc_finish(png_ptr, 0);\n      return 1;\n   }\n}\n",
      "line_start": 2723,
      "line_end": 2768,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Handles structured external input (PNG unknown chunk), allocates/frees memory based on an untrusted length, and reads chunk data/CRC with multiple error-handling branches. These characteristics make it a high-value fuzz target (memory ops and parsing logic) though it is not crypto/auth related or extremely complex."
    },
    {
      "name": "png_set_hIST",
      "clean_name": "png_set_hIST",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\nvoid PNGAPI\npng_set_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_uint_16p hist)\n{\n   int i;\n\n   png_debug1(1, \"in %s storage function\", \"hIST\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (info_ptr->num_palette == 0 || info_ptr->num_palette\n       > PNG_MAX_PALETTE_LENGTH)\n   {\n      png_warning(png_ptr,\n          \"Invalid palette size, hIST allocation skipped\");\n\n      return;\n   }\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);\n\n   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in\n    * version 1.2.1\n    */\n   info_ptr->hist = png_voidcast(png_uint_16p, png_malloc_warn(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_uint_16))));\n\n   if (info_ptr->hist == NULL)\n   {\n      png_warning(png_ptr, \"Insufficient memory for hIST chunk data\");\n      return;\n   }\n\n   for (i = 0; i < info_ptr->num_palette; i++)\n      info_ptr->hist[i] = hist[i];\n\n   info_ptr->free_me |= PNG_FREE_HIST;\n   info_ptr->valid |= PNG_INFO_hIST;\n}\n",
      "line_start": 383,
      "line_end": 422,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Handles structured PNG chunk data and performs memory operations on untrusted input: allocates and then copies hist[i] for info_ptr->num_palette (an external/input-dependent bound). This makes it a good fuzz target for OOB reads/crashes (simple control flow but input-dependent loop and unvalidated source buffer)."
    },
    {
      "name": "png_set_sPLT",
      "clean_name": "png_set_sPLT",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\nvoid PNGAPI\npng_set_sPLT(png_const_structrp png_ptr,\n    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)\n/*\n *  entries        - array of png_sPLT_t structures\n *                   to be added to the list of palettes\n *                   in the info structure.\n *\n *  nentries       - number of palette structures to be\n *                   added.\n */\n{\n   png_sPLT_tp np;\n\n   png_debug1(1, \"in %s storage function\", \"sPLT\");\n\n   if (png_ptr == NULL || info_ptr == NULL || nentries <= 0 || entries == NULL)\n      return;\n\n   /* Use the internal realloc function, which checks for all the possible\n    * overflows.  Notice that the parameters are (int) and (size_t)\n    */\n   np = png_voidcast(png_sPLT_tp,png_realloc_array(png_ptr,\n       info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries,\n       sizeof *np));\n\n   if (np == NULL)\n   {\n      /* Out of memory or too many chunks */\n      png_chunk_report(png_ptr, \"too many sPLT chunks\", PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   png_free(png_ptr, info_ptr->splt_palettes);\n\n   info_ptr->splt_palettes = np;\n   info_ptr->free_me |= PNG_FREE_SPLT;\n\n   np += info_ptr->splt_palettes_num;\n\n   do\n   {\n      size_t length;\n\n      /* Skip invalid input entries */\n      if (entries->name == NULL || entries->entries == NULL)\n      {\n         /* png_handle_sPLT doesn't do this, so this is an app error */\n         png_app_error(png_ptr, \"png_set_sPLT: invalid sPLT\");\n         /* Just skip the invalid entry */\n         continue;\n      }\n\n      np->depth = entries->depth;\n\n      /* In the event of out-of-memory just return - there's no point keeping\n       * on trying to add sPLT chunks.\n       */\n      length = strlen(entries->name) + 1;\n      np->name = png_voidcast(png_charp, png_malloc_base(png_ptr, length));\n\n      if (np->name == NULL)\n         break;\n\n      memcpy(np->name, entries->name, length);\n\n      /* IMPORTANT: we have memory now that won't get freed if something else\n       * goes wrong; this code must free it.  png_malloc_array produces no\n       * warnings; use a png_chunk_report (below) if there is an error.\n       */\n      np->entries = png_voidcast(png_sPLT_entryp, png_malloc_array(png_ptr,\n          entries->nentries, sizeof (png_sPLT_entry)));\n\n      if (np->entries == NULL)\n      {\n         png_free(png_ptr, np->name);\n         np->name = NULL;\n         break;\n      }\n\n      np->nentries = entries->nentries;\n      /* This multiply can't overflow because png_malloc_array has already\n       * checked it when doing the allocation.\n       */\n      memcpy(np->entries, entries->entries,\n          (unsigned int)entries->nentries * sizeof (png_sPLT_entry));\n\n      /* Note that 'continue' skips the advance of the out pointer and out\n       * count, so an invalid entry is not added.\n       */\n      info_ptr->valid |= PNG_INFO_sPLT;\n      ++(info_ptr->splt_palettes_num);\n      ++np;\n      ++entries;\n   }\n   while (--nentries);\n\n   if (nentries > 0)\n      png_chunk_report(png_ptr, \"sPLT out of memory\", PNG_CHUNK_WRITE_ERROR);\n}\n",
      "line_start": 1216,
      "line_end": 1315,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 103,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes structured external data (sPLT palette entries), contains input-dependent loops and branching, and does multiple memory operations (strlen, malloc/realloc, memcpy) on untrusted data. Allocations check for overflow, but memcpy/lengths and out-of-memory branches make it a good target for fuzzing (memory/copy/logic bugs)."
    },
    {
      "name": "png_set_unknown_chunks",
      "clean_name": "png_set_unknown_chunks",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "    */\n   return (png_byte)location;\n}\n\nvoid PNGAPI\npng_set_unknown_chunks(png_const_structrp png_ptr,\n    png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)\n{\n   png_unknown_chunkp np;\n\n   if (png_ptr == NULL || info_ptr == NULL || num_unknowns <= 0 ||\n       unknowns == NULL)\n      return;\n\n   /* Check for the failure cases where support has been disabled at compile\n    * time.  This code is hardly ever compiled - it's here because\n    * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this\n    * code) but may be meaningless if the read or write handling of unknown\n    * chunks is not compiled in.\n    */\n#  if !defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) && \\\n      defined(PNG_READ_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n      {\n         png_app_error(png_ptr, \"no unknown chunk support on read\");\n\n         return;\n      }\n#  endif\n#  if !defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED) && \\\n      defined(PNG_WRITE_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n      {\n         png_app_error(png_ptr, \"no unknown chunk support on write\");\n\n         return;\n      }\n#  endif\n\n   /* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that\n    * unknown critical chunks could be lost with just a warning resulting in\n    * undefined behavior.  Now png_chunk_report is used to provide behavior\n    * appropriate to read or write.\n    */\n   np = png_voidcast(png_unknown_chunkp, png_realloc_array(png_ptr,\n       info_ptr->unknown_chunks, info_ptr->unknown_chunks_num, num_unknowns,\n       sizeof *np));\n\n   if (np == NULL)\n   {\n      png_chunk_report(png_ptr, \"too many unknown chunks\",\n          PNG_CHUNK_WRITE_ERROR);\n      return;\n   }\n\n   png_free(png_ptr, info_ptr->unknown_chunks);\n\n   info_ptr->unknown_chunks = np; /* safe because it is initialized */\n   info_ptr->free_me |= PNG_FREE_UNKN;\n\n   np += info_ptr->unknown_chunks_num;\n\n   /* Increment unknown_chunks_num each time round the loop to protect the\n    * just-allocated chunk data.\n    */\n   for (; num_unknowns > 0; --num_unknowns, ++unknowns)\n   {\n      memcpy(np->name, unknowns->name, (sizeof np->name));\n      np->name[(sizeof np->name)-1] = '\\0';\n      np->location = check_location(png_ptr, unknowns->location);\n\n      if (unknowns->size == 0)\n      {\n         np->data = NULL;\n         np->size = 0;\n      }\n\n      else\n      {\n         np->data = png_voidcast(png_bytep,\n             png_malloc_base(png_ptr, unknowns->size));\n\n         if (np->data == NULL)\n         {\n            png_chunk_report(png_ptr, \"unknown chunk: out of memory\",\n                PNG_CHUNK_WRITE_ERROR);\n            /* But just skip storing the unknown chunk */\n            continue;\n         }\n\n         memcpy(np->data, unknowns->data, unknowns->size);\n         np->size = unknowns->size;\n      }\n\n      /* These increments are skipped on out-of-memory for the data - the\n       * unknown chunk entry gets overwritten if the png_chunk_report returns.\n       * This is correct in the read case (the chunk is just dropped.)\n       */\n      ++np;\n      ++(info_ptr->unknown_chunks_num);\n   }\n}\n",
      "line_start": 1356,
      "line_end": 1453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Processes structured external data (unknown PNG chunks), performs memory allocations and memcpy on caller-controlled data, and has input-dependent looping/branching. These characteristics make it a high-priority fuzz target (multiple code paths and unsafe memory operations), though it is not a full file parser by itself so not placed in the topmost (critical) tier."
    },
    {
      "name": "png_do_strip_channel",
      "clean_name": "png_do_strip_channel",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": " *\n * The routine isn't general - the channel must be the channel at the start or\n * end (not in the middle) of each pixel.\n */\nvoid /* PRIVATE */\npng_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)\n{\n   png_bytep sp = row; /* source pointer */\n   png_bytep dp = row; /* destination pointer */\n   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */\n\n   png_debug(1, \"in png_do_strip_channel\");\n\n   /* At the start sp will point to the first byte to copy and dp to where\n    * it is copied to.  ep always points just beyond the end of the row, so\n    * the loop simply copies (channels-1) channels until sp reaches ep.\n    *\n    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.\n    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.\n    */\n\n   /* GA, GX, XG cases */\n   if (row_info->channels == 2)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channel and, for sp, the filler */\n         {\n            sp += 2; ++dp;\n         }\n\n         /* For a 1 pixel wide image there is nothing to do */\n         while (sp < ep)\n         {\n            *dp++ = *sp; sp += 2;\n         }\n\n         row_info->pixel_depth = 8;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channel and, for sp, the filler */\n         {\n            sp += 4; dp += 2;\n         }\n\n         while (sp < ep)\n         {\n            *dp++ = *sp++; *dp++ = *sp; sp += 3;\n         }\n\n         row_info->pixel_depth = 16;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 1;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_GRAY;\n   }\n\n   /* RGBA, RGBX, XRGB cases */\n   else if (row_info->channels == 4)\n   {\n      if (row_info->bit_depth == 8)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            ++sp;\n         else          /* Skip initial channels and, for sp, the filler */\n         {\n            sp += 4; dp += 3;\n         }\n\n         /* Note that the loop adds 3 to dp and 4 to sp each time. */\n         while (sp < ep)\n         {\n            *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp; sp += 2;\n         }\n\n         row_info->pixel_depth = 24;\n      }\n\n      else if (row_info->bit_depth == 16)\n      {\n         if (at_start != 0) /* Skip initial filler */\n            sp += 2;\n         else          /* Skip initial channels and, for sp, the filler */\n         {\n            sp += 8; dp += 6;\n         }\n\n         while (sp < ep)\n         {\n            /* Copy 6 bytes, skip 2 */\n            *dp++ = *sp++; *dp++ = *sp++;\n            *dp++ = *sp++; *dp++ = *sp++;\n            *dp++ = *sp++; *dp++ = *sp; sp += 3;\n         }\n\n         row_info->pixel_depth = 48;\n      }\n\n      else\n         return; /* bad bit depth */\n\n      row_info->channels = 3;\n\n      /* Finally fix the color type if it records an alpha channel */\n      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         row_info->color_type = PNG_COLOR_TYPE_RGB;\n   }\n\n   else\n      return; /* The filler channel has gone already */\n\n   /* Fix the rowbytes value. */\n   row_info->rowbytes = (size_t)(dp-row);\n}\n",
      "line_start": 493,
      "line_end": 614,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 115,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Good fuzz target: part of PNG row processing that does raw pointer/byte-level copies and pointer arithmetic based on row_info (channels, bit_depth, rowbytes, at_start). Multiple branches (channels/bit_depth/at_start), loops with input-dependent bounds and manual memory writes make it prone to out\u2011of\u2011bounds or logic errors when row_info is inconsistent with buffer contents. Not a top-tier critical (doesn't itself parse the file format or handle crypto/auth), but high priority due to unsafe memory ops on untrusted data and multiple code paths."
    },
    {
      "name": "pngrtran.c:png_do_unpack",
      "clean_name": "png_do_unpack",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " * a bit depth of 1, you would end up with bytes that only contained\n * the numbers 0 or 1.  If you would rather they contain 0 and 255, use\n * png_do_shift() after this.\n */\nstatic void\npng_do_unpack(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_unpack\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_uint_32 i;\n      png_uint_32 row_width=row_info->width;\n\n      switch (row_info->bit_depth)\n      {\n         case 1:\n         {\n            png_bytep sp = row + (size_t)((row_width - 1) >> 3);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = 7U - ((row_width + 7U) & 0x07);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x01);\n\n               if (shift == 7)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift++;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 2:\n         {\n\n            png_bytep sp = row + (size_t)((row_width - 1) >> 2);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = ((3U - ((row_width + 3U) & 0x03)) << 1);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x03);\n\n               if (shift == 6)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift += 2;\n\n               dp--;\n            }\n            break;\n         }\n\n         case 4:\n         {\n            png_bytep sp = row + (size_t)((row_width - 1) >> 1);\n            png_bytep dp = row + (size_t)row_width - 1;\n            png_uint_32 shift = ((1U - ((row_width + 1U) & 0x01)) << 2);\n            for (i = 0; i < row_width; i++)\n            {\n               *dp = (png_byte)((*sp >> shift) & 0x0f);\n\n               if (shift == 4)\n               {\n                  shift = 0;\n                  sp--;\n               }\n\n               else\n                  shift = 4;\n\n               dp--;\n            }\n            break;\n         }\n\n         default:\n            break;\n      }\n      row_info->bit_depth = 8;\n      row_info->pixel_depth = (png_byte)(8 * row_info->channels);\n      row_info->rowbytes = row_width * row_info->channels;\n   }\n}\n",
      "line_start": 2270,
      "line_end": 2359,
      "execution_count": 1103,
      "covered_regions": 4,
      "total_regions": 58,
      "coverage_percent": 6.9,
      "is_covered": true,
      "is_static": true,
      "score": 8.0,
      "reason": "Unpacks PNG packed-pixel data (file-format parsing) and performs in-place memory/byte operations with pointer arithmetic and loops controlled by row_info->width. Multiple code paths for different bit depths and external-input-dependent bounds make it a high-value fuzz target (potential OOBs/logic bugs), though cyclomatic complexity is moderate so not scored as critical."
    },
    {
      "name": "png_xy_from_XYZ",
      "clean_name": "png_xy_from_XYZ",
      "source_file": "/src/libpng/png.c",
      "source_code": " * cHRM, as opposed to using chromaticities.  These internal APIs return\n * non-zero on a parameter error.  The X, Y and Z values are required to be\n * positive and less than 1.0.\n */\nint /* PRIVATE */\npng_xy_from_XYZ(png_xy *xy, const png_XYZ *XYZ)\n{\n   /* NOTE: returns 0 on success, 1 means error. */\n   png_int_32 d, dred, dgreen, dblue, dwhite, whiteX, whiteY;\n\n   /* 'd' in each of the blocks below is just X+Y+Z for each component,\n    * x, y and z are X,Y,Z/(X+Y+Z).\n    */\n   d = XYZ->red_X;\n   if (png_safe_add(&d, XYZ->red_Y, XYZ->red_Z))\n      return 1;\n   dred = d;\n   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, dred) == 0)\n      return 1;\n   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, dred) == 0)\n      return 1;\n\n   d = XYZ->green_X;\n   if (png_safe_add(&d, XYZ->green_Y, XYZ->green_Z))\n      return 1;\n   dgreen = d;\n   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, dgreen) == 0)\n      return 1;\n   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, dgreen) == 0)\n      return 1;\n\n   d = XYZ->blue_X;\n   if (png_safe_add(&d, XYZ->blue_Y, XYZ->blue_Z))\n      return 1;\n   dblue = d;\n   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, dblue) == 0)\n      return 1;\n   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, dblue) == 0)\n      return 1;\n\n   /* The reference white is simply the sum of the end-point (X,Y,Z) vectors so\n    * the fillowing calculates (X+Y+Z) of the reference white (media white,\n    * encoding white) itself:\n    */\n   d = dblue;\n   if (png_safe_add(&d, dred, dgreen))\n      return 1;\n   dwhite = d;\n\n   /* Find the white X,Y values from the sum of the red, green and blue X,Y\n    * values.\n    */\n   d = XYZ->red_X;\n   if (png_safe_add(&d, XYZ->green_X, XYZ->blue_X))\n      return 1;\n   whiteX = d;\n\n   d = XYZ->red_Y;\n   if (png_safe_add(&d, XYZ->green_Y, XYZ->blue_Y))\n      return 1;\n   whiteY = d;\n\n   if (png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite) == 0)\n      return 1;\n   if (png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite) == 0)\n      return 1;\n\n   return 0;\n}\n",
      "line_start": 1133,
      "line_end": 1197,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 112,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Processes structured input (XYZ chromaticities from PNG cHRM), performs arithmetic/division and input validation with multiple error branches. Has moderate complexity and several input-dependent code paths but no memory copying or complex parsing/loops, so it is a high-priority but not critical fuzz target."
    },
    {
      "name": "png_set_rgb_coefficients",
      "clean_name": "png_set_rgb_coefficients",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return 0; /* sRGB defaults */\n}\n#endif /* READ_mDCV || READ_cHRM */\n\nvoid /* PRIVATE */\npng_set_rgb_coefficients(png_structrp png_ptr)\n{\n   /* Set the rgb_to_gray coefficients from the colorspace if available.  Note\n    * that '_set' means that png_rgb_to_gray was called **and** it successfully\n    * set up the coefficients.\n    */\n   if (png_ptr->rgb_to_gray_coefficients_set == 0)\n   {\n#  if check_chromaticities\n      png_XYZ xyz;\n\n      if (have_chromaticities(png_ptr) &&\n          png_XYZ_from_xy(&xyz, &png_ptr->chromaticities) == 0)\n      {\n         /* png_set_rgb_to_gray has not set the coefficients, get them from the\n          * Y * values of the colorspace colorants.\n          */\n         png_fixed_point r = xyz.red_Y;\n         png_fixed_point g = xyz.green_Y;\n         png_fixed_point b = xyz.blue_Y;\n         png_fixed_point total = r+g+b;\n\n         if (total > 0 &&\n            r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n            g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n            b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n            r+g+b <= 32769)\n         {\n            /* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n             * all of the coefficients were rounded up.  Handle this by\n             * reducing the *largest* coefficient by 1; this matches the\n             * approach used for the default coefficients in pngrtran.c\n             */\n            int add = 0;\n\n            if (r+g+b > 32768)\n               add = -1;\n            else if (r+g+b < 32768)\n               add = 1;\n\n            if (add != 0)\n            {\n               if (g >= r && g >= b)\n                  g += add;\n               else if (r >= g && r >= b)\n                  r += add;\n               else\n                  b += add;\n            }\n\n            /* Check for an internal error. */\n            if (r+g+b != 32768)\n               png_error(png_ptr,\n                   \"internal error handling cHRM coefficients\");\n\n            else\n            {\n               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n            }\n         }\n      }\n      else\n#  endif /* check_chromaticities */\n      {\n         /* Use the historical REC 709 (etc) values: */\n         png_ptr->rgb_to_gray_red_coeff   = 6968;\n         png_ptr->rgb_to_gray_green_coeff = 23434;\n         /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */\n      }\n   }\n}\n",
      "line_start": 1882,
      "line_end": 1954,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 107,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Uses structured, externally-sourced PNG colorimetric data (chromaticities) and performs validation, arithmetic transforms and branching to compute coefficients. Multiple code paths depend on input values and it writes into the png struct, making it a good high-priority fuzz target though it is not highly complex or performing raw memory ops."
    },
    {
      "name": "png.c:png_build_16bit_table",
      "clean_name": "png_build_16bit_table",
      "source_file": "/src/libpng/png.c",
      "source_code": " * The caller is responsible for ensuring that the table gets cleaned up on\n * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument\n * should be somewhere that will be cleaned.\n */\nstatic void\npng_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,\n    unsigned int shift, png_fixed_point gamma_val)\n{\n   /* Various values derived from 'shift': */\n   unsigned int num = 1U << (8U - shift);\n#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n   /* CSE the division and work round wacky GCC warnings (see the comments\n    * in png_gamma_8bit_correct for where these come from.)\n    */\n   double fmax = 1.0 / (((png_int_32)1 << (16U - shift)) - 1);\n#endif\n   unsigned int max = (1U << (16U - shift)) - 1U;\n   unsigned int max_by_2 = 1U << (15U - shift);\n   unsigned int i;\n\n   png_uint_16pp table = *ptable =\n       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));\n\n   for (i = 0; i < num; i++)\n   {\n      png_uint_16p sub_table = table[i] =\n          (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));\n\n      /* The 'threshold' test is repeated here because it can arise for one of\n       * the 16-bit tables even if the others don't hit it.\n       */\n      if (png_gamma_significant(gamma_val) != 0)\n      {\n         /* The old code would overflow at the end and this would cause the\n          * 'pow' function to return a result >1, resulting in an\n          * arithmetic error.  This code follows the spec exactly; ig is\n          * the recovered input sample, it always has 8-16 bits.\n          *\n          * We want input * 65535/max, rounded, the arithmetic fits in 32\n          * bits (unsigned) so long as max <= 32767.\n          */\n         unsigned int j;\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n               /* Inline the 'max' scaling operation: */\n               /* See png_gamma_8bit_correct for why the cast to (int) is\n                * required here.\n                */\n               double d = floor(65535.*pow(ig*fmax, gamma_val*.00001)+.5);\n               sub_table[j] = (png_uint_16)d;\n#           else\n               if (shift != 0)\n                  ig = (ig * 65535U + max_by_2)/max;\n\n               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);\n#           endif\n         }\n      }\n      else\n      {\n         /* We must still build a table, but do it the fast way. */\n         unsigned int j;\n\n         for (j = 0; j < 256; j++)\n         {\n            png_uint_32 ig = (j << (8-shift)) + i;\n\n            if (shift != 0)\n               ig = (ig * 65535U + max_by_2)/max;\n\n            sub_table[j] = (png_uint_16)ig;\n         }\n      }\n   }\n}\n",
      "line_start": 3377,
      "line_end": 3449,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Allocates and writes large tables based on external parameters (shift, gamma_val), includes nested loops with input-dependent bounds, multiple code paths (gamma-significant vs fast path), and numeric conversions (including pow/floating-point path). It performs memory operations on untrusted values so it's a good high-priority fuzz target, though it is a helper table-builder (bounded sizes) rather than a full parser/protocol handler."
    },
    {
      "name": "png_formatted_warning",
      "clean_name": "png_formatted_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "\n   png_warning_parameter(p, number, str);\n}\n\nvoid\npng_formatted_warning(png_const_structrp png_ptr, png_warning_parameters p,\n    png_const_charp message)\n{\n   /* The internal buffer is just 192 bytes - enough for all our messages,\n    * overflow doesn't happen because this code checks!  If someone figures\n    * out how to send us a message longer than 192 bytes, all that will\n    * happen is that the message will be truncated appropriately.\n    */\n   size_t i = 0; /* Index in the msg[] buffer: */\n   char msg[192];\n\n   /* Each iteration through the following loop writes at most one character\n    * to msg[i++] then returns here to validate that there is still space for\n    * the trailing '\\0'.  It may (in the case of a parameter) read more than\n    * one character from message[]; it must check for '\\0' and continue to the\n    * test if it finds the end of string.\n    */\n   while (i<(sizeof msg)-1 && *message != '\\0')\n   {\n      /* '@' at end of string is now just printed (previously it was skipped);\n       * it is an error in the calling code to terminate the string with @.\n       */\n      if (p != NULL && *message == '@' && message[1] != '\\0')\n      {\n         int parameter_char = *++message; /* Consume the '@' */\n         static const char valid_parameters[] = \"123456789\";\n         int parameter = 0;\n\n         /* Search for the parameter digit, the index in the string is the\n          * parameter to use.\n          */\n         while (valid_parameters[parameter] != parameter_char &&\n            valid_parameters[parameter] != '\\0')\n            ++parameter;\n\n         /* If the parameter digit is out of range it will just get printed. */\n         if (parameter < PNG_WARNING_PARAMETER_COUNT)\n         {\n            /* Append this parameter */\n            png_const_charp parm = p[parameter];\n            png_const_charp pend = p[parameter] + (sizeof p[parameter]);\n\n            /* No need to copy the trailing '\\0' here, but there is no guarantee\n             * that parm[] has been initialized, so there is no guarantee of a\n             * trailing '\\0':\n             */\n            while (i<(sizeof msg)-1 && *parm != '\\0' && parm < pend)\n               msg[i++] = *parm++;\n\n            /* Consume the parameter digit too: */\n            ++message;\n            continue;\n         }\n\n         /* else not a parameter and there is a character after the @ sign; just\n          * copy that.  This is known not to be '\\0' because of the test above.\n          */\n      }\n\n      /* At this point *message can't be '\\0', even in the bad parameter case\n       * above where there is a lone '@' at the end of the message string.\n       */\n      msg[i++] = *message++;\n   }\n\n   /* i is always less than (sizeof msg), so: */\n   msg[i] = '\\0';\n\n   /* And this is the formatted message. It may be larger than\n    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these\n    * are not (currently) formatted.\n    */\n   png_warning(png_ptr, msg);\n}\n",
      "line_start": 228,
      "line_end": 302,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 54,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses an external formatted string with parameter substitution and performs explicit memory/string operations into a fixed-size buffer. It has multiple branches (parameter handling vs literal copying) and loops whose bounds depend on input, so it\u2019s a good high-priority fuzz target. Proper bounds checks reduce trivial overflow risk, so it\u2019s not top-critical, but the parameter-handling logic and pointer arithmetic still merit fuzzing."
    },
    {
      "name": "pngread.c:png_do_read_intrapixel",
      "clean_name": "png_do_read_intrapixel",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "#ifdef PNG_MNG_FEATURES_SUPPORTED\n/* Undoes intrapixel differencing,\n * NOTE: this is apparently only supported in the 'sequential' reader.\n */\nstatic void\npng_do_read_intrapixel(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_read_intrapixel\");\n\n   if (\n       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      int bytes_per_pixel;\n      png_uint_32 row_width = row_info->width;\n\n      if (row_info->bit_depth == 8)\n      {\n         png_bytep rp;\n         png_uint_32 i;\n\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n            bytes_per_pixel = 3;\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            bytes_per_pixel = 4;\n\n         else\n            return;\n\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\n         {\n            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);\n            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);\n         }\n      }\n      else if (row_info->bit_depth == 16)\n      {\n         png_bytep rp;\n         png_uint_32 i;\n\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n            bytes_per_pixel = 6;\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n            bytes_per_pixel = 8;\n\n         else\n            return;\n\n         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)\n         {\n            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);\n            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);\n            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);\n            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;\n            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;\n            *(rp    ) = (png_byte)((red >> 8) & 0xff);\n            *(rp + 1) = (png_byte)(red & 0xff);\n            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);\n            *(rp + 5) = (png_byte)(blue & 0xff);\n         }\n      }\n   }\n}\n",
      "line_start": 223,
      "line_end": 282,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 78,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Processes structured external input (pixel rows) and performs in-place memory operations on untrusted data with loops driven by row_width and branches for bit_depth/color_type. Moderate complexity and multiple code paths make it a high-value fuzz target, though it is not handling crypto/authentication or extremely complex parsing."
    },
    {
      "name": "pngread.c:decode_gamma",
      "clean_name": "decode_gamma",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   else\n      display->file_encoding = P_LINEAR8;\n}\n\nstatic unsigned int\ndecode_gamma(png_image_read_control *display, png_uint_32 value, int encoding)\n{\n   if (encoding == P_FILE) /* double check */\n      encoding = display->file_encoding;\n\n   if (encoding == P_NOTSET) /* must be the file encoding */\n   {\n      set_file_encoding(display);\n      encoding = display->file_encoding;\n   }\n\n   switch (encoding)\n   {\n      case P_FILE:\n         value = png_gamma_16bit_correct(value*257, display->gamma_to_linear);\n         break;\n\n      case P_sRGB:\n         value = png_sRGB_table[value];\n         break;\n\n      case P_LINEAR:\n         break;\n\n      case P_LINEAR8:\n         value *= 257;\n         break;\n\n#ifdef __GNUC__\n      default:\n         png_error(display->image->opaque->png_ptr,\n             \"unexpected encoding (internal error)\");\n#endif\n   }\n\n   return value;\n}\n",
      "line_start": 1555,
      "line_end": 1592,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 45,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Multiple input-dependent branches and data transformations (encoding switch, gamma correction, 8/16-bit scaling). Uses untrusted 'value' for table indexing (png_sRGB_table[value]) and arithmetic (value*257) which can cause OOB reads or overflow; dereferences display fields (possible NULL/tainted pointers). Not a complex parser but sufficiently risky and valuable as a fuzz target."
    },
    {
      "name": "pngrutil.c:png_handle_hIST",
      "clean_name": "png_handle_hIST",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "#  define png_handle_eXIf NULL\n#endif\n\n#ifdef PNG_READ_hIST_SUPPORTED\nstatic png_handle_result_code /* PRIVATE */\npng_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n\n   png_debug(1, \"in png_handle_hIST\");\n\n   /* This cast is safe because the chunk definition limits the length to a\n    * maximum of 1024 bytes.\n    *\n    * TODO: maybe use png_uint_32 anyway, not unsigned int, to reduce the\n    * casts.\n    */\n   num = (unsigned int)length / 2 ;\n\n   if (length != num * 2 ||\n       num != (unsigned int)png_ptr->num_palette ||\n       num > (unsigned int)PNG_MAX_PALETTE_LENGTH)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return handled_error;\n   }\n\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return handled_error;\n\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n   return handled_ok;\n}\n",
      "line_start": 2058,
      "line_end": 2096,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Parses structured external input (PNG hIST chunk) and performs input-dependent looping and type conversions with explicit length/CRC validation. Logic is straightforward with strict bounds checks (limits risk), so it\u2019s a valuable but not top-tier fuzz target."
    },
    {
      "name": "png_set_iCCP",
      "clean_name": "png_set_iCCP",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#endif /* sRGB */\n\n\n#ifdef PNG_iCCP_SUPPORTED\nvoid PNGAPI\npng_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_charp name, int compression_type,\n    png_const_bytep profile, png_uint_32 proflen)\n{\n   png_charp new_iccp_name;\n   png_bytep new_iccp_profile;\n   size_t length;\n\n   png_debug1(1, \"in %s storage function\", \"iCCP\");\n\n   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)\n      return;\n\n   if (compression_type != PNG_COMPRESSION_TYPE_BASE)\n      png_app_error(png_ptr, \"Invalid iCCP compression method\");\n\n   length = strlen(name)+1;\n   new_iccp_name = png_voidcast(png_charp, png_malloc_warn(png_ptr, length));\n\n   if (new_iccp_name == NULL)\n   {\n      png_benign_error(png_ptr, \"Insufficient memory to process iCCP chunk\");\n\n      return;\n   }\n\n   memcpy(new_iccp_name, name, length);\n   new_iccp_profile = png_voidcast(png_bytep,\n       png_malloc_warn(png_ptr, proflen));\n\n   if (new_iccp_profile == NULL)\n   {\n      png_free(png_ptr, new_iccp_name);\n      png_benign_error(png_ptr,\n          \"Insufficient memory to process iCCP profile\");\n\n      return;\n   }\n\n   memcpy(new_iccp_profile, profile, proflen);\n\n   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);\n\n   info_ptr->iccp_proflen = proflen;\n   info_ptr->iccp_name = new_iccp_name;\n   info_ptr->iccp_profile = new_iccp_profile;\n   info_ptr->free_me |= PNG_FREE_ICCP;\n   info_ptr->valid |= PNG_INFO_iCCP;\n}\n",
      "line_start": 860,
      "line_end": 909,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Accepts external name and profile buffers and performs unchecked memory operations (strlen, malloc, memcpy) using caller-supplied lengths (proflen). This makes it a good target for finding memory-corruption issues, but the function itself is a relatively simple setter with low branching/complexity so it is high (not critical) priority for fuzzing."
    },
    {
      "name": "png_check_keyword",
      "clean_name": "png_check_keyword",
      "source_file": "/src/libpng/pngset.c",
      "source_code": " * The 'new_key' buffer must be 80 characters in size (for the keyword plus a\n * trailing '\\0').  If this routine returns 0 then there was no keyword, or a\n * valid one could not be generated, and the caller must png_error.\n */\npng_uint_32 /* PRIVATE */\npng_check_keyword(png_structrp png_ptr, png_const_charp key, png_bytep new_key)\n{\n#ifdef PNG_WARNINGS_SUPPORTED\n   png_const_charp orig_key = key;\n#endif\n   png_uint_32 key_len = 0;\n   int bad_character = 0;\n   int space = 1;\n\n   png_debug(1, \"in png_check_keyword\");\n\n   if (key == NULL)\n   {\n      *new_key = 0;\n      return 0;\n   }\n\n   while (*key && key_len < 79)\n   {\n      png_byte ch = (png_byte)*key++;\n\n      if ((ch > 32 && ch <= 126) || (ch >= 161 /*&& ch <= 255*/))\n      {\n         *new_key++ = ch; ++key_len; space = 0;\n      }\n\n      else if (space == 0)\n      {\n         /* A space or an invalid character when one wasn't seen immediately\n          * before; output just a space.\n          */\n         *new_key++ = 32; ++key_len; space = 1;\n\n         /* If the character was not a space then it is invalid. */\n         if (ch != 32)\n            bad_character = ch;\n      }\n\n      else if (bad_character == 0)\n         bad_character = ch; /* just skip it, record the first error */\n   }\n\n   if (key_len > 0 && space != 0) /* trailing space */\n   {\n      --key_len; --new_key;\n      if (bad_character == 0)\n         bad_character = 32;\n   }\n\n   /* Terminate the keyword */\n   *new_key = 0;\n\n   if (key_len == 0)\n      return 0;\n\n#ifdef PNG_WARNINGS_SUPPORTED\n   /* Try to only output one warning per keyword: */\n   if (*key != 0) /* keyword too long */\n      png_warning(png_ptr, \"keyword truncated\");\n\n   else if (bad_character != 0)\n   {\n      PNG_WARNING_PARAMETERS(p)\n\n      png_warning_parameter(p, 1, orig_key);\n      png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);\n\n      png_formatted_warning(png_ptr, p, \"keyword \\\"@1\\\": bad character '0x@2'\");\n   }\n#else /* !WARNINGS */\n   PNG_UNUSED(png_ptr)\n#endif /* !WARNINGS */\n\n   return key_len;\n}\n",
      "line_start": 1909,
      "line_end": 1984,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 88,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses untrusted input (keyword string) with validation and normalization: loop with input-dependent bounds, multiple branching paths (valid chars, spaces, invalid chars, truncation) and writes into a bounded buffer. Moderately complex and useful as a fuzz target, but relatively small/contained and not performing crypto or high-risk memory operations (writes are bounds-checked), so not top-critical."
    },
    {
      "name": "png_do_invert",
      "clean_name": "png_do_invert",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "   png_ptr->transformations |= PNG_INVERT_MONO;\n}\n\n/* Invert monochrome grayscale data */\nvoid /* PRIVATE */\npng_do_invert(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_invert\");\n\n  /* This test removed from libpng version 1.0.13 and 1.2.0:\n   *   if (row_info->bit_depth == 1 &&\n   */\n   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i++)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp++;\n      }\n   }\n\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 8)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 2)\n      {\n         *rp = (png_byte)(~(*rp));\n         rp += 2;\n      }\n   }\n\n#ifdef PNG_16BIT_SUPPORTED\n   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&\n      row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      size_t i;\n      size_t istop = row_info->rowbytes;\n\n      for (i = 0; i < istop; i += 4)\n      {\n         *rp = (png_byte)(~(*rp));\n         *(rp + 1) = (png_byte)(~(*(rp + 1)));\n         rp += 4;\n      }\n   }\n#endif\n}\n",
      "line_start": 260,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Transforms untrusted PNG row data and performs direct memory writes based on row_info->rowbytes and color/bit-depth fields. Contains input-dependent loops and several code paths (gray, gray+alpha, 16-bit path), so it is a good fuzz target for detecting OOB/logic bugs despite relatively simple logic."
    },
    {
      "name": "png_do_swap",
      "clean_name": "png_do_swap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#ifdef PNG_16BIT_SUPPORTED\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\n/* Swaps byte order on 16-bit depth images */\nvoid /* PRIVATE */\npng_do_swap(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_swap\");\n\n   if (row_info->bit_depth == 16)\n   {\n      png_bytep rp = row;\n      png_uint_32 i;\n      png_uint_32 istop= row_info->width * row_info->channels;\n\n      for (i = 0; i < istop; i++, rp += 2)\n      {\n#ifdef PNG_BUILTIN_BSWAP16_SUPPORTED\n         /* Feature added to libpng-1.6.11 for testing purposes, not\n          * enabled by default.\n          */\n         *(png_uint_16*)rp = __builtin_bswap16(*(png_uint_16*)rp);\n#else\n         png_byte t = *rp;\n         *rp = *(rp + 1);\n         *(rp + 1) = t;\n#endif\n      }\n   }\n}\n",
      "line_start": 317,
      "line_end": 342,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "In-place byte-swapping of 16-bit image data with a loop whose bounds come from row_info (width * channels) \u2014 i.e. a transformation on untrusted input with memory writes and input-dependent loop bounds. The logic is simple (low cyclomatic complexity) so not top-critical, but it is a good high-priority fuzz target because incorrect bounds/overflows or malformed row buffers can lead to memory corruption."
    },
    {
      "name": "png_do_bgr",
      "clean_name": "png_do_bgr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\n/* Swaps red and blue bytes within a pixel */\nvoid /* PRIVATE */\npng_do_bgr(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_bgr\");\n\n   if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)\n   {\n      png_uint_32 row_width = row_info->width;\n      if (row_info->bit_depth == 8)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 3)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 4)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 2);\n               *(rp + 2) = save;\n            }\n         }\n      }\n\n#ifdef PNG_16BIT_SUPPORTED\n      else if (row_info->bit_depth == 16)\n      {\n         if (row_info->color_type == PNG_COLOR_TYPE_RGB)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 6)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n\n         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         {\n            png_bytep rp;\n            png_uint_32 i;\n\n            for (i = 0, rp = row; i < row_width; i++, rp += 8)\n            {\n               png_byte save = *rp;\n               *rp = *(rp + 4);\n               *(rp + 4) = save;\n               save = *(rp + 1);\n               *(rp + 1) = *(rp + 5);\n               *(rp + 5) = save;\n            }\n         }\n      }\n#endif\n   }\n}\n",
      "line_start": 619,
      "line_end": 693,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Processes structured (PNG) input and performs direct memory operations (pointer arithmetic, byte swaps) on untrusted buffers. Multiple code paths based on bit_depth and color_type and loops driven by row_info->width increase the chance of triggering memory-corruption bugs. Moderate complexity \u2014 high-priority fuzz target."
    },
    {
      "name": "png_do_packswap",
      "clean_name": "png_do_packswap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF\n};\n\n/* Swaps pixel packing order within bytes */\nvoid /* PRIVATE */\npng_do_packswap(png_row_infop row_info, png_bytep row)\n{\n   png_debug(1, \"in png_do_packswap\");\n\n   if (row_info->bit_depth < 8)\n   {\n      png_bytep rp;\n      png_const_bytep end, table;\n\n      end = row + row_info->rowbytes;\n\n      if (row_info->bit_depth == 1)\n         table = onebppswaptable;\n\n      else if (row_info->bit_depth == 2)\n         table = twobppswaptable;\n\n      else if (row_info->bit_depth == 4)\n         table = fourbppswaptable;\n\n      else\n         return;\n\n      for (rp = row; rp < end; rp++)\n         *rp = table[*rp];\n   }\n}\n",
      "line_start": 453,
      "line_end": 480,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Medium priority: it performs memory writes on untrusted image data with a loop whose bounds come from row_info->rowbytes and uses per-byte table lookups. The logic is simple (single loop, few branches) and not a full parser or crypto, but it still manipulates external buffers so it's worth fuzzing."
    },
    {
      "name": "png_convert_to_rfc1123_buffer",
      "clean_name": "png_convert_to_rfc1123_buffer",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  ifdef PNG_TIME_RFC1123_SUPPORTED\n/* Convert the supplied time into an RFC 1123 string suitable for use in\n * a \"Creation Time\" or other text-based time string.\n */\nint PNGAPI\npng_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)\n{\n   static const char short_months[12][4] =\n        {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\n   if (out == NULL)\n      return 0;\n\n   if (ptime->year > 9999 /* RFC1123 limitation */ ||\n       ptime->month == 0    ||  ptime->month > 12  ||\n       ptime->day   == 0    ||  ptime->day   > 31  ||\n       ptime->hour  > 23    ||  ptime->minute > 59 ||\n       ptime->second > 60)\n      return 0;\n\n   {\n      size_t pos = 0;\n      char number_buf[5] = {0, 0, 0, 0, 0}; /* enough for a four-digit year */\n\n#     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))\n#     define APPEND_NUMBER(format, value)\\\n         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))\n#     define APPEND(ch) if (pos < 28) out[pos++] = (ch)\n\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);\n      APPEND(' ');\n      APPEND_STRING(short_months[(ptime->month - 1)]);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);\n      APPEND(' ');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);\n      APPEND(':');\n      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);\n      APPEND_STRING(\" +0000\"); /* This reliably terminates the buffer */\n      PNG_UNUSED (pos)\n\n#     undef APPEND\n#     undef APPEND_NUMBER\n#     undef APPEND_STRING\n   }\n\n   return 1;\n}\n",
      "line_start": 738,
      "line_end": 784,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 100,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts structured external input (ptime) and does validation and buffer writes, but logic is simple with few branches, no complex parsing or loops, and appears to use safe concatenation. Moderate fuzz value (helper-level, limited attack surface)."
    },
    {
      "name": "png_icc_check_length",
      "clean_name": "png_icc_check_length",
      "source_file": "/src/libpng/png.c",
      "source_code": "      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n   return 1;\n}\n\nint /* PRIVATE */\npng_icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length)\n{\n   if (!icc_check_length(png_ptr, name, profile_length))\n      return 0;\n\n   /* This needs to be here because the 'normal' check is in\n    * png_decompress_chunk, yet this happens after the attempt to\n    * png_malloc_base the required data.  We only need this on read; on write\n    * the caller supplies the profile buffer so libpng doesn't allocate it.  See\n    * the call to icc_check_length below (the write case).\n    */\n   if (profile_length > png_chunk_max(png_ptr))\n      return png_icc_profile_error(png_ptr, name, profile_length,\n            \"profile too long\");\n\n   return 1;\n}\n",
      "line_start": 1590,
      "line_end": 1608,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple validation helper: it checks profile_length via icc_check_length and png_chunk_max and reports errors. Low cyclomatic complexity and no parsing or direct memory operations here, but it influences allocation bounds elsewhere so it has moderate fuzzing value."
    },
    {
      "name": "png_ascii_from_fixed",
      "clean_name": "png_ascii_from_fixed",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n#  ifdef PNG_FIXED_POINT_SUPPORTED\n/* Function to format a fixed point value in ASCII.\n */\nvoid /* PRIVATE */\npng_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,\n    size_t size, png_fixed_point fp)\n{\n   /* Require space for 10 decimal digits, a decimal point, a minus sign and a\n    * trailing \\0, 13 characters:\n    */\n   if (size > 12)\n   {\n      png_uint_32 num;\n\n      /* Avoid overflow here on the minimum integer. */\n      if (fp < 0)\n      {\n         *ascii++ = 45; num = (png_uint_32)(-fp);\n      }\n      else\n         num = (png_uint_32)fp;\n\n      if (num <= 0x80000000) /* else overflowed */\n      {\n         unsigned int ndigits = 0, first = 16 /* flag value */;\n         char digits[10] = {0};\n\n         while (num)\n         {\n            /* Split the low digit off num: */\n            unsigned int tmp = num/10;\n            num -= tmp*10;\n            digits[ndigits++] = (char)(48 + num);\n            /* Record the first non-zero digit, note that this is a number\n             * starting at 1, it's not actually the array index.\n             */\n            if (first == 16 && num > 0)\n               first = ndigits;\n            num = tmp;\n         }\n\n         if (ndigits > 0)\n         {\n            while (ndigits > 5) *ascii++ = digits[--ndigits];\n            /* The remaining digits are fractional digits, ndigits is '5' or\n             * smaller at this point.  It is certainly not zero.  Check for a\n             * non-zero fractional digit:\n             */\n            if (first <= 5)\n            {\n               unsigned int i;\n               *ascii++ = 46; /* decimal point */\n               /* ndigits may be <5 for small numbers, output leading zeros\n                * then ndigits digits to first:\n                */\n               i = 5;\n               while (ndigits < i)\n               {\n                  *ascii++ = 48; --i;\n               }\n               while (ndigits >= first) *ascii++ = digits[--ndigits];\n               /* Don't output the trailing zeros! */\n            }\n         }\n         else\n            *ascii++ = 48;\n\n         /* And null terminate the string: */\n         *ascii = 0;\n         return;\n      }\n   }\n\n   /* Here on buffer too small. */\n   png_error(png_ptr, \"ASCII conversion buffer too small\");\n}\n",
      "line_start": 2639,
      "line_end": 2711,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "A small helper that formats a fixed-point integer into a caller-provided buffer. It has some branching and loops dependent on the fp value and does memory writes to an external buffer, but it does not parse complex external formats or perform security-critical operations. The function includes size checks and overflow guards so the attack surface is limited \u2014 medium fuzzing priority."
    },
    {
      "name": "png_fixed",
      "clean_name": "png_fixed",
      "source_file": "/src/libpng/png.c",
      "source_code": "   defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \\\n   (defined(PNG_sCAL_SUPPORTED) && \\\n   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))\npng_fixed_point\npng_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(100000 * fp + .5);\n\n   if (r > 2147483647. || r < -2147483648.)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_fixed_point)r;\n}\n",
      "line_start": 2722,
      "line_end": 2735,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple numeric conversion of an external double to a 32-bit fixed-point: multiplies, floor, a range check and cast. No parsing or memory operations and minimal branching, but potential for UB with NaN/Inf makes it moderately interesting for fuzzing."
    },
    {
      "name": "png_fixed_ITU",
      "clean_name": "png_fixed_ITU",
      "source_file": "/src/libpng/png.c",
      "source_code": "\n#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\npng_uint_32\npng_fixed_ITU(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(10000 * fp + .5);\n\n   if (r > 2147483647. || r < 0)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_uint_32)r;\n}\n",
      "line_start": 2741,
      "line_end": 2754,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts external floating input and does numeric conversion with a range check, so fuzzing can reveal edge cases (NaN/Inf, rounding, range handling) and trigger png_fixed_error, but the logic is simple (single branch, no loops, no memory or string ops) and has low cyclomatic complexity, so medium priority as a fuzz target."
    },
    {
      "name": "png.c:png_icc_profile_error",
      "clean_name": "png_icc_profile_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "      is_ICC_signature_char((it >> 8) & 0xff) &&\n      is_ICC_signature_char(it & 0xff);\n}\n\nstatic int\npng_icc_profile_error(png_const_structrp png_ptr, png_const_charp name,\n   png_alloc_size_t value, png_const_charp reason)\n{\n   size_t pos;\n   char message[196]; /* see below for calculation */\n\n   pos = png_safecat(message, (sizeof message), 0, \"profile '\"); /* 9 chars */\n   pos = png_safecat(message, pos+79, pos, name); /* Truncate to 79 chars */\n   pos = png_safecat(message, (sizeof message), pos, \"': \"); /* +2 = 90 */\n   if (is_ICC_signature(value) != 0)\n   {\n      /* So 'value' is at most 4 bytes and the following cast is safe */\n      png_icc_tag_name(message+pos, (png_uint_32)value);\n      pos += 6; /* total +8; less than the else clause */\n      message[pos++] = ':';\n      message[pos++] = ' ';\n   }\n#  ifdef PNG_WARNINGS_SUPPORTED\n   else\n   {\n      char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114 */\n\n      pos = png_safecat(message, (sizeof message), pos,\n          png_format_number(number, number+(sizeof number),\n          PNG_NUMBER_FORMAT_x, value));\n      pos = png_safecat(message, (sizeof message), pos, \"h: \"); /* +2 = 116 */\n   }\n#  endif\n   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */\n   pos = png_safecat(message, (sizeof message), pos, reason);\n   PNG_UNUSED(pos)\n\n   png_chunk_benign_error(png_ptr, message);\n\n   return 0;\n}\n",
      "line_start": 1535,
      "line_end": 1571,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Helper that formats an error message from external inputs (name, value, reason). It performs buffer concatenation and conditional formatting (branching) but does not parse complex file formats or perform risky memory ops on raw untrusted payloads. Moderate complexity and use of external data make it a medium-priority fuzz target (useful for negative/robustness tests, but not critical)."
    },
    {
      "name": "png_format_number",
      "clean_name": "png_format_number",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "/* Utility to dump an unsigned value into a buffer, given a start pointer and\n * and end pointer (which should point just *beyond* the end of the buffer!)\n * Returns the pointer to the start of the formatted string.\n */\npng_charp\npng_format_number(png_const_charp start, png_charp end, int format,\n    png_alloc_size_t number)\n{\n   int count = 0;    /* number of digits output */\n   int mincount = 1; /* minimum number required */\n   int output = 0;   /* digit output (for the fixed point format) */\n\n   *--end = '\\0';\n\n   /* This is written so that the loop always runs at least once, even with\n    * number zero.\n    */\n   while (end > start && (number != 0 || count < mincount))\n   {\n\n      static const char digits[] = \"0123456789ABCDEF\";\n\n      switch (format)\n      {\n         case PNG_NUMBER_FORMAT_fixed:\n            /* Needs five digits (the fraction) */\n            mincount = 5;\n            if (output != 0 || number % 10 != 0)\n            {\n               *--end = digits[number % 10];\n               output = 1;\n            }\n            number /= 10;\n            break;\n\n         case PNG_NUMBER_FORMAT_02u:\n            /* Expects at least 2 digits. */\n            mincount = 2;\n            /* FALLTHROUGH */\n\n         case PNG_NUMBER_FORMAT_u:\n            *--end = digits[number % 10];\n            number /= 10;\n            break;\n\n         case PNG_NUMBER_FORMAT_02x:\n            /* This format expects at least two digits */\n            mincount = 2;\n            /* FALLTHROUGH */\n\n         case PNG_NUMBER_FORMAT_x:\n            *--end = digits[number & 0xf];\n            number >>= 4;\n            break;\n\n         default: /* an error */\n            number = 0;\n            break;\n      }\n\n      /* Keep track of the number of digits added */\n      ++count;\n\n      /* Float a fixed number here: */\n      if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))\n      {\n         /* End of the fraction, but maybe nothing was output?  In that case\n          * drop the decimal point.  If the number is a true zero handle that\n          * here.\n          */\n         if (output != 0)\n            *--end = '.';\n         else if (number == 0) /* and !output */\n            *--end = '0';\n      }\n   }\n\n   return end;\n}\n",
      "line_start": 92,
      "line_end": 166,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Small helper that formats an unsigned number into a buffer. It does perform buffer writes and has some branching (switch, fixed-point handling) but is not parsing complex external formats, has limited complexity, and contains bounds checks. Useful but medium-priority as a fuzz target."
    },
    {
      "name": "png_chunk_error",
      "clean_name": "png_chunk_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* WARNINGS || ERROR_TEXT */\n\n#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)\nPNG_FUNCTION(void,PNGAPI\npng_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   char msg[18+PNG_MAX_ERROR_TEXT];\n   if (png_ptr == NULL)\n      png_error(png_ptr, error_message);\n\n   else\n   {\n      png_format_buffer(png_ptr, msg, error_message);\n      png_error(png_ptr, msg);\n   }\n}\n",
      "line_start": 424,
      "line_end": 437,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple wrapper that formats an error message into a fixed-size buffer and calls the global error handler. It touches external input (error_message) but contains minimal logic/branching and no complex parsing or memory-manipulating code, so medium fuzzing priority."
    },
    {
      "name": "pngerror.c:png_format_buffer",
      "clean_name": "png_format_buffer",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n   'A', 'B', 'C', 'D', 'E', 'F'\n};\n\nstatic void /* PRIVATE */\npng_format_buffer(png_const_structrp png_ptr, png_charp buffer, png_const_charp\n    error_message)\n{\n   png_uint_32 chunk_name = png_ptr->chunk_name;\n   int iout = 0, ishift = 24;\n\n   while (ishift >= 0)\n   {\n      int c = (int)(chunk_name >> ishift) & 0xff;\n\n      ishift -= 8;\n      if (isnonalpha(c) != 0)\n      {\n         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;\n         buffer[iout++] = png_digit[(c & 0xf0) >> 4];\n         buffer[iout++] = png_digit[c & 0x0f];\n         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;\n      }\n\n      else\n      {\n         buffer[iout++] = (char)c;\n      }\n   }\n\n   if (error_message == NULL)\n      buffer[iout] = '\\0';\n\n   else\n   {\n      int iin = 0;\n\n      buffer[iout++] = ':';\n      buffer[iout++] = ' ';\n\n      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\\0')\n         buffer[iout++] = error_message[iin++];\n\n      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */\n      buffer[iout] = '\\0';\n   }\n}\n",
      "line_start": 378,
      "line_end": 420,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: it formats untrusted data (chunk_name and an error_message) into a caller-supplied buffer and performs byte/character writes and a looped copy. Complexity is low (fixed 4-byte loop + bounded copy up to PNG_MAX_ERROR_TEXT), and there is no protocol parsing or heavy branching, but the function does perform memory writes without inherent buffer-size checks (caller must size buffer correctly), so it is worth fuzzing as a medium-priority helper that could reveal buffer misuse."
    },
    {
      "name": "pngget.c:ppi_from_ppm",
      "clean_name": "ppi_from_ppm",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_INCH_CONVERSIONS_SUPPORTED\nstatic png_uint_32\nppi_from_ppm(png_uint_32 ppm)\n{\n#if 0\n   /* The conversion is *(2.54/100), in binary (32 digits):\n    * .00000110100000001001110101001001\n    */\n   png_uint_32 t1001, t1101;\n   ppm >>= 1;                  /* .1 */\n   t1001 = ppm + (ppm >> 3);   /* .1001 */\n   t1101 = t1001 + (ppm >> 1); /* .1101 */\n   ppm >>= 20;                 /* .000000000000000000001 */\n   t1101 += t1101 >> 15;       /* .1101000000000001101 */\n   t1001 >>= 11;               /* .000000000001001 */\n   t1001 += t1001 >> 12;       /* .000000000001001000000001001 */\n   ppm += t1001;               /* .000000000001001000001001001 */\n   ppm += t1101;               /* .110100000001001110101001001 */\n   return (ppm + 16) >> 5;/* .00000110100000001001110101001001 */\n#else\n   /* The argument is a PNG unsigned integer, so it is not permitted\n    * to be bigger than 2^31.\n    */\n   png_fixed_point result;\n   if (ppm <= PNG_UINT_31_MAX && png_muldiv(&result, (png_int_32)ppm, 127,\n       5000) != 0)\n      return (png_uint_32)result;\n\n   /* Overflow. */\n   return 0;\n#endif\n}\n",
      "line_start": 324,
      "line_end": 354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple numeric conversion with a range/overflow check and a call to png_muldiv. No parsing of complex external formats, no memory or buffer operations, and only minimal branching \u2014 moderate value for fuzzing (medium priority) mostly useful if png_muldiv has subtle edge cases."
    },
    {
      "name": "pngread.c:set_file_encoding",
      "clean_name": "set_file_encoding",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " */\n#define PNG_DIV51(v8) (((v8) * 5 + 130) >> 8)\n\n/* Utility functions to make particular color-maps */\nstatic void\nset_file_encoding(png_image_read_control *display)\n{\n   png_structrp png_ptr = display->image->opaque->png_ptr;\n   png_fixed_point g = png_resolve_file_gamma(png_ptr);\n\n   /* PNGv3: the result may be 0 however the 'default_gamma' should have been\n    * set before this is called so zero is an error:\n    */\n   if (g == 0)\n      png_error(png_ptr, \"internal: default gamma not set\");\n\n   if (png_gamma_significant(g) != 0)\n   {\n      if (png_gamma_not_sRGB(g) != 0)\n      {\n         display->file_encoding = P_FILE;\n         display->gamma_to_linear = png_reciprocal(g);\n      }\n\n      else\n         display->file_encoding = P_sRGB;\n   }\n\n   else\n      display->file_encoding = P_LINEAR8;\n}\n",
      "line_start": 1527,
      "line_end": 1553,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Small helper that reads a gamma value (derived from parsed PNG state) and sets enums/reciprocal; has simple branching but no loops, no direct memory/string operations, and no crypto/auth logic. Moderate relevance as part of image parsing pipeline but low individual attack surface."
    },
    {
      "name": "pngrtran.c:convert_gamma_value",
      "clean_name": "convert_gamma_value",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   return output_gamma;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nstatic png_fixed_point\nconvert_gamma_value(png_structrp png_ptr, double output_gamma)\n{\n   /* The following silently ignores cases where fixed point (times 100,000)\n    * gamma values are passed to the floating point API.  This is safe and it\n    * means the fixed point constants work just fine with the floating point\n    * API.  The alternative would just lead to undetected errors and spurious\n    * bug reports.  Negative values fail inside the _fixed API unless they\n    * correspond to the flag values.\n    */\n   if (output_gamma > 0 && output_gamma < 128)\n      output_gamma *= PNG_FP_1;\n\n   /* This preserves -1 and -2 exactly: */\n   output_gamma = floor(output_gamma + .5);\n\n   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)\n      png_fixed_error(png_ptr, \"gamma value\");\n\n   return (png_fixed_point)output_gamma;\n}\n",
      "line_start": 308,
      "line_end": 328,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Numeric conversion/validation of a (likely external) double with a few branches and range checks but no memory/raw buffer operations or complex parsing. Useful to fuzz for corner cases (NaN, inf, rounding, range errors) but low likelihood of memory safety bugs \u2014 medium priority."
    },
    {
      "name": "png_set_cHRM",
      "clean_name": "png_set_cHRM",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\n    double white_x, double white_y, double red_x, double red_y,\n    double green_x, double green_y, double blue_x, double blue_y)\n{\n   png_set_cHRM_fixed(png_ptr, info_ptr,\n       png_fixed(png_ptr, white_x, \"cHRM White X\"),\n       png_fixed(png_ptr, white_y, \"cHRM White Y\"),\n       png_fixed(png_ptr, red_x, \"cHRM Red X\"),\n       png_fixed(png_ptr, red_y, \"cHRM Red Y\"),\n       png_fixed(png_ptr, green_x, \"cHRM Green X\"),\n       png_fixed(png_ptr, green_y, \"cHRM Green Y\"),\n       png_fixed(png_ptr, blue_x, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_y, \"cHRM Blue Y\"));\n}\n",
      "line_start": 98,
      "line_end": 112,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple wrapper API: converts floating-point chromaticity values to fixed-point and forwards to png_set_cHRM_fixed. Minimal logic/branching, no direct parsing of complex external input or memory operations. Useful but medium priority as a fuzz target (helper-level validation/type-conversion)."
    },
    {
      "name": "png_set_sCAL_fixed",
      "clean_name": "png_set_sCAL_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FIXED_POINT_SUPPORTED\nvoid PNGAPI\npng_set_sCAL_fixed(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\n    png_fixed_point width, png_fixed_point height)\n{\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\n\n   /* Check the arguments. */\n   if (width <= 0)\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\n\n   else if (height <= 0)\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\n\n   else\n   {\n      /* Convert 'width' and 'height' to ASCII. */\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\n\n      png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);\n      png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);\n\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\n   }\n}\n",
      "line_start": 695,
      "line_end": 719,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple wrapper/helper: it validates two fixed-point inputs, converts them to ASCII into fixed-size buffers and forwards them on. Low cyclomatic complexity, no parsing of complex external formats or input-dependent loops, so limited fuzz value. It does touch buffers and calls downstream functions (conversion and png_set_sCAL_s), so not trivial but only medium priority for fuzzing."
    },
    {
      "name": "png_set_alpha_mode_fixed",
      "clean_name": "png_set_alpha_mode_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif /* READ_ALPHA_MODE || READ_GAMMA */\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\nvoid PNGFAPI\npng_set_alpha_mode_fixed(png_structrp png_ptr, int mode,\n    png_fixed_point output_gamma)\n{\n   png_fixed_point file_gamma;\n   int compose = 0;\n\n   png_debug(1, \"in png_set_alpha_mode_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   output_gamma = translate_gamma_flags(output_gamma, 1/*screen*/);\n   if (unsupported_gamma(png_ptr, output_gamma, 0/*error*/))\n      return;\n\n   /* The default file gamma is the inverse of the output gamma; the output\n    * gamma may be changed below so get the file value first.  The default_gamma\n    * is set here and from the simplified API (which uses a different algorithm)\n    * so don't overwrite a set value:\n    */\n   file_gamma = png_ptr->default_gamma;\n   if (file_gamma == 0)\n   {\n      file_gamma = png_reciprocal(output_gamma);\n      png_ptr->default_gamma = file_gamma;\n   }\n\n   /* There are really 8 possibilities here, composed of any combination\n    * of:\n    *\n    *    premultiply the color channels\n    *    do not encode non-opaque pixels\n    *    encode the alpha as well as the color channels\n    *\n    * The differences disappear if the input/output ('screen') gamma is 1.0,\n    * because then the encoding is a no-op and there is only the choice of\n    * premultiplying the color channels or not.\n    *\n    * png_set_alpha_mode and png_set_background interact because both use\n    * png_compose to do the work.  Calling both is only useful when\n    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along\n    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.\n    */\n   switch (mode)\n   {\n      case PNG_ALPHA_PNG:        /* default: png standard */\n         /* No compose, but it may be set by png_set_background! */\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         break;\n\n      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */\n         compose = 1;\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         /* The output is linear: */\n         output_gamma = PNG_FP_1;\n         break;\n\n      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */\n         compose = 1;\n         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;\n         /* output_gamma records the encoding of opaque pixels! */\n         break;\n\n      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */\n         compose = 1;\n         png_ptr->transformations |= PNG_ENCODE_ALPHA;\n         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid alpha mode\");\n   }\n\n   /* Set the screen gamma values: */\n   png_ptr->screen_gamma = output_gamma;\n\n   /* Finally, if pre-multiplying, set the background fields to achieve the\n    * desired result.\n    */\n   if (compose != 0)\n   {\n      /* And obtain alpha pre-multiplication by composing on black: */\n      memset(&png_ptr->background, 0, (sizeof png_ptr->background));\n      png_ptr->background_gamma = file_gamma; /* just in case */\n      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n\n      if ((png_ptr->transformations & PNG_COMPOSE) != 0)\n         png_error(png_ptr,\n             \"conflicting calls to set alpha mode and background\");\n\n      png_ptr->transformations |= PNG_COMPOSE;\n   }\n}\n",
      "line_start": 360,
      "line_end": 457,
      "execution_count": 358,
      "covered_regions": 24,
      "total_regions": 94,
      "coverage_percent": 25.53,
      "is_covered": true,
      "is_static": false,
      "score": 5.0,
      "reason": "A configuration/helper that updates png_struct based on mode and gamma: has branching and validation but no parsing of complex external input, no loops or risky memory copies, and only simple state manipulation \u2014 moderate fuzzing priority."
    },
    {
      "name": "png_info_init_3",
      "clean_name": "png_info_init_3",
      "source_file": "/src/libpng/png.c",
      "source_code": " * NOTE: it is almost inconceivable that this API is used because it bypasses\n * the user-memory mechanism and the user error handling/warning mechanisms in\n * those cases where it does anything other than a memset.\n */\nPNG_FUNCTION(void,PNGAPI\npng_info_init_3,(png_infopp ptr_ptr, size_t png_info_struct_size),\n    PNG_DEPRECATED)\n{\n   png_inforp info_ptr = *ptr_ptr;\n\n   png_debug(1, \"in png_info_init_3\");\n\n   if (info_ptr == NULL)\n      return;\n\n   if ((sizeof (png_info)) > png_info_struct_size)\n   {\n      *ptr_ptr = NULL;\n      /* The following line is why this API should not be used: */\n      free(info_ptr);\n      info_ptr = png_voidcast(png_inforp, png_malloc_base(NULL,\n          (sizeof *info_ptr)));\n      if (info_ptr == NULL)\n         return;\n      *ptr_ptr = info_ptr;\n   }\n\n   /* Set everything to 0 */\n   memset(info_ptr, 0, (sizeof *info_ptr));\n}\n",
      "line_start": 433,
      "line_end": 458,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "A simple, deprecated initializer that does low-complexity memory operations (free/malloc/memset) on an external pointer. It has minimal branching and no parsing of complex input or protocol handling, so it is of moderate interest to fuzzers but not high priority."
    },
    {
      "name": "png_build_grayscale_palette",
      "clean_name": "png_build_grayscale_palette",
      "source_file": "/src/libpng/png.c",
      "source_code": " * large of png_color.  This lets grayscale images be treated as\n * paletted.  Most useful for gamma correction and simplification\n * of code.  This API is not used internally.\n */\nvoid PNGAPI\npng_build_grayscale_palette(int bit_depth, png_colorp palette)\n{\n   int num_palette;\n   int color_inc;\n   int i;\n   int v;\n\n   png_debug(1, \"in png_do_build_grayscale_palette\");\n\n   if (palette == NULL)\n      return;\n\n   switch (bit_depth)\n   {\n      case 1:\n         num_palette = 2;\n         color_inc = 0xff;\n         break;\n\n      case 2:\n         num_palette = 4;\n         color_inc = 0x55;\n         break;\n\n      case 4:\n         num_palette = 16;\n         color_inc = 0x11;\n         break;\n\n      case 8:\n         num_palette = 256;\n         color_inc = 1;\n         break;\n\n      default:\n         num_palette = 0;\n         color_inc = 0;\n         break;\n   }\n\n   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)\n   {\n      palette[i].red = (png_byte)(v & 0xff);\n      palette[i].green = (png_byte)(v & 0xff);\n      palette[i].blue = (png_byte)(v & 0xff);\n   }\n}\n",
      "line_start": 876,
      "line_end": 923,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small helper that builds a grayscale palette from bit_depth with a simple switch and a loop (<=256) writing into the caller-provided palette. Low parsing/cyclomatic complexity and limited attack surface, though it writes to an external buffer without a length parameter (caller responsibility), so it has some modest value as a fuzz target but is not high priority."
    },
    {
      "name": "png_warning_parameter_unsigned",
      "clean_name": "png_warning_parameter_unsigned",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)\n      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);\n}\n\nvoid\npng_warning_parameter_unsigned(png_warning_parameters p, int number, int format,\n    png_alloc_size_t value)\n{\n   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));\n}\n",
      "line_start": 199,
      "line_end": 205,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small helper that formats an unsigned value into a local buffer and forwards it to png_warning_parameter. Minimal logic and no loops or complex parsing; memory operations are limited and appear to use safe helpers. Useful only insofar as related helpers/macros are buggy, so medium-low fuzz priority."
    },
    {
      "name": "png_get_pixel_aspect_ratio_fixed",
      "clean_name": "png_get_pixel_aspect_ratio_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\npng_fixed_point PNGAPI\npng_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n#ifdef PNG_READ_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixel_aspect_ratio_fixed\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0 &&\n       info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&\n       info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX &&\n       info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)\n   {\n      png_fixed_point res;\n\n      /* The following casts work because a PNG 4 byte integer only has a valid\n       * range of 0..2^31-1; otherwise the cast might overflow.\n       */\n      if (png_muldiv(&res, (png_int_32)info_ptr->y_pixels_per_unit, PNG_FP_1,\n          (png_int_32)info_ptr->x_pixels_per_unit) != 0)\n         return res;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 212,
      "line_end": 240,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple accessor/helper: reads fields from info_ptr, does bounds checks and a single multiply/divide with minor casting. No complex parsing of external input, no loops or heavy branching. Useful only when exercised as part of a PNG parsing pipeline, but low standalone fuzz value."
    },
    {
      "name": "png_get_sCAL_fixed",
      "clean_name": "png_get_sCAL_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#ifdef PNG_sCAL_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\n#    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \\\n         defined(PNG_FLOATING_POINT_SUPPORTED)\npng_uint_32 PNGAPI\npng_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, png_fixed_point *width, png_fixed_point *height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      /*TODO: make this work without FP support; the API is currently eliminated\n       * if neither floating point APIs nor internal floating point arithmetic\n       * are enabled.\n       */\n      *width = png_fixed(png_ptr, atof(info_ptr->scal_s_width), \"sCAL width\");\n      *height = png_fixed(png_ptr, atof(info_ptr->scal_s_height),\n          \"sCAL height\");\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1034,
      "line_end": 1055,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple getter-style helper: checks pointers/valid flag and converts stored string fields to fixed-point via atof/png_fixed. It touches data derived from external input (the parsed PNG chunk) but has low branching/cyclomatic complexity and no loops or complex parsing, so medium fuzzing priority (some value but not high)."
    },
    {
      "name": "png_read_rows",
      "clean_name": "png_read_rows",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " *\n * [*] png_handle_alpha() does not exist yet, as of this version of libpng\n */\n\nvoid PNGAPI\npng_read_rows(png_structrp png_ptr, png_bytepp row,\n    png_bytepp display_row, png_uint_32 num_rows)\n{\n   png_uint_32 i;\n   png_bytepp rp;\n   png_bytepp dp;\n\n   png_debug(1, \"in png_read_rows\");\n\n   if (png_ptr == NULL)\n      return;\n\n   rp = row;\n   dp = display_row;\n   if (rp != NULL && dp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep rptr = *rp++;\n         png_bytep dptr = *dp++;\n\n         png_read_row(png_ptr, rptr, dptr);\n      }\n\n   else if (rp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep rptr = *rp;\n         png_read_row(png_ptr, rptr, NULL);\n         rp++;\n      }\n\n   else if (dp != NULL)\n      for (i = 0; i < num_rows; i++)\n      {\n         png_bytep dptr = *dp;\n         png_read_row(png_ptr, NULL, dptr);\n         dp++;\n      }\n}\n",
      "line_start": 551,
      "line_end": 590,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Thin wrapper that iterates num_rows and forwards row/display pointers to png_read_row. It has simple branching based on which arrays are non-NULL and a loop driven by external num_rows, but it does no parsing or direct memory manipulation itself \u2014 the real attack surface is in png_read_row. Useful as a fuzz harness wrapper but not high-value on its own."
    },
    {
      "name": "pngread.c:png_colormap_compose",
      "clean_name": "png_colormap_compose",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return value;\n}\n\nstatic png_uint_32\npng_colormap_compose(png_image_read_control *display,\n    png_uint_32 foreground, int foreground_encoding, png_uint_32 alpha,\n    png_uint_32 background, int encoding)\n{\n   /* The file value is composed on the background, the background has the given\n    * encoding and so does the result, the file is encoded with P_FILE and the\n    * file and alpha are 8-bit values.  The (output) encoding will always be\n    * P_LINEAR or P_sRGB.\n    */\n   png_uint_32 f = decode_gamma(display, foreground, foreground_encoding);\n   png_uint_32 b = decode_gamma(display, background, encoding);\n\n   /* The alpha is always an 8-bit value (it comes from the palette), the value\n    * scaled by 255 is what PNG_sRGB_FROM_LINEAR requires.\n    */\n   f = f * alpha + b * (255-alpha);\n\n   if (encoding == P_LINEAR)\n   {\n      /* Scale to 65535; divide by 255, approximately (in fact this is extremely\n       * accurate, it divides by 255.00000005937181414556, with no overflow.)\n       */\n      f *= 257; /* Now scaled by 65535 */\n      f += f >> 16;\n      f = (f+32768) >> 16;\n   }\n\n   else /* P_sRGB */\n      f = PNG_sRGB_FROM_LINEAR(f);\n\n   return f;\n}\n",
      "line_start": 1594,
      "line_end": 1626,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Small helper that composes color values: simple arithmetic and one branch (P_LINEAR vs sRGB). It doesn't parse complex external formats or perform memory/buffer operations; no loops or heavy branching. While it operates on untrusted color components and calls decode_gamma, its logic is low complexity and thus moderate fuzzing value."
    },
    {
      "name": "png_set_rgb_to_gray_fixed",
      "clean_name": "png_set_rgb_to_gray_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\nvoid PNGFAPI\npng_set_rgb_to_gray_fixed(png_structrp png_ptr, int error_action,\n    png_fixed_point red, png_fixed_point green)\n{\n   png_debug(1, \"in png_set_rgb_to_gray_fixed\");\n\n   /* Need the IHDR here because of the check on color_type below. */\n   /* TODO: fix this */\n   if (png_rtran_ok(png_ptr, 1) == 0)\n      return;\n\n   switch (error_action)\n   {\n      case PNG_ERROR_ACTION_NONE:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY;\n         break;\n\n      case PNG_ERROR_ACTION_WARN:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;\n         break;\n\n      case PNG_ERROR_ACTION_ERROR:\n         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;\n         break;\n\n      default:\n         png_error(png_ptr, \"invalid error action to rgb_to_gray\");\n   }\n\n   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n#ifdef PNG_READ_EXPAND_SUPPORTED\n      png_ptr->transformations |= PNG_EXPAND;\n#else\n   {\n      /* Make this an error in 1.6 because otherwise the application may assume\n       * that it just worked and get a memory overwrite.\n       */\n      png_error(png_ptr,\n          \"Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED\");\n\n      /* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */\n   }\n#endif\n   {\n      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)\n      {\n         png_uint_16 red_int, green_int;\n\n         /* NOTE: this calculation does not round, but this behavior is retained\n          * for consistency; the inaccuracy is very small.  The code here always\n          * overwrites the coefficients, regardless of whether they have been\n          * defaulted or set already.\n          */\n         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);\n         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);\n\n         png_ptr->rgb_to_gray_red_coeff   = red_int;\n         png_ptr->rgb_to_gray_green_coeff = green_int;\n         png_ptr->rgb_to_gray_coefficients_set = 1;\n      }\n\n      else if (red >= 0 && green >= 0)\n         png_app_warning(png_ptr,\n               \"ignoring out of range rgb_to_gray coefficients\");\n   }\n}\n",
      "line_start": 1036,
      "line_end": 1101,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple configuration helper: sets transformation flags and stores two coefficient values with basic range checks. Small branching (switch + a couple of ifs), no parsing of complex external formats, no loops or unbounded memory operations, and no direct crypto/auth handling. Useful but low-medium priority as a fuzz target."
    },
    {
      "name": "png_get_int_32",
      "clean_name": "png_get_int_32",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * data is stored in the PNG file in two's complement format and there\n * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore\n * the following code does a two's complement to native conversion.\n */\npng_int_32 (PNGAPI\npng_get_int_32)(png_const_bytep buf)\n{\n   png_uint_32 uval = png_get_uint_32(buf);\n   if ((uval & 0x80000000) == 0) /* non-negative */\n      return (png_int_32)uval;\n\n   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */\n   if ((uval & 0x80000000) == 0) /* no overflow */\n      return -(png_int_32)uval;\n   /* The following has to be safe; this function only gets called on PNG data\n    * and if we get here that data is invalid.  0 is the most safe value and\n    * if not then an attacker would surely just generate a PNG with 0 instead.\n    */\n   return 0;\n}\n",
      "line_start": 79,
      "line_end": 94,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Tiny helper that converts 4 bytes to a signed integer with a couple of simple branches. It does operate on external PNG bytes but contains no loops, no memory/buffer manipulation, and very low cyclomatic complexity, so it has limited standalone value as a fuzz target compared with higher-level PNG parsing code."
    },
    {
      "name": "png_set_unknown_chunk_location",
      "clean_name": "png_set_unknown_chunk_location",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      ++(info_ptr->unknown_chunks_num);\n   }\n}\n\nvoid PNGAPI\npng_set_unknown_chunk_location(png_const_structrp png_ptr, png_inforp info_ptr,\n    int chunk, int location)\n{\n   /* This API is pretty pointless in 1.6.0 because the location can be set\n    * before the call to png_set_unknown_chunks.\n    *\n    * TODO: add a png_app_warning in 1.7\n    */\n   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&\n      chunk < info_ptr->unknown_chunks_num)\n   {\n      if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT)) == 0)\n      {\n         png_app_error(png_ptr, \"invalid unknown chunk location\");\n         /* Fake out the pre 1.6.0 behavior: */\n         if (((unsigned int)location & PNG_HAVE_IDAT) != 0) /* undocumented! */\n            location = PNG_AFTER_IDAT;\n\n         else\n            location = PNG_HAVE_IHDR; /* also undocumented */\n      }\n\n      info_ptr->unknown_chunks[chunk].location =\n         check_location(png_ptr, location);\n   }\n}\n",
      "line_start": 1455,
      "line_end": 1481,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small helper that only performs simple validation and a bounded array assignment: checks chunk index and bitmask flags then calls check_location. Low cyclomatic complexity, no parsing of external formats, no memory copies or loops; modest value as a fuzz target (medium priority)."
    },
    {
      "name": "png.c:png_icc_tag_name",
      "clean_name": "png_icc_tag_name",
      "source_file": "/src/libpng/png.c",
      "source_code": "   else\n      return '?';\n}\n\nstatic void\npng_icc_tag_name(char *name, png_uint_32 tag)\n{\n   name[0] = '\\'';\n   name[1] = png_icc_tag_char(tag >> 24);\n   name[2] = png_icc_tag_char(tag >> 16);\n   name[3] = png_icc_tag_char(tag >>  8);\n   name[4] = png_icc_tag_char(tag      );\n   name[5] = '\\'';\n}\n",
      "line_start": 1508,
      "line_end": 1517,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Trivial helper that formats a 4-byte tag into a 6-byte name; no parsing, loops, or complex branching. Minimal logic and low fuzzing value (though it writes into caller buffer without bounds checks, the function itself is simple)."
    },
    {
      "name": "png_warning_parameter",
      "clean_name": "png_warning_parameter",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter\n * is introduced by @<number>, where 'number' starts at 1.  This follows the\n * standard established by X/Open for internationalizable error messages.\n */\nvoid\npng_warning_parameter(png_warning_parameters p, int number,\n    png_const_charp string)\n{\n   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)\n      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);\n}\n",
      "line_start": 191,
      "line_end": 197,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Trivial helper: one conditional and a single call to png_safecat to append a string into a parameter buffer. It handles external data but has minimal logic/branching, no parsing, loops, or complex memory manipulation \u2014 low-value fuzz target."
    },
    {
      "name": "png_chunk_warning",
      "clean_name": "png_chunk_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* READ && ERROR_TEXT */\n\n#ifdef PNG_WARNINGS_SUPPORTED\nvoid PNGAPI\npng_chunk_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n   char msg[18+PNG_MAX_ERROR_TEXT];\n   if (png_ptr == NULL)\n      png_warning(png_ptr, warning_message);\n\n   else\n   {\n      png_format_buffer(png_ptr, msg, warning_message);\n      png_warning(png_ptr, msg);\n   }\n}\n",
      "line_start": 441,
      "line_end": 453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper with minimal logic: one null check, a stack buffer allocation and delegation to png_format_buffer/png_warning. It accepts external strings but performs no parsing/complex memory operations itself, so low fuzz priority (possible risk depends on called functions)."
    },
    {
      "name": "png_fixed_error",
      "clean_name": "png_fixed_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n\n#ifdef PNG_ERROR_TEXT_SUPPORTED\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nPNG_FUNCTION(void,\npng_fixed_error,(png_const_structrp png_ptr, png_const_charp name),PNG_NORETURN)\n{\n#  define fixed_message \"fixed point overflow in \"\n#  define fixed_message_ln ((sizeof fixed_message)-1)\n   unsigned int  iin;\n   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];\n   memcpy(msg, fixed_message, fixed_message_ln);\n   iin = 0;\n   if (name != NULL)\n      while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)\n      {\n         msg[fixed_message_ln + iin] = name[iin];\n         ++iin;\n      }\n   msg[fixed_message_ln + iin] = 0;\n   png_error(png_ptr, msg);\n}\n",
      "line_start": 516,
      "line_end": 533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple helper that builds an error message: copies a possibly external 'name' into a fixed-size buffer with a constant bound and null-termination. Minimal branching/complexity, no parsing of complex formats or security-critical logic, so low fuzz priority."
    },
    {
      "name": "png_safe_error",
      "clean_name": "png_safe_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   /* Currently the above both depend on SETJMP_SUPPORTED, however it would be\n    * possible to implement without setjmp support just so long as there is some\n    * way to handle the error return here:\n    */\nPNG_FUNCTION(void /* PRIVATE */, (PNGCBAPI\npng_safe_error),(png_structp png_nonconst_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   png_const_structrp png_ptr = png_nonconst_ptr;\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\n\n   /* An error is always logged here, overwriting anything (typically a warning)\n    * that is already there:\n    */\n   if (image != NULL)\n   {\n      png_safecat(image->message, (sizeof image->message), 0, error_message);\n      image->warning_or_error |= PNG_IMAGE_ERROR;\n\n      /* Retrieve the jmp_buf from within the png_control, making this work for\n       * C++ compilation too is pretty tricky: C++ wants a pointer to the first\n       * element of a jmp_buf, but C doesn't tell us the type of that.\n       */\n      if (image->opaque != NULL && image->opaque->error_buf != NULL)\n         longjmp(png_control_jmp_buf(image->opaque), 1);\n\n      /* Missing longjmp buffer, the following is to help debugging: */\n      {\n         size_t pos = png_safecat(image->message, (sizeof image->message), 0,\n             \"bad longjmp: \");\n         png_safecat(image->message, (sizeof image->message), pos,\n             error_message);\n      }\n   }\n\n   /* Here on an internal programming error. */\n   abort();\n}\n",
      "line_start": 760,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple error-handling helper: bounded safe string concatenation into image->message, sets a flag and does longjmp/abort. Minimal branching and no parsing/validation of complex external formats, no loops or heavy data transformation \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_cHRM_XYZ",
      "clean_name": "png_get_cHRM_XYZ",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_cHRM_XYZ(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *red_X, double *red_Y, double *red_Z, double *green_X,\n    double *green_Y, double *green_Z, double *blue_X, double *blue_Y,\n    double *blue_Z)\n{\n   png_XYZ XYZ;\n   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0 &&\n       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n   {\n      if (red_X != NULL)\n         *red_X = png_float(png_ptr, XYZ.red_X, \"cHRM red X\");\n      if (red_Y != NULL)\n         *red_Y = png_float(png_ptr, XYZ.red_Y, \"cHRM red Y\");\n      if (red_Z != NULL)\n         *red_Z = png_float(png_ptr, XYZ.red_Z, \"cHRM red Z\");\n      if (green_X != NULL)\n         *green_X = png_float(png_ptr, XYZ.green_X, \"cHRM green X\");\n      if (green_Y != NULL)\n         *green_Y = png_float(png_ptr, XYZ.green_Y, \"cHRM green Y\");\n      if (green_Z != NULL)\n         *green_Z = png_float(png_ptr, XYZ.green_Z, \"cHRM green Z\");\n      if (blue_X != NULL)\n         *blue_X = png_float(png_ptr, XYZ.blue_X, \"cHRM blue X\");\n      if (blue_Y != NULL)\n         *blue_Y = png_float(png_ptr, XYZ.blue_Y, \"cHRM blue Y\");\n      if (blue_Z != NULL)\n         *blue_Z = png_float(png_ptr, XYZ.blue_Z, \"cHRM blue Z\");\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 558,
      "line_end": 593,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple getter-style helper: checks pointers, calls png_XYZ_from_xy and png_float and writes to output pointers. Low cyclomatic complexity, no parsing of external input or raw memory manipulation. Useful only as part of larger PNG parsing targets, not a high-value standalone fuzz target."
    },
    {
      "name": "png_set_background_fixed",
      "clean_name": "png_set_background_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_BACKGROUND_SUPPORTED\n/* Handle alpha and tRNS via a background color */\nvoid PNGFAPI\npng_set_background_fixed(png_structrp png_ptr,\n    png_const_color_16p background_color, int background_gamma_code,\n    int need_expand, png_fixed_point background_gamma)\n{\n   png_debug(1, \"in png_set_background_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0 || background_color == NULL)\n      return;\n\n   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)\n   {\n      png_warning(png_ptr, \"Application must supply a known background gamma\");\n      return;\n   }\n\n   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;\n   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;\n   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;\n\n   png_ptr->background = *background_color;\n   png_ptr->background_gamma = background_gamma;\n   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);\n   if (need_expand != 0)\n      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;\n   else\n      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n}\n",
      "line_start": 141,
      "line_end": 168,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple setter/configuration function: only validates a pointer and a gamma code, sets flags and copies a small color struct. No parsing of complex external input, no loops, no memory-manipulation vulnerabilities or high branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_cHRM_XYZ_fixed",
      "clean_name": "png_set_cHRM_XYZ_fixed",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n   info_ptr->valid |= PNG_INFO_cHRM;\n}\n\nvoid PNGFAPI\npng_set_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_fixed_point int_red_X, png_fixed_point int_red_Y,\n    png_fixed_point int_red_Z, png_fixed_point int_green_X,\n    png_fixed_point int_green_Y, png_fixed_point int_green_Z,\n    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,\n    png_fixed_point int_blue_Z)\n{\n   png_XYZ XYZ;\n   png_xy xy;\n\n   png_debug1(1, \"in %s storage function\", \"cHRM XYZ fixed\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   XYZ.red_X = int_red_X;\n   XYZ.red_Y = int_red_Y;\n   XYZ.red_Z = int_red_Z;\n   XYZ.green_X = int_green_X;\n   XYZ.green_Y = int_green_Y;\n   XYZ.green_Z = int_green_Z;\n   XYZ.blue_X = int_blue_X;\n   XYZ.blue_Y = int_blue_Y;\n   XYZ.blue_Z = int_blue_Z;\n\n   if (png_xy_from_XYZ(&xy, &XYZ) == 0)\n   {\n      info_ptr->cHRM = xy;\n      info_ptr->valid |= PNG_INFO_cHRM;\n   }\n\n   else\n      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n}\n",
      "line_start": 61,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple setter: copies fixed-point inputs into a struct, calls a single conversion/validation helper, and sets flags or reports an error. It has minimal branching, no parsing of complex external input, no unsafe memory ops, and thus low value as a primary fuzz target (the called png_xy_from_XYZ would be a better target)."
    },
    {
      "name": "png_set_cHRM_XYZ",
      "clean_name": "png_set_cHRM_XYZ",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "       png_fixed(png_ptr, blue_x, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_y, \"cHRM Blue Y\"));\n}\n\nvoid PNGAPI\npng_set_cHRM_XYZ(png_const_structrp png_ptr, png_inforp info_ptr, double red_X,\n    double red_Y, double red_Z, double green_X, double green_Y, double green_Z,\n    double blue_X, double blue_Y, double blue_Z)\n{\n   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,\n       png_fixed(png_ptr, red_X, \"cHRM Red X\"),\n       png_fixed(png_ptr, red_Y, \"cHRM Red Y\"),\n       png_fixed(png_ptr, red_Z, \"cHRM Red Z\"),\n       png_fixed(png_ptr, green_X, \"cHRM Green X\"),\n       png_fixed(png_ptr, green_Y, \"cHRM Green Y\"),\n       png_fixed(png_ptr, green_Z, \"cHRM Green Z\"),\n       png_fixed(png_ptr, blue_X, \"cHRM Blue X\"),\n       png_fixed(png_ptr, blue_Y, \"cHRM Blue Y\"),\n       png_fixed(png_ptr, blue_Z, \"cHRM Blue Z\"));\n}\n",
      "line_start": 114,
      "line_end": 129,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple wrapper that converts double parameters to fixed-point and forwards them to png_set_cHRM_XYZ_fixed. Minimal logic/branching, no parsing of complex external formats or raw memory operations\u2014low-value fuzz target."
    },
    {
      "name": "png_set_sCAL",
      "clean_name": "png_set_sCAL",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_sCAL;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_sCAL(png_const_structrp png_ptr, png_inforp info_ptr, int unit,\n    double width, double height)\n{\n   png_debug1(1, \"in %s storage function\", \"sCAL\");\n\n   /* Check the arguments. */\n   if (width <= 0)\n      png_warning(png_ptr, \"Invalid sCAL width ignored\");\n\n   else if (height <= 0)\n      png_warning(png_ptr, \"Invalid sCAL height ignored\");\n\n   else\n   {\n      /* Convert 'width' and 'height' to ASCII. */\n      char swidth[PNG_sCAL_MAX_DIGITS+1];\n      char sheight[PNG_sCAL_MAX_DIGITS+1];\n\n      png_ascii_from_fp(png_ptr, swidth, (sizeof swidth), width,\n          PNG_sCAL_PRECISION);\n      png_ascii_from_fp(png_ptr, sheight, (sizeof sheight), height,\n          PNG_sCAL_PRECISION);\n\n      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);\n   }\n}\n",
      "line_start": 665,
      "line_end": 691,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple API setter: only basic bounds checks on two doubles, converts them to ASCII in fixed-size buffers and forwards to png_set_sCAL_s. Low cyclomatic complexity, no complex parsing or input-dependent loops \u2014 limited fuzz value (small attack surface)."
    },
    {
      "name": "png_set_compression_buffer_size",
      "clean_name": "png_set_compression_buffer_size",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      info_ptr->valid |= PNG_INFO_IDAT;\n}\n#endif\n\nvoid PNGAPI\npng_set_compression_buffer_size(png_structrp png_ptr, size_t size)\n{\n   png_debug(1, \"in png_set_compression_buffer_size\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (size == 0 || size > PNG_UINT_31_MAX)\n      png_error(png_ptr, \"invalid compression buffer size\");\n\n#  ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n   {\n      png_ptr->IDAT_read_size = (png_uint_32)size; /* checked above */\n      return;\n   }\n#  endif\n\n#  ifdef PNG_WRITE_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n   {\n      if (png_ptr->zowner != 0)\n      {\n         png_warning(png_ptr,\n             \"Compression buffer size cannot be changed because it is in use\");\n\n         return;\n      }\n\n#ifndef __COVERITY__\n      /* Some compilers complain that this is always false.  However, it\n       * can be true when integer overflow happens.\n       */\n      if (size > ZLIB_IO_MAX)\n      {\n         png_warning(png_ptr,\n             \"Compression buffer size limited to system maximum\");\n         size = ZLIB_IO_MAX; /* must fit */\n      }\n#endif\n\n      if (size < 6)\n      {\n         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH\n          * if this is permitted.\n          */\n         png_warning(png_ptr,\n             \"Compression buffer size cannot be reduced below 6\");\n\n         return;\n      }\n\n      if (png_ptr->zbuffer_size != size)\n      {\n         png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);\n         png_ptr->zbuffer_size = (uInt)size;\n      }\n   }\n#  endif\n}\n",
      "line_start": 1725,
      "line_end": 1785,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple setter-style function: it validates a size parameter and updates internal fields with a few branches and warnings. It does not parse complex external data or perform heavy memory operations on untrusted content (only frees an existing buffer list), has low cyclomatic complexity, and offers limited fuzzing value beyond exercising API-boundary validation."
    },
    {
      "name": "pngset.c:check_location",
      "clean_name": "check_location",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* sPLT */\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\nstatic png_byte\ncheck_location(png_const_structrp png_ptr, int location)\n{\n   location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);\n\n   /* New in 1.6.0; copy the location and check it.  This is an API\n    * change; previously the app had to use the\n    * png_set_unknown_chunk_location API below for each chunk.\n    */\n   if (location == 0 && (png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n   {\n      /* Write struct, so unknown chunks come from the app */\n      png_app_warning(png_ptr,\n          \"png_set_unknown_chunks now expects a valid location\");\n      /* Use the old behavior */\n      location = (png_byte)(png_ptr->mode &\n          (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));\n   }\n\n   /* This need not be an internal error - if the app calls\n    * png_set_unknown_chunks on a read pointer it must get the location right.\n    */\n   if (location == 0)\n      png_error(png_ptr, \"invalid location in png_set_unknown_chunks\");\n\n   /* Now reduce the location to the top-most set bit by removing each least\n    * significant bit in turn.\n    */\n   while (location != (location & -location))\n      location &= ~(location & -location);\n\n   /* The cast is safe because 'location' is a bit mask and only the low four\n    * bits are significant.\n    */\n   return (png_byte)location;\n}\n",
      "line_start": 1319,
      "line_end": 1354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 39,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple helper that canonicalizes a small bitmask and validates it against png_ptr->mode. Low complexity, no parsing of complex external formats, no memory ops on untrusted data, and limited control-flow dependent on input."
    },
    {
      "name": "png_set_crc_action",
      "clean_name": "png_set_crc_action",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "\n#ifdef PNG_READ_SUPPORTED\n\n/* Set the action on getting a CRC error for an ancillary or critical chunk. */\nvoid PNGAPI\npng_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)\n{\n   png_debug(1, \"in png_set_crc_action\");\n\n   if (png_ptr == NULL)\n      return;\n\n   /* Tell libpng how we react to CRC errors in critical chunks */\n   switch (crit_action)\n   {\n      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                               /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |\n                           PNG_FLAG_CRC_CRITICAL_IGNORE;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */\n         png_warning(png_ptr,\n             \"Can't discard critical data on CRC error\");\n         /* FALLTHROUGH */\n      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;\n         break;\n   }\n\n   /* Tell libpng how we react to CRC errors in ancillary chunks */\n   switch (ancil_action)\n   {\n      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */\n         break;\n\n      case PNG_CRC_WARN_USE:                              /* Warn/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;\n         break;\n\n      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |\n                           PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;\n         break;\n\n      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */\n\n      case PNG_CRC_DEFAULT:\n      default:\n         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;\n         break;\n   }\n}\n",
      "line_start": 40,
      "line_end": 106,
      "execution_count": 179,
      "covered_regions": 35,
      "total_regions": 129,
      "coverage_percent": 27.13,
      "is_covered": true,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple configuration setter: takes two ints and updates flag bits in the png struct via small switch statements. No parsing of external data, no memory or buffer operations, no loops, and low cyclomatic complexity \u2014 limited direct attack surface (could only influence later behavior), so low-priority as a fuzz target."
    },
    {
      "name": "png_data_freer",
      "clean_name": "png_data_freer",
      "source_file": "/src/libpng/png.c",
      "source_code": "   /* Set everything to 0 */\n   memset(info_ptr, 0, (sizeof *info_ptr));\n}\n\nvoid PNGAPI\npng_data_freer(png_const_structrp png_ptr, png_inforp info_ptr,\n    int freer, png_uint_32 mask)\n{\n   png_debug(1, \"in png_data_freer\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (freer == PNG_DESTROY_WILL_FREE_DATA)\n      info_ptr->free_me |= mask;\n\n   else if (freer == PNG_USER_WILL_FREE_DATA)\n      info_ptr->free_me &= ~mask;\n\n   else\n      png_error(png_ptr, \"Unknown freer parameter in png_data_freer\");\n}\n",
      "line_start": 460,
      "line_end": 477,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple state-modifying helper: validates pointers and an enum-like 'freer' argument, then sets/clears bits in info_ptr->free_me. No parsing of external formats, no memory copies, no loops or complex branching \u2014 low fuzz value."
    },
    {
      "name": "png_convert_to_rfc1123",
      "clean_name": "png_convert_to_rfc1123",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* Original API that uses a private buffer in png_struct.\n * Deprecated because it causes png_struct to carry a spurious temporary\n * buffer (png_struct::time_buffer), better to have the caller pass this in.\n */\npng_const_charp PNGAPI\npng_convert_to_rfc1123(png_structrp png_ptr, png_const_timep ptime)\n{\n   if (png_ptr != NULL)\n   {\n      /* The only failure above if png_ptr != NULL is from an invalid ptime */\n      if (png_convert_to_rfc1123_buffer(png_ptr->time_buffer, ptime) == 0)\n         png_warning(png_ptr, \"Ignoring invalid time value\");\n\n      else\n         return png_ptr->time_buffer;\n   }\n\n   return NULL;\n}\n",
      "line_start": 792,
      "line_end": 806,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple deprecated wrapper: only checks png_ptr, calls png_convert_to_rfc1123_buffer and returns an internal buffer or NULL. It has minimal logic/branching, no parsing, loops, or direct memory manipulation here; the real complexity/risk is in the called function, so this is low-priority as a fuzz target."
    },
    {
      "name": "png_reset_zstream",
      "clean_name": "png_reset_zstream",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* SET_UNKNOWN_CHUNKS */\n\n#ifdef PNG_READ_SUPPORTED\n/* This function, added to libpng-1.0.6g, is untested. */\nint PNGAPI\npng_reset_zstream(png_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return Z_STREAM_ERROR;\n\n   /* WARNING: this resets the window bits to the maximum! */\n   return inflateReset(&png_ptr->zstream);\n}\n",
      "line_start": 975,
      "line_end": 983,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: only checks png_ptr for NULL and calls inflateReset on an internal zstream. No parsing or memory manipulation of external data, minimal branching and logic\u2014low-value fuzz target."
    },
    {
      "name": "png_gamma_correct",
      "clean_name": "png_gamma_correct",
      "source_file": "/src/libpng/png.c",
      "source_code": " * png_struct, interpreting values as 8-bit or 16-bit.  While the result\n * is nominally a 16-bit value if bit depth is 8 then the result is\n * 8-bit (as are the arguments.)\n */\npng_uint_16 /* PRIVATE */\npng_gamma_correct(png_structrp png_ptr, unsigned int value,\n    png_fixed_point gamma_val)\n{\n   if (png_ptr->bit_depth == 8)\n      return png_gamma_8bit_correct(value, gamma_val);\n\n#ifdef PNG_16BIT_SUPPORTED\n   else\n      return png_gamma_16bit_correct(value, gamma_val);\n#else\n      /* should not reach this */\n      return 0;\n#endif /* 16BIT */\n}\n",
      "line_start": 3352,
      "line_end": 3366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that just checks bit_depth and dispatches to 8-/16-bit routines. Very low cyclomatic complexity, no direct parsing or memory ops here \u2014 the real risk/complexity is in the called functions, so this is a low-value fuzz target on its own."
    },
    {
      "name": "png_set_option",
      "clean_name": "png_set_option",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* READ_GAMMA */\n\n/* HARDWARE OR SOFTWARE OPTION SUPPORT */\n#ifdef PNG_SET_OPTION_SUPPORTED\nint PNGAPI\npng_set_option(png_structrp png_ptr, int option, int onoff)\n{\n   if (png_ptr != NULL && option >= 0 && option < PNG_OPTION_NEXT &&\n      (option & 1) == 0)\n   {\n      png_uint_32 mask = 3U << option;\n      png_uint_32 setting = (2U + (onoff != 0)) << option;\n      png_uint_32 current = png_ptr->options;\n\n      png_ptr->options = (png_uint_32)((current & ~mask) | setting);\n\n      return (int)(current & mask) >> option;\n   }\n\n   return PNG_OPTION_INVALID;\n}\n",
      "line_start": 3765,
      "line_end": 3781,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: only bounds-checked integer/bitfield manipulation on a struct field. No parsing of external formats, no memory copies, no loops or complex branching. Low value as a fuzz target."
    },
    {
      "name": "png_image_error",
      "clean_name": "png_image_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "      image->opaque = NULL;\n   }\n}\n\nint /* PRIVATE */\npng_image_error(png_imagep image, png_const_charp error_message)\n{\n   /* Utility to log an error. */\n   png_safecat(image->message, (sizeof image->message), 0, error_message);\n   image->warning_or_error |= PNG_IMAGE_ERROR;\n   png_image_free(image);\n   return 0;\n}\n",
      "line_start": 4030,
      "line_end": 4038,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that logs an error and frees the image. It performs a single safe string append and sets a flag, with no parsing, branching, loops, or complex memory manipulation. Limited value as a fuzz target beyond exercising trivial error-flow and potential double-free issues."
    },
    {
      "name": "png.c:png_safe_add",
      "clean_name": "png_safe_add",
      "source_file": "/src/libpng/png.c",
      "source_code": "   *error = 1;\n   return PNG_FP_1/2;\n}\n\nstatic int\npng_safe_add(png_int_32 *addend0_and_result, png_int_32 addend1,\n      png_int_32 addend2)\n{\n   /* Safely add three integers.  Returns 0 on success, 1 on overflow.  Does not\n    * set the result on overflow.\n    */\n   int error = 0;\n   int result = png_fp_add(*addend0_and_result,\n                           png_fp_add(addend1, addend2, &error),\n                           &error);\n   if (!error) *addend0_and_result = result;\n   return error;\n}\n",
      "line_start": 1113,
      "line_end": 1126,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that performs bounded integer addition with overflow checks and a single pointer write. Minimal branching and no parsing, memory-manipulation of untrusted buffers, or complex control flow \u2014 low direct value as a fuzz target (though it may be reached indirectly)."
    },
    {
      "name": "png.c:png_fp_add",
      "clean_name": "png_fp_add",
      "source_file": "/src/libpng/png.c",
      "source_code": "   }\n}\n\n#ifdef PNG_COLORSPACE_SUPPORTED\nstatic png_int_32\npng_fp_add(png_int_32 addend0, png_int_32 addend1, int *error)\n{\n   /* Safely add two fixed point values setting an error flag and returning 0.5\n    * on overflow.\n    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n    * relying on addition of two positive values producing a negative one is not\n    * safe.\n    */\n   if (addend0 > 0)\n   {\n      if (0x7fffffff - addend0 >= addend1)\n         return addend0+addend1;\n   }\n   else if (addend0 < 0)\n   {\n      if (-0x7fffffff - addend0 <= addend1)\n         return addend0+addend1;\n   }\n   else\n      return addend1;\n\n   *error = 1;\n   return PNG_FP_1/2;\n}\n",
      "line_start": 1066,
      "line_end": 1090,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Tiny helper that safely adds two fixed-point ints with simple overflow checks. No parsing of external formats, no memory/string operations, no loops, and only minimal branching \u2014 low attack surface and low value as an isolated fuzz target (might be exercised indirectly when fuzzing PNG code, but not high priority itself)."
    },
    {
      "name": "png.c:png_fp_sub",
      "clean_name": "png_fp_sub",
      "source_file": "/src/libpng/png.c",
      "source_code": "   *error = 1;\n   return PNG_FP_1/2;\n}\n\nstatic png_int_32\npng_fp_sub(png_int_32 addend0, png_int_32 addend1, int *error)\n{\n   /* As above but calculate addend0-addend1. */\n   if (addend1 > 0)\n   {\n      if (-0x7fffffff + addend1 <= addend0)\n         return addend0-addend1;\n   }\n   else if (addend1 < 0)\n   {\n      if (0x7fffffff + addend1 >= addend0)\n         return addend0-addend1;\n   }\n   else\n      return addend0;\n\n   *error = 1;\n   return PNG_FP_1/2;\n}\n",
      "line_start": 1092,
      "line_end": 1111,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that performs integer subtraction with overflow checks. No parsing of complex external input, no memory or buffer operations, and only limited branching \u2014 low value as a standalone fuzz target (may be exercised indirectly)."
    },
    {
      "name": "png.c:icc_check_length",
      "clean_name": "icc_check_length",
      "source_file": "/src/libpng/png.c",
      "source_code": " */\nstatic const png_byte D50_nCIEXYZ[12] =\n   { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };\n\nstatic int /* bool */\nicc_check_length(png_const_structrp png_ptr, png_const_charp name,\n   png_uint_32 profile_length)\n{\n   if (profile_length < 132)\n      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n   return 1;\n}\n",
      "line_start": 1581,
      "line_end": 1588,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple single-length validation: only compares profile_length against a constant and reports an error. No parsing, memory ops, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png.c:is_ICC_signature",
      "clean_name": "is_ICC_signature",
      "source_file": "/src/libpng/png.c",
      "source_code": "   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||\n      (it >= 97 && it <= 122);\n}\n\nstatic int\nis_ICC_signature(png_alloc_size_t it)\n{\n   return is_ICC_signature_char(it >> 24) /* checks all the top bits */ &&\n      is_ICC_signature_char((it >> 16) & 0xff) &&\n      is_ICC_signature_char((it >> 8) & 0xff) &&\n      is_ICC_signature_char(it & 0xff);\n}\n",
      "line_start": 1526,
      "line_end": 1533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "A small helper that checks four bytes for ASCII alnum/space. Low complexity, no memory manipulation, no parsing of complex formats or branching on input \u2014 minimal value as a standalone fuzz target."
    },
    {
      "name": "png.c:is_ICC_signature_char",
      "clean_name": "is_ICC_signature_char",
      "source_file": "/src/libpng/png.c",
      "source_code": "   name[4] = png_icc_tag_char(tag      );\n   name[5] = '\\'';\n}\n\nstatic int\nis_ICC_signature_char(png_alloc_size_t it)\n{\n   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||\n      (it >= 97 && it <= 122);\n}\n",
      "line_start": 1519,
      "line_end": 1524,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial character-class checker: simple comparisons on a single input value with no loops, memory operations, or parsing. Minimal fuzz value beyond being a tiny helper used elsewhere."
    },
    {
      "name": "png.c:png_icc_tag_char",
      "clean_name": "png_icc_tag_char",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* COLORSPACE */\n\n#ifdef PNG_READ_iCCP_SUPPORTED\n/* Error message generation */\nstatic char\npng_icc_tag_char(png_uint_32 byte)\n{\n   byte &= 0xff;\n   if (byte >= 32 && byte <= 126)\n      return (char)byte;\n   else\n      return '?';\n}\n",
      "line_start": 1498,
      "line_end": 1506,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial helper that masks a value to 8 bits and maps it to a printable ASCII character or '?'. Minimal branching, no buffer/memory operations or parsing of complex external input \u2014 low value as a fuzz target."
    },
    {
      "name": "png.c:have_chromaticities",
      "clean_name": "have_chromaticities",
      "source_file": "/src/libpng/png.c",
      "source_code": "#endif /* READ_iCCP */\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n#if (defined PNG_READ_mDCV_SUPPORTED) || (defined PNG_READ_cHRM_SUPPORTED)\nstatic int\nhave_chromaticities(png_const_structrp png_ptr)\n{\n   /* Handle new PNGv3 chunks and the precedence rules to determine whether\n    * png_struct::chromaticities must be processed.  Only required for RGB to\n    * gray.\n    *\n    * mDCV: this is the mastering colour space and it is independent of the\n    *       encoding so it needs to be used regardless of the encoded space.\n    *\n    * cICP: first in priority but not yet implemented - the chromaticities come\n    *       from the 'primaries'.\n    *\n    * iCCP: not supported by libpng (so ignored)\n    *\n    * sRGB: the defaults match sRGB\n    *\n    * cHRM: calculate the coefficients\n    */\n#  ifdef PNG_READ_mDCV_SUPPORTED\n      if (png_has_chunk(png_ptr, mDCV))\n         return 1;\n#     define check_chromaticities 1\n#  endif /*mDCV*/\n\n#  ifdef PNG_READ_sRGB_SUPPORTED\n      if (png_has_chunk(png_ptr, sRGB))\n         return 0;\n#  endif /*sRGB*/\n\n#  ifdef PNG_READ_cHRM_SUPPORTED\n      if (png_has_chunk(png_ptr, cHRM))\n         return 1;\n#     define check_chromaticities 1\n#  endif /*cHRM*/\n\n   return 0; /* sRGB defaults */\n}\n",
      "line_start": 1842,
      "line_end": 1879,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Small helper that only checks presence of specific PNG chunks and returns a boolean. Low cyclomatic complexity, no parsing or memory operations on untrusted data, minimal attack surface \u2014 low priority as a fuzz target."
    },
    {
      "name": "png_error",
      "clean_name": "png_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * you should supply a replacement error function and use png_set_error_fn()\n * to replace the error function at run-time.\n */\n#ifdef PNG_ERROR_TEXT_SUPPORTED\nPNG_FUNCTION(void,PNGAPI\npng_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n   if (png_ptr != NULL && png_ptr->error_fn != NULL)\n      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),\n          error_message);\n\n   /* If the custom handler doesn't exist, or if it returns,\n      use the default handler, which will not return. */\n   png_default_error(png_ptr, error_message);\n}\n",
      "line_start": 38,
      "line_end": 49,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/error-dispatch function: it just invokes a callback and the default aborting handler, with no parsing, memory manipulation, loops, or branching on untrusted data. Low value as a fuzz target."
    },
    {
      "name": "png_safecat",
      "clean_name": "png_safecat",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "\n/* Utility to safely appends strings to a buffer.  This never errors out so\n * error checking is not required in the caller.\n */\nsize_t\npng_safecat(png_charp buffer, size_t bufsize, size_t pos,\n    png_const_charp string)\n{\n   if (buffer != NULL && pos < bufsize)\n   {\n      if (string != NULL)\n         while (*string != '\\0' && pos < bufsize-1)\n           buffer[pos++] = *string++;\n\n      buffer[pos] = '\\0';\n   }\n\n   return pos;\n}\n",
      "line_start": 71,
      "line_end": 85,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "A trivial safe string-append helper with minimal logic and branching. It does simple character copying into a provided buffer (no complex parsing, crypto, or protocol handling) and presents a very small attack surface\u2014useful as a regression target but low priority for fuzzing."
    },
    {
      "name": "png_warning",
      "clean_name": "png_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * should not be changed.  If there is a need to handle warnings differently,\n * you should supply a replacement warning function and use\n * png_set_error_fn() to replace the warning function at run-time.\n */\nvoid PNGAPI\npng_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n   int offset = 0;\n   if (png_ptr != NULL && png_ptr->warning_fn != NULL)\n      (*(png_ptr->warning_fn))(png_constcast(png_structrp,png_ptr),\n          warning_message + offset);\n   else\n      png_default_warning(png_ptr, warning_message + offset);\n}\n",
      "line_start": 175,
      "line_end": 184,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: no parsing, no buffer/memory manipulation, no loops or complex branching. It merely forwards a string to a user/default callback (offset is unused). Low value as a fuzz target \u2014 minimal logic to exercise and no direct processing of untrusted data (though the callback it calls could be interesting separately)."
    },
    {
      "name": "png_warning_parameter_signed",
      "clean_name": "png_warning_parameter_signed",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));\n}\n\nvoid\npng_warning_parameter_signed(png_warning_parameters p, int number, int format,\n    png_int_32 value)\n{\n   png_alloc_size_t u;\n   png_charp str;\n   char buffer[PNG_NUMBER_BUFFER_SIZE] = {0};\n\n   /* Avoid overflow by doing the negate in a png_alloc_size_t: */\n   u = (png_alloc_size_t)value;\n   if (value < 0)\n      u = ~u + 1;\n\n   str = PNG_FORMAT_NUMBER(buffer, format, u);\n\n   if (value < 0 && str > buffer)\n      *--str = '-';\n\n   png_warning_parameter(p, number, str);\n}\n",
      "line_start": 207,
      "line_end": 226,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that formats an integer into a local buffer and calls a warning handler. Minimal branching and no complex parsing of external data; low attack surface. The only potential risks depend on PNG_FORMAT_NUMBER or png_warning_parameter implementations, but this function itself is low-value as a fuzz target."
    },
    {
      "name": "png_benign_error",
      "clean_name": "png_benign_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif /* WARNINGS */\n\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\nvoid PNGAPI\npng_benign_error(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)\n   {\n#     ifdef PNG_READ_SUPPORTED\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n            png_ptr->chunk_name != 0)\n            png_chunk_warning(png_ptr, error_message);\n         else\n#     endif\n      png_warning(png_ptr, error_message);\n   }\n\n   else\n   {\n#     ifdef PNG_READ_SUPPORTED\n         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n            png_ptr->chunk_name != 0)\n            png_chunk_error(png_ptr, error_message);\n         else\n#     endif\n      png_error(png_ptr, error_message);\n   }\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 306,
      "line_end": 334,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 39,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that routes an error_message to warning/error handlers based on flags and mode. Minimal branching and no parsing or memory manipulation of untrusted data, so low value as a fuzz target."
    },
    {
      "name": "png_app_warning",
      "clean_name": "png_app_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "      PNG_UNUSED(error_message)\n#  endif\n}\n\nvoid /* PRIVATE */\npng_app_warning(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_APP_WARNINGS_WARN) != 0)\n      png_warning(png_ptr, error_message);\n   else\n      png_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 336,
      "line_end": 347,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small wrapper: it just checks a flag and calls png_warning or png_error. No parsing of external input, no memory/ buffer ops, no loops or complex branching. Minimal logic makes it a low-value fuzz target (though png_error may abort/longjmp, the function itself offers little surface for finding memory bugs)."
    },
    {
      "name": "png_app_error",
      "clean_name": "png_app_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "      PNG_UNUSED(error_message)\n#  endif\n}\n\nvoid /* PRIVATE */\npng_app_error(png_const_structrp png_ptr, png_const_charp error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN) != 0)\n      png_warning(png_ptr, error_message);\n   else\n      png_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 349,
      "line_end": 360,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that routes to png_warning or png_error based on an internal flag; no parsing, memory manipulation, or complex input-dependent logic. Minimal value as a standalone fuzz target (low priority)."
    },
    {
      "name": "png_chunk_benign_error",
      "clean_name": "png_chunk_benign_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "#endif /* WARNINGS */\n\n#ifdef PNG_READ_SUPPORTED\n#ifdef PNG_BENIGN_ERRORS_SUPPORTED\nvoid PNGAPI\npng_chunk_benign_error(png_const_structrp png_ptr, png_const_charp\n    error_message)\n{\n   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)\n      png_chunk_warning(png_ptr, error_message);\n\n   else\n      png_chunk_error(png_ptr, error_message);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n      PNG_UNUSED(error_message)\n#  endif\n}\n",
      "line_start": 458,
      "line_end": 471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/dispatcher: checks a flag and calls either png_chunk_warning or png_chunk_error. Minimal logic and branching, no parsing of external input, no memory manipulation or complex control flow \u2014 low-value fuzz target on its own."
    },
    {
      "name": "png_chunk_report",
      "clean_name": "png_chunk_report",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "}\n#endif\n#endif /* READ */\n\nvoid /* PRIVATE */\npng_chunk_report(png_const_structrp png_ptr, png_const_charp message, int error)\n{\n#  ifndef PNG_WARNINGS_SUPPORTED\n      PNG_UNUSED(message)\n#  endif\n\n   /* This is always supported, but for just read or just write it\n    * unconditionally does the right thing.\n    */\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\n      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n#  endif\n\n#  ifdef PNG_READ_SUPPORTED\n      {\n         if (error < PNG_CHUNK_ERROR)\n            png_chunk_warning(png_ptr, message);\n\n         else\n            png_chunk_benign_error(png_ptr, message);\n      }\n#  endif\n\n#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)\n      else if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)\n#  endif\n\n#  ifdef PNG_WRITE_SUPPORTED\n      {\n         if (error < PNG_CHUNK_WRITE_ERROR)\n            png_app_warning(png_ptr, message);\n\n         else\n            png_app_error(png_ptr, message);\n      }\n#  endif\n}\n",
      "line_start": 475,
      "line_end": 512,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/dispatcher: selects which logging routine to call based on png_ptr->mode and error level. No parsing of complex external formats, no memory ops on untrusted data, and very low cyclomatic complexity \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_error_ptr",
      "clean_name": "png_get_error_ptr",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "/* This function returns a pointer to the error_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\npng_voidp PNGAPI\npng_get_error_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return (png_voidp)png_ptr->error_ptr;\n}\n",
      "line_start": 735,
      "line_end": 742,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only a NULL check and returns png_ptr->error_ptr. No parsing, no memory operations on untrusted data, minimal logic \u2014 low-value fuzz target."
    },
    {
      "name": "png_safe_warning",
      "clean_name": "png_safe_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "   abort();\n}\n\n#ifdef PNG_WARNINGS_SUPPORTED\nvoid /* PRIVATE */ PNGCBAPI\npng_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)\n{\n   png_const_structrp png_ptr = png_nonconst_ptr;\n   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);\n\n   /* A warning is only logged if there is no prior warning or error. */\n   if (image->warning_or_error == 0)\n   {\n      png_safecat(image->message, (sizeof image->message), 0, warning_message);\n      image->warning_or_error |= PNG_IMAGE_WARNING;\n   }\n}\n",
      "line_start": 796,
      "line_end": 808,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that conditionally appends a warning string into a fixed-size buffer using a safe concat routine. Minimal control flow and low complexity; limited value as a fuzz target."
    },
    {
      "name": "pngerror.c:png_default_warning",
      "clean_name": "png_default_warning",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * it can continue anyway.  Replacement functions don't have to do anything\n * here if you don't want them to.  In the default configuration, png_ptr is\n * not used, but it is passed in case it may be useful.\n */\nstatic void /* PRIVATE */\npng_default_warning(png_const_structrp png_ptr, png_const_charp warning_message)\n{\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n   fprintf(stderr, \"libpng warning: %s\", warning_message);\n   fprintf(stderr, PNG_STRING_NEWLINE);\n#else\n   PNG_UNUSED(warning_message) /* Make compiler happy */\n#endif\n   PNG_UNUSED(png_ptr) /* Make compiler happy */\n}\n",
      "line_start": 696,
      "line_end": 706,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper that prints a provided string; contains no parsing, memory manipulation, loops, or branching. Minimal attack surface (uses fprintf with %s), so only low fuzzing value."
    },
    {
      "name": "png_get_valid",
      "clean_name": "png_get_valid",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#include \"pngpriv.h\"\n\n#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n\npng_uint_32 PNGAPI\npng_get_valid(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 flag)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n   {\n#ifdef PNG_READ_tRNS_SUPPORTED\n      /* png_handle_PLTE() may have canceled a valid tRNS chunk but left the\n       * 'valid' flag for the detection of duplicate chunks. Do not report a\n       * valid tRNS chunk in this case.\n       */\n      if (flag == PNG_INFO_tRNS && png_ptr->num_trans == 0)\n         return 0;\n#endif\n\n      return info_ptr->valid & flag;\n   }\n\n   return 0;\n}\n",
      "line_start": 18,
      "line_end": 37,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: performs null checks and returns info_ptr->valid & flag (with a small compile-time tRNS special-case). No parsing, no memory operations, no loops or complex control flow \u2014 minimal attack surface and low value as a fuzz target."
    },
    {
      "name": "png_get_rows",
      "clean_name": "png_get_rows",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\npng_bytepp PNGAPI\npng_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->row_pointers;\n\n   return 0;\n}\n",
      "line_start": 49,
      "line_end": 56,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: performs only null checks and returns info_ptr->row_pointers. No parsing, memory operations, or branching on external data \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_image_height",
      "clean_name": "png_get_image_height",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_image_height(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->height;\n\n   return 0;\n}\n",
      "line_start": 70,
      "line_end": 77,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: trivial null-check and return of info_ptr->height. No parsing, memory ops, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_color_type",
      "clean_name": "png_get_color_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_color_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->color_type;\n\n   return 0;\n}\n",
      "line_start": 88,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: returns info_ptr->color_type after a null check. No parsing, no memory operations, no branching or loops on external input \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_filter_type",
      "clean_name": "png_get_filter_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_filter_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->filter_type;\n\n   return 0;\n}\n",
      "line_start": 97,
      "line_end": 104,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only checks for NULL and returns a single struct field. No parsing, no memory operations, no complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_interlace_type",
      "clean_name": "png_get_interlace_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_interlace_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->interlace_type;\n\n   return 0;\n}\n",
      "line_start": 106,
      "line_end": 113,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only checks for NULL and returns a single struct field (interlace_type). No parsing, memory operations, loops, or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_compression_type",
      "clean_name": "png_get_compression_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->compression_type;\n\n   return 0;\n}\n",
      "line_start": 115,
      "line_end": 122,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: just returns a compression_type field if pointers are non-NULL. No parsing, no memory operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_x_pixels_per_meter",
      "clean_name": "png_get_x_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\n   info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_x_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n         return info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 124,
      "line_end": 143,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers and a validity flag then returns a struct field. No parsing, no memory operations, no loops or complex branching, so low value as a fuzz target."
    },
    {
      "name": "png_get_y_pixels_per_meter",
      "clean_name": "png_get_y_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_y_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp\n    info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_y_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)\n         return info_ptr->y_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 145,
      "line_end": 164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: conditionally returns a struct field or 0. No parsing of external input, no memory ops, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_pixels_per_meter",
      "clean_name": "png_get_pixels_per_meter",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixels_per_meter\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER &&\n          info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit)\n         return info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 166,
      "line_end": 185,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: it checks pointers and a few struct fields and returns a value. No parsing of external input, no memory operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_pixel_aspect_ratio",
      "clean_name": "png_get_pixel_aspect_ratio",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_pixel_aspect_ratio(png_const_structrp png_ptr, png_const_inforp\n   info_ptr)\n{\n#ifdef PNG_READ_pHYs_SUPPORTED\n   png_debug(1, \"in png_get_pixel_aspect_ratio\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (info_ptr->x_pixels_per_unit != 0)\n         return (float)info_ptr->y_pixels_per_unit\n              / (float)info_ptr->x_pixels_per_unit;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return (float)0.0;\n}\n",
      "line_start": 188,
      "line_end": 208,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that computes a float ratio from already-parsed struct fields with a trivial null/zero check; no parsing of external input, no memory operations or complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_x_offset_microns",
      "clean_name": "png_get_x_offset_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n#endif\n\npng_int_32 PNGAPI\npng_get_x_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_x_offset_microns\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\n         return info_ptr->x_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 243,
      "line_end": 261,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks for NULL and a flag then returns a field. No parsing, no memory operations, no loops or complex branching, and not security-critical \u2014 low priority as a fuzz target."
    },
    {
      "name": "png_get_y_offset_microns",
      "clean_name": "png_get_y_offset_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_y_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_y_offset_microns\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)\n         return info_ptr->y_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 263,
      "line_end": 281,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple getter: only checks pointers/flags and returns a stored y_offset when unit type is MICROMETER. No parsing of external data, no memory operations, no loops, and only trivial branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_x_offset_pixels",
      "clean_name": "png_get_x_offset_pixels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_x_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_x_offset_pixels\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\n         return info_ptr->x_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 283,
      "line_end": 301,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only checks flags and returns a struct field (or 0). No parsing, loops, memory operations, or complex branching; minimal value as a fuzz target."
    },
    {
      "name": "png_get_y_offset_pixels",
      "clean_name": "png_get_y_offset_pixels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_int_32 PNGAPI\npng_get_y_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n#ifdef PNG_oFFs_SUPPORTED\n   png_debug(1, \"in png_get_y_offset_pixels\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0)\n   {\n      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)\n         return info_ptr->y_offset;\n   }\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(info_ptr)\n#endif\n\n   return 0;\n}\n",
      "line_start": 303,
      "line_end": 321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers/flags and returns info_ptr->y_offset. No parsing, no loops, no memory operations or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_pixels_per_inch",
      "clean_name": "png_get_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n#endif\n}\n\npng_uint_32 PNGAPI\npng_get_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 356,
      "line_end": 360,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that just converts pixels-per-meter to pixels-per-inch by calling other functions. No parsing of external input, no memory operations, minimal logic \u2014 low fuzzing value (depends on upstream callers for risk)."
    },
    {
      "name": "png_get_x_pixels_per_inch",
      "clean_name": "png_get_x_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));\n}\n\npng_uint_32 PNGAPI\npng_get_x_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 362,
      "line_end": 366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper/accessor: just calls png_get_x_pixels_per_meter and ppi_from_ppm. No parsing, no memory operations, no branching or loops; minimal logic and low value as a standalone fuzz target."
    },
    {
      "name": "png_get_x_offset_inches_fixed",
      "clean_name": "png_get_x_offset_inches_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   png_warning(png_ptr, \"fixed point overflow ignored\");\n   return 0;\n}\n\npng_fixed_point PNGAPI\npng_get_x_offset_inches_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n   return png_fixed_inches_from_microns(png_ptr,\n       png_get_x_offset_microns(png_ptr, info_ptr));\n}\n",
      "line_start": 392,
      "line_end": 398,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: it just calls png_get_x_offset_microns and png_fixed_inches_from_microns and returns the result. No parsing, branching, loops, or direct memory operations here; any interesting behavior lives in the called functions, so this wrapper is a low-value fuzz target."
    },
    {
      "name": "png_get_y_offset_inches_fixed",
      "clean_name": "png_get_y_offset_inches_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif /* FIXED_POINT */\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\npng_fixed_point PNGAPI\npng_get_y_offset_inches_fixed(png_const_structrp png_ptr,\n    png_const_inforp info_ptr)\n{\n   return png_fixed_inches_from_microns(png_ptr,\n       png_get_y_offset_microns(png_ptr, info_ptr));\n}\n",
      "line_start": 402,
      "line_end": 408,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that just calls two helper functions; no parsing, no memory/buffer operations, and no branching \u2014 minimal value as a direct fuzz target (any risk would lie in the called functions)."
    },
    {
      "name": "png_get_y_offset_inches",
      "clean_name": "png_get_y_offset_inches",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_y_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   /* To avoid the overflow do the conversion directly in floating\n    * point.\n    */\n   return (float)(png_get_y_offset_microns(png_ptr, info_ptr) * .00003937);\n}\n",
      "line_start": 423,
      "line_end": 430,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: calls png_get_y_offset_microns and does a single floating-point multiplication. No parsing, memory operations, or branching; very low cyclomatic complexity. Not a good standalone fuzz target (any risk would be in the underlying call)."
    },
    {
      "name": "png_get_pHYs_dpi",
      "clean_name": "png_get_pHYs_dpi",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_pHYs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pHYs_dpi(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (res_x != NULL)\n      {\n         *res_x = info_ptr->x_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (res_y != NULL)\n      {\n         *res_y = info_ptr->y_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (unit_type != NULL)\n      {\n         *unit_type = (int)info_ptr->phys_unit_type;\n         retval |= PNG_INFO_pHYs;\n\n         if (*unit_type == 1)\n         {\n            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);\n            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);\n         }\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 434,
      "line_end": 471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: reads fields from an info struct and optionally does a small numeric conversion. No parsing of complex external input, no buffer or memory manipulation, no loops or branching of significance \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_channels",
      "clean_name": "png_get_channels",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n#endif /* EASY_ACCESS */\n\n\npng_byte PNGAPI\npng_get_channels(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->channels;\n\n   return 0;\n}\n",
      "line_start": 480,
      "line_end": 487,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only returns a struct field after a null check. No parsing, no memory operations, no input-dependent control flow \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_signature",
      "clean_name": "png_get_signature",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_READ_SUPPORTED\npng_const_bytep PNGAPI\npng_get_signature(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->signature;\n\n   return NULL;\n}\n",
      "line_start": 490,
      "line_end": 497,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks for NULL and returns an internal pointer to the signature. No parsing, no memory or buffer operations, no branching or loops on external data \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_bKGD",
      "clean_name": "png_get_bKGD",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_bKGD_SUPPORTED\npng_uint_32 PNGAPI\npng_get_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_color_16p *background)\n{\n   png_debug1(1, \"in %s retrieval function\", \"bKGD\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_bKGD) != 0 &&\n       background != NULL)\n   {\n      *background = &(info_ptr->background);\n      return PNG_INFO_bKGD;\n   }\n\n   return 0;\n}\n",
      "line_start": 501,
      "line_end": 516,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter: checks for NULL and a valid flag then returns a pointer to stored background data. No parsing, no memory operations on untrusted input, no loops or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_cHRM",
      "clean_name": "png_get_cHRM",
      "source_file": "/src/libpng/pngget.c",
      "source_code": " * same time to correct the rgb grayscale coefficient defaults obtained from the\n * cHRM chunk in 1.5.4\n */\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cHRM(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *whitex, double *whitey, double *redx, double *redy,\n    double *greenx, double *greeny, double *bluex, double *bluey)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n\n   /* PNGv3: this just returns the values store from the cHRM, if any. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n   {\n      if (whitex != NULL)\n         *whitex = png_float(png_ptr, info_ptr->cHRM.whitex, \"cHRM wx\");\n      if (whitey != NULL)\n         *whitey = png_float(png_ptr, info_ptr->cHRM.whitey, \"cHRM wy\");\n      if (redx   != NULL)\n         *redx   = png_float(png_ptr, info_ptr->cHRM.redx,   \"cHRM rx\");\n      if (redy   != NULL)\n         *redy   = png_float(png_ptr, info_ptr->cHRM.redy,   \"cHRM ry\");\n      if (greenx != NULL)\n         *greenx = png_float(png_ptr, info_ptr->cHRM.greenx, \"cHRM gx\");\n      if (greeny != NULL)\n         *greeny = png_float(png_ptr, info_ptr->cHRM.greeny, \"cHRM gy\");\n      if (bluex  != NULL)\n         *bluex  = png_float(png_ptr, info_ptr->cHRM.bluex,  \"cHRM bx\");\n      if (bluey  != NULL)\n         *bluey  = png_float(png_ptr, info_ptr->cHRM.bluey,  \"cHRM by\");\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 525,
      "line_end": 556,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter: it merely returns cHRM fields from an already-parsed info struct (with null checks) and calls a small conversion helper. No parsing of external input, no memory manipulation, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_cHRM_XYZ_fixed",
      "clean_name": "png_get_cHRM_XYZ_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,\n    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,\n    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,\n    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,\n    png_fixed_point *int_blue_Z)\n{\n   png_XYZ XYZ;\n   png_debug1(1, \"in %s retrieval function\", \"cHRM_XYZ\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0U &&\n       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n   {\n      if (int_red_X != NULL) *int_red_X = XYZ.red_X;\n      if (int_red_Y != NULL) *int_red_Y = XYZ.red_Y;\n      if (int_red_Z != NULL) *int_red_Z = XYZ.red_Z;\n      if (int_green_X != NULL) *int_green_X = XYZ.green_X;\n      if (int_green_Y != NULL) *int_green_Y = XYZ.green_Y;\n      if (int_green_Z != NULL) *int_green_Z = XYZ.green_Z;\n      if (int_blue_X != NULL) *int_blue_X = XYZ.blue_X;\n      if (int_blue_Y != NULL) *int_blue_Y = XYZ.blue_Y;\n      if (int_blue_Z != NULL) *int_blue_Z = XYZ.blue_Z;\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 597,
      "line_end": 625,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 65,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/wrapper: it mainly checks pointers/flags and calls png_XYZ_from_xy, then writes out fields to provided pointers. No parsing of external input, no loops or complex branching, no raw memory operations on untrusted buffers \u2014 low value as a standalone fuzz target."
    },
    {
      "name": "png_get_cHRM_fixed",
      "clean_name": "png_get_cHRM_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_cHRM_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *whitex, png_fixed_point *whitey, png_fixed_point *redx,\n    png_fixed_point *redy, png_fixed_point *greenx, png_fixed_point *greeny,\n    png_fixed_point *bluex, png_fixed_point *bluey)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cHRM\");\n\n   /* PNGv3: this just returns the values store from the cHRM, if any. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n   {\n      if (whitex != NULL) *whitex = info_ptr->cHRM.whitex;\n      if (whitey != NULL) *whitey = info_ptr->cHRM.whitey;\n      if (redx   != NULL) *redx   = info_ptr->cHRM.redx;\n      if (redy   != NULL) *redy   = info_ptr->cHRM.redy;\n      if (greenx != NULL) *greenx = info_ptr->cHRM.greenx;\n      if (greeny != NULL) *greeny = info_ptr->cHRM.greeny;\n      if (bluex  != NULL) *bluex  = info_ptr->cHRM.bluex;\n      if (bluey  != NULL) *bluey  = info_ptr->cHRM.bluey;\n      return PNG_INFO_cHRM;\n   }\n\n   return 0;\n}\n",
      "line_start": 627,
      "line_end": 651,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: checks pointers/flag and copies struct fields to outputs. No parsing of external input, no loops, no memory-manipulation on untrusted buffers and minimal branching\u2014low value as a fuzz target."
    },
    {
      "name": "png_get_gAMA_fixed",
      "clean_name": "png_get_gAMA_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_gAMA_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_gAMA_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *file_gamma)\n{\n   png_debug1(1, \"in %s retrieval function\", \"gAMA\");\n\n   /* PNGv3 compatibility: only report gAMA if it is really present. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n   {\n      if (file_gamma != NULL) *file_gamma = info_ptr->gamma;\n      return PNG_INFO_gAMA;\n   }\n\n   return 0;\n}\n",
      "line_start": 657,
      "line_end": 672,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: checks pointers and a flag, optionally copies a stored gamma value and returns a status. No parsing of external data, no memory-manipulation, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_gAMA",
      "clean_name": "png_get_gAMA",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_gAMA(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *file_gamma)\n{\n   png_debug1(1, \"in %s retrieval function\", \"gAMA(float)\");\n\n   /* PNGv3 compatibility: only report gAMA if it is really present. */\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n   {\n      if (file_gamma != NULL)\n         *file_gamma = png_float(png_ptr, info_ptr->gamma, \"gAMA\");\n\n      return PNG_INFO_gAMA;\n   }\n\n   return 0;\n}\n",
      "line_start": 676,
      "line_end": 693,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers/valid flag and optionally writes a double via png_float. Minimal logic, no parsing of external data, no loops or buffer manipulation \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_sRGB",
      "clean_name": "png_get_sRGB",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#  endif\n#endif\n\n#ifdef PNG_sRGB_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sRGB(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *file_srgb_intent)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sRGB\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n      (info_ptr->valid & PNG_INFO_sRGB) != 0)\n   {\n      if (file_srgb_intent != NULL)\n         *file_srgb_intent = info_ptr->rendering_intent;\n      return PNG_INFO_sRGB;\n   }\n\n   return 0;\n}\n",
      "line_start": 698,
      "line_end": 713,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: just checks pointers/flags and optionally writes an int. No parsing of external input, no memory/loop-intensive operations, and minimal branching \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_iCCP",
      "clean_name": "png_get_iCCP",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\npng_uint_32 PNGAPI\npng_get_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_charpp name, int *compression_type,\n    png_bytepp profile, png_uint_32 *proflen)\n{\n   png_debug1(1, \"in %s retrieval function\", \"iCCP\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_iCCP) != 0 &&\n       name != NULL && profile != NULL && proflen != NULL)\n   {\n      *name = info_ptr->iccp_name;\n      *profile = info_ptr->iccp_profile;\n      *proflen = png_get_uint_32(info_ptr->iccp_profile);\n      /* This is somewhat irrelevant since the profile data returned has\n       * actually been uncompressed.\n       */\n      if (compression_type != NULL)\n         *compression_type = PNG_COMPRESSION_TYPE_BASE;\n      return PNG_INFO_iCCP;\n   }\n\n   return 0;\n\n}\n",
      "line_start": 717,
      "line_end": 741,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a simple accessor/getter: it performs basic null/flag checks and returns pointers/lengths from an info struct. There is no parsing, looping, or complex branching and only a small read (png_get_uint_32) of stored data. Low value as a standalone fuzz target."
    },
    {
      "name": "png_get_sPLT",
      "clean_name": "png_get_sPLT",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\nint PNGAPI\npng_get_sPLT(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_sPLT_tpp spalettes)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sPLT\");\n\n   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)\n   {\n      *spalettes = info_ptr->splt_palettes;\n      return info_ptr->splt_palettes_num;\n   }\n\n   return 0;\n}\n",
      "line_start": 745,
      "line_end": 758,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only null checks and pointer assignment/return of internal sPLT palette count. No parsing, no memory manipulation on untrusted data, minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_cICP",
      "clean_name": "png_get_cICP",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_cICP_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cICP(png_const_structrp png_ptr,\n             png_const_inforp info_ptr, png_bytep colour_primaries,\n             png_bytep transfer_function, png_bytep matrix_coefficients,\n             png_bytep video_full_range_flag)\n{\n    png_debug1(1, \"in %s retrieval function\", \"cICP\");\n\n    if (png_ptr != NULL && info_ptr != NULL &&\n        (info_ptr->valid & PNG_INFO_cICP) != 0 &&\n        colour_primaries != NULL && transfer_function != NULL &&\n        matrix_coefficients != NULL && video_full_range_flag != NULL)\n    {\n        *colour_primaries = info_ptr->cicp_colour_primaries;\n        *transfer_function = info_ptr->cicp_transfer_function;\n        *matrix_coefficients = info_ptr->cicp_matrix_coefficients;\n        *video_full_range_flag = info_ptr->cicp_video_full_range_flag;\n        return (PNG_INFO_cICP);\n    }\n\n    return 0;\n}\n",
      "line_start": 762,
      "line_end": 783,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: basic null/flag checks and byte copies from an internal info struct. No parsing, no complex logic, no memory-manipulating operations on untrusted data \u2014 low fuzzing value."
    },
    {
      "name": "png_get_cLLI_fixed",
      "clean_name": "png_get_cLLI_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_cLLI_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cLLI_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32p maxCLL,\n    png_uint_32p maxFALL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cLLI\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n   {\n      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL;\n      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL;\n      return PNG_INFO_cLLI;\n   }\n\n   return 0;\n}\n",
      "line_start": 788,
      "line_end": 804,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter: checks pointer validity and copies two integer fields if present. No parsing of external input, no buffer/memory manipulation, no loops or complex branching \u2014 minimal fuzzing value."
    },
    {
      "name": "png_get_cLLI",
      "clean_name": "png_get_cLLI",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_cLLI(png_const_structrp png_ptr, png_const_inforp info_ptr,\n      double *maxCLL, double *maxFALL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"cLLI(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n   {\n      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL * .0001;\n      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL * .0001;\n      return PNG_INFO_cLLI;\n   }\n\n   return 0;\n}\n",
      "line_start": 808,
      "line_end": 823,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: checks pointers and a flag, reads two struct fields and applies a trivial scale to produce doubles. No parsing of external input, no unbounded loops or memory manipulation, and minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_mDCV_fixed",
      "clean_name": "png_get_mDCV_fixed",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* cLLI */\n\n#ifdef PNG_mDCV_SUPPORTED\n#  ifdef PNG_FIXED_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_mDCV_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_fixed_point *white_x, png_fixed_point *white_y,\n    png_fixed_point *red_x, png_fixed_point *red_y,\n    png_fixed_point *green_x, png_fixed_point *green_y,\n    png_fixed_point *blue_x, png_fixed_point *blue_y,\n    png_uint_32p mastering_maxDL, png_uint_32p mastering_minDL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"mDCV\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n   {\n      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * 2;\n      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * 2;\n      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * 2;\n      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * 2;\n      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * 2;\n      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * 2;\n      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * 2;\n      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * 2;\n      if (mastering_maxDL != NULL) *mastering_maxDL = info_ptr->mastering_maxDL;\n      if (mastering_minDL != NULL) *mastering_minDL = info_ptr->mastering_minDL;\n      return PNG_INFO_mDCV;\n   }\n\n   return 0;\n}\n",
      "line_start": 829,
      "line_end": 856,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: just checks pointers/valid flag and copies/multiplies struct fields by 2. No parsing of external formats, no loops, no memory copies or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_mDCV",
      "clean_name": "png_get_mDCV",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#  endif\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_mDCV(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    double *white_x, double *white_y, double *red_x, double *red_y,\n    double *green_x, double *green_y, double *blue_x, double *blue_y,\n    double *mastering_maxDL, double *mastering_minDL)\n{\n   png_debug1(1, \"in %s retrieval function\", \"mDCV(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n   {\n      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * .00002;\n      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * .00002;\n      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * .00002;\n      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * .00002;\n      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * .00002;\n      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * .00002;\n      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * .00002;\n      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * .00002;\n      if (mastering_maxDL != NULL)\n         *mastering_maxDL = info_ptr->mastering_maxDL * .0001;\n      if (mastering_minDL != NULL)\n         *mastering_minDL = info_ptr->mastering_minDL * .0001;\n      return PNG_INFO_mDCV;\n   }\n\n   return 0;\n}\n",
      "line_start": 860,
      "line_end": 887,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: it simply reads numeric fields from info_ptr and scales them into output pointers. No parsing, memory manipulation, loops, or complex branching. While info_ptr may come from parsed PNG data, this function itself offers minimal attack surface for fuzzing."
    },
    {
      "name": "png_get_eXIf_1",
      "clean_name": "png_get_eXIf_1",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "  PNG_UNUSED(exif)\n  return 0;\n}\n\npng_uint_32 PNGAPI\npng_get_eXIf_1(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *num_exif, png_bytep *exif)\n{\n   png_debug1(1, \"in %s retrieval function\", \"eXIf\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_eXIf) != 0 && exif != NULL)\n   {\n      *num_exif = info_ptr->num_exif;\n      *exif = info_ptr->exif;\n      return PNG_INFO_eXIf;\n   }\n\n   return 0;\n}\n",
      "line_start": 902,
      "line_end": 917,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter that only returns stored pointers and a flag check; no parsing, no loops, no memory manipulation of untrusted data. Limited fuzz value. (Note: it omits a null check for num_exif, so a null-dereference bug is possible, but overall complexity and attack surface remain low.)"
    },
    {
      "name": "png_get_oFFs",
      "clean_name": "png_get_oFFs",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 1;\n}\n\n#ifdef PNG_oFFs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_oFFs(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)\n{\n   png_debug1(1, \"in %s retrieval function\", \"oFFs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_oFFs) != 0 &&\n       offset_x != NULL && offset_y != NULL && unit_type != NULL)\n   {\n      *offset_x = info_ptr->x_offset;\n      *offset_y = info_ptr->y_offset;\n      *unit_type = (int)info_ptr->offset_unit_type;\n      return PNG_INFO_oFFs;\n   }\n\n   return 0;\n}\n",
      "line_start": 983,
      "line_end": 1000,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that copies stored offset fields after null/valid checks. No parsing of external data, no memory/manipulation operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_sCAL",
      "clean_name": "png_get_sCAL",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#    endif /* FLOATING_ARITHMETIC */\n#  endif /* FIXED_POINT */\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sCAL(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, double *width, double *height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL(float)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      *width = atof(info_ptr->scal_s_width);\n      *height = atof(info_ptr->scal_s_height);\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1059,
      "line_end": 1075,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: it just checks a valid flag, copies an int and calls atof() on stored strings. Minimal branching, no memory-manipulating operations or complex parsing, so low value as a fuzz target. (Minor note: it dereferences output pointers and calls atof on stored strings without extra validation, but this is not high-risk compared to real parsing or buffer-manipulation code.)"
    },
    {
      "name": "png_get_sCAL_s",
      "clean_name": "png_get_sCAL_s",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n#  endif /* FLOATING POINT */\npng_uint_32 PNGAPI\npng_get_sCAL_s(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    int *unit, png_charpp width, png_charpp height)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sCAL(str)\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sCAL) != 0)\n   {\n      *unit = info_ptr->scal_unit;\n      *width = info_ptr->scal_s_width;\n      *height = info_ptr->scal_s_height;\n      return PNG_INFO_sCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1077,
      "line_end": 1093,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: just checks pointers/flags and copies fields from an internal info struct to output pointers. No parsing, no loops, no memory-manipulating operations on untrusted data and very low complexity. (Note: it does not validate the output pointer arguments, so misuse could cause a crash, but this is not a complex or high-value fuzz target.)"
    },
    {
      "name": "png_get_pHYs",
      "clean_name": "png_get_pHYs",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif /* sCAL */\n\n#ifdef PNG_pHYs_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pHYs(png_const_structrp png_ptr, png_const_inforp info_ptr,\n    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"pHYs\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pHYs) != 0)\n   {\n      if (res_x != NULL)\n      {\n         *res_x = info_ptr->x_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (res_y != NULL)\n      {\n         *res_y = info_ptr->y_pixels_per_unit;\n         retval |= PNG_INFO_pHYs;\n      }\n\n      if (unit_type != NULL)\n      {\n         *unit_type = (int)info_ptr->phys_unit_type;\n         retval |= PNG_INFO_pHYs;\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 1097,
      "line_end": 1128,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: checks pointers and a validity bitmask, then copies small integer fields into output pointers. No parsing of external formats, no memory manipulation, no loops or complex branching\u2014low value as a fuzz target."
    },
    {
      "name": "png_get_PLTE",
      "clean_name": "png_get_PLTE",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return retval;\n}\n#endif /* pHYs */\n\npng_uint_32 PNGAPI\npng_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_colorp *palette, int *num_palette)\n{\n   png_debug1(1, \"in %s retrieval function\", \"PLTE\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_PLTE) != 0 && palette != NULL)\n   {\n      *palette = info_ptr->palette;\n      *num_palette = info_ptr->num_palette;\n      png_debug1(3, \"num_palette = %d\", *num_palette);\n      return PNG_INFO_PLTE;\n   }\n\n   return 0;\n}\n",
      "line_start": 1131,
      "line_end": 1147,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: just checks pointers/flags and returns stored palette pointer and count. No parsing, no memory manipulation, no complex control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_sBIT",
      "clean_name": "png_get_sBIT",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return 0;\n}\n\n#ifdef PNG_sBIT_SUPPORTED\npng_uint_32 PNGAPI\npng_get_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_color_8p *sig_bit)\n{\n   png_debug1(1, \"in %s retrieval function\", \"sBIT\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_sBIT) != 0 && sig_bit != NULL)\n   {\n      *sig_bit = &(info_ptr->sig_bit);\n      return PNG_INFO_sBIT;\n   }\n\n   return 0;\n}\n",
      "line_start": 1150,
      "line_end": 1164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only performs null/flag checks and returns a pointer to internal sig_bit. No parsing of external input, no buffer/memory manipulation or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_text",
      "clean_name": "png_get_text",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_TEXT_SUPPORTED\nint PNGAPI\npng_get_text(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_textp *text_ptr, int *num_text)\n{\n   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)\n   {\n      png_debug1(1, \"in text retrieval function, chunk typeid = 0x%lx\",\n         (unsigned long)png_ptr->chunk_name);\n\n      if (text_ptr != NULL)\n         *text_ptr = info_ptr->text;\n\n      if (num_text != NULL)\n         *num_text = info_ptr->num_text;\n\n      return info_ptr->num_text;\n   }\n\n   if (num_text != NULL)\n      *num_text = 0;\n\n   return 0;\n}\n",
      "line_start": 1168,
      "line_end": 1190,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: it just returns pointers/counts from an info struct with basic NULL checks. No parsing of external input, no memory manipulation, no loops or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_tIME",
      "clean_name": "png_get_tIME",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tIME_SUPPORTED\npng_uint_32 PNGAPI\npng_get_tIME(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_timep *mod_time)\n{\n   png_debug1(1, \"in %s retrieval function\", \"tIME\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_tIME) != 0 && mod_time != NULL)\n   {\n      *mod_time = &(info_ptr->mod_time);\n      return PNG_INFO_tIME;\n   }\n\n   return 0;\n}\n",
      "line_start": 1194,
      "line_end": 1208,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers and a validity flag and returns a pointer to info_ptr->mod_time. No parsing of external data, no loops, no buffer/memory manipulation or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_tRNS",
      "clean_name": "png_get_tRNS",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\npng_uint_32 PNGAPI\npng_get_tRNS(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)\n{\n   png_uint_32 retval = 0;\n\n   png_debug1(1, \"in %s retrieval function\", \"tRNS\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_tRNS) != 0)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n      {\n         if (trans_alpha != NULL)\n         {\n            *trans_alpha = info_ptr->trans_alpha;\n            retval |= PNG_INFO_tRNS;\n         }\n\n         if (trans_color != NULL)\n            *trans_color = &(info_ptr->trans_color);\n      }\n\n      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */\n      {\n         if (trans_color != NULL)\n         {\n            *trans_color = &(info_ptr->trans_color);\n            retval |= PNG_INFO_tRNS;\n         }\n\n         if (trans_alpha != NULL)\n            *trans_alpha = NULL;\n      }\n\n      if (num_trans != NULL)\n      {\n         *num_trans = info_ptr->num_trans;\n         retval |= PNG_INFO_tRNS;\n      }\n   }\n\n   return retval;\n}\n",
      "line_start": 1212,
      "line_end": 1255,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/wrapper: only checks pointers and sets output pointers/flags based on info struct fields. Low cyclomatic complexity, no parsing of external input, no memory operations on untrusted data or loops \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_unknown_chunks",
      "clean_name": "png_get_unknown_chunks",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED\nint PNGAPI\npng_get_unknown_chunks(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_unknown_chunkpp unknowns)\n{\n   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)\n   {\n      *unknowns = info_ptr->unknown_chunks;\n      return info_ptr->unknown_chunks_num;\n   }\n\n   return 0;\n}\n",
      "line_start": 1259,
      "line_end": 1270,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: performs null checks and returns internal pointer/count from the info struct. No parsing, memory operations, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_rgb_to_gray_status",
      "clean_name": "png_get_rgb_to_gray_status",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\npng_byte PNGAPI\npng_get_rgb_to_gray_status(png_const_structrp png_ptr)\n{\n   return (png_byte)(png_ptr ? png_ptr->rgb_to_gray_status : 0);\n}\n",
      "line_start": 1274,
      "line_end": 1278,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: returns a struct field with a single null check. No parsing, memory operations, loops, or complex branching on external input, so low value as a fuzz target."
    },
    {
      "name": "png_get_user_chunk_ptr",
      "clean_name": "png_get_user_chunk_ptr",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_USER_CHUNKS_SUPPORTED\npng_voidp PNGAPI\npng_get_user_chunk_ptr(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);\n}\n",
      "line_start": 1282,
      "line_end": 1286,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: returns png_ptr->user_chunk_ptr or NULL. No parsing, memory ops, or complex logic; minimal value as a fuzz target."
    },
    {
      "name": "png_get_compression_buffer_size",
      "clean_name": "png_get_compression_buffer_size",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);\n}\n#endif\n\nsize_t PNGAPI\npng_get_compression_buffer_size(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return 0;\n\n#ifdef PNG_WRITE_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)\n#endif\n   {\n#ifdef PNG_SEQUENTIAL_READ_SUPPORTED\n      return png_ptr->IDAT_read_size;\n#else\n      return PNG_IDAT_READ_SIZE;\n#endif\n   }\n\n#ifdef PNG_WRITE_SUPPORTED\n   else\n      return png_ptr->zbuffer_size;\n#endif\n}\n",
      "line_start": 1289,
      "line_end": 1310,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns a size field from png_ptr with only a null check and compile-time/one-bit branching. No parsing, memory operations on untrusted data, loops, or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_user_width_max",
      "clean_name": "png_get_user_width_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n/* These functions were added to libpng 1.2.6 and were enabled\n * by default in libpng-1.4.0 */\npng_uint_32 PNGAPI\npng_get_user_width_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_width_max : 0);\n}\n",
      "line_start": 1315,
      "line_end": 1319,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter: simply returns a field from a struct (or 0 on NULL). No parsing, no memory/mutable operations, no branching or loops on external data \u2014 minimal fuzz value."
    },
    {
      "name": "png_get_chunk_cache_max",
      "clean_name": "png_get_chunk_cache_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_height_max : 0);\n}\n\n/* This function was added to libpng 1.4.0 */\npng_uint_32 PNGAPI\npng_get_chunk_cache_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);\n}\n",
      "line_start": 1328,
      "line_end": 1332,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: just returns a struct field or 0 if null. No parsing, no memory ops, no branching on input beyond a null check \u2014 low-value fuzz target."
    },
    {
      "name": "png_get_chunk_malloc_max",
      "clean_name": "png_get_chunk_malloc_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);\n}\n\n/* This function was added to libpng 1.4.1 */\npng_alloc_size_t PNGAPI\npng_get_chunk_malloc_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);\n}\n",
      "line_start": 1335,
      "line_end": 1339,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: returns png_ptr->user_chunk_malloc_max or 0 if png_ptr is NULL. No parsing, no memory/ buffer operations, minimal branching \u2014 trivial getter with low value as a fuzz target."
    },
    {
      "name": "png_get_io_chunk_type",
      "clean_name": "png_get_io_chunk_type",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return png_ptr->io_state;\n}\n\npng_uint_32 PNGAPI\npng_get_io_chunk_type(png_const_structrp png_ptr)\n{\n   return png_ptr->chunk_name;\n}\n",
      "line_start": 1350,
      "line_end": 1354,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor that returns a struct field (png_ptr->chunk_name). No parsing, memory operations, or branching on external input \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_palette_max",
      "clean_name": "png_get_palette_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* IO_STATE */\n\n#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED\n#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED\nint PNGAPI\npng_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return png_ptr->num_palette_max;\n\n   return -1;\n}\n",
      "line_start": 1359,
      "line_end": 1366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers and returns a struct field or -1. No parsing, memory ops, loops, or complex logic \u2014 low-value as a fuzz target."
    },
    {
      "name": "pngget.c:png_fixed_inches_from_microns",
      "clean_name": "png_fixed_inches_from_microns",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));\n}\n\n#ifdef PNG_FIXED_POINT_SUPPORTED\nstatic png_fixed_point\npng_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)\n{\n   /* Convert from meters * 1,000,000 to inches * 100,000, meters to\n    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.\n    * Notice that this can overflow - a warning is output and 0 is\n    * returned.\n    */\n   png_fixed_point result;\n\n   if (png_muldiv(&result, microns, 500, 127) != 0)\n      return result;\n\n   png_warning(png_ptr, \"fixed point overflow ignored\");\n   return 0;\n}\n",
      "line_start": 375,
      "line_end": 390,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple fixed-point conversion with a single overflow check and one branch. No parsing of complex input, no memory/string operations, no loops or multiple code paths; useful only as a low-value subroutine (better exercised via higher-level PNG parsing targets)."
    },
    {
      "name": "png_malloc_array",
      "clean_name": "png_malloc_array",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "   /* The failure case when the request is too large */\n   return NULL;\n}\n\nPNG_FUNCTION(png_voidp /* PRIVATE */,\npng_malloc_array,(png_const_structrp png_ptr, int nelements,\n    size_t element_size),PNG_ALLOCATED)\n{\n   if (nelements <= 0 || element_size == 0)\n      png_error(png_ptr, \"internal error: array alloc\");\n\n   return png_malloc_array_checked(png_ptr, nelements, element_size);\n}\n",
      "line_start": 119,
      "line_end": 127,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper: it performs a trivial bounds/zero check then delegates to png_malloc_array_checked. It has minimal branching and no direct parsing or memory manipulation on untrusted data itself, so low value as a standalone fuzz target (the real logic/risks are in the called function)."
    },
    {
      "name": "png_malloc_default",
      "clean_name": "png_malloc_default",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "   return ret;\n}\n\n#ifdef PNG_USER_MEM_SUPPORTED\nPNG_FUNCTION(png_voidp,PNGAPI\npng_malloc_default,(png_const_structrp png_ptr, png_alloc_size_t size),\n    PNG_ALLOCATED PNG_DEPRECATED)\n{\n   png_voidp ret;\n\n   if (png_ptr == NULL)\n      return NULL;\n\n   /* Passing 'NULL' here bypasses the application provided memory handler. */\n   ret = png_malloc_base(NULL/*use malloc*/, size);\n\n   if (ret == NULL)\n      png_error(png_ptr, \"Out of Memory\"); /* 'M' means png_malloc_default */\n\n   return ret;\n}\n",
      "line_start": 186,
      "line_end": 202,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around allocation: minimal logic (null check + call to png_malloc_base), no parsing or manipulation of external data, no complex branching. Only user-controllable input is size (could cause DoS), but it does not perform memory operations on returned buffer or security-critical processing, so low fuzzing priority."
    },
    {
      "name": "png_start_read_image",
      "clean_name": "png_start_read_image",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * are set, but before any reading takes place.  This allows\n * the user to obtain a gamma-corrected palette, for example.\n * If the user doesn't call this, we will do it ourselves.\n */\nvoid PNGAPI\npng_start_read_image(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_start_read_image\");\n\n   if (png_ptr != NULL)\n   {\n      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)\n         png_read_start_row(png_ptr);\n\n      /* New in 1.6.0 this avoids the bug of doing the initializations twice */\n      else\n         png_app_error(png_ptr,\n             \"png_start_read_image/png_read_update_info: duplicate call\");\n   }\n}\n",
      "line_start": 200,
      "line_end": 215,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: checks png_ptr and a single flag, then either calls png_read_start_row or reports a duplicate call. No parsing of external input, no memory ops, and very low complexity \u2014 minimal value as a standalone fuzz target (may only affect internal state sequencing)."
    },
    {
      "name": "pngread.c:make_gray_colormap",
      "clean_name": "make_gray_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "\n   return (int)i;\n}\n\nstatic int\nmake_gray_colormap(png_image_read_control *display)\n{\n   unsigned int i;\n\n   for (i=0; i<256; ++i)\n      png_create_colormap_entry(display, i, i, i, i, 255, P_sRGB);\n\n   return (int)i;\n}\n",
      "line_start": 1863,
      "line_end": 1872,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial helper: deterministic fixed 0..255 loop calling png_create_colormap_entry with constant values. No parsing or input-dependent branching, no user-controlled bounds or complex memory operations \u2014 low value as a fuzz target."
    },
    {
      "name": "pngread.c:make_ga_colormap",
      "clean_name": "make_ga_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   return (int)i;\n}\n#define PNG_GRAY_COLORMAP_ENTRIES 256\n\nstatic int\nmake_ga_colormap(png_image_read_control *display)\n{\n   unsigned int i, a;\n\n   /* Alpha is retained, the output will be a color-map with entries\n    * selected by six levels of alpha.  One transparent entry, 6 gray\n    * levels for all the intermediate alpha values, leaving 230 entries\n    * for the opaque grays.  The color-map entries are the six values\n    * [0..5]*51, the GA processing uses PNG_DIV51(value) to find the\n    * relevant entry.\n    *\n    * if (alpha > 229) // opaque\n    * {\n    *    // The 231 entries are selected to make the math below work:\n    *    base = 0;\n    *    entry = (231 * gray + 128) >> 8;\n    * }\n    * else if (alpha < 26) // transparent\n    * {\n    *    base = 231;\n    *    entry = 0;\n    * }\n    * else // partially opaque\n    * {\n    *    base = 226 + 6 * PNG_DIV51(alpha);\n    *    entry = PNG_DIV51(gray);\n    * }\n    */\n   i = 0;\n   while (i < 231)\n   {\n      unsigned int gray = (i * 256 + 115) / 231;\n      png_create_colormap_entry(display, i++, gray, gray, gray, 255, P_sRGB);\n   }\n\n   /* 255 is used here for the component values for consistency with the code\n    * that undoes premultiplication in pngwrite.c.\n    */\n   png_create_colormap_entry(display, i++, 255, 255, 255, 0, P_sRGB);\n\n   for (a=1; a<5; ++a)\n   {\n      unsigned int g;\n\n      for (g=0; g<6; ++g)\n         png_create_colormap_entry(display, i++, g*51, g*51, g*51, a*51,\n             P_sRGB);\n   }\n\n   return (int)i;\n}\n",
      "line_start": 1875,
      "line_end": 1926,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Deterministic helper that builds a fixed PNG colormap: no parsing of external input, no input-dependent branching or bounds, only simple fixed-count loops and calls to png_create_colormap_entry. Low value as an isolated fuzz target."
    },
    {
      "name": "pngread.c:png_gamma_not_sRGB",
      "clean_name": "png_gamma_not_sRGB",
      "source_file": "/src/libpng/pngread.c",
      "source_code": " * one used in pngrtran.c when deciding whether to do gamma correction.  The\n * arithmetic optimizes the division by using the fact that the inverse of the\n * file sRGB gamma is 2.2\n */\nstatic int\npng_gamma_not_sRGB(png_fixed_point g)\n{\n   /* 1.6.47: use the same sanity checks as used in pngrtran.c */\n   if (g < PNG_LIB_GAMMA_MIN || g > PNG_LIB_GAMMA_MAX)\n      return 0; /* Includes the uninitialized value 0 */\n\n   return png_gamma_significant((g * 11 + 2)/5 /* i.e. *2.2, rounded */);\n}\n",
      "line_start": 1234,
      "line_end": 1242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple range check and a small integer arithmetic expression followed by a single helper call. No parsing, no buffer/memory operations, no complex branching or loops \u2014 low value as a fuzz target."
    },
    {
      "name": "pngread.c:make_gray_file_colormap",
      "clean_name": "make_gray_file_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "#     endif\n   }\n}\n\nstatic int\nmake_gray_file_colormap(png_image_read_control *display)\n{\n   unsigned int i;\n\n   for (i=0; i<256; ++i)\n      png_create_colormap_entry(display, i, i, i, i, 255, P_FILE);\n\n   return (int)i;\n}\n",
      "line_start": 1852,
      "line_end": 1861,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that deterministically fills 256 grayscale colormap entries in a fixed loop. No parsing of external input, no branching, no input-dependent bounds or complex memory/string operations in this function itself \u2014 low value as a fuzz target."
    },
    {
      "name": "pngread.c:make_rgb_colormap",
      "clean_name": "make_rgb_colormap",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "}\n\n#define PNG_GA_COLORMAP_ENTRIES 256\n\nstatic int\nmake_rgb_colormap(png_image_read_control *display)\n{\n   unsigned int i, r;\n\n   /* Build a 6x6x6 opaque RGB cube */\n   for (i=r=0; r<6; ++r)\n   {\n      unsigned int g;\n\n      for (g=0; g<6; ++g)\n      {\n         unsigned int b;\n\n         for (b=0; b<6; ++b)\n            png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,\n                P_sRGB);\n      }\n   }\n\n   return (int)i;\n}\n",
      "line_start": 1930,
      "line_end": 1951,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Deterministic helper that builds a fixed 6x6x6 RGB cube with constant loop bounds and no parsing of external/untrusted input. Low cyclomatic complexity and only calls a colormap-entry helper, so minimal value as a fuzz target."
    },
    {
      "name": "png_set_background",
      "clean_name": "png_set_background",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_background(png_structrp png_ptr,\n    png_const_color_16p background_color, int background_gamma_code,\n    int need_expand, double background_gamma)\n{\n   png_set_background_fixed(png_ptr, background_color, background_gamma_code,\n      need_expand, png_fixed(png_ptr, background_gamma, \"png_set_background\"));\n}\n",
      "line_start": 171,
      "line_end": 178,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around png_set_background_fixed that converts a double to fixed-point and forwards arguments. No parsing, memory manipulation, or complex branching here \u2014 low standalone value as a fuzz target (fuzz the underlying implementation instead)."
    },
    {
      "name": "png_set_strip_16",
      "clean_name": "png_set_strip_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif\n\n#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED\n/* Chop 16-bit depth files to 8-bit depth */\nvoid PNGAPI\npng_set_strip_16(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_strip_16\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_16_TO_8;\n}\n",
      "line_start": 201,
      "line_end": 210,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: performs a readiness check and sets a transformation flag on an internal struct. No parsing of external input, no buffer/memory operations, no loops or complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "png_set_strip_alpha",
      "clean_name": "png_set_strip_alpha",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\nvoid PNGAPI\npng_set_strip_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_strip_alpha\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= PNG_STRIP_ALPHA;\n}\n",
      "line_start": 214,
      "line_end": 223,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper: just checks png_rtran_ok and sets a transformation flag on an internal struct. No parsing of external data, no memory ops, no loops or branching on untrusted input\u2014low fuzzing value."
    },
    {
      "name": "png_set_alpha_mode",
      "clean_name": "png_set_alpha_mode",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   }\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)\n{\n   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,\n       output_gamma));\n}\n",
      "line_start": 460,
      "line_end": 465,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Tiny wrapper that forwards an int and converted double to another function; no parsing of complex input, no memory ops or branching here\u2014minimal fuzz value (simple wrapper logic)."
    },
    {
      "name": "png_set_gamma_fixed",
      "clean_name": "png_set_gamma_fixed",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "}\n#endif /* READ_QUANTIZE */\n\n#ifdef PNG_READ_GAMMA_SUPPORTED\nvoid PNGFAPI\npng_set_gamma_fixed(png_structrp png_ptr, png_fixed_point scrn_gamma,\n    png_fixed_point file_gamma)\n{\n   png_debug(1, \"in png_set_gamma_fixed\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   /* New in libpng-1.5.4 - reserve particular negative values as flags. */\n   scrn_gamma = translate_gamma_flags(scrn_gamma, 1/*screen*/);\n   file_gamma = translate_gamma_flags(file_gamma, 0/*file*/);\n\n   /* Checking the gamma values for being >0 was added in 1.5.4 along with the\n    * premultiplied alpha support; this actually hides an undocumented feature\n    * of the previous implementation which allowed gamma processing to be\n    * disabled in background handling.  There is no evidence (so far) that this\n    * was being used; however, png_set_background itself accepted and must still\n    * accept '0' for the gamma value it takes, because it isn't always used.\n    *\n    * Since this is an API change (albeit a very minor one that removes an\n    * undocumented API feature) the following checks were only enabled in\n    * libpng-1.6.0.\n    */\n   if (file_gamma <= 0)\n      png_app_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n   if (scrn_gamma <= 0)\n      png_app_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n\n   if (unsupported_gamma(png_ptr, file_gamma, 1/*warn*/) ||\n       unsupported_gamma(png_ptr, scrn_gamma, 1/*warn*/))\n      return;\n\n   /* 1.6.47: png_struct::file_gamma and png_struct::screen_gamma are now only\n    * written by this API.  This removes dependencies on the order of API calls\n    * and allows the complex gamma checks to be delayed until needed.\n    */\n   png_ptr->file_gamma = file_gamma;\n   png_ptr->screen_gamma = scrn_gamma;\n}\n",
      "line_start": 882,
      "line_end": 921,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple API setter: validates two fixed-point gamma values, maps flag values, emits errors/warnings, and stores them in the png struct. Low cyclomatic complexity, no parsing of complex external formats, no memory operations or loops on untrusted data \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_set_gamma",
      "clean_name": "png_set_gamma",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "   png_ptr->screen_gamma = scrn_gamma;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_gamma(png_structrp png_ptr, double scrn_gamma, double file_gamma)\n{\n   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),\n       convert_gamma_value(png_ptr, file_gamma));\n}\n",
      "line_start": 924,
      "line_end": 929,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that converts two double gamma values and calls png_set_gamma_fixed. Minimal logic, no parsing or memory manipulation here; the real work/risk is in convert_gamma_value/png_set_gamma_fixed, so this target itself is low priority for fuzzing."
    },
    {
      "name": "png_set_palette_to_rgb",
      "clean_name": "png_set_palette_to_rgb",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": " *  and its name was changed to png_set_expand_gray_1_2_4_to_8().\n */\n\n/* Expand paletted images to RGB. */\nvoid PNGAPI\npng_set_palette_to_rgb(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_palette_to_rgb\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 968,
      "line_end": 977,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is essentially a small setter/wrapper: it performs a simple conditional check (png_rtran_ok) and sets transformation flags on an internal struct. It has no parsing of external input, no memory operations on untrusted data, no loops or complex branching, and thus offers low value as a fuzz target."
    },
    {
      "name": "png_set_expand_16",
      "clean_name": "png_set_expand_16",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#ifdef PNG_READ_EXPAND_16_SUPPORTED\n/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise\n * it may not work correctly.)\n */\nvoid PNGAPI\npng_set_expand_16(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_expand_16\");\n\n   if (png_rtran_ok(png_ptr, 0) == 0)\n      return;\n\n   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);\n}\n",
      "line_start": 1008,
      "line_end": 1017,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter-style function: only checks png_rtran_ok then ORs transformation flags on the png struct. No parsing of external input, no memory/buffer operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_rgb_to_gray",
      "clean_name": "png_set_rgb_to_gray",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "/* Convert a RGB image to a grayscale of the same width.  This allows us,\n * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.\n */\n\nvoid PNGAPI\npng_set_rgb_to_gray(png_structrp png_ptr, int error_action, double red,\n    double green)\n{\n   png_set_rgb_to_gray_fixed(png_ptr, error_action,\n       png_fixed(png_ptr, red, \"rgb to gray red coefficient\"),\n      png_fixed(png_ptr, green, \"rgb to gray green coefficient\"));\n}\n",
      "line_start": 1108,
      "line_end": 1115,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: this function only converts two double coefficients via png_fixed and forwards them to png_set_rgb_to_gray_fixed. It contains minimal logic, no direct parsing, no memory operations, and limited attack surface (any validation happens in png_fixed), so it's a low-value fuzz target."
    },
    {
      "name": "png_set_read_user_transform_fn",
      "clean_name": "png_set_read_user_transform_fn",
      "source_file": "/src/libpng/pngrtran.c",
      "source_code": "#endif /* RGB_TO_GRAY */\n\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\nvoid PNGAPI\npng_set_read_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr\n    read_user_transform_fn)\n{\n   png_debug(1, \"in png_set_read_user_transform_fn\");\n\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   png_ptr->transformations |= PNG_USER_TRANSFORM;\n   png_ptr->read_user_transform_fn = read_user_transform_fn;\n#endif\n}\n",
      "line_start": 1122,
      "line_end": 1132,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper that assigns a function pointer and sets a flag; no parsing, no memory manipulation, no complex control flow. Minimal value as a fuzz target (aside from basic API misuse/null-pointer tests)."
    },
    {
      "name": "png_get_uint_32",
      "clean_name": "png_get_uint_32",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": " * these (unused but exported) functions.\n */\n\n/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */\npng_uint_32 (PNGAPI\npng_get_uint_32)(png_const_bytep buf)\n{\n   png_uint_32 uval =\n       ((png_uint_32)(*(buf    )) << 24) +\n       ((png_uint_32)(*(buf + 1)) << 16) +\n       ((png_uint_32)(*(buf + 2)) <<  8) +\n       ((png_uint_32)(*(buf + 3))      ) ;\n\n   return uval;\n}\n",
      "line_start": 62,
      "line_end": 72,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial helper that decodes 4 bytes to a uint32 in big-endian. No branching, no parsing/validation logic, and only four byte reads; minimal attack surface as a standalone fuzz target (may expose OOB/null-read issues but low value to fuzz in isolation)."
    },
    {
      "name": "png_get_uint_16",
      "clean_name": "png_get_uint_16",
      "source_file": "/src/libpng/pngrutil.c",
      "source_code": "   return 0;\n}\n\n/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */\npng_uint_16 (PNGAPI\npng_get_uint_16)(png_const_bytep buf)\n{\n   /* ANSI-C requires an int value to accommodate at least 16 bits so this\n    * works and allows the compiler not to worry about possible narrowing\n    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller\n    * than 16 bits either.)\n    */\n   unsigned int val =\n       ((unsigned int)(*buf) << 8) +\n       ((unsigned int)(*(buf + 1)));\n\n   return (png_uint_16)val;\n}\n",
      "line_start": 97,
      "line_end": 110,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial helper that reads two bytes in big-endian and returns a uint16. Minimal logic, no parsing/validation, no loops or branching; only a simple dereference (NULL could crash) so low value as a fuzz target."
    },
    {
      "name": "png_set_cLLI",
      "clean_name": "png_set_cLLI",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_cLLI;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_cLLI(png_const_structrp png_ptr, png_inforp info_ptr,\n   double maxCLL, double maxFALL)\n{\n   png_set_cLLI_fixed(png_ptr, info_ptr,\n       png_fixed_ITU(png_ptr, maxCLL, \"png_set_cLLI(maxCLL)\"),\n       png_fixed_ITU(png_ptr, maxFALL, \"png_set_cLLI(maxFALL)\"));\n}\n",
      "line_start": 193,
      "line_end": 200,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: converts two doubles via png_fixed_ITU and calls png_set_cLLI_fixed. Minimal logic, no parsing of complex external formats, no memory ops or branching \u2014 low-value fuzz target. (Fuzz lower-level parsing/conversion functions instead.)"
    },
    {
      "name": "png_set_mDCV",
      "clean_name": "png_set_mDCV",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_mDCV;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_mDCV(png_const_structrp png_ptr, png_inforp info_ptr,\n    double white_x, double white_y, double red_x, double red_y, double green_x,\n    double green_y, double blue_x, double blue_y,\n    double maxDL, double minDL)\n{\n   png_set_mDCV_fixed(png_ptr, info_ptr,\n      png_fixed(png_ptr, white_x, \"png_set_mDCV(white(x))\"),\n      png_fixed(png_ptr, white_y, \"png_set_mDCV(white(y))\"),\n      png_fixed(png_ptr, red_x, \"png_set_mDCV(red(x))\"),\n      png_fixed(png_ptr, red_y, \"png_set_mDCV(red(y))\"),\n      png_fixed(png_ptr, green_x, \"png_set_mDCV(green(x))\"),\n      png_fixed(png_ptr, green_y, \"png_set_mDCV(green(y))\"),\n      png_fixed(png_ptr, blue_x, \"png_set_mDCV(blue(x))\"),\n      png_fixed(png_ptr, blue_y, \"png_set_mDCV(blue(y))\"),\n      png_fixed_ITU(png_ptr, maxDL, \"png_set_mDCV(maxDL)\"),\n      png_fixed_ITU(png_ptr, minDL, \"png_set_mDCV(minDL)\"));\n}\n",
      "line_start": 296,
      "line_end": 313,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: converts double parameters to fixed-point and forwards to png_set_mDCV_fixed. No parsing of external data, no loops, no buffer/memory operations or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_gAMA",
      "clean_name": "png_set_gAMA",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->valid |= PNG_INFO_gAMA;\n}\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\nvoid PNGAPI\npng_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)\n{\n   png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,\n       \"png_set_gAMA\"));\n}\n",
      "line_start": 373,
      "line_end": 378,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: this function merely forwards a double file_gamma to png_set_gAMA_fixed via a conversion macro. It contains no parsing, branching, loops, or direct memory operations on untrusted data \u2014 minimal logic and low fuzzing value (wrapper/delegation)."
    },
    {
      "name": "png_set_sRGB_gAMA_and_cHRM",
      "clean_name": "png_set_sRGB_gAMA_and_cHRM",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   info_ptr->rendering_intent = srgb_intent;\n   info_ptr->valid |= PNG_INFO_sRGB;\n}\n\nvoid PNGAPI\npng_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,\n    int srgb_intent)\n{\n   png_debug1(1, \"in %s storage function\", \"sRGB_gAMA_and_cHRM\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   png_set_sRGB(png_ptr, info_ptr, srgb_intent);\n\n#  ifdef PNG_gAMA_SUPPORTED\n      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);\n#  endif /* gAMA */\n\n#  ifdef PNG_cHRM_SUPPORTED\n      png_set_cHRM_fixed(png_ptr, info_ptr,\n         /* color      x       y */\n         /* white */ 31270, 32900,\n         /* red   */ 64000, 33000,\n         /* green */ 30000, 60000,\n         /* blue  */ 15000,  6000);\n#  endif /* cHRM */\n}\n",
      "line_start": 832,
      "line_end": 855,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that sets sRGB/gAMA/cHRM metadata: only a NULL check and calls to other setters. No parsing of external input, no buffer/memory ops, no complex branching or loops \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_text",
      "clean_name": "png_set_text",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_TEXT_SUPPORTED\nvoid PNGAPI\npng_set_text(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_const_textp text_ptr, int num_text)\n{\n   int ret;\n   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);\n\n   if (ret != 0)\n      png_error(png_ptr, \"Insufficient memory to store text\");\n}\n",
      "line_start": 913,
      "line_end": 922,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper that delegates all parsing/handling to png_set_text_2 and only checks its return value to raise an error. It contains no parsing, memory operations, loops, or branching on untrusted input itself \u2014 low-value direct fuzz target (real risk resides in png_set_text_2)."
    },
    {
      "name": "png_permit_mng_features",
      "clean_name": "png_permit_mng_features",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif /* STORE_UNKNOWN_CHUNKS */\n\n#ifdef PNG_MNG_FEATURES_SUPPORTED\npng_uint_32 PNGAPI\npng_permit_mng_features(png_structrp png_ptr, png_uint_32 mng_features)\n{\n   png_debug(1, \"in png_permit_mng_features\");\n\n   if (png_ptr == NULL)\n      return 0;\n\n   png_ptr->mng_features_permitted = mng_features & PNG_ALL_MNG_FEATURES;\n\n   return png_ptr->mng_features_permitted;\n}\n",
      "line_start": 1485,
      "line_end": 1496,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: masks and stores a bitmask with a null check. No parsing, memory operations, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_set_read_user_chunk_fn",
      "clean_name": "png_set_read_user_chunk_fn",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_READ_USER_CHUNKS_SUPPORTED\nvoid PNGAPI\npng_set_read_user_chunk_fn(png_structrp png_ptr, png_voidp user_chunk_ptr,\n    png_user_chunk_ptr read_user_chunk_fn)\n{\n   png_debug(1, \"in png_set_read_user_chunk_fn\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->read_user_chunk_fn = read_user_chunk_fn;\n   png_ptr->user_chunk_ptr = user_chunk_ptr;\n}\n",
      "line_start": 1690,
      "line_end": 1701,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter function: only checks png_ptr != NULL and assigns a user pointer and callback. No parsing, no memory operations on untrusted data, and minimal logic\u2014low value as a fuzz target."
    },
    {
      "name": "png_set_rows",
      "clean_name": "png_set_rows",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\nvoid PNGAPI\npng_set_rows(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytepp row_pointers)\n{\n   png_debug(1, \"in png_set_rows\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n   if (info_ptr->row_pointers != NULL &&\n       (info_ptr->row_pointers != row_pointers))\n      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);\n\n   info_ptr->row_pointers = row_pointers;\n\n   if (row_pointers != NULL)\n      info_ptr->valid |= PNG_INFO_IDAT;\n}\n",
      "line_start": 1705,
      "line_end": 1722,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: updates info_ptr->row_pointers and a flag and conditionally frees previous rows. Minimal logic/branching, no parsing of external input, no buffer/length operations \u2014 low value as a fuzz target (aside from indirect effects via png_free_data)."
    },
    {
      "name": "png_set_invalid",
      "clean_name": "png_set_invalid",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   }\n#  endif\n}\n\nvoid PNGAPI\npng_set_invalid(png_const_structrp png_ptr, png_inforp info_ptr, int mask)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      info_ptr->valid &= (unsigned int)(~mask);\n}\n",
      "line_start": 1787,
      "line_end": 1792,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter-like helper: only null checks and a single bitwise update of a struct field. No parsing, no loops, no memory operations on untrusted buffers and very low complexity, so low fuzzing value."
    },
    {
      "name": "png_set_user_limits",
      "clean_name": "png_set_user_limits",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "\n\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n/* This function was added to libpng 1.2.6 */\nvoid PNGAPI\npng_set_user_limits(png_structrp png_ptr, png_uint_32 user_width_max,\n    png_uint_32 user_height_max)\n{\n   png_debug(1, \"in png_set_user_limits\");\n\n   /* Images with dimensions larger than these limits will be\n    * rejected by png_set_IHDR().  To accept any PNG datastream\n    * regardless of dimensions, set both limits to 0x7fffffff.\n    */\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->user_width_max = user_width_max;\n   png_ptr->user_height_max = user_height_max;\n}\n",
      "line_start": 1797,
      "line_end": 1812,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "A trivial setter: it only checks png_ptr for NULL and assigns two fields. No parsing, memory operations, loops, or complex branching. While the values influence other code (image acceptance thresholds), this function itself is not a valuable fuzz target\u2014test the PNG parser/decoder instead."
    },
    {
      "name": "png_set_chunk_cache_max",
      "clean_name": "png_set_chunk_cache_max",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "   png_ptr->user_height_max = user_height_max;\n}\n\n/* This function was added to libpng 1.4.0 */\nvoid PNGAPI\npng_set_chunk_cache_max(png_structrp png_ptr, png_uint_32 user_chunk_cache_max)\n{\n   png_debug(1, \"in png_set_chunk_cache_max\");\n\n   if (png_ptr != NULL)\n      png_ptr->user_chunk_cache_max = user_chunk_cache_max;\n}\n",
      "line_start": 1815,
      "line_end": 1822,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: only checks png_ptr != NULL and assigns user_chunk_cache_max. No parsing, memory operations, loops, or complex branching \u2014 low fuzzing priority."
    },
    {
      "name": "png_set_chunk_malloc_max",
      "clean_name": "png_set_chunk_malloc_max",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "      png_ptr->user_chunk_cache_max = user_chunk_cache_max;\n}\n\n/* This function was added to libpng 1.4.1 */\nvoid PNGAPI\npng_set_chunk_malloc_max(png_structrp png_ptr,\n    png_alloc_size_t user_chunk_malloc_max)\n{\n   png_debug(1, \"in png_set_chunk_malloc_max\");\n\n   /* pngstruct::user_chunk_malloc_max is initialized to a non-zero value in\n    * png.c.  This API supports '0' for unlimited, make sure the correct\n    * (unlimited) value is set here to avoid a need to check for 0 everywhere\n    * the parameter is used.\n    */\n   if (png_ptr != NULL)\n   {\n      if (user_chunk_malloc_max == 0U) /* unlimited */\n      {\n#        ifdef PNG_MAX_MALLOC_64K\n            png_ptr->user_chunk_malloc_max = 65536U;\n#        else\n            png_ptr->user_chunk_malloc_max = PNG_SIZE_MAX;\n#        endif\n      }\n      else\n         png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n   }\n}\n",
      "line_start": 1825,
      "line_end": 1849,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: it only assigns a limit value into the png struct with a simple conditional for zero/unlimited. No parsing of external input, no memory ops, low complexity. It only affects later allocation behavior but contains no parsing/processing logic suitable as a primary fuzz target."
    },
    {
      "name": "png_set_check_for_invalid_index",
      "clean_name": "png_set_check_for_invalid_index",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "    * from this gracefully by filling any incomplete palette with zeros\n    * (opaque black).  By default, when this occurs libpng will issue\n    * a benign error.  This API can be used to override that behavior.\n    */\nvoid PNGAPI\npng_set_check_for_invalid_index(png_structrp png_ptr, int allowed)\n{\n   png_debug(1, \"in png_set_check_for_invalid_index\");\n\n   if (allowed > 0)\n      png_ptr->num_palette_max = 0;\n\n   else\n      png_ptr->num_palette_max = -1;\n}\n",
      "line_start": 1884,
      "line_end": 1894,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: simply sets a struct field based on a single integer condition. No parsing, memory operations, loops, or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_swap",
      "clean_name": "png_set_swap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)\n/* Turn on 16-bit byte swapping */\nvoid PNGAPI\npng_set_swap(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_swap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth == 16)\n      png_ptr->transformations |= PNG_SWAP_BYTES;\n}\n",
      "line_start": 33,
      "line_end": 43,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very simple setter: checks for NULL and bit_depth==16 then sets a flag. No parsing, memory operations, loops, or complex branching; minimal fuzzing value (low priority)."
    },
    {
      "name": "png_set_packswap",
      "clean_name": "png_set_packswap",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)\n/* Turn on packed pixel swapping */\nvoid PNGAPI\npng_set_packswap(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_packswap\");\n\n   if (png_ptr == NULL)\n      return;\n\n   if (png_ptr->bit_depth < 8)\n      png_ptr->transformations |= PNG_PACKSWAP;\n}\n",
      "line_start": 68,
      "line_end": 78,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small setter-style function: checks png_ptr and flips a transformation flag based on bit_depth. No parsing of external input, no memory ops, no loops or complex branching \u2014 low fuzzing value."
    },
    {
      "name": "png_set_shift",
      "clean_name": "png_set_shift",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)\nvoid PNGAPI\npng_set_shift(png_structrp png_ptr, png_const_color_8p true_bits)\n{\n   png_debug(1, \"in png_set_shift\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_SHIFT;\n   png_ptr->shift = *true_bits;\n}\n",
      "line_start": 82,
      "line_end": 92,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that copies a small struct and sets a flag; minimal logic and branching and not parsing external/untrusted input. (Minor concern: it dereferences true_bits without a null-check, but overall low fuzz value.)"
    },
    {
      "name": "png_set_swap_alpha",
      "clean_name": "png_set_swap_alpha",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \\\n    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)\nvoid PNGAPI\npng_set_swap_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_swap_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_SWAP_ALPHA;\n}\n",
      "line_start": 221,
      "line_end": 230,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that only flips a transformation flag on the png_struct; no parsing of external data, no memory operations, and minimal control flow \u2014 low-value fuzz target."
    },
    {
      "name": "png_set_invert_alpha",
      "clean_name": "png_set_invert_alpha",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#endif\n\n#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \\\n    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)\nvoid PNGAPI\npng_set_invert_alpha(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_invert_alpha\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_INVERT_ALPHA;\n}\n",
      "line_start": 235,
      "line_end": 244,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: only checks for NULL and sets a flag in the png_struct. No parsing, memory operations, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_invert_mono",
      "clean_name": "png_set_invert_mono",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)\nvoid PNGAPI\npng_set_invert_mono(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_invert_mono\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_INVERT_MONO;\n}\n",
      "line_start": 248,
      "line_end": 257,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that flips a transformation flag on the png_struct; only a NULL check and a single bitwise-or. No parsing of external input, no memory or buffer operations, and minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_set_user_transform_info",
      "clean_name": "png_set_user_transform_info",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \\\n    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\nvoid PNGAPI\npng_set_user_transform_info(png_structrp png_ptr, png_voidp\n   user_transform_ptr, int user_transform_depth, int user_transform_channels)\n{\n   png_debug(1, \"in png_set_user_transform_info\");\n\n   if (png_ptr == NULL)\n      return;\n\n#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED\n   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n      (png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)\n   {\n      png_app_error(png_ptr,\n          \"info change after png_start_read_image or png_read_update_info\");\n      return;\n   }\n#endif\n\n   png_ptr->user_transform_ptr = user_transform_ptr;\n   png_ptr->user_transform_depth = (png_byte)user_transform_depth;\n   png_ptr->user_transform_channels = (png_byte)user_transform_channels;\n}\n",
      "line_start": 804,
      "line_end": 826,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter/initializer: validates png_ptr and a read-state flag, then stores a pointer and two small integer fields. No parsing of external data, no memory operations on untrusted input, and minimal branching \u2014 low-value fuzz target."
    },
    {
      "name": "png_zstream_error",
      "clean_name": "png_zstream_error",
      "source_file": "/src/libpng/png.c",
      "source_code": "/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.\n * If it doesn't 'ret' is used to set it to something appropriate, even in cases\n * like Z_OK or Z_STREAM_END where the error code is apparently a success code.\n */\nvoid /* PRIVATE */\npng_zstream_error(png_structrp png_ptr, int ret)\n{\n   /* Translate 'ret' into an appropriate error string, priority is given to the\n    * one in zstream if set.  This always returns a string, even in cases like\n    * Z_OK or Z_STREAM_END where the error code is a success code.\n    */\n   if (png_ptr->zstream.msg == NULL) switch (ret)\n   {\n      default:\n      case Z_OK:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return code\");\n         break;\n\n      case Z_STREAM_END:\n         /* Normal exit */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected end of LZ stream\");\n         break;\n\n      case Z_NEED_DICT:\n         /* This means the deflate stream did not have a dictionary; this\n          * indicates a bogus PNG.\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"missing LZ dictionary\");\n         break;\n\n      case Z_ERRNO:\n         /* gz APIs only: should not happen */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"zlib IO error\");\n         break;\n\n      case Z_STREAM_ERROR:\n         /* internal libpng error */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"bad parameters to zlib\");\n         break;\n\n      case Z_DATA_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"damaged LZ stream\");\n         break;\n\n      case Z_MEM_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"insufficient memory\");\n         break;\n\n      case Z_BUF_ERROR:\n         /* End of input or output; not a problem if the caller is doing\n          * incremental read or write.\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"truncated\");\n         break;\n\n      case Z_VERSION_ERROR:\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unsupported zlib version\");\n         break;\n\n      case PNG_UNEXPECTED_ZLIB_RETURN:\n         /* Compile errors here mean that zlib now uses the value co-opted in\n          * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above\n          * and change pngpriv.h.  Note that this message is \"... return\",\n          * whereas the default/Z_OK one is \"... return code\".\n          */\n         png_ptr->zstream.msg = PNGZ_MSG_CAST(\"unexpected zlib return\");\n         break;\n   }\n}\n",
      "line_start": 999,
      "line_end": 1063,
      "execution_count": 454,
      "covered_regions": 9,
      "total_regions": 73,
      "coverage_percent": 12.33,
      "is_covered": true,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that sets static error strings based on a zlib return code. Contains only a small switch with trivial branching, no parsing of external input, no memory operations or loops, and minimal attack surface for fuzzing."
    },
    {
      "name": "png_get_libpng_ver",
      "clean_name": "png_get_libpng_ver",
      "source_file": "/src/libpng/png.c",
      "source_code": " * Note: now there is no difference between png_get_libpng_ver() and\n * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,\n * it is guaranteed that png.c uses the correct version of png.h.\n */\npng_const_charp PNGAPI\npng_get_libpng_ver(png_const_structrp png_ptr)\n{\n   /* Version of *.c files used when building libpng */\n   return png_get_header_ver(png_ptr);\n}\n",
      "line_start": 838,
      "line_end": 843,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial wrapper that just calls png_get_header_ver(png_ptr); no parsing, no memory operations on untrusted data, and no branching or complex logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "pngerror.c:png_default_error",
      "clean_name": "png_default_error",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": " * this function MUST NOT RETURN, or the program will likely crash.  This\n * function is used by default, or if the program supplies NULL for the\n * error function pointer in png_set_error_fn().\n */\nstatic PNG_FUNCTION(void /* PRIVATE */,\npng_default_error,(png_const_structrp png_ptr, png_const_charp error_message),\n    PNG_NORETURN)\n{\n#ifdef PNG_CONSOLE_IO_SUPPORTED\n   fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n      \"undefined\");\n   fprintf(stderr, PNG_STRING_NEWLINE);\n#else\n   PNG_UNUSED(error_message) /* Make compiler happy */\n#endif\n   png_longjmp(png_ptr, 1);\n}\n",
      "line_start": 655,
      "line_end": 667,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Trivial error handler: it only prints an error string (using a safe \"%s\" format) and longjmps out. It does not parse or manipulate external data, has no loops or complex logic, and offers little value as a fuzz target."
    },
    {
      "name": "png_get_image_width",
      "clean_name": "png_get_image_width",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif\n\n#ifdef PNG_EASY_ACCESS_SUPPORTED\n/* Easy access to info, added in libpng-0.99 */\npng_uint_32 PNGAPI\npng_get_image_width(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->width;\n\n   return 0;\n}\n",
      "line_start": 61,
      "line_end": 68,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: just a null check and returns a width field. No parsing, no memory operations, no branching or loops on untrusted input \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_bit_depth",
      "clean_name": "png_get_bit_depth",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "\n   return 0;\n}\n\npng_byte PNGAPI\npng_get_bit_depth(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->bit_depth;\n\n   return 0;\n}\n",
      "line_start": 79,
      "line_end": 86,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial getter: only returns info_ptr->bit_depth if pointers non-NULL. No parsing, no memory operations, no branches dependent on external input beyond a null check \u2014 minimal fuzzing value."
    },
    {
      "name": "png_get_y_pixels_per_inch",
      "clean_name": "png_get_y_pixels_per_inch",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));\n}\n\npng_uint_32 PNGAPI\npng_get_y_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));\n}\n",
      "line_start": 368,
      "line_end": 372,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial wrapper: simply calls png_get_y_pixels_per_meter and ppi_from_ppm and returns a conversion. No parsing, no branching, no memory operations on untrusted data. Fuzzing should target the underlying parsers/validators instead."
    },
    {
      "name": "png_get_x_offset_inches",
      "clean_name": "png_get_x_offset_inches",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_FLOATING_POINT_SUPPORTED\nfloat PNGAPI\npng_get_x_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)\n{\n   /* To avoid the overflow do the conversion directly in floating\n    * point.\n    */\n   return (float)(png_get_x_offset_microns(png_ptr, info_ptr) * .00003937);\n}\n",
      "line_start": 412,
      "line_end": 419,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple wrapper that converts the result of png_get_x_offset_microns to inches via a single floating-point multiply. No parsing, memory operations, branching, or input-dependent logic \u2014 minimal fuzzing value."
    },
    {
      "name": "png_get_hIST",
      "clean_name": "png_get_hIST",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\npng_uint_32 PNGAPI\npng_get_hIST(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_uint_16p *hist)\n{\n   png_debug1(1, \"in %s retrieval function\", \"hIST\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_hIST) != 0 && hist != NULL)\n   {\n      *hist = info_ptr->hist;\n      return PNG_INFO_hIST;\n   }\n\n   return 0;\n}\n",
      "line_start": 921,
      "line_end": 935,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor/getter: only checks pointers and copies a stored pointer; no parsing, no loops, no memory manipulation of untrusted data, and minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "png_get_pCAL",
      "clean_name": "png_get_pCAL",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\npng_uint_32 PNGAPI\npng_get_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,\n    png_charp *units, png_charpp *params)\n{\n   png_debug1(1, \"in %s retrieval function\", \"pCAL\");\n\n   if (png_ptr != NULL && info_ptr != NULL &&\n       (info_ptr->valid & PNG_INFO_pCAL) != 0 &&\n       purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&\n       nparams != NULL && units != NULL && params != NULL)\n   {\n      *purpose = info_ptr->pcal_purpose;\n      *X0 = info_ptr->pcal_X0;\n      *X1 = info_ptr->pcal_X1;\n      *type = (int)info_ptr->pcal_type;\n      *nparams = (int)info_ptr->pcal_nparams;\n      *units = info_ptr->pcal_units;\n      *params = info_ptr->pcal_params;\n      return PNG_INFO_pCAL;\n   }\n\n   return 0;\n}\n",
      "line_start": 1004,
      "line_end": 1027,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor/getter: only checks pointers and a valid flag then copies stored pointers/ints out. No parsing, no memory operations on untrusted data, no loops or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_user_height_max",
      "clean_name": "png_get_user_height_max",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "{\n   return (png_ptr ? png_ptr->user_width_max : 0);\n}\n\npng_uint_32 PNGAPI\npng_get_user_height_max(png_const_structrp png_ptr)\n{\n   return (png_ptr ? png_ptr->user_height_max : 0);\n}\n",
      "line_start": 1321,
      "line_end": 1325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: simply returns a field (or 0 if png_ptr is NULL). No parsing, no memory operations, no branching or loops\u2014minimal fuzzing value."
    },
    {
      "name": "png_get_io_state",
      "clean_name": "png_get_io_state",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#endif /* SET_USER_LIMITS */\n\n/* These functions were added to libpng 1.4.0 */\n#ifdef PNG_IO_STATE_SUPPORTED\npng_uint_32 PNGAPI\npng_get_io_state(png_const_structrp png_ptr)\n{\n   return png_ptr->io_state;\n}\n",
      "line_start": 1344,
      "line_end": 1348,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor/getter that just returns png_ptr->io_state; no parsing, no memory operations, no branching or input-dependent logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_mem_ptr",
      "clean_name": "png_get_mem_ptr",
      "source_file": "/src/libpng/pngmem.c",
      "source_code": "/* This function returns a pointer to the mem_ptr associated with the user\n * functions.  The application should free any memory associated with this\n * pointer before png_write_destroy and png_read_destroy are called.\n */\npng_voidp PNGAPI\npng_get_mem_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return png_ptr->mem_ptr;\n}\n",
      "line_start": 273,
      "line_end": 280,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor: only a null-check and return of a struct field; no parsing, memory manipulation, loops, or branching on external data\u2014low-value fuzz target."
    },
    {
      "name": "png_set_read_status_fn",
      "clean_name": "png_set_read_status_fn",
      "source_file": "/src/libpng/pngread.c",
      "source_code": "   png_read_destroy(png_ptr);\n   png_destroy_png_struct(png_ptr);\n}\n\nvoid PNGAPI\npng_set_read_status_fn(png_structrp png_ptr, png_read_status_ptr read_row_fn)\n{\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->read_row_fn = read_row_fn;\n}\n",
      "line_start": 856,
      "line_end": 863,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: only a NULL check and assignment of a callback pointer. No parsing, no memory ops on untrusted data, no branching or loops\u2014very low value as a fuzz target."
    },
    {
      "name": "png_set_eXIf",
      "clean_name": "png_set_eXIf",
      "source_file": "/src/libpng/pngset.c",
      "source_code": "#  endif /* FLOATING_POINT */\n#endif /* mDCV */\n\n#ifdef PNG_eXIf_SUPPORTED\nvoid PNGAPI\npng_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep exif)\n{\n  png_warning(png_ptr, \"png_set_eXIf does not work; use png_set_eXIf_1\");\n  PNG_UNUSED(info_ptr)\n  PNG_UNUSED(exif)\n}\n",
      "line_start": 318,
      "line_end": 325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial wrapper that does no parsing or memory operations: it only emits a warning and marks parameters unused. No external-input processing, branching, or buffer handling \u2014 low fuzzing value."
    },
    {
      "name": "png_set_bgr",
      "clean_name": "png_set_bgr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)\n\n#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)\n/* Turn on BGR-to-RGB mapping */\nvoid PNGAPI\npng_set_bgr(png_structrp png_ptr)\n{\n   png_debug(1, \"in png_set_bgr\");\n\n   if (png_ptr == NULL)\n      return;\n\n   png_ptr->transformations |= PNG_BGR;\n}\n",
      "line_start": 19,
      "line_end": 28,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: only checks for NULL and ORs a flag into an internal struct. No parsing, memory ops, loops, or input-dependent logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_user_transform_ptr",
      "clean_name": "png_get_user_transform_ptr",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": " * associated with this pointer before png_write_destroy and png_read_destroy\n * are called.\n */\n#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED\npng_voidp PNGAPI\npng_get_user_transform_ptr(png_const_structrp png_ptr)\n{\n   if (png_ptr == NULL)\n      return NULL;\n\n   return png_ptr->user_transform_ptr;\n}\n",
      "line_start": 835,
      "line_end": 842,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: only a NULL check and return of a struct field. No parsing, memory operations, or branching\u2014minimal value as a fuzz target."
    },
    {
      "name": "png_get_current_row_number",
      "clean_name": "png_get_current_row_number",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "}\n#endif\n\n#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED\npng_uint_32 PNGAPI\npng_get_current_row_number(png_const_structrp png_ptr)\n{\n   /* See the comments in png.h - this is the sub-image row when reading an\n    * interlaced image.\n    */\n   if (png_ptr != NULL)\n      return png_ptr->row_number;\n\n   return PNG_UINT_32_MAX; /* help the app not to fail silently */\n}\n",
      "line_start": 846,
      "line_end": 856,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: returns a field or a constant for NULL. No parsing, memory operations, loops, or branching on external input \u2014 minimal value as a fuzz target."
    },
    {
      "name": "png_get_current_pass_number",
      "clean_name": "png_get_current_pass_number",
      "source_file": "/src/libpng/pngtrans.c",
      "source_code": "\n   return PNG_UINT_32_MAX; /* help the app not to fail silently */\n}\n\npng_byte PNGAPI\npng_get_current_pass_number(png_const_structrp png_ptr)\n{\n   if (png_ptr != NULL)\n      return png_ptr->pass;\n   return 8; /* invalid */\n}\n",
      "line_start": 858,
      "line_end": 864,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: simply returns a struct field or a constant on NULL. No parsing, no memory operations, minimal branching \u2014 very low value as a fuzz target."
    },
    {
      "name": "png_get_copyright",
      "clean_name": "png_get_copyright",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  endif /* TIME_RFC1123 */\n\n#endif /* READ || WRITE */\n\npng_const_charp PNGAPI\npng_get_copyright(png_const_structrp png_ptr)\n{\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n#ifdef PNG_STRING_COPYRIGHT\n   return PNG_STRING_COPYRIGHT\n#else\n   return PNG_STRING_NEWLINE \\\n      \"libpng version 1.6.52.git\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 2018-2025 Cosmin Truta\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\" \\\n      PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1996-1997 Andreas Dilger\" PNG_STRING_NEWLINE \\\n      \"Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\" \\\n      PNG_STRING_NEWLINE;\n#endif\n}\n",
      "line_start": 812,
      "line_end": 828,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Returns a constant string and ignores its argument; no parsing of external input, no memory manipulation, no branching or input-dependent behavior \u2014 not suitable as a fuzz target."
    },
    {
      "name": "png_get_header_ver",
      "clean_name": "png_get_header_ver",
      "source_file": "/src/libpng/png.c",
      "source_code": "   /* Version of *.c files used when building libpng */\n   return png_get_header_ver(png_ptr);\n}\n\npng_const_charp PNGAPI\npng_get_header_ver(png_const_structrp png_ptr)\n{\n   /* Version of *.h files used when building libpng */\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n   return PNG_LIBPNG_VER_STRING;\n}\n",
      "line_start": 845,
      "line_end": 851,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Function ignores its input and returns a constant version string; no parsing, no memory operations, and no external-input-dependent logic \u2014 not suitable as a fuzz target."
    },
    {
      "name": "png_get_header_version",
      "clean_name": "png_get_header_version",
      "source_file": "/src/libpng/png.c",
      "source_code": "   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n   return PNG_LIBPNG_VER_STRING;\n}\n\npng_const_charp PNGAPI\npng_get_header_version(png_const_structrp png_ptr)\n{\n   /* Returns longer string containing both version and date */\n   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */\n#ifdef __STDC__\n   return PNG_HEADER_VERSION_STRING\n#  ifndef PNG_READ_SUPPORTED\n      \" (NO READ SUPPORT)\"\n#  endif\n      PNG_STRING_NEWLINE;\n#else\n   return PNG_HEADER_VERSION_STRING;\n#endif\n}\n",
      "line_start": 853,
      "line_end": 867,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Returns a compile-time constant string and ignores its png_ptr parameter; no parsing or memory operations on external input and thus not suitable as a fuzz target."
    },
    {
      "name": "png_access_version_number",
      "clean_name": "png_access_version_number",
      "source_file": "/src/libpng/png.c",
      "source_code": "}\n#endif /* READ */\n\n/* This function was added to libpng-1.0.7 */\npng_uint_32 PNGAPI\npng_access_version_number(void)\n{\n   /* Version of *.c files used when building libpng */\n   return (png_uint_32)PNG_LIBPNG_VER;\n}\n",
      "line_start": 987,
      "line_end": 992,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or runtime parsing; pure accessor that returns a compile-time constant (library version). Not suitable as a fuzz target."
    },
    {
      "name": "png.c:png_pow10",
      "clean_name": "png_pow10",
      "source_file": "/src/libpng/png.c",
      "source_code": "#  ifdef PNG_FLOATING_POINT_SUPPORTED\n/* Utility used below - a simple accurate power of ten from an integral\n * exponent.\n */\nstatic double\npng_pow10(int power)\n{\n   int recip = 0;\n   double d = 1;\n\n   /* Handle negative exponent with a reciprocal at the end because\n    * 10 is exact whereas .1 is inexact in base 2\n    */\n   if (power < 0)\n   {\n      if (power < DBL_MIN_10_EXP) return 0;\n      recip = 1; power = -power;\n   }\n\n   if (power > 0)\n   {\n      /* Decompose power bitwise. */\n      double mult = 10;\n      do\n      {\n         if (power & 1) d *= mult;\n         mult *= mult;\n         power >>= 1;\n      }\n      while (power > 0);\n\n      if (recip != 0) d = 1/d;\n   }\n   /* else power is 0 and d is 1 */\n\n   return d;\n}\n",
      "line_start": 2276,
      "line_end": 2308,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "Pure numeric utility: deterministic math routine computing 10^power. No parsing of external file/protocol data, no memory or string operations, no security-sensitive logic, and minimal branching \u2014 not a meaningful fuzz target."
    },
    {
      "name": "png_longjmp",
      "clean_name": "png_longjmp",
      "source_file": "/src/libpng/pngerror.c",
      "source_code": "#endif\n   png_longjmp(png_ptr, 1);\n}\n\nPNG_FUNCTION(void,PNGAPI\npng_longjmp,(png_const_structrp png_ptr, int val),PNG_NORETURN)\n{\n#ifdef PNG_SETJMP_SUPPORTED\n   if (png_ptr != NULL && png_ptr->longjmp_fn != NULL &&\n       png_ptr->jmp_buf_ptr != NULL)\n      png_ptr->longjmp_fn(*png_ptr->jmp_buf_ptr, val);\n#else\n   PNG_UNUSED(png_ptr)\n   PNG_UNUSED(val)\n#endif\n\n   /* If control reaches this point, png_longjmp() must not return. The only\n    * choice is to terminate the whole process (or maybe the thread); to do\n    * this the ANSI-C abort() function is used unless a different method is\n    * implemented by overriding the default configuration setting for\n    * PNG_ABORT().\n    */\n   PNG_ABORT();\n}\n",
      "line_start": 669,
      "line_end": 688,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Internal control-flow helper that triggers longjmp/abort; it does not parse external input, perform memory/string ops, or implement logic useful for fuzzing."
    },
    {
      "name": "png_get_eXIf",
      "clean_name": "png_get_eXIf",
      "source_file": "/src/libpng/pngget.c",
      "source_code": "#  endif /* FLOATING_POINT */\n#endif /* mDCV */\n\n#ifdef PNG_eXIf_SUPPORTED\npng_uint_32 PNGAPI\npng_get_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,\n    png_bytep *exif)\n{\n  png_warning(png_ptr, \"png_get_eXIf does not work; use png_get_eXIf_1\");\n  PNG_UNUSED(info_ptr)\n  PNG_UNUSED(exif)\n  return 0;\n}\n",
      "line_start": 892,
      "line_end": 900,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Stub function: parameters are unused, no parsing or memory operations, no control flow \u2014 simply emits a warning and returns 0. Not suitable as a fuzz target."
    }
  ],
  "batch_id": "batch_692a8de9ee808190be0dba9c72bc13b1"
}