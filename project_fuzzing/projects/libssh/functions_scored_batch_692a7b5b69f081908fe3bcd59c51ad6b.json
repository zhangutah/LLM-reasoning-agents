{
  "project": "libssh",
  "model": "gpt-5-mini",
  "total_scored": 928,
  "high_value": 224,
  "functions": [
    {
      "name": "libcrypto.c:evp_cipher_aead_decrypt",
      "clean_name": "evp_cipher_aead_decrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "        return;\n    }\n}\n\nstatic int\nevp_cipher_aead_decrypt(struct ssh_cipher_struct *cipher,\n                        void *complete_packet,\n                        uint8_t *out,\n                        size_t encrypted_size,\n                        uint64_t seq)\n{\n    size_t authlen, aadlen;\n    uint8_t lastiv[1];\n    int outlen = 0;\n    int rc = 0;\n\n    (void)seq;\n\n    aadlen = cipher->lenfield_blocksize;\n    authlen = cipher->tag_size;\n\n    /* increment IV */\n    rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                             EVP_CTRL_GCM_IV_GEN,\n                             1,\n                             lastiv);\n    if (rc == 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_IV_GEN failed\");\n        return SSH_ERROR;\n    }\n\n    /* set tag for authentication */\n    rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                             EVP_CTRL_GCM_SET_TAG,\n                             (int)authlen,\n                             (unsigned char *)complete_packet + aadlen + encrypted_size);\n    if (rc == 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_SET_TAG failed\");\n        return SSH_ERROR;\n    }\n\n    /* Pass over the authenticated data (not encrypted) */\n    rc = EVP_DecryptUpdate(cipher->ctx,\n                           NULL,\n                           &outlen,\n                           (unsigned char *)complete_packet,\n                           (int)aadlen);\n    if (rc == 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to pass authenticated data\");\n        return SSH_ERROR;\n    }\n    /* Do not copy the length to the target buffer, because it is already processed */\n    //memcpy(out, complete_packet, aadlen);\n\n    /* Decrypt the rest of the data */\n    rc = EVP_DecryptUpdate(cipher->ctx,\n                           (unsigned char *)out,\n                           &outlen,\n                           (unsigned char *)complete_packet + aadlen,\n                           (int)encrypted_size /* already subtracted aadlen */);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DecryptUpdate failed\");\n        return SSH_ERROR;\n    }\n\n    if (outlen != (int)encrypted_size) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"EVP_DecryptUpdate: output size %d for %zd in\",\n                outlen,\n                encrypted_size);\n        return SSH_ERROR;\n    }\n\n    /* verify tag */\n    rc = EVP_DecryptFinal(cipher->ctx,\n                          NULL,\n                          &outlen);\n    if (rc < 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DecryptFinal failed: Failed authentication\");\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 664,
      "line_end": 743,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 71,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Performs AEAD decryption on externally-controlled packet data (AAD, ciphertext, tag), uses OpenSSL EVP APIs, and writes decrypted data to an output buffer \u2014 security-critical crypto code that manipulates untrusted memory and has multiple failure branches, making it a high-value fuzz target."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_aead_decrypt",
      "clean_name": "chacha20_poly1305_aead_decrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n    return SSH_OK;\n}\n\nstatic int\nchacha20_poly1305_aead_decrypt(struct ssh_cipher_struct *cipher,\n                               void *complete_packet,\n                               uint8_t *out,\n                               size_t encrypted_size,\n                               uint64_t seq)\n{\n    struct chacha20_poly1305_keysched *ctx = cipher->chacha20_schedule;\n    uint8_t *mac = (uint8_t *)complete_packet + sizeof(uint32_t) +\n                   encrypted_size;\n    uint8_t tag[POLY1305_TAGLEN] = {0};\n    int ret = SSH_ERROR;\n    int rv, cmp, len = 0;\n    size_t taglen = POLY1305_TAGLEN;\n\n    /* Prepare the Poly1305 key */\n    rv = chacha20_poly1305_packet_setup(cipher, seq, 0);\n    if (rv != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to setup packet\");\n        goto out;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"received mac\", mac, POLY1305_TAGLEN);\n#endif /* DEBUG_CRYPTO */\n\n    /* Calculate MAC of received data */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    rv = EVP_DigestSignUpdate(ctx->mctx, complete_packet,\n                              encrypted_size + sizeof(uint32_t));\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DigestSignUpdate failed\");\n        goto out;\n    }\n\n    rv = EVP_DigestSignFinal(ctx->mctx, tag, &taglen);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"poly1305 verify error\");\n        goto out;\n    }\n#else\n    rv = EVP_MAC_update(ctx->mctx, complete_packet,\n                        encrypted_size + sizeof(uint32_t));\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_update failed\");\n        goto out;\n    }\n\n    rv = EVP_MAC_final(ctx->mctx, tag, &taglen, POLY1305_TAGLEN);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_final failed\");\n        goto out;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"calculated mac\", tag, POLY1305_TAGLEN);\n#endif /* DEBUG_CRYPTO */\n\n    /* Verify the calculated MAC matches the attached MAC */\n    cmp = CRYPTO_memcmp(tag, mac, POLY1305_TAGLEN);\n    if (cmp != 0) {\n        /* mac error */\n        SSH_LOG(SSH_LOG_PACKET, \"poly1305 verify error\");\n        return SSH_ERROR;\n    }\n\n    /* Decrypt the message */\n    rv = EVP_CipherUpdate(ctx->main_evp,\n                          out,\n                          &len,\n                          (uint8_t *)complete_packet + sizeof(uint32_t),\n                          (int)encrypted_size);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherUpdate failed\");\n        goto out;\n    }\n\n    rv = EVP_CipherFinal_ex(ctx->main_evp, out + len, &len);\n    if (rv != 1 || len != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherFinal_ex failed\");\n        goto out;\n    }\n\n    ret = SSH_OK;\nout:\n    return ret;\n}\n",
      "line_start": 1020,
      "line_end": 1107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 71,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "High-value fuzz target: consumes complex external input (complete_packet + size), performs security-critical operations (Poly1305 MAC verification and ChaCha20 decryption), manipulates untrusted memory buffers and invokes crypto library calls with multiple error paths \u2014 ideal for finding authentication/buffer handling bugs."
    },
    {
      "name": "bind_config.c:ssh_bind_config_parse_line",
      "clean_name": "ssh_bind_config_parse_line",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "\n    return BIND_MATCH_UNKNOWN;\n}\n\nstatic int\nssh_bind_config_parse_line(ssh_bind bind,\n                           const char *line,\n                           unsigned int count,\n                           uint32_t *parser_flags,\n                           uint8_t *seen,\n                           unsigned int depth)\n{\n    enum ssh_bind_config_opcode_e opcode;\n    const char *p = NULL;\n    char *s = NULL, *x = NULL;\n    char *keyword = NULL;\n    size_t len;\n\n    int rc = 0;\n\n    if (bind == NULL) {\n        return -1;\n    }\n\n    /* Ignore empty lines */\n    if (line == NULL || *line == '\\0') {\n        return 0;\n    }\n\n    if (parser_flags == NULL) {\n        ssh_set_error_invalid(bind);\n        return -1;\n    }\n\n    x = s = strdup(line);\n    if (s == NULL) {\n        ssh_set_error_oom(bind);\n        return -1;\n    }\n\n    /* Remove trailing spaces */\n    for (len = strlen(s) - 1; len > 0; len--) {\n        if (! isspace(s[len])) {\n            break;\n        }\n        s[len] = '\\0';\n    }\n\n    keyword = ssh_config_get_token(&s);\n    if (keyword == NULL || *keyword == '#' ||\n            *keyword == '\\0' || *keyword == '\\n') {\n        SAFE_FREE(x);\n        return 0;\n    }\n\n    opcode = ssh_bind_config_get_opcode(keyword, parser_flags);\n    if ((*parser_flags & PARSING) &&\n            opcode != BIND_CFG_HOSTKEY &&\n            opcode != BIND_CFG_INCLUDE &&\n            opcode != BIND_CFG_MATCH &&\n            opcode > BIND_CFG_UNSUPPORTED) { /* Ignore all unknown types here */\n        /* Skip all the options that were already applied */\n        if (seen[opcode] != 0) {\n            SAFE_FREE(x);\n            return 0;\n        }\n        seen[opcode] = 1;\n    }\n\n    switch (opcode) {\n    case BIND_CFG_INCLUDE:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n#if defined(HAVE_GLOB) && defined(HAVE_GLOB_GL_FLAGS_MEMBER)\n            local_parse_glob(bind, p, parser_flags, seen, depth + 1);\n#else\n            local_parse_file(bind, p, parser_flags, seen, depth + 1);\n#endif /* HAVE_GLOB */\n        }\n        break;\n\n    case BIND_CFG_HOSTKEY:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_HOSTKEY, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set Hostkey value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_LISTENADDRESS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_BINDADDR, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set ListenAddress value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_PORT:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_BINDPORT_STR, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set Port value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_CIPHERS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_CIPHERS_C_S, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set C->S Ciphers value '%s'\",\n                        count, p);\n                break;\n            }\n\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_CIPHERS_S_C, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set S->C Ciphers value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_MACS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_HMAC_C_S, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set C->S MAC value '%s'\",\n                        count, p);\n                break;\n            }\n\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_HMAC_S_C, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set S->C MAC value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_LOGLEVEL:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            int value = -1;\n\n            if (strcasecmp(p, \"quiet\") == 0) {\n                value = SSH_LOG_NONE;\n            } else if (strcasecmp(p, \"fatal\") == 0 ||\n                    strcasecmp(p, \"error\")== 0) {\n                value = SSH_LOG_WARN;\n            } else if (strcasecmp(p, \"verbose\") == 0 ||\n                    strcasecmp(p, \"info\") == 0) {\n                value = SSH_LOG_INFO;\n            } else if (strcasecmp(p, \"DEBUG\") == 0 ||\n                    strcasecmp(p, \"DEBUG1\") == 0) {\n                value = SSH_LOG_DEBUG;\n            } else if (strcasecmp(p, \"DEBUG2\") == 0 ||\n                    strcasecmp(p, \"DEBUG3\") == 0) {\n                value = SSH_LOG_TRACE;\n            }\n            if (value != -1) {\n                rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_LOG_VERBOSITY,\n                        &value);\n                if (rc != 0) {\n                    SSH_LOG(SSH_LOG_TRACE,\n                            \"line %d: Failed to set LogLevel value '%s'\",\n                            count, p);\n                }\n            }\n        }\n        break;\n    case BIND_CFG_KEXALGORITHMS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind, SSH_BIND_OPTIONS_KEY_EXCHANGE, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set KexAlgorithms value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_MATCH: {\n        bool negate;\n        int result = PARSING;\n        size_t args = 0;\n        enum ssh_bind_config_match_e opt;\n        const char *p2 = NULL;\n\n        /* The options set in Match blocks should be applied when a connection\n         * is accepted, and not right away when parsing the file (as it is\n         * currently done). This means the configuration files should be parsed\n         * again or the options set in the Match blocks should be stored and\n         * applied as necessary. */\n\n        /* If this is the first Match block, erase the seen table to allow\n         * options to be overridden. Erasing the seen table was the easiest way\n         * to allow overriding an option, but only for the first occurrence of\n         * an option in a Match block. This is sufficient for the current\n         * implementation which supports only the 'All' criterion, meaning the\n         * options can be applied right away. */\n        if (!(*parser_flags & IN_MATCH)) {\n            memset(seen, 0x00, BIND_CFG_MAX * sizeof(uint8_t));\n        }\n\n        /* In this line the PARSING bit is cleared from the flags */\n        *parser_flags = IN_MATCH;\n        do {\n            p = p2 = ssh_config_get_str_tok(&s, NULL);\n            if (p == NULL || p[0] == '\\0') {\n                break;\n            }\n            args++;\n            SSH_LOG(SSH_LOG_TRACE, \"line %d: Processing Match keyword '%s'\",\n                    count, p);\n\n            /* If the option is prefixed with ! the result should be negated */\n            negate = false;\n            if (p[0] == '!') {\n                negate = true;\n                p++;\n            }\n\n            opt = ssh_bind_config_get_match_opcode(p);\n            switch (opt) {\n            case BIND_MATCH_ALL:\n                p = ssh_config_get_str_tok(&s, NULL);\n                if ((args == 1) && (p == NULL || p[0] == '\\0')) {\n                    /* The \"all\" keyword does not accept arguments or modifiers\n                     */\n                    if (negate == true) {\n                        result = 0;\n                    }\n                    break;\n                }\n                ssh_set_error(bind, SSH_FATAL,\n                              \"line %d: ERROR - Match all cannot be combined with \"\n                              \"other Match attributes\", count);\n                SAFE_FREE(x);\n                return -1;\n            case BIND_MATCH_USER:\n            case BIND_MATCH_GROUP:\n            case BIND_MATCH_HOST:\n            case BIND_MATCH_LOCALADDRESS:\n            case BIND_MATCH_LOCALPORT:\n            case BIND_MATCH_RDOMAIN:\n            case BIND_MATCH_ADDRESS:\n                /* Only \"All\" is supported for now */\n                /* Skip one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    SSH_LOG(SSH_LOG_TRACE, \"line %d: Match keyword \"\n                            \"'%s' requires argument\\n\", count, p2);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                args++;\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"line %d: Unsupported Match keyword '%s', ignoring\\n\",\n                        count,\n                        p2);\n                result = 0;\n                break;\n            case BIND_MATCH_UNKNOWN:\n            default:\n                ssh_set_error(bind, SSH_FATAL,\n                              \"ERROR - Unknown argument '%s' for Match keyword\", p);\n                SAFE_FREE(x);\n                return -1;\n            }\n        } while (p != NULL && p[0] != '\\0');\n        if (args == 0) {\n            ssh_set_error(bind, SSH_FATAL,\n                          \"ERROR - Match keyword requires an argument\");\n            SAFE_FREE(x);\n            return -1;\n        }\n        /* This line only sets the PARSING flag if all checks passed */\n        *parser_flags |= result;\n        break;\n    }\n    case BIND_CFG_PUBKEY_ACCEPTED_KEY_TYPES:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind,\n                                 SSH_BIND_OPTIONS_PUBKEY_ACCEPTED_KEY_TYPES, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set PubKeyAcceptedKeyTypes value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_HOSTKEY_ALGORITHMS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && (*parser_flags & PARSING)) {\n            rc = ssh_bind_options_set(bind,\n                                 SSH_BIND_OPTIONS_HOSTKEY_ALGORITHMS, p);\n            if (rc != 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Failed to set HostkeyAlgorithms value '%s'\",\n                        count, p);\n            }\n        }\n        break;\n    case BIND_CFG_NOT_ALLOWED_IN_MATCH:\n        SSH_LOG(SSH_LOG_DEBUG, \"Option not allowed in Match block: %s, line: %d\",\n                keyword, count);\n        break;\n    case BIND_CFG_UNKNOWN:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown option: %s, line: %d\",\n                keyword, count);\n        break;\n    case BIND_CFG_UNSUPPORTED:\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported option: %s, line: %d\",\n                keyword, count);\n        break;\n    case BIND_CFG_NA:\n        SSH_LOG(SSH_LOG_TRACE, \"Option not applicable: %s, line: %d\",\n                keyword, count);\n        break;\n    default:\n        ssh_set_error(bind, SSH_FATAL, \"ERROR - unimplemented opcode: %d\",\n                opcode);\n        SAFE_FREE(x);\n        return -1;\n        break;\n    }\n\n    SAFE_FREE(x);\n    return rc;\n}\n",
      "line_start": 284,
      "line_end": 623,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 517,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses complex external input (configuration lines/files), performs many string/memory operations (strdup, tokenization, trimming), contains high branching/cyclomatic complexity (many opcodes, Match block loop, state changes), and touches security-critical options (hostkey, ciphers, kex, MACs) and include/recursion \u2014 high-value fuzz target."
    },
    {
      "name": "ssh_userauth_agent",
      "clean_name": "ssh_userauth_agent",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @note Most server implementations do not permit changing the username during\n * authentication. The username should only be set with ssh_options_set() only\n * before you connect to the server.\n */\nint ssh_userauth_agent(ssh_session session, const char *username)\n{\n    int rc = SSH_AUTH_ERROR;\n    struct ssh_agent_state_struct *state = NULL;\n    ssh_key *configKeys = NULL;\n    ssh_key *configCerts = NULL;\n    size_t configKeysCount = 0;\n    size_t configCertsCount = 0;\n    size_t i;\n\n    if (session == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n\n    if (!ssh_agent_is_running(session)) {\n        return SSH_AUTH_DENIED;\n    }\n\n    if (!session->agent_state) {\n        session->agent_state = calloc(1, sizeof(struct ssh_agent_state_struct));\n        if (!session->agent_state) {\n            ssh_set_error_oom(session);\n            return SSH_AUTH_ERROR;\n        }\n        session->agent_state->state = SSH_AGENT_STATE_NONE;\n    }\n\n    state = session->agent_state;\n    if (state->pubkey == NULL) {\n        state->pubkey = ssh_agent_get_first_ident(session, &state->comment);\n    }\n\n    if (state->pubkey == NULL) {\n        return SSH_AUTH_DENIED;\n    }\n\n    if (session->opts.identities_only) {\n        /*\n         * Read keys mentioned in the config, so we can check if key from agent\n         * is in there.\n         */\n        size_t identityLen = ssh_list_count(session->opts.identity);\n        size_t certsLen = ssh_list_count(session->opts.certificate);\n        struct ssh_iterator *it = ssh_list_get_iterator(session->opts.identity);\n\n        configKeys = malloc(identityLen * sizeof(ssh_key));\n        configCerts = malloc((certsLen + identityLen) * sizeof(ssh_key));\n        if (configKeys == NULL || configCerts == NULL) {\n            free(configKeys);\n            free(configCerts);\n            ssh_set_error_oom(session);\n            return SSH_AUTH_ERROR;\n        }\n\n        while (it != NULL && configKeysCount < identityLen) {\n            const char *privkeyFile = it->data;\n            size_t certPathLen;\n            char *certFile = NULL;\n            ssh_key pubkey = NULL;\n            ssh_key cert = NULL;\n\n            /*\n             * Read the private key file listed in the config, but we're only\n             * interested in the public key. Don't try to decrypt private key.\n             */\n            rc = ssh_pki_import_pubkey_file(privkeyFile, &pubkey);\n            if (rc == SSH_OK) {\n                configKeys[configKeysCount++] = pubkey;\n            } else {\n                char *pubkeyFile = NULL;\n                size_t pubkeyPathLen = strlen(privkeyFile) + sizeof(\".pub\");\n\n                SSH_KEY_FREE(pubkey);\n\n                /*\n                * If we couldn't get the public key from the private key file,\n                * try a .pub file instead.\n                */\n                pubkeyFile = malloc(pubkeyPathLen);\n                if (!pubkeyFile) {\n                    ssh_set_error_oom(session);\n                    rc = SSH_AUTH_ERROR;\n                    goto done;\n                }\n                snprintf(pubkeyFile, pubkeyPathLen, \"%s.pub\", privkeyFile);\n                rc = ssh_pki_import_pubkey_file(pubkeyFile, &pubkey);\n                free(pubkeyFile);\n                if (rc == SSH_OK) {\n                    configKeys[configKeysCount++] = pubkey;\n                } else if (pubkey) {\n                    SSH_KEY_FREE(pubkey);\n                }\n            }\n            /* Now try to see if there is a certificate with default name\n             * do not merge it yet with the key as we need to try first the\n             * non-certified key */\n            certPathLen = strlen(privkeyFile) + sizeof(\"-cert.pub\");\n            certFile = malloc(certPathLen);\n            if (!certFile) {\n                ssh_set_error_oom(session);\n                rc = SSH_AUTH_ERROR;\n                goto done;\n            }\n            snprintf(certFile, certPathLen, \"%s-cert.pub\", privkeyFile);\n            rc = ssh_pki_import_cert_file(certFile, &cert);\n            free(certFile);\n            if (rc == SSH_OK) {\n                configCerts[configCertsCount++] = cert;\n            } else if (cert) {\n                SSH_KEY_FREE(cert);\n            }\n\n            it = it->next;\n        }\n        /* And now load separately-listed certificates. */\n        it = ssh_list_get_iterator(session->opts.certificate);\n        while (it != NULL && configCertsCount < certsLen + identityLen) {\n            const char *certFile = it->data;\n            ssh_key cert = NULL;\n\n            rc = ssh_pki_import_cert_file(certFile, &cert);\n            if (rc == SSH_OK) {\n                configCerts[configCertsCount++] = cert;\n            } else if (cert) {\n                SSH_KEY_FREE(cert);\n            }\n\n            it = it->next;\n        }\n    }\n\n    while (state->pubkey != NULL) {\n        if (state->state == SSH_AGENT_STATE_NONE) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Trying identity %s\",\n                    state->comment);\n            if (session->opts.identities_only) {\n                /* Check if this key is one of the keys listed in the config */\n                bool found_key = false;\n                for (i = 0; i < configKeysCount; i++) {\n                    int cmp = ssh_key_cmp(state->pubkey,\n                                          configKeys[i],\n                                          SSH_KEY_CMP_PUBLIC);\n                    if (cmp == 0) {\n                        found_key = true;\n                        break;\n                    }\n                }\n                /* or in separate certificates */\n                for (i = 0; i < configCertsCount; i++) {\n                    int cmp = ssh_key_cmp(state->pubkey,\n                                          configCerts[i],\n                                          SSH_KEY_CMP_PUBLIC);\n                    if (cmp == 0) {\n                        found_key = true;\n                        break;\n                    }\n                }\n\n                if (!found_key) {\n                    SSH_LOG(SSH_LOG_DEBUG,\n                            \"Identities only is enabled and identity %s was \"\n                            \"not listed in config, skipping\",\n                            state->comment);\n                    SSH_STRING_FREE_CHAR(state->comment);\n                    state->comment = NULL;\n                    SSH_KEY_FREE(state->pubkey);\n                    state->pubkey = ssh_agent_get_next_ident(\n                        session, &state->comment);\n\n                    if (state->pubkey == NULL) {\n                        rc = SSH_AUTH_DENIED;\n                    }\n                    continue;\n                }\n            }\n        }\n        if (state->state == SSH_AGENT_STATE_NONE ||\n            state->state == SSH_AGENT_STATE_PUBKEY ||\n            state->state == SSH_AGENT_STATE_CERT) {\n            rc = ssh_userauth_try_publickey(session, username, state->pubkey);\n            if (rc == SSH_AUTH_ERROR) {\n                ssh_agent_state_free(state);\n                session->agent_state = NULL;\n                goto done;\n            } else if (rc == SSH_AUTH_AGAIN) {\n                state->state = (state->state == SSH_AGENT_STATE_NONE ?\n                                SSH_AGENT_STATE_PUBKEY : state->state);\n                goto done;\n            } else if (rc != SSH_AUTH_SUCCESS) {\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"Public key of %s refused by server\",\n                        state->comment);\n                if (state->state == SSH_AGENT_STATE_PUBKEY) {\n                    for (i = 0; i < configCertsCount; i++) {\n                        int cmp = ssh_key_cmp(state->pubkey,\n                                              configCerts[i],\n                                              SSH_KEY_CMP_PUBLIC);\n                        if (cmp == 0) {\n                            SSH_LOG(SSH_LOG_DEBUG,\n                                    \"Retry with matching certificate\");\n                            SSH_KEY_FREE(state->pubkey);\n                            state->pubkey = ssh_key_dup(configCerts[i]);\n                            state->state = SSH_AGENT_STATE_CERT;\n                            continue;\n                        }\n                    }\n                }\n                SSH_STRING_FREE_CHAR(state->comment);\n                state->comment = NULL;\n                SSH_KEY_FREE(state->pubkey);\n                state->pubkey = ssh_agent_get_next_ident(session,\n                                                         &state->comment);\n                state->state = SSH_AGENT_STATE_NONE;\n                continue;\n            }\n\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Public key of %s accepted by server\",\n                    state->comment);\n            state->state = SSH_AGENT_STATE_AUTH;\n        }\n        if (state->state == SSH_AGENT_STATE_AUTH) {\n            rc = ssh_userauth_agent_publickey(session, username, state->pubkey);\n            if (rc == SSH_AUTH_AGAIN) {\n                goto done;\n            }\n            SSH_STRING_FREE_CHAR(state->comment);\n            state->comment = NULL;\n            if (rc == SSH_AUTH_ERROR || rc == SSH_AUTH_PARTIAL) {\n                ssh_agent_state_free(session->agent_state);\n                session->agent_state = NULL;\n                goto done;\n            } else if (rc != SSH_AUTH_SUCCESS) {\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"Server accepted public key but refused the signature\");\n                SSH_KEY_FREE(state->pubkey);\n                state->pubkey = ssh_agent_get_next_ident(session,\n                                                         &state->comment);\n                state->state = SSH_AGENT_STATE_NONE;\n                continue;\n            }\n            ssh_agent_state_free (session->agent_state);\n            session->agent_state = NULL;\n            rc = SSH_AUTH_SUCCESS;\n            goto done;\n        }\n    }\n\n    ssh_agent_state_free (session->agent_state);\n    session->agent_state = NULL;\ndone:\n    for (i = 0; i < configKeysCount; i++) {\n        ssh_key_free(configKeys[i]);\n    }\n    free(configKeys);\n    for (i = 0; i < configCertsCount; i++) {\n        ssh_key_free(configCerts[i]);\n    }\n    free(configCerts);\n    return rc;\n}\n",
      "line_start": 1010,
      "line_end": 1272,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 371,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Critical target: handles SSH authentication and cryptographic operations, processes multiple external inputs (session options, agent identities, key and cert files), performs memory operations (malloc, snprintf, buffer handling), and contains complex branching and loops driven by untrusted data \u2014 high risk and high value for fuzzing."
    },
    {
      "name": "curve25519.c:ssh_packet_client_curve25519_reply",
      "clean_name": "ssh_packet_client_curve25519_reply",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "\n/** @internal\n * @brief parses a SSH_MSG_KEX_ECDH_REPLY packet and sends back\n * a SSH_MSG_NEWKEYS\n */\nstatic SSH_PACKET_CALLBACK(ssh_packet_client_curve25519_reply)\n{\n    ssh_string q_s_string = NULL;\n    ssh_string pubkey_blob = NULL;\n    ssh_string signature = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    ssh_client_curve25519_remove_callbacks(session);\n\n    pubkey_blob = ssh_buffer_get_ssh_string(packet);\n    if (pubkey_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No public key in packet\");\n        goto error;\n    }\n\n    rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n    SSH_STRING_FREE(pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to import next public key\");\n        goto error;\n    }\n\n    q_s_string = ssh_buffer_get_ssh_string(packet);\n    if (q_s_string == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No Q_S ECC point in packet\");\n        goto error;\n    }\n    if (ssh_string_len(q_s_string) != CURVE25519_PUBKEY_SIZE) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Incorrect size for server Curve25519 public key: %zu\",\n                      ssh_string_len(q_s_string));\n        SSH_STRING_FREE(q_s_string);\n        goto error;\n    }\n    memcpy(session->next_crypto->curve25519_server_pubkey,\n           ssh_string_data(q_s_string),\n           CURVE25519_PUBKEY_SIZE);\n    SSH_STRING_FREE(q_s_string);\n\n    signature = ssh_buffer_get_ssh_string(packet);\n    if (signature == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No signature in packet\");\n        goto error;\n    }\n    session->next_crypto->dh_server_signature = signature;\n    signature = NULL; /* ownership changed */\n    /* TODO: verify signature now instead of waiting for NEWKEYS */\n    if (ssh_curve25519_build_k(session) < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_packet_send_newkeys(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n\n    return SSH_PACKET_USED;\n\nerror:\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 131,
      "line_end": 199,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 100,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses structured SSH packet data (complex external input), performs memcpy of untrusted data into crypto state, and is part of a cryptographic key-exchange handshake\u2014security-critical with multiple validation branches; high-impact fuzzing target."
    },
    {
      "name": "curve25519.c:ssh_packet_server_curve25519_init",
      "clean_name": "ssh_packet_server_curve25519_init",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "}\n\n/** @brief Parse a SSH_MSG_KEXDH_INIT packet (server) and send a\n * SSH_MSG_KEXDH_REPLY\n */\nstatic SSH_PACKET_CALLBACK(ssh_packet_server_curve25519_init)\n{\n    /* ECDH keys */\n    ssh_string q_c_string = NULL;\n    ssh_string q_s_string = NULL;\n    ssh_string server_pubkey_blob = NULL;\n\n    /* SSH host keys (rsa, ed25519 and ecdsa) */\n    ssh_key privkey = NULL;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    ssh_packet_remove_callbacks(session, &ssh_curve25519_server_callbacks);\n\n    /* Extract the client pubkey from the init packet */\n    q_c_string = ssh_buffer_get_ssh_string(packet);\n    if (q_c_string == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No Q_C ECC point in packet\");\n        goto error;\n    }\n    if (ssh_string_len(q_c_string) != CURVE25519_PUBKEY_SIZE) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Incorrect size for server Curve25519 public key: %zu\",\n                      ssh_string_len(q_c_string));\n        goto error;\n    }\n\n    memcpy(session->next_crypto->curve25519_client_pubkey,\n           ssh_string_data(q_c_string),\n           CURVE25519_PUBKEY_SIZE);\n    SSH_STRING_FREE(q_c_string);\n\n    /* Build server's key pair */\n    rc = ssh_curve25519_init(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to generate curve25519 keys\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_KEX_ECDH_REPLY);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* build k and session_id */\n    rc = ssh_curve25519_build_k(session);\n    if (rc < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* privkey is not allocated */\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n\n    rc = ssh_dh_get_next_server_publickey_blob(session, &server_pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL, \"Could not export server public key\");\n        goto error;\n    }\n\n    /* add host's public key */\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, server_pubkey_blob);\n    SSH_STRING_FREE(server_pubkey_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* add ecdh public key */\n    q_s_string = ssh_string_new(CURVE25519_PUBKEY_SIZE);\n    if (q_s_string == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_string_fill(q_s_string,\n                         session->next_crypto->curve25519_server_pubkey,\n                         CURVE25519_PUBKEY_SIZE);\n    if (rc < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Could not copy public key\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, q_s_string);\n    SSH_STRING_FREE(q_s_string);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    /* add signature blob */\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_KEX_ECDH_REPLY sent\");\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_packet_send_newkeys(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    return SSH_PACKET_USED;\nerror:\n    SSH_STRING_FREE(q_c_string);\n    SSH_STRING_FREE(q_s_string);\n    ssh_buffer_reinit(session->out_buffer);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 227,
      "line_end": 366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 214,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses and validates external packet data (client Curve25519 public key), performs memory operations on untrusted data, drives cryptographic key generation/signing and session state transitions, and contains many error/branch paths \u2014 making it a high-value, security-critical fuzz target."
    },
    {
      "name": "sntrup761.c:ssh_packet_server_sntrup761x25519_init",
      "clean_name": "ssh_packet_server_sntrup761x25519_init",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "}\n\n/** @brief Parse a SSH_MSG_KEXDH_INIT packet (server) and send a\n * SSH_MSG_KEXDH_REPLY\n */\nstatic SSH_PACKET_CALLBACK(ssh_packet_server_sntrup761x25519_init)\n{\n    /* ECDH/SNTRUP761 keys */\n    ssh_string q_c_string = NULL;\n    ssh_string q_s_string = NULL;\n    ssh_string server_pubkey_blob = NULL;\n\n    /* SSH host keys (rsa, ed25519 and ecdsa) */\n    ssh_key privkey = NULL;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    ssh_packet_remove_callbacks(session, &ssh_sntrup761x25519_server_callbacks);\n\n    /* Extract the client pubkey from the init packet */\n    q_c_string = ssh_buffer_get_ssh_string(packet);\n    if (q_c_string == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No sntrup761x25519 Q_C in packet\");\n        goto error;\n    }\n    if (ssh_string_len(q_c_string) != (SNTRUP761_PUBLICKEY_SIZE + CURVE25519_PUBKEY_SIZE)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Incorrect size for server sntrup761x25519 public key: %zu\",\n                      ssh_string_len(q_c_string));\n        goto error;\n    }\n\n    memcpy(session->next_crypto->sntrup761_client_pubkey,\n           ssh_string_data(q_c_string),\n           SNTRUP761_PUBLICKEY_SIZE);\n    memcpy(session->next_crypto->curve25519_client_pubkey,\n           ((char *)ssh_string_data(q_c_string)) + SNTRUP761_PUBLICKEY_SIZE,\n           CURVE25519_PUBKEY_SIZE);\n    SSH_STRING_FREE(q_c_string);\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"client public key sntrup761\",\n                    session->next_crypto->sntrup761_client_pubkey,\n                    SNTRUP761_PUBLICKEY_SIZE);\n    ssh_log_hexdump(\"client public key c25519\",\n                    session->next_crypto->curve25519_client_pubkey,\n                    CURVE25519_PUBKEY_SIZE);\n#endif\n\n    /* Build server's key pair */\n    rc = ssh_sntrup761x25519_init(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to generate sntrup761 keys\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_KEX_ECDH_REPLY);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* build k and session_id */\n    rc = ssh_sntrup761x25519_build_k(session);\n    if (rc < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* privkey is not allocated */\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n\n    rc = ssh_dh_get_next_server_publickey_blob(session, &server_pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL, \"Could not export server public key\");\n        goto error;\n    }\n\n    /* add host's public key */\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, server_pubkey_blob);\n    SSH_STRING_FREE(server_pubkey_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* add ecdh public key */\n    rc = ssh_buffer_add_u32(session->out_buffer,\n                            ntohl(SNTRUP761_CIPHERTEXT_SIZE\n                                  + CURVE25519_PUBKEY_SIZE));\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_add_data(session->out_buffer,\n                             session->next_crypto->sntrup761_ciphertext,\n                             SNTRUP761_CIPHERTEXT_SIZE);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_add_data(session->out_buffer,\n                             session->next_crypto->curve25519_server_pubkey,\n                             CURVE25519_PUBKEY_SIZE);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"server public key c25519\",\n                    session->next_crypto->curve25519_server_pubkey,\n                    CURVE25519_PUBKEY_SIZE);\n#endif\n\n    /* add signature blob */\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    if (rc < 0) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"ECDH_REPLY:\",\n                    ssh_buffer_get(session->out_buffer),\n                    ssh_buffer_get_len(session->out_buffer));\n#endif\n\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_KEX_ECDH_REPLY sent\");\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_NEWKEYS);\n    if (rc < 0) {\n        goto error;\n    }\n\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_NEWKEYS sent\");\n\n    return SSH_PACKET_USED;\nerror:\n    SSH_STRING_FREE(q_c_string);\n    SSH_STRING_FREE(q_s_string);\n    ssh_buffer_reinit(session->out_buffer);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 346,
      "line_end": 518,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 224,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "High-value fuzz target: parses structured SSH KEX packet (external input), validates length then memcpy's untrusted bytes into crypto buffers, performs keygen/key-agreement and signs session (security-critical), and contains many branches/error paths \u2014 ideal for finding memory/crypto parsing bugs."
    },
    {
      "name": "ssh_server_dh_process_init",
      "clean_name": "ssh_server_dh_process_init",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "\n/** @internal\n * @brief processes a SSH_MSG_KEXDH_INIT or SSH_MSG_KEX_DH_GEX_INIT packet and sends\n * the appropriate SSH_MSG_KEXDH_REPLY or SSH_MSG_KEX_DH_GEX_REPLY\n */\nint ssh_server_dh_process_init(ssh_session session, ssh_buffer packet)\n{\n    struct ssh_crypto_struct *crypto = session->next_crypto;\n    ssh_key privkey = NULL;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    ssh_string pubkey_blob = NULL;\n    bignum client_pubkey;\n#if !defined(HAVE_LIBCRYPTO) || OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum server_pubkey;\n#else\n    bignum server_pubkey = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n    int packet_type;\n    int rc;\n\n    rc = ssh_buffer_unpack(packet, \"B\", &client_pubkey);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"No e number in client request\");\n        goto error;\n    }\n\n    rc = ssh_dh_keypair_set_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR,\n                                 NULL, client_pubkey);\n    if (rc != SSH_OK) {\n        bignum_safe_free(client_pubkey);\n        goto error;\n    }\n\n    rc = ssh_dh_keypair_gen_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n    rc = ssh_dh_compute_shared_secret(crypto->dh_ctx,\n                                      DH_SERVER_KEYPAIR, DH_CLIENT_KEYPAIR,\n                                      &crypto->shared_secret);\n    ssh_dh_debug_crypto(crypto);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"Could not generate shared secret\");\n        goto error;\n    }\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n    switch (crypto->kex_type){\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n        packet_type = SSH2_MSG_KEXDH_REPLY;\n        break;\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n    case SSH_KEX_DH_GEX_SHA256:\n        packet_type = SSH2_MSG_KEX_DH_GEX_REPLY;\n        break;\n#endif /* WITH_GEX */\n    default:\n        ssh_set_error(session, SSH_FATAL, \"Invalid kex type\");\n        goto error;\n    }\n    rc = ssh_dh_keypair_get_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR,\n                                 NULL, &server_pubkey);\n    if (rc != SSH_OK){\n        goto error;\n    }\n    rc = ssh_dh_get_next_server_publickey_blob(session, &pubkey_blob);\n    if (rc != SSH_OK){\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bSBS\",\n                         packet_type,\n                         pubkey_blob,\n                         server_pubkey,\n                         sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(pubkey_blob);\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(server_pubkey);\n#endif\n    if(rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        ssh_buffer_reinit(session->out_buffer);\n        goto error;\n    }\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"Sent KEX_DH_[GEX]_REPLY\");\n\n    session->dh_handshake_state=DH_STATE_NEWKEYS_SENT;\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_packet_send_newkeys(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    return SSH_OK;\nerror:\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(pubkey_blob);\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(server_pubkey);\n#endif\n\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    ssh_dh_cleanup(session->next_crypto);\n    return SSH_ERROR;\n}\n",
      "line_start": 441,
      "line_end": 566,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 212,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses untrusted SSH packet data (bignum client public key), performs cryptographic key-exchange, shared-secret computation and signing, and builds/sends protocol replies \u2014 security-critical code with multiple error/branch paths and memory operations on attacker-controlled input, making it a top-priority fuzz target."
    },
    {
      "name": "dh.c:ssh_packet_client_dh_reply",
      "clean_name": "ssh_packet_client_dh_reply",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "void ssh_client_dh_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_dh_client_callbacks);\n}\n\nSSH_PACKET_CALLBACK(ssh_packet_client_dh_reply){\n  struct ssh_crypto_struct *crypto=session->next_crypto;\n  ssh_string pubkey_blob = NULL;\n  bignum server_pubkey;\n  int rc;\n\n  (void)type;\n  (void)user;\n\n  ssh_client_dh_remove_callbacks(session);\n\n  rc = ssh_buffer_unpack(packet, \"SBS\", &pubkey_blob, &server_pubkey,\n          &crypto->dh_server_signature);\n  if (rc == SSH_ERROR) {\n      goto error;\n  }\n  rc = ssh_dh_keypair_set_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR,\n                               NULL, server_pubkey);\n  if (rc != SSH_OK) {\n      SSH_STRING_FREE(pubkey_blob);\n      bignum_safe_free(server_pubkey);\n      goto error;\n  }\n  rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n  SSH_STRING_FREE(pubkey_blob);\n  if (rc != 0) {\n      goto error;\n  }\n\n  rc = ssh_dh_compute_shared_secret(session->next_crypto->dh_ctx,\n                                    DH_CLIENT_KEYPAIR, DH_SERVER_KEYPAIR,\n                                    &session->next_crypto->shared_secret);\n  ssh_dh_debug_crypto(session->next_crypto);\n  if (rc == SSH_ERROR){\n    ssh_set_error(session, SSH_FATAL, \"Could not generate shared secret\");\n    goto error;\n  }\n\n  /* Send the MSG_NEWKEYS */\n  rc = ssh_packet_send_newkeys(session);\n  if (rc == SSH_ERROR) {\n    goto error;\n  }\n  session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n  return SSH_PACKET_USED;\nerror:\n  ssh_dh_cleanup(session->next_crypto);\n  session->session_state=SSH_SESSION_STATE_ERROR;\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 361,
      "line_end": 411,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 91,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses complex external input (SSH packet unpacking including a public-key blob and bignum), performs cryptographic operations (DH key handling, shared-secret computation, signature handling), and has multiple error branches \u2014 high-security, high-value fuzz target."
    },
    {
      "name": "sshkdf_derive_key",
      "clean_name": "sshkdf_derive_key",
      "source_file": "/src/libssh/src/kdf.c",
      "source_code": "    }\n    SAFE_FREE(ctx);\n    return rc;\n}\n\nint sshkdf_derive_key(struct ssh_crypto_struct *crypto,\n                      unsigned char *key,\n                      size_t key_len,\n                      uint8_t key_type,\n                      unsigned char *output,\n                      size_t requested_len)\n{\n    /* Can't use VLAs with Visual Studio, so allocate the biggest\n     * digest buffer we can possibly need */\n    unsigned char digest[DIGEST_MAX_LEN];\n    size_t output_len = crypto->digest_len;\n    ssh_mac_ctx ctx;\n    int rc;\n\n    if (DIGEST_MAX_LEN < crypto->digest_len) {\n        return -1;\n    }\n\n    ctx = ssh_mac_ctx_init(crypto->digest_type);\n    if (ctx == NULL) {\n        return -1;\n    }\n\n    rc = ssh_mac_update(ctx, key, key_len);\n    if (rc != SSH_OK) {\n        ssh_mac_ctx_free(ctx);\n        return -1;\n    }\n    rc = ssh_mac_update(ctx, crypto->secret_hash, crypto->digest_len);\n    if (rc != SSH_OK) {\n        ssh_mac_ctx_free(ctx);\n        return -1;\n    }\n    rc = ssh_mac_update(ctx, &key_type, 1);\n    if (rc != SSH_OK) {\n        ssh_mac_ctx_free(ctx);\n        return -1;\n    }\n    rc = ssh_mac_update(ctx, crypto->session_id, crypto->session_id_len);\n    if (rc != SSH_OK) {\n        ssh_mac_ctx_free(ctx);\n        return -1;\n    }\n    rc = ssh_mac_final(digest, ctx);\n    if (rc != SSH_OK) {\n        return -1;\n    }\n\n    if (requested_len < output_len) {\n        output_len = requested_len;\n    }\n    memcpy(output, digest, output_len);\n\n    while (requested_len > output_len) {\n        ctx = ssh_mac_ctx_init(crypto->digest_type);\n        if (ctx == NULL) {\n            return -1;\n        }\n        rc = ssh_mac_update(ctx, key, key_len);\n        if (rc != SSH_OK) {\n            ssh_mac_ctx_free(ctx);\n            return -1;\n        }\n        rc = ssh_mac_update(ctx, crypto->secret_hash, crypto->digest_len);\n        if (rc != SSH_OK) {\n            ssh_mac_ctx_free(ctx);\n            return -1;\n        }\n        rc = ssh_mac_update(ctx, output, output_len);\n        if (rc != SSH_OK) {\n            ssh_mac_ctx_free(ctx);\n            return -1;\n        }\n        rc = ssh_mac_final(digest, ctx);\n        if (rc != SSH_OK) {\n            return -1;\n        }\n        if (requested_len < output_len + crypto->digest_len) {\n            memcpy(output + output_len, digest, requested_len - output_len);\n        } else {\n            memcpy(output + output_len, digest, crypto->digest_len);\n        }\n        output_len += crypto->digest_len;\n    }\n\n    return 0;\n}\n",
      "line_start": 151,
      "line_end": 238,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 103,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Cryptographic key-derivation function that processes external inputs (key, session_id, lengths), performs memory operations (memcpy) and iterative MAC updates with input-dependent loop bounds \u2014 security-critical and high-value fuzz target for finding memory/logic/crypto misuse issues."
    },
    {
      "name": "ssh_packet_kexinit",
      "clean_name": "ssh_packet_kexinit",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    is_wrong = (strncmp(client_str, server_str, client_kex_len) != 0);\n\n    return is_wrong;\n}\n\nSSH_PACKET_CALLBACK(ssh_packet_kexinit)\n{\n    int i, ok;\n    struct ssh_crypto_struct *crypto = session->next_crypto;\n    int server_kex = session->server;\n    ssh_string str = NULL;\n    char *strings[SSH_KEX_METHODS] = {0};\n    int rc = SSH_ERROR;\n    size_t len;\n\n    uint8_t first_kex_packet_follows = 0;\n    uint32_t kexinit_reserved = 0;\n\n    (void)type;\n    (void)user;\n\n    SSH_LOG(SSH_LOG_TRACE, \"KEXINIT received\");\n\n    if (session->session_state == SSH_SESSION_STATE_AUTHENTICATED) {\n        if (session->dh_handshake_state == DH_STATE_FINISHED) {\n            SSH_LOG(SSH_LOG_DEBUG, \"Peer initiated key re-exchange\");\n            /* Reset the sent flag if the re-kex was initiated by the peer */\n            session->flags &= ~SSH_SESSION_FLAG_KEXINIT_SENT;\n        } else if (session->flags & SSH_SESSION_FLAG_KEXINIT_SENT &&\n                   session->dh_handshake_state == DH_STATE_INIT_SENT) {\n            /* This happens only when we are sending our-guessed first kex\n             * packet right after our KEXINIT packet. */\n            SSH_LOG(SSH_LOG_DEBUG, \"Received peer kexinit answer.\");\n        } else if (session->session_state != SSH_SESSION_STATE_INITIAL_KEX) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"SSH_KEXINIT received in wrong state\");\n            goto error;\n        }\n    } else if (session->session_state != SSH_SESSION_STATE_INITIAL_KEX) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"SSH_KEXINIT received in wrong state\");\n        goto error;\n    }\n\n    if (server_kex) {\n#ifdef WITH_SERVER\n        len = ssh_buffer_get_data(packet, crypto->client_kex.cookie, 16);\n        if (len != 16) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"ssh_packet_kexinit: no cookie in packet\");\n            goto error;\n        }\n\n        ok = ssh_hashbufin_add_cookie(session, crypto->client_kex.cookie);\n        if (ok < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"ssh_packet_kexinit: adding cookie failed\");\n            goto error;\n        }\n\n        ok = server_set_kex(session);\n        if (ok == SSH_ERROR) {\n            goto error;\n        }\n#endif /* WITH_SERVER */\n    } else {\n        len = ssh_buffer_get_data(packet, crypto->server_kex.cookie, 16);\n        if (len != 16) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"ssh_packet_kexinit: no cookie in packet\");\n            goto error;\n        }\n\n        ok = ssh_hashbufin_add_cookie(session, crypto->server_kex.cookie);\n        if (ok < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"ssh_packet_kexinit: adding cookie failed\");\n            goto error;\n        }\n\n        ok = ssh_set_client_kex(session);\n        if (ok == SSH_ERROR) {\n            goto error;\n        }\n    }\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        str = ssh_buffer_get_ssh_string(packet);\n        if (str == NULL) {\n          goto error;\n        }\n\n        rc = ssh_buffer_add_ssh_string(session->in_hashbuf, str);\n        if (rc < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Error adding string in hash buffer\");\n            goto error;\n        }\n\n        strings[i] = ssh_string_to_char(str);\n        if (strings[i] == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        SSH_STRING_FREE(str);\n        str = NULL;\n    }\n\n    /* copy the peer kex info into an array of strings */\n    if (server_kex) {\n#ifdef WITH_SERVER\n        for (i = 0; i < SSH_KEX_METHODS; i++) {\n            crypto->client_kex.methods[i] = strings[i];\n        }\n#endif /* WITH_SERVER */\n    } else { /* client */\n        for (i = 0; i < SSH_KEX_METHODS; i++) {\n            crypto->server_kex.methods[i] = strings[i];\n        }\n    }\n\n    /*\n     * Handle the two final fields for the KEXINIT message (RFC 4253 7.1):\n     *\n     *      boolean      first_kex_packet_follows\n     *      uint32       0 (reserved for future extension)\n     *\n     * Notably if clients set 'first_kex_packet_follows', it is expected\n     * that its value is included when computing the session ID (see\n     * 'make_sessionid').\n     */\n\n    rc = ssh_buffer_get_u8(packet, &first_kex_packet_follows);\n    if (rc != 1) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_u8(session->in_hashbuf, first_kex_packet_follows);\n    if (rc < 0) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_u32(session->in_hashbuf, kexinit_reserved);\n    if (rc < 0) {\n        goto error;\n    }\n\n    /*\n     * Remember whether 'first_kex_packet_follows' was set and the client\n     * guess was wrong: in this case the next SSH_MSG_KEXDH_INIT message\n     * must be ignored on the server side.\n     * Client needs to start the Key exchange over with the correct method\n     */\n    if (first_kex_packet_follows || session->send_first_kex_follows) {\n        char **client_methods = crypto->client_kex.methods;\n        char **server_methods = crypto->server_kex.methods;\n        session->first_kex_follows_guess_wrong =\n            cmp_first_kex_algo(client_methods[SSH_KEX],\n                               server_methods[SSH_KEX]) ||\n            cmp_first_kex_algo(client_methods[SSH_HOSTKEYS],\n                               server_methods[SSH_HOSTKEYS]);\n            SSH_LOG(SSH_LOG_DEBUG, \"The initial guess was %s.\",\n                    session->first_kex_follows_guess_wrong ? \"wrong\" : \"right\");\n    }\n\n    /*\n     * handle the \"strict KEX\" feature. If supported by peer, then set up the\n     * flag and verify packet sequence numbers.\n     */\n    if (server_kex) {\n        ok = match_group(crypto->client_kex.methods[SSH_KEX],\n                         KEX_STRICT_CLIENT);\n        if (ok) {\n            SSH_LOG(SSH_LOG_DEBUG, \"Client supports strict kex, enabling.\");\n            session->flags |= SSH_SESSION_FLAG_KEX_STRICT;\n        }\n    } else {\n        /* client kex */\n        ok = match_group(crypto->server_kex.methods[SSH_KEX],\n                         KEX_STRICT_SERVER);\n        if (ok) {\n            SSH_LOG(SSH_LOG_DEBUG, \"Server supports strict kex, enabling.\");\n            session->flags |= SSH_SESSION_FLAG_KEX_STRICT;\n        }\n    }\n#ifdef WITH_SERVER\n    if (server_kex) {\n        /*\n         * If client sent a ext-info-c message in the kex list, it supports\n         * RFC 8308 extension negotiation.\n         */\n        ok = match_group(crypto->client_kex.methods[SSH_KEX],\n                         KEX_EXTENSION_CLIENT);\n        if (ok) {\n            const char *hostkeys = NULL, *wanted_hostkeys = NULL;\n\n            /* The client supports extension negotiation */\n            session->extensions |= SSH_EXT_NEGOTIATION;\n            /*\n             * RFC 8332 Section 3.1: Use for Server Authentication\n             * Check what algorithms were provided in the SSH_HOSTKEYS list\n             * by the client and enable the respective extensions to provide\n             * correct signature in the next packet if RSA is negotiated\n             */\n            hostkeys = crypto->client_kex.methods[SSH_HOSTKEYS];\n            wanted_hostkeys = session->opts.wanted_methods[SSH_HOSTKEYS];\n            ok = match_group(hostkeys, \"rsa-sha2-512\");\n            if (ok) {\n                /* Check if rsa-sha2-512 is allowed by config */\n                if (wanted_hostkeys != NULL) {\n                    char *is_allowed = ssh_find_matching(wanted_hostkeys,\n                                                         \"rsa-sha2-512\");\n                    if (is_allowed != NULL) {\n                        session->extensions |= SSH_EXT_SIG_RSA_SHA512;\n                    }\n                    SAFE_FREE(is_allowed);\n                }\n            }\n            ok = match_group(hostkeys, \"rsa-sha2-256\");\n            if (ok) {\n                /* Check if rsa-sha2-256 is allowed by config */\n                if (wanted_hostkeys != NULL) {\n                    char *is_allowed = ssh_find_matching(wanted_hostkeys,\n                                                         \"rsa-sha2-256\");\n                    if (is_allowed != NULL) {\n                        session->extensions |= SSH_EXT_SIG_RSA_SHA256;\n                    }\n                    SAFE_FREE(is_allowed);\n                }\n            }\n\n            /*\n             * Ensure that the client preference is honored for the case\n             * both signature types are enabled.\n             */\n            if ((session->extensions & SSH_EXT_SIG_RSA_SHA256) &&\n                (session->extensions & SSH_EXT_SIG_RSA_SHA512)) {\n                char *rsa_sig_ext = NULL;\n                session->extensions &= ~(SSH_EXT_SIG_RSA_SHA256 | SSH_EXT_SIG_RSA_SHA512);\n                rsa_sig_ext = ssh_find_matching(\"rsa-sha2-512,rsa-sha2-256\",\n                                                hostkeys);\n                if (rsa_sig_ext == NULL) {\n                    goto error; /* should never happen */\n                } else if (strcmp(rsa_sig_ext, \"rsa-sha2-512\") == 0) {\n                    session->extensions |= SSH_EXT_SIG_RSA_SHA512;\n                } else if (strcmp(rsa_sig_ext, \"rsa-sha2-256\") == 0) {\n                    session->extensions |= SSH_EXT_SIG_RSA_SHA256;\n                } else {\n                    SAFE_FREE(rsa_sig_ext);\n                    goto error; /* should never happen */\n                }\n                SAFE_FREE(rsa_sig_ext);\n            }\n\n            SSH_LOG(SSH_LOG_DEBUG, \"The client supports extension \"\n                    \"negotiation. Enabled signature algorithms: %s%s\",\n                    session->extensions & SSH_EXT_SIG_RSA_SHA256 ? \"SHA256\" : \"\",\n                    session->extensions & SSH_EXT_SIG_RSA_SHA512 ? \" SHA512\" : \"\");\n        }\n    }\n#endif /* WITH_SERVER */\n\n    /* Note, that his overwrites authenticated state in case of rekeying */\n    session->session_state = SSH_SESSION_STATE_KEXINIT_RECEIVED;\n    /* if we already sent our initial key exchange packet, do not reset the\n     * DH state. We will know if we were right with our guess only in\n     * dh_handshake_state() */\n    if (session->send_first_kex_follows == false) {\n        session->dh_handshake_state = DH_STATE_INIT;\n    }\n    session->ssh_connection_callback(session);\n    return SSH_PACKET_USED;\n\nerror:\n    SSH_STRING_FREE(str);\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        if (server_kex) {\n#ifdef WITH_SERVER\n            session->next_crypto->client_kex.methods[i] = NULL;\n#endif /* WITH_SERVER */\n        } else { /* client */\n            session->next_crypto->server_kex.methods[i] = NULL;\n        }\n        SAFE_FREE(strings[i]);\n    }\n\n    session->session_state = SSH_SESSION_STATE_ERROR;\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 374,
      "line_end": 659,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 388,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex external SSH KEXINIT packets (variable-length strings, cookies, booleans), performs buffer/string allocations and manipulations, has many branches and loops, and makes security-critical decisions (key-exchange, hostkey/extension negotiation). High potential for memory/logic bugs \u2014 critical fuzz target."
    },
    {
      "name": "ssh_send_kex",
      "clean_name": "ssh_send_kex",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    return SSH_OK;\n}\n\n\n/* this function only sends the predefined set of kex methods */\nint ssh_send_kex(ssh_session session)\n{\n    struct ssh_kex_struct *kex = (session->server ?\n        &session->next_crypto->server_kex :\n        &session->next_crypto->client_kex);\n    ssh_string str = NULL;\n    int i;\n    int rc;\n    int first_kex_packet_follows = 0;\n\n    /* Only client can initiate the handshake methods we implement. If we\n     * already received the peer mechanisms, there is no point in guessing */\n    if (session->client &&\n        session->session_state != SSH_SESSION_STATE_KEXINIT_RECEIVED &&\n        session->send_first_kex_follows) {\n        first_kex_packet_follows = 1;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Sending KEXINIT packet, first_kex_packet_follows = %d\",\n            first_kex_packet_follows);\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bP\",\n                         SSH2_MSG_KEXINIT,\n                         (size_t)16,\n                         kex->cookie); /* cookie */\n    if (rc != SSH_OK)\n        goto error;\n    if (ssh_hashbufout_add_cookie(session) < 0) {\n        goto error;\n    }\n\n    ssh_list_kex(kex);\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        str = ssh_string_from_char(kex->methods[i]);\n        if (str == NULL) {\n            goto error;\n        }\n\n        rc = ssh_buffer_add_ssh_string(session->out_hashbuf, str);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = ssh_buffer_add_ssh_string(session->out_buffer, str);\n        if (rc < 0) {\n            goto error;\n        }\n        SSH_STRING_FREE(str);\n        str = NULL;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bd\",\n                         first_kex_packet_follows,\n                         0);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    /* Prepare also the first_kex_packet_follows and reserved to 0 */\n    rc = ssh_buffer_add_u8(session->out_hashbuf, first_kex_packet_follows);\n    if (rc < 0) {\n        goto error;\n    }\n    rc = ssh_buffer_add_u32(session->out_hashbuf, 0);\n    if (rc < 0) {\n        goto error;\n    }\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return -1;\n    }\n\n    session->flags |= SSH_SESSION_FLAG_KEXINIT_SENT;\n    SSH_LOG(SSH_LOG_PACKET, \"SSH_MSG_KEXINIT sent\");\n\n    /* If we indicated that we are sending the guessed key exchange packet,\n     * do it now. The packet is simple, but we need to do some preparations */\n    if (first_kex_packet_follows == 1) {\n        char *list = kex->methods[SSH_KEX];\n        char *colon = strchr(list, ',');\n        size_t kex_name_len = colon ? (size_t)(colon - list) : strlen(list);\n        char *kex_name = calloc(kex_name_len + 1, 1);\n        if (kex_name == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        snprintf(kex_name, kex_name_len + 1, \"%.*s\", (int)kex_name_len, list);\n        SSH_LOG(SSH_LOG_TRACE, \"Sending the first kex packet for %s\", kex_name);\n\n        session->next_crypto->kex_type = kex_select_kex_type(kex_name);\n        free(kex_name);\n\n        /* run the first step of the DH handshake */\n        session->dh_handshake_state = DH_STATE_INIT;\n        if (dh_handshake(session) == SSH_ERROR) {\n            goto error;\n        }\n    }\n    return 0;\n\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n    ssh_buffer_reinit(session->out_hashbuf);\n    SSH_STRING_FREE(str);\n\n    return -1;\n}\n",
      "line_start": 1054,
      "line_end": 1165,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 165,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Constructs/parses SSH KEX packets and method strings, performs memory/string/buffer ops (calloc, snprintf, strchr, ssh_buffer_*), loops over methods, has multiple branches (including first_kex_packet_follows), and invokes DH handshake/crypto logic \u2014 security-critical and high-risk code, making it a top-priority fuzz target."
    },
    {
      "name": "ssh_make_sessionid",
      "clean_name": "ssh_make_sessionid",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "\n    free(tmp);\n    return ret;\n}\n\nint ssh_make_sessionid(ssh_session session)\n{\n    ssh_string num = NULL;\n    ssh_buffer server_hash = NULL;\n    ssh_buffer client_hash = NULL;\n    ssh_buffer buf = NULL;\n    ssh_string server_pubkey_blob = NULL;\n#if !defined(HAVE_LIBCRYPTO) || OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum client_pubkey, server_pubkey;\n#else\n    bignum client_pubkey = NULL, server_pubkey = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n#ifdef WITH_GEX\n#if !defined(HAVE_LIBCRYPTO) || OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum modulus, generator;\n#else\n    bignum modulus = NULL, generator = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n#endif /* WITH_GEX */\n    int rc = SSH_ERROR;\n\n    buf = ssh_buffer_new();\n    if (buf == NULL) {\n        ssh_set_error_oom(session);\n        return rc;\n    }\n\n    rc = ssh_buffer_pack(buf,\n                         \"ss\",\n                         session->clientbanner,\n                         session->serverbanner);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Failed to pack client and server banner\");\n        goto error;\n    }\n\n    if (session->client) {\n        server_hash = session->in_hashbuf;\n        client_hash = session->out_hashbuf;\n    } else {\n        server_hash = session->out_hashbuf;\n        client_hash = session->in_hashbuf;\n    }\n\n    rc = ssh_dh_get_next_server_publickey_blob(session, &server_pubkey_blob);\n    if (rc != SSH_OK) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Failed to get next server pubkey blob\");\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(buf,\n                         \"dPdPS\",\n                         ssh_buffer_get_len(client_hash),\n                         (size_t)ssh_buffer_get_len(client_hash),\n                         ssh_buffer_get(client_hash),\n                         ssh_buffer_get_len(server_hash),\n                         (size_t)ssh_buffer_get_len(server_hash),\n                         ssh_buffer_get(server_hash),\n                         server_pubkey_blob);\n    SSH_STRING_FREE(server_pubkey_blob);\n    if (rc != SSH_OK){\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Failed to pack hashes and pubkey blob\");\n        goto error;\n    }\n\n    switch(session->next_crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n        rc = ssh_dh_keypair_get_keys(session->next_crypto->dh_ctx,\n                                     DH_CLIENT_KEYPAIR, NULL, &client_pubkey);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_dh_keypair_get_keys(session->next_crypto->dh_ctx,\n                                     DH_SERVER_KEYPAIR, NULL, &server_pubkey);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_buffer_pack(buf,\n                             \"BB\",\n                             client_pubkey,\n                             server_pubkey);\n        if (rc != SSH_OK) {\n            ssh_set_error(session, SSH_FATAL, \"Failed to pack DH pubkeys\");\n            goto error;\n        }\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n        bignum_safe_free(client_pubkey);\n        bignum_safe_free(server_pubkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n    case SSH_KEX_DH_GEX_SHA256:\n        rc = ssh_dh_keypair_get_keys(session->next_crypto->dh_ctx,\n                                     DH_CLIENT_KEYPAIR, NULL, &client_pubkey);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_dh_keypair_get_keys(session->next_crypto->dh_ctx,\n                                     DH_SERVER_KEYPAIR, NULL, &server_pubkey);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_dh_get_parameters(session->next_crypto->dh_ctx,\n                                   &modulus, &generator);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_buffer_pack(buf,\n                    \"dddBBBB\",\n                    session->next_crypto->dh_pmin,\n                    session->next_crypto->dh_pn,\n                    session->next_crypto->dh_pmax,\n                    modulus,\n                    generator,\n                    client_pubkey,\n                    server_pubkey);\n        if (rc != SSH_OK) {\n            ssh_set_error(session, SSH_FATAL, \"Failed to pack DH GEX params\");\n            goto error;\n        }\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n        bignum_safe_free(modulus);\n        bignum_safe_free(generator);\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n#endif /* WITH_GEX */\n#ifdef HAVE_ECDH\n    case SSH_KEX_ECDH_SHA2_NISTP256:\n    case SSH_KEX_ECDH_SHA2_NISTP384:\n    case SSH_KEX_ECDH_SHA2_NISTP521:\n        if (session->next_crypto->ecdh_client_pubkey == NULL ||\n            session->next_crypto->ecdh_server_pubkey == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"ECDH parameter missing\");\n            goto error;\n        }\n        rc = ssh_buffer_pack(buf,\n                             \"SS\",\n                             session->next_crypto->ecdh_client_pubkey,\n                             session->next_crypto->ecdh_server_pubkey);\n        if (rc != SSH_OK) {\n            ssh_set_error(session, SSH_FATAL, \"Failed to pack ECDH pubkeys\");\n            goto error;\n        }\n        break;\n#endif /* HAVE_ECDH */\n#ifdef HAVE_CURVE25519\n    case SSH_KEX_CURVE25519_SHA256:\n    case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n        rc = ssh_buffer_pack(buf,\n                             \"dPdP\",\n                             CURVE25519_PUBKEY_SIZE,\n                             (size_t)CURVE25519_PUBKEY_SIZE,\n                             session->next_crypto->curve25519_client_pubkey,\n                             CURVE25519_PUBKEY_SIZE,\n                             (size_t)CURVE25519_PUBKEY_SIZE,\n                             session->next_crypto->curve25519_server_pubkey);\n\n        if (rc != SSH_OK) {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Failed to pack Curve25519 pubkeys\");\n            goto error;\n        }\n        break;\n#endif /* HAVE_CURVE25519 */\n#ifdef HAVE_SNTRUP761\n    case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n        rc = ssh_buffer_pack(buf,\n                             \"dPPdPP\",\n                             SNTRUP761_PUBLICKEY_SIZE + CURVE25519_PUBKEY_SIZE,\n                             (size_t)SNTRUP761_PUBLICKEY_SIZE,\n                             session->next_crypto->sntrup761_client_pubkey,\n                             (size_t)CURVE25519_PUBKEY_SIZE,\n                             session->next_crypto->curve25519_client_pubkey,\n                             SNTRUP761_CIPHERTEXT_SIZE + CURVE25519_PUBKEY_SIZE,\n                             (size_t)SNTRUP761_CIPHERTEXT_SIZE,\n                             session->next_crypto->sntrup761_ciphertext,\n                             (size_t)CURVE25519_PUBKEY_SIZE,\n                             session->next_crypto->curve25519_server_pubkey);\n\n        if (rc != SSH_OK) {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Failed to pack SNTRU Prime params\");\n            goto error;\n        }\n        break;\n#endif /* HAVE_SNTRUP761 */\n    }\n    if (session->next_crypto->kex_type == SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM) {\n        rc = ssh_buffer_pack(buf,\n                             \"F\",\n                             session->next_crypto->shared_secret,\n                             SHA512_DIGEST_LEN);\n    } else {\n        rc = ssh_buffer_pack(buf, \"B\", session->next_crypto->shared_secret);\n    }\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to pack shared secret\");\n        goto error;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"hash buffer\", ssh_buffer_get(buf), ssh_buffer_get_len(buf));\n#endif\n\n    /* Set rc for the following switch statement in case we goto error. */\n    rc = SSH_ERROR;\n    switch (session->next_crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n#endif /* WITH_GEX */\n        session->next_crypto->digest_len = SHA_DIGEST_LENGTH;\n        session->next_crypto->digest_type = SSH_KDF_SHA1;\n        session->next_crypto->secret_hash = malloc(session->next_crypto->digest_len);\n        if (session->next_crypto->secret_hash == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        sha1(ssh_buffer_get(buf), ssh_buffer_get_len(buf),\n                                   session->next_crypto->secret_hash);\n        break;\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_ECDH_SHA2_NISTP256:\n    case SSH_KEX_CURVE25519_SHA256:\n    case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA256:\n#endif /* WITH_GEX */\n        session->next_crypto->digest_len = SHA256_DIGEST_LENGTH;\n        session->next_crypto->digest_type = SSH_KDF_SHA256;\n        session->next_crypto->secret_hash = malloc(session->next_crypto->digest_len);\n        if (session->next_crypto->secret_hash == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        sha256(ssh_buffer_get(buf), ssh_buffer_get_len(buf),\n                                     session->next_crypto->secret_hash);\n        break;\n    case SSH_KEX_ECDH_SHA2_NISTP384:\n        session->next_crypto->digest_len = SHA384_DIGEST_LENGTH;\n        session->next_crypto->digest_type = SSH_KDF_SHA384;\n        session->next_crypto->secret_hash = malloc(session->next_crypto->digest_len);\n        if (session->next_crypto->secret_hash == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        sha384(ssh_buffer_get(buf), ssh_buffer_get_len(buf),\n                                     session->next_crypto->secret_hash);\n        break;\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n    case SSH_KEX_ECDH_SHA2_NISTP521:\n    case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n        session->next_crypto->digest_len = SHA512_DIGEST_LENGTH;\n        session->next_crypto->digest_type = SSH_KDF_SHA512;\n        session->next_crypto->secret_hash = malloc(session->next_crypto->digest_len);\n        if (session->next_crypto->secret_hash == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        sha512(ssh_buffer_get(buf),\n               ssh_buffer_get_len(buf),\n               session->next_crypto->secret_hash);\n        break;\n    }\n\n    /* During the first kex, secret hash and session ID are equal. However, after\n     * a key re-exchange, a new secret hash is calculated. This hash will not replace\n     * but complement existing session id.\n     */\n    if (!session->next_crypto->session_id) {\n        session->next_crypto->session_id = malloc(session->next_crypto->digest_len);\n        if (session->next_crypto->session_id == NULL) {\n            ssh_set_error_oom(session);\n            rc = SSH_ERROR;\n            goto error;\n        }\n        memcpy(session->next_crypto->session_id, session->next_crypto->secret_hash,\n                session->next_crypto->digest_len);\n\t/* Initial length is the same as secret hash */\n\tsession->next_crypto->session_id_len = session->next_crypto->digest_len;\n    }\n#ifdef DEBUG_CRYPTO\n    SSH_LOG(SSH_LOG_DEBUG, \"Session hash: \\n\");\n    ssh_log_hexdump(\"secret hash\", session->next_crypto->secret_hash, session->next_crypto->digest_len);\n    ssh_log_hexdump(\"session id\", session->next_crypto->session_id, session->next_crypto->session_id_len);\n#endif /* DEBUG_CRYPTO */\n\n    rc = SSH_OK;\nerror:\n    SSH_BUFFER_FREE(buf);\n    SSH_BUFFER_FREE(client_hash);\n    SSH_BUFFER_FREE(server_hash);\n\n    session->in_hashbuf = NULL;\n    session->out_hashbuf = NULL;\n\n    SSH_STRING_FREE(num);\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(client_pubkey);\n    bignum_safe_free(server_pubkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    return rc;\n}\n",
      "line_start": 1354,
      "line_end": 1673,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 440,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Critical fuzz target: it ingests many externally-controlled fields (banners, hash buffers, server pubkey blob, shared-secret, DH/ECDH/Curve25519/SNTRUP params), performs buffer packing and memory operations (alloc/memcpy), contains many kex-dependent branches and crypto hashing. High security impact and complex input-dependent control flow make it top priority for fuzzing."
    },
    {
      "name": "ssh_known_hosts_parse_line",
      "clean_name": "ssh_known_hosts_parse_line",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *                          entry structure. The user needs to free the memory\n *                          using SSH_KNOWNHOSTS_ENTRY_FREE().\n *\n * @return SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_known_hosts_parse_line(const char *hostname,\n                               const char *line,\n                               struct ssh_knownhosts_entry **entry)\n{\n    struct ssh_knownhosts_entry *e = NULL;\n    char *known_host = NULL;\n    char *p = NULL;\n    char *save_tok = NULL;\n    enum ssh_keytypes_e key_type;\n    int match = 0;\n    int rc = SSH_OK;\n\n    known_host = strdup(line);\n    if (known_host == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* match pattern for hostname or hashed hostname */\n    p = strtok_r(known_host, \" \", &save_tok);\n    if (p == NULL ) {\n        free(known_host);\n        return SSH_ERROR;\n    }\n\n    e = calloc(1, sizeof(struct ssh_knownhosts_entry));\n    if (e == NULL) {\n        free(known_host);\n        return SSH_ERROR;\n    }\n\n    if (hostname != NULL) {\n        char *host_port = NULL;\n        char *q = NULL;\n\n        /* Hashed */\n        if (p[0] == '|') {\n            match = match_hashed_hostname(hostname, p);\n        }\n\n        save_tok = NULL;\n\n        for (q = strtok_r(p, \",\", &save_tok);\n             q != NULL;\n             q = strtok_r(NULL, \",\", &save_tok)) {\n            int cmp;\n\n            if (q[0] == '[' && hostname[0] != '[') {\n                /* Corner case: We have standard port so we do not have\n                 * hostname in square braces. But the pattern is enclosed\n                 * in braces with, possibly standard or wildcard, port.\n                 * We need to test against [host]:port pair here.\n                 */\n                if (host_port == NULL) {\n                    host_port = ssh_hostport(hostname, 22);\n                    if (host_port == NULL) {\n                        rc = SSH_ERROR;\n                        goto out;\n                    }\n                }\n\n                cmp = match_hostname(host_port, q, strlen(q));\n            } else {\n                cmp = match_hostname(hostname, q, strlen(q));\n            }\n            if (cmp == 1) {\n                match = 1;\n                break;\n            }\n        }\n        free(host_port);\n\n        if (match == 0) {\n            rc = SSH_AGAIN;\n            goto out;\n        }\n\n        e->hostname = strdup(hostname);\n        if (e->hostname == NULL) {\n            rc = SSH_ERROR;\n            goto out;\n        }\n    }\n\n    /* Restart parsing */\n    SAFE_FREE(known_host);\n    known_host = strdup(line);\n    if (known_host == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    save_tok = NULL;\n\n    p = strtok_r(known_host, \" \", &save_tok);\n    if (p == NULL ) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    e->unparsed = strdup(p);\n    if (e->unparsed == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    /* pubkey type */\n    p = strtok_r(NULL, \" \", &save_tok);\n    if (p == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    key_type = ssh_key_type_from_name(p);\n    if (key_type == SSH_KEYTYPE_UNKNOWN) {\n        SSH_LOG(SSH_LOG_TRACE, \"key type '%s' unknown!\", p);\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    /* public key */\n    p = strtok_r(NULL, \" \", &save_tok);\n    if (p == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    rc = ssh_pki_import_pubkey_base64(p,\n                                      key_type,\n                                      &e->publickey);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to parse %s key for entry: %s!\",\n                ssh_key_type_to_char(key_type),\n                e->unparsed);\n        goto out;\n    }\n\n    /* comment */\n    p = strtok_r(NULL, \" \", &save_tok);\n    if (p != NULL) {\n        p = strstr(line, p);\n        if (p != NULL) {\n            e->comment = strdup(p);\n            if (e->comment == NULL) {\n                rc = SSH_ERROR;\n                goto out;\n            }\n        }\n    }\n\n    *entry = e;\n    SAFE_FREE(known_host);\n\n    return SSH_OK;\nout:\n    SAFE_FREE(known_host);\n    ssh_knownhosts_entry_free(e);\n    return rc;\n}\n",
      "line_start": 634,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 218,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex external input (known_hosts lines), performs extensive string/buffer operations and tokenization, loops over comma-separated patterns, handles hashed hostnames, resolves key types and imports base64 public keys (crypto parsing). High branching/cyclomatic complexity and security-critical behavior make it a high-value fuzz target."
    },
    {
      "name": "ssh_packet_userauth_request",
      "clean_name": "ssh_packet_userauth_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " * @internal\n *\n * @brief Handle a SSH_MSG_MSG_USERAUTH_REQUEST packet and queue a\n * SSH Message\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_request)\n{\n    ssh_message msg = NULL;\n    ssh_signature sig = NULL;\n    char *service = NULL;\n    char *method = NULL;\n    int cmp;\n    int rc;\n\n    (void)user;\n    (void)type;\n\n    msg = ssh_message_new(session);\n    if (msg == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    msg->type = SSH_REQUEST_AUTH;\n    rc = ssh_buffer_unpack(packet,\n                           \"sss\",\n                           &msg->auth_request.username,\n                           &service,\n                           &method);\n\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Auth request for service %s, method %s for user '%s'\",\n            service,\n            method,\n            msg->auth_request.username);\n\n    cmp = strcmp(service, \"ssh-connection\");\n    if (cmp != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid service request: %s\", service);\n        goto end;\n    }\n\n    if (strcmp(method, \"none\") == 0) {\n        msg->auth_request.method = SSH_AUTH_METHOD_NONE;\n        goto end;\n    }\n\n    if (strcmp(method, \"password\") == 0) {\n        uint8_t tmp;\n\n        msg->auth_request.method = SSH_AUTH_METHOD_PASSWORD;\n        rc = ssh_buffer_unpack(packet, \"bs\", &tmp, &msg->auth_request.password);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(method, \"keyboard-interactive\") == 0) {\n        ssh_string lang = NULL;\n        ssh_string submethods = NULL;\n\n        msg->auth_request.method = SSH_AUTH_METHOD_INTERACTIVE;\n        lang = ssh_buffer_get_ssh_string(packet);\n        if (lang == NULL) {\n            goto error;\n        }\n        /* from the RFC 4256\n         * 3.1.  Initial Exchange\n         * \"The language tag is deprecated and SHOULD be the empty string.\"\n         */\n        SSH_STRING_FREE(lang);\n\n        submethods = ssh_buffer_get_ssh_string(packet);\n        if (submethods == NULL) {\n            goto error;\n        }\n        /* from the RFC 4256\n         * 3.1.  Initial Exchange\n         * \"One possible implementation strategy of the submethods field on the\n         *  server is that, unless the user may use multiple different\n         *  submethods, the server ignores this field.\"\n         */\n        SSH_STRING_FREE(submethods);\n\n        goto end;\n    }\n\n    if (strcmp(method, \"publickey\") == 0 ||\n        strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0) {\n        ssh_string algo = NULL;\n        ssh_string pubkey_blob = NULL;\n        ssh_string server_pubkey_blob = NULL;\n        uint8_t has_sign;\n\n        msg->auth_request.method = SSH_AUTH_METHOD_PUBLICKEY;\n\n        rc = ssh_buffer_unpack(packet, \"bSS\", &has_sign, &algo, &pubkey_blob);\n\n        if (rc != SSH_OK) {\n            goto error;\n        }\n\n        cmp = strcmp(method, \"publickey-hostbound-v00@openssh.com\");\n        if (cmp == 0) {\n            server_pubkey_blob = ssh_buffer_get_ssh_string(packet);\n            if (server_pubkey_blob == NULL) {\n                SSH_STRING_FREE(pubkey_blob);\n                SSH_STRING_FREE(algo);\n                goto error;\n            }\n\n            rc = ssh_pki_import_pubkey_blob(server_pubkey_blob,\n                                            &msg->auth_request.server_pubkey);\n            SSH_STRING_FREE(server_pubkey_blob);\n\n            if (rc < 0) {\n                SSH_STRING_FREE(pubkey_blob);\n                SSH_STRING_FREE(algo);\n                goto error;\n            }\n        }\n\n        rc = ssh_pki_import_pubkey_blob(pubkey_blob, &msg->auth_request.pubkey);\n        SSH_STRING_FREE(pubkey_blob);\n        pubkey_blob = NULL;\n        if (rc < 0) {\n            SSH_STRING_FREE(algo);\n            algo = NULL;\n            goto error;\n        }\n        msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_NONE;\n        msg->auth_request.sigtype = strdup(ssh_string_get_char(algo));\n        if (msg->auth_request.sigtype == NULL) {\n            msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_ERROR;\n            SSH_STRING_FREE(algo);\n            algo = NULL;\n            goto error;\n        }\n\n        // has a valid signature ?\n        if (has_sign) {\n            ssh_string sig_blob = NULL;\n            ssh_buffer digest = NULL;\n\n            sig_blob = ssh_buffer_get_ssh_string(packet);\n            if (sig_blob == NULL) {\n                SSH_LOG(SSH_LOG_PACKET, \"Invalid signature packet from peer\");\n                msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_ERROR;\n                SSH_STRING_FREE(algo);\n                algo = NULL;\n                goto error;\n            }\n\n            digest = ssh_msg_userauth_build_digest(session,\n                                                   msg,\n                                                   service,\n                                                   algo,\n                                                   method);\n            SSH_STRING_FREE(algo);\n            algo = NULL;\n            if (digest == NULL) {\n                SSH_STRING_FREE(sig_blob);\n                SSH_LOG(SSH_LOG_PACKET, \"Failed to get digest\");\n                msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_WRONG;\n                goto error;\n            }\n\n            rc = ssh_pki_import_signature_blob(sig_blob,\n                                               msg->auth_request.pubkey,\n                                               &sig);\n            if (rc == SSH_OK) {\n                /* Check if the signature from client matches server preferences\n                 */\n                if (session->opts.pubkey_accepted_types) {\n                    cmp = match_group(session->opts.pubkey_accepted_types,\n                                      sig->type_c);\n                    if (cmp != 1) {\n                        ssh_set_error(\n                            session,\n                            SSH_FATAL,\n                            \"Public key from client (%s) doesn't match server \"\n                            \"preference (%s)\",\n                            sig->type_c,\n                            session->opts.pubkey_accepted_types);\n                        rc = SSH_ERROR;\n                    }\n                }\n\n                if (rc == SSH_OK) {\n                    rc = ssh_pki_signature_verify(session,\n                                                  sig,\n                                                  msg->auth_request.pubkey,\n                                                  ssh_buffer_get(digest),\n                                                  ssh_buffer_get_len(digest));\n                }\n            }\n            SSH_STRING_FREE(sig_blob);\n            SSH_BUFFER_FREE(digest);\n            ssh_signature_free(sig);\n            if (rc < 0) {\n                SSH_LOG(SSH_LOG_PACKET,\n                        \"Received an invalid signature from peer\");\n                msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_WRONG;\n                goto error;\n            }\n\n            SSH_LOG(SSH_LOG_PACKET, \"Valid signature received\");\n\n            cmp = strcmp(method, \"publickey-hostbound-v00@openssh.com\");\n            if (cmp == 0) {\n                ssh_key server_key = NULL;\n\n                if (msg->auth_request.server_pubkey == NULL) {\n                    SSH_LOG(SSH_LOG_PACKET,\n                            \"Server public key not provided by client\");\n                    msg->auth_request.signature_state =\n                        SSH_PUBLICKEY_STATE_WRONG;\n                    goto error;\n                }\n\n                rc = ssh_get_server_publickey(session, &server_key);\n                if (rc != SSH_OK) {\n                    SSH_LOG(SSH_LOG_PACKET,\n                            \"Failed to get server public key for hostbound \"\n                            \"verification\");\n                    msg->auth_request.signature_state =\n                        SSH_PUBLICKEY_STATE_ERROR;\n                    ssh_key_free(server_key);\n                    goto error;\n                }\n\n                if (ssh_key_cmp(server_key,\n                                msg->auth_request.server_pubkey,\n                                SSH_KEY_CMP_PUBLIC) != 0) {\n                    SSH_LOG(SSH_LOG_PACKET,\n                            \"Server public key doesn't match the one provided \"\n                            \"by client\");\n                    msg->auth_request.signature_state =\n                        SSH_PUBLICKEY_STATE_WRONG;\n                    ssh_key_free(server_key);\n                    goto error;\n                }\n                ssh_key_free(server_key);\n            }\n\n            msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_VALID;\n        }\n\n        SAFE_FREE(method);\n        SSH_STRING_FREE(algo);\n        goto end;\n    }\n#ifdef WITH_GSSAPI\n    if (strcmp(method, \"gssapi-with-mic\") == 0) {\n        uint32_t n_oid;\n        ssh_string *oids = NULL;\n        ssh_string oid = NULL;\n        char *hexa = NULL;\n        int i;\n        ssh_buffer_get_u32(packet, &n_oid);\n        n_oid = ntohl(n_oid);\n        if (n_oid > 100) {\n            ssh_set_error(\n                session,\n                SSH_FATAL,\n                \"USERAUTH_REQUEST: gssapi-with-mic OID count too big (%d)\",\n                n_oid);\n            goto error;\n        }\n        SSH_LOG(SSH_LOG_PACKET, \"gssapi: %d OIDs\", n_oid);\n        oids = calloc(n_oid, sizeof(ssh_string));\n        if (oids == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        for (i = 0; i < (int)n_oid; ++i) {\n            oid = ssh_buffer_get_ssh_string(packet);\n            if (oid == NULL) {\n                for (i = i - 1; i >= 0; --i) {\n                    SAFE_FREE(oids[i]);\n                }\n                SAFE_FREE(oids);\n                ssh_set_error(session,\n                              SSH_LOG_PACKET,\n                              \"USERAUTH_REQUEST: gssapi-with-mic missing OID\");\n                goto error;\n            }\n            oids[i] = oid;\n            if (session->common.log_verbosity >= SSH_LOG_PACKET) {\n                hexa = ssh_get_hexa(ssh_string_data(oid), ssh_string_len(oid));\n                SSH_LOG(SSH_LOG_PACKET, \"gssapi: OID %d: %s\", i, hexa);\n                SAFE_FREE(hexa);\n            }\n        }\n        ssh_gssapi_handle_userauth(session,\n                                   msg->auth_request.username,\n                                   n_oid,\n                                   oids);\n\n        for (i = 0; i < (int)n_oid; ++i) {\n            SAFE_FREE(oids[i]);\n        }\n        SAFE_FREE(oids);\n        /* bypass the message queue thing */\n        SAFE_FREE(service);\n        SAFE_FREE(method);\n        SSH_MESSAGE_FREE(msg);\n\n        return SSH_PACKET_USED;\n    }\n#endif\n\n    msg->auth_request.method = SSH_AUTH_METHOD_UNKNOWN;\n    SAFE_FREE(method);\n    goto end;\nerror:\n    SAFE_FREE(service);\n    SAFE_FREE(method);\n\n    SSH_MESSAGE_FREE(msg);\n\n    return SSH_PACKET_USED;\nend:\n    SAFE_FREE(service);\n    SAFE_FREE(method);\n\n    ssh_message_queue(session, msg);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 840,
      "line_end": 1169,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 477,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex, structured SSH userauth packets and untrusted blobs; performs many memory operations/allocations on attacker-controlled data (unpack/get_ssh_string, strdup, import blobs), has high branching/cyclomatic complexity across multiple auth methods, includes input-dependent loops (GSSAPI OID count) and handles cryptographic/security-critical operations (publickey import, signature parsing and verification, hostbound checks). High-risk, high-value fuzz target."
    },
    {
      "name": "ssh_packet_userauth_info_response",
      "clean_name": "ssh_packet_userauth_info_response",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    (void)packet;\n    (void)user;\n    return SSH_PACKET_USED;\n}\n#else /* WITH_SERVER */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_info_response){\n  uint32_t nanswers;\n  uint32_t i;\n  ssh_string tmp = NULL;\n  int rc;\n\n  ssh_message msg = NULL;\n\n  /* GSSAPI_TOKEN has same packed number. XXX fix this */\n#ifdef WITH_GSSAPI\n  if (session->gssapi != NULL) {\n      return ssh_packet_userauth_gssapi_token(session, type, packet, user);\n  }\n#endif\n  (void)user;\n  (void)type;\n\n  msg = ssh_message_new(session);\n  if (msg == NULL) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  /* HACK: we forge a message to be able to handle it in the\n   * same switch() as other auth methods */\n  msg->type = SSH_REQUEST_AUTH;\n  msg->auth_request.method = SSH_AUTH_METHOD_INTERACTIVE;\n  msg->auth_request.kbdint_response = 1;\n#if 0 // should we wipe the username ?\n  msg->auth_request.username = NULL;\n#endif\n\n  rc = ssh_buffer_unpack(packet, \"d\", &nanswers);\n  if (rc != SSH_OK) {\n      ssh_set_error_invalid(session);\n      goto error;\n  }\n\n  if (session->kbdint == NULL) {\n    SSH_LOG(SSH_LOG_DEBUG, \"Warning: Got a keyboard-interactive \"\n                        \"response but it seems we didn't send the request.\");\n\n    session->kbdint = ssh_kbdint_new();\n    if (session->kbdint == NULL) {\n      ssh_set_error_oom(session);\n\n      goto error;\n    }\n  } else if (session->kbdint->answers != NULL) {\n      uint32_t n;\n\n      for (n = 0; n < session->kbdint->nanswers; n++) {\n            explicit_bzero(session->kbdint->answers[n],\n                           strlen(session->kbdint->answers[n]));\n            SAFE_FREE(session->kbdint->answers[n]);\n      }\n      SAFE_FREE(session->kbdint->answers);\n      session->kbdint->nanswers = 0;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\"kbdint: %\" PRIu32 \" answers\", nanswers);\n  if (nanswers > KBDINT_MAX_PROMPT) {\n    ssh_set_error(session, SSH_FATAL,\n        \"Too much answers received from client: %\" PRIu32 \" (0x%.4\" PRIx32 \")\",\n        nanswers, nanswers);\n    ssh_kbdint_free(session->kbdint);\n    session->kbdint = NULL;\n\n    goto error;\n  }\n\n  if(nanswers != session->kbdint->nprompts) {\n    /* warn but let the application handle this case */\n    SSH_LOG(SSH_LOG_DEBUG, \"Warning: Number of prompts and answers\"\n                \" mismatch: p=%\" PRIu32 \" a=%\" PRIu32, session->kbdint->nprompts, nanswers);\n  }\n  session->kbdint->nanswers = nanswers;\n\n  session->kbdint->answers = calloc(nanswers, sizeof(char *));\n  if (session->kbdint->answers == NULL) {\n    session->kbdint->nanswers = 0;\n    ssh_set_error_oom(session);\n    ssh_kbdint_free(session->kbdint);\n    session->kbdint = NULL;\n\n    goto error;\n  }\n\n  for (i = 0; i < nanswers; i++) {\n    tmp = ssh_buffer_get_ssh_string(packet);\n    if (tmp == NULL) {\n      ssh_set_error(session, SSH_FATAL, \"Short INFO_RESPONSE packet\");\n      session->kbdint->nanswers = i;\n      ssh_kbdint_free(session->kbdint);\n      session->kbdint = NULL;\n\n      goto error;\n    }\n    session->kbdint->answers[i] = ssh_string_to_char(tmp);\n    SSH_STRING_FREE(tmp);\n    if (session->kbdint->answers[i] == NULL) {\n      ssh_set_error_oom(session);\n      session->kbdint->nanswers = i;\n      ssh_kbdint_free(session->kbdint);\n      session->kbdint = NULL;\n\n      goto error;\n    }\n  }\n\n  ssh_message_queue(session,msg);\n\n  return SSH_PACKET_USED;\n\nerror:\n  SSH_MESSAGE_FREE(msg);\n\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 1186,
      "line_end": 1305,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 168,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses SSH keyboard-interactive responses (network protocol) from untrusted packet data, performs memory allocations and string operations based on attacker-controlled counts/lengths, contains input-dependent loops and branching, and is part of the authentication flow \u2014 high-risk and high-value fuzz target."
    },
    {
      "name": "messages.c:ssh_execute_server_request",
      "clean_name": "ssh_execute_server_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    return rc;\n}\n\n#ifdef WITH_SERVER\n\nstatic int ssh_execute_server_request(ssh_session session, ssh_message msg)\n{\n    ssh_channel channel = NULL;\n    int rc;\n\n    switch(msg->type) {\n        case SSH_REQUEST_AUTH:\n            if (msg->auth_request.method == SSH_AUTH_METHOD_PASSWORD &&\n                ssh_callbacks_exists(session->server_callbacks, auth_password_function)) {\n                rc = session->server_callbacks->auth_password_function(session,\n                        msg->auth_request.username, msg->auth_request.password,\n                        session->server_callbacks->userdata);\n                if (rc == SSH_AUTH_SUCCESS || rc == SSH_AUTH_PARTIAL) {\n                    ssh_message_auth_reply_success(msg, rc == SSH_AUTH_PARTIAL);\n                } else {\n                    ssh_message_reply_default(msg);\n                }\n\n                return SSH_OK;\n            } else if(msg->auth_request.method == SSH_AUTH_METHOD_PUBLICKEY &&\n                      ssh_callbacks_exists(session->server_callbacks, auth_pubkey_function)) {\n               rc = session->server_callbacks->auth_pubkey_function(session,\n                       msg->auth_request.username, msg->auth_request.pubkey,\n                       msg->auth_request.signature_state,\n                       session->server_callbacks->userdata);\n               if (msg->auth_request.signature_state != SSH_PUBLICKEY_STATE_NONE) {\n                 if (rc == SSH_AUTH_SUCCESS || rc == SSH_AUTH_PARTIAL) {\n                   ssh_message_auth_reply_success(msg, rc == SSH_AUTH_PARTIAL);\n                 } else {\n                   ssh_message_reply_default(msg);\n                 }\n               } else {\n                 if (rc == SSH_AUTH_SUCCESS) {\n                   ssh_message_auth_reply_pk_ok_simple(msg);\n                 } else {\n                   ssh_message_reply_default(msg);\n                 }\n               }\n\n               return SSH_OK;\n            } else if (msg->auth_request.method == SSH_AUTH_METHOD_NONE &&\n                       ssh_callbacks_exists(session->server_callbacks, auth_none_function)) {\n                rc = session->server_callbacks->auth_none_function(session,\n                    msg->auth_request.username, session->server_callbacks->userdata);\n                if (rc == SSH_AUTH_SUCCESS || rc == SSH_AUTH_PARTIAL){\n                    ssh_message_auth_reply_success(msg, rc == SSH_AUTH_PARTIAL);\n                } else {\n                    ssh_message_reply_default(msg);\n                }\n\n                return SSH_OK;\n            }\n            break;\n        case SSH_REQUEST_CHANNEL_OPEN:\n            if (msg->channel_request_open.type == SSH_CHANNEL_SESSION &&\n                ssh_callbacks_exists(session->server_callbacks, channel_open_request_session_function)) {\n                channel = session->server_callbacks->channel_open_request_session_function(session,\n                        session->server_callbacks->userdata);\n                if (channel != NULL) {\n                    rc = ssh_message_channel_request_open_reply_accept_channel(msg, channel);\n                    if (rc != SSH_OK) {\n                        SSH_LOG(SSH_LOG_TRACE,\n                                \"Failed to send reply for accepting a channel \"\n                                \"open\");\n                    }\n                    return SSH_OK;\n                } else {\n                    ssh_message_reply_default(msg);\n                }\n\n                return SSH_OK;\n#define CB channel_open_request_direct_tcpip_function\n            } else if (msg->channel_request_open.type == SSH_CHANNEL_DIRECT_TCPIP &&\n                       ssh_callbacks_exists(session->server_callbacks, CB)) {\n                struct ssh_channel_request_open *rq = &msg->channel_request_open;\n                channel = session->server_callbacks->CB(session,\n                                                        rq->destination,\n                                                        rq->destination_port,\n                                                        rq->originator,\n                                                        rq->originator_port,\n                                                        session->server_callbacks->userdata);\n#undef CB\n                if (channel != NULL) {\n                    rc = ssh_message_channel_request_open_reply_accept_channel(\n                        msg,\n                        channel);\n                    if (rc != SSH_OK) {\n                        SSH_LOG(SSH_LOG_TRACE,\n                                \"Failed to send reply for accepting a channel \"\n                                \"open\");\n                    }\n                    return SSH_OK;\n                } else {\n                    ssh_message_reply_default(msg);\n                }\n\n                return SSH_OK;\n            }\n\n            break;\n        case SSH_REQUEST_CHANNEL:\n            channel = msg->channel_request.channel;\n\n            if (msg->channel_request.type == SSH_CHANNEL_REQUEST_PTY){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_pty_request_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_pty_request_function,\n                                                    session,\n                                                    channel,\n                                                    msg->channel_request.TERM,\n                                                    msg->channel_request.width,\n                                                    msg->channel_request.height,\n                                                    msg->channel_request.pxwidth,\n                                                    msg->channel_request.pxheight);\n                    if (rc == 0) {\n                        ssh_message_channel_request_reply_success(msg);\n                    } else {\n                        ssh_message_reply_default(msg);\n                    }\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_SHELL){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_shell_request_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_shell_request_function,\n                                                    session,\n                                                    channel);\n                    if (rc == 0) {\n                        ssh_message_channel_request_reply_success(msg);\n                    } else {\n                        ssh_message_reply_default(msg);\n                    }\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_X11){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_x11_req_function) {\n                    ssh_callbacks_iterate_exec(channel_x11_req_function,\n                                               session,\n                                               channel,\n                                               msg->channel_request.x11_single_connection,\n                                               msg->channel_request.x11_auth_protocol,\n                                               msg->channel_request.x11_auth_cookie,\n                                               msg->channel_request.x11_screen_number);\n                    ssh_message_channel_request_reply_success(msg);\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_WINDOW_CHANGE){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_pty_window_change_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_pty_window_change_function,\n                                                    session,\n                                                    channel,\n                                                    msg->channel_request.width,\n                                                    msg->channel_request.height,\n                                                    msg->channel_request.pxwidth,\n                                                    msg->channel_request.pxheight);\n                    if (rc != SSH_OK) {\n                        SSH_LOG(SSH_LOG_TRACE,\n                                \"Failed to iterate callbacks for window change\");\n                    }\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_EXEC){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_exec_request_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_exec_request_function,\n                                                    session,\n                                                    channel,\n                                                    msg->channel_request.command);\n                    if (rc == 0) {\n                        ssh_message_channel_request_reply_success(msg);\n                    } else {\n                        ssh_message_reply_default(msg);\n                    }\n\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_ENV){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_env_request_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_env_request_function,\n                                                    session,\n                                                    channel,\n                                                    msg->channel_request.var_name,\n                                                    msg->channel_request.var_value);\n                    if (rc == 0) {\n                        ssh_message_channel_request_reply_success(msg);\n                    } else {\n                        ssh_message_reply_default(msg);\n                    }\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            } else if (msg->channel_request.type == SSH_CHANNEL_REQUEST_SUBSYSTEM){\n                ssh_callbacks_iterate(channel->callbacks,\n                                      ssh_channel_callbacks,\n                                      channel_subsystem_request_function) {\n                    rc = ssh_callbacks_iterate_exec(channel_subsystem_request_function,\n                                                    session,\n                                                    channel,\n                                                    msg->channel_request.subsystem);\n                    if (rc == 0) {\n                        ssh_message_channel_request_reply_success(msg);\n                    } else {\n                        ssh_message_reply_default(msg);\n                    }\n\n                    return SSH_OK;\n                }\n                ssh_callbacks_iterate_end();\n            }\n            break;\n        case SSH_REQUEST_SERVICE:\n            if (ssh_callbacks_exists(session->server_callbacks, service_request_function)) {\n                rc = session->server_callbacks->service_request_function(session,\n                        msg->service_request.service, session->server_callbacks->userdata);\n                if (rc == 0) {\n                    ssh_message_reply_default(msg);\n                } else {\n                    ssh_send_disconnect(session);\n                }\n\n                return SSH_OK;\n            }\n\n            return SSH_AGAIN;\n        case SSH_REQUEST_GLOBAL:\n            break;\n    }\n\n    return SSH_AGAIN;\n}\n",
      "line_start": 136,
      "line_end": 380,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 483,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Handles complex, attacker-controlled SSH protocol messages (auth methods, channel open, many channel requests and service requests) with high branching/cyclomatic complexity and security-critical operations (authentication/authorization). Excellent high-value fuzz target."
    },
    {
      "name": "ssh_packet_socket_callback",
      "clean_name": "ssh_packet_socket_callback",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": " * @len length of data received. It might not be enough for a complete packet\n * @returns number of bytes read and processed. Zero means only partial packet\n * received and negative value means error.\n */\nsize_t\nssh_packet_socket_callback(const void *data, size_t receivedlen, void *user)\n{\n    ssh_session session = (ssh_session)user;\n    uint32_t blocksize = 8;\n    uint32_t lenfield_blocksize = 8;\n    size_t current_macsize = 0;\n    uint8_t *ptr = NULL;\n    ssize_t to_be_read;\n    int rc;\n    uint8_t *cleartext_packet = NULL;\n    uint8_t *packet_second_block = NULL;\n    uint8_t *mac = NULL;\n    size_t packet_remaining, packet_offset;\n    uint32_t packet_len, compsize, payloadsize;\n    uint8_t padding;\n    size_t processed = 0; /* number of bytes processed from the callback */\n    enum ssh_packet_filter_result_e filter_result;\n    struct ssh_crypto_struct *crypto = NULL;\n    bool etm = false;\n    uint32_t etm_packet_offset = 0;\n    bool ok;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto != NULL) {\n        current_macsize = hmac_digest_len(crypto->in_hmac);\n        blocksize = crypto->in_cipher->blocksize;\n        lenfield_blocksize = crypto->in_cipher->lenfield_blocksize;\n        etm = crypto->in_hmac_etm;\n    }\n\n    if (etm) {\n        /* In EtM mode packet size is unencrypted. This means\n         * we need to use this offset and set the block size\n         * that is part of the encrypted part to 0.\n         */\n        etm_packet_offset = sizeof(uint32_t);\n        lenfield_blocksize = 0;\n    } else if (lenfield_blocksize == 0) {\n        lenfield_blocksize = blocksize;\n    }\n    if (data == NULL) {\n        goto error;\n    }\n\n    if (session->session_state == SSH_SESSION_STATE_ERROR) {\n        goto error;\n    }\n#ifdef DEBUG_PACKET\n    SSH_LOG(SSH_LOG_PACKET,\n            \"rcv packet cb (len=%zu, state=%s)\",\n            receivedlen,\n            session->packet_state == PACKET_STATE_INIT ?\n                \"INIT\" :\n                session->packet_state == PACKET_STATE_SIZEREAD ?\n                    \"SIZE_READ\" :\n                    session->packet_state == PACKET_STATE_PROCESSING ?\n                    \"PROCESSING\" : \"unknown\");\n#endif\n    switch (session->packet_state) {\n        case PACKET_STATE_INIT:\n            if (receivedlen < lenfield_blocksize + etm_packet_offset) {\n                /*\n                 * We didn't receive enough data to read either at least one\n                 * block size or the unencrypted length in EtM mode.\n                 */\n#ifdef DEBUG_PACKET\n                SSH_LOG(SSH_LOG_PACKET,\n                        \"Waiting for more data (%zu < %u)\",\n                        receivedlen,\n                        lenfield_blocksize);\n#endif\n                return 0;\n            }\n\n            session->in_packet = (struct packet_struct) {\n                .type = 0,\n            };\n\n            if (session->in_buffer) {\n                rc = ssh_buffer_reinit(session->in_buffer);\n                if (rc < 0) {\n                    goto error;\n                }\n            } else {\n                session->in_buffer = ssh_buffer_new();\n                if (session->in_buffer == NULL) {\n                    goto error;\n                }\n            }\n\n            if (!etm) {\n                ptr = ssh_buffer_allocate(session->in_buffer,\n                                          lenfield_blocksize);\n                if (ptr == NULL) {\n                    goto error;\n                }\n                packet_len = ssh_packet_decrypt_len(session, ptr,\n                                                    (uint8_t *)data);\n                to_be_read = packet_len - lenfield_blocksize + sizeof(uint32_t);\n            } else {\n                /* Length is unencrypted in case of Encrypt-then-MAC */\n                packet_len = PULL_BE_U32(data, 0);\n                to_be_read = packet_len - etm_packet_offset;\n            }\n\n            processed += lenfield_blocksize + etm_packet_offset;\n            if (packet_len > MAX_PACKET_LEN) {\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"read_packet(): Packet len too high(%\" PRIu32 \" %.4\" PRIx32 \")\",\n                              packet_len, packet_len);\n                goto error;\n            }\n            if (to_be_read < 0) {\n                /* remote sshd sends invalid sizes? */\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Given numbers of bytes left to be read < 0 (%zd)!\",\n                              to_be_read);\n                goto error;\n            }\n\n            session->in_packet.len = packet_len;\n            session->packet_state = PACKET_STATE_SIZEREAD;\n            FALL_THROUGH;\n        case PACKET_STATE_SIZEREAD:\n            packet_len = session->in_packet.len;\n            packet_offset = processed = lenfield_blocksize + etm_packet_offset;\n            to_be_read = packet_len + sizeof(uint32_t) + current_macsize;\n            /* if to_be_read is zero, the whole packet was blocksize bytes. */\n            if (to_be_read != 0) {\n                if (receivedlen < (unsigned long)to_be_read) {\n                    /* give up, not enough data in buffer */\n                    SSH_LOG(SSH_LOG_PACKET,\n                            \"packet: partial packet (read len) \"\n                            \"[len=%\" PRIu32 \", receivedlen=%zu, to_be_read=%zd]\",\n                            packet_len,\n                            receivedlen,\n                            to_be_read);\n                    return 0;\n                }\n\n                packet_second_block = (uint8_t*)data + packet_offset;\n                processed = to_be_read - current_macsize;\n            }\n\n            /* remaining encrypted bytes from the packet, MAC not included */\n            packet_remaining = packet_len - (packet_offset - sizeof(uint32_t));\n            cleartext_packet = ssh_buffer_allocate(session->in_buffer,\n                                                   (uint32_t)packet_remaining);\n            if (cleartext_packet == NULL) {\n                goto error;\n            }\n\n            if (packet_second_block != NULL) {\n                if (crypto != NULL) {\n                    mac = packet_second_block + packet_remaining;\n\n                    if (crypto->in_hmac != SSH_HMAC_NONE && etm) {\n                        rc = ssh_packet_hmac_verify(session,\n                                                    data,\n                                                    processed,\n                                                    mac,\n                                                    crypto->in_hmac);\n                        if (rc < 0) {\n                            ssh_set_error(session, SSH_FATAL, \"HMAC error\");\n                            goto error;\n                        }\n                    }\n                    /*\n                     * Decrypt the packet. In case of EtM mode, the length is\n                     * already known as it's unencrypted. In the other case,\n                     * lenfield_blocksize bytes already have been decrypted.\n                     */\n                    if (packet_remaining > 0) {\n                        rc = ssh_packet_decrypt(session,\n                                                cleartext_packet,\n                                                (uint8_t *)data,\n                                                packet_offset,\n                                                processed - packet_offset);\n                        if (rc < 0) {\n                            ssh_set_error(session,\n                                          SSH_FATAL,\n                                          \"Decryption error\");\n                            goto error;\n                        }\n                    }\n\n                    if (crypto->in_hmac != SSH_HMAC_NONE && !etm) {\n                        ssh_buffer in = session->in_buffer;\n                        rc = ssh_packet_hmac_verify(session,\n                                                    ssh_buffer_get(in),\n                                                    ssh_buffer_get_len(in),\n                                                    mac,\n                                                    crypto->in_hmac);\n                        if (rc < 0) {\n                            ssh_set_error(session, SSH_FATAL, \"HMAC error\");\n                            goto error;\n                        }\n                    }\n                    processed += current_macsize;\n                } else {\n                    memcpy(cleartext_packet,\n                           packet_second_block,\n                           packet_remaining);\n                }\n            }\n\n#ifdef WITH_PCAP\n            if (session->pcap_ctx != NULL) {\n                ssh_pcap_context_write(session->pcap_ctx,\n                                       SSH_PCAP_DIR_IN,\n                                       ssh_buffer_get(session->in_buffer),\n                                       ssh_buffer_get_len(session->in_buffer),\n                                       ssh_buffer_get_len(session->in_buffer));\n            }\n#endif\n\n            if (!etm) {\n                /* skip the size field which has been processed before */\n                ssh_buffer_pass_bytes(session->in_buffer, sizeof(uint32_t));\n            }\n\n            rc = ssh_buffer_get_u8(session->in_buffer, &padding);\n            if (rc == 0) {\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Packet too short to read padding\");\n                goto error;\n            }\n\n            if (padding > ssh_buffer_get_len(session->in_buffer)) {\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Invalid padding: %d (%\" PRIu32 \" left)\",\n                              padding,\n                              ssh_buffer_get_len(session->in_buffer));\n                goto error;\n            }\n            ssh_buffer_pass_bytes_end(session->in_buffer, padding);\n            compsize = ssh_buffer_get_len(session->in_buffer);\n\n            if (crypto && crypto->do_compress_in &&\n                ssh_buffer_get_len(session->in_buffer) > 0) {\n                rc = decompress_buffer(session, session->in_buffer,\n                                       MAX_PACKET_LEN);\n                if (rc < 0) {\n                    goto error;\n                }\n            }\n            payloadsize = ssh_buffer_get_len(session->in_buffer);\n            if (session->recv_seq == UINT32_MAX) {\n                /* Overflowing sequence numbers is always fishy */\n                if (crypto == NULL) {\n                    /* don't allow sequence number overflow when unencrypted */\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"Incoming sequence number overflow\");\n                    goto error;\n                } else {\n                    SSH_LOG(SSH_LOG_WARNING,\n                            \"Incoming sequence number overflow\");\n                }\n            }\n            session->recv_seq++;\n            if (crypto != NULL) {\n                struct ssh_cipher_struct *cipher = NULL;\n\n                cipher = crypto->in_cipher;\n                cipher->packets++;\n                cipher->blocks += payloadsize / cipher->blocksize;\n            }\n            if (session->raw_counter != NULL) {\n                session->raw_counter->in_bytes += payloadsize;\n                session->raw_counter->in_packets++;\n            }\n\n            /*\n             * We don't want to rewrite a new packet while still executing the\n             * packet callbacks\n             */\n            session->packet_state = PACKET_STATE_PROCESSING;\n            ssh_packet_parse_type(session);\n            SSH_LOG(SSH_LOG_PACKET,\n                    \"packet: read type %hhd [len=%\" PRIu32 \",padding=%hhd,\"\n                    \"comp=%\" PRIu32 \",payload=%\" PRIu32 \"]\",\n                    session->in_packet.type, packet_len, padding, compsize,\n                    payloadsize);\n            if (crypto == NULL) {\n                /* In strict kex, only a few packets are allowed. Taint the session\n                 * if we received packets that are normally allowed but to be\n                 * refused if we are in strict kex when KEX is over.\n                 */\n                uint8_t type = session->in_packet.type;\n\n                if (type != SSH2_MSG_KEXINIT && type != SSH2_MSG_NEWKEYS &&\n                    (type < SSH2_MSG_KEXDH_INIT ||\n                     type > SSH2_MSG_KEX_DH_GEX_REQUEST)) {\n                    session->flags |= SSH_SESSION_FLAG_KEX_TAINTED;\n                }\n            }\n            /* Check if the packet is expected */\n            filter_result = ssh_packet_incoming_filter(session);\n\n            switch (filter_result) {\n            case SSH_PACKET_ALLOWED:\n                /* Execute callbacks */\n                ssh_packet_process(session, session->in_packet.type);\n                break;\n            case SSH_PACKET_DENIED:\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Packet filter: rejected packet (type %d)\",\n                              session->in_packet.type);\n                goto error;\n            case SSH_PACKET_UNKNOWN:\n                if (crypto == NULL) {\n                    session->flags |= SSH_SESSION_FLAG_KEX_TAINTED;\n                }\n                ssh_packet_send_unimplemented(session, session->recv_seq - 1);\n                break;\n            }\n\n            session->packet_state = PACKET_STATE_INIT;\n            if (processed < receivedlen) {\n                size_t num;\n                /* Handle a potential packet left in socket buffer */\n                SSH_LOG(SSH_LOG_PACKET,\n                        \"Processing %zu bytes left in socket buffer\",\n                        receivedlen-processed);\n\n                ptr = ((uint8_t*)data) + processed;\n\n                num = ssh_packet_socket_callback(ptr,\n                                                 receivedlen - processed,\n                                                 user);\n                processed += num;\n            }\n\n            ok = ssh_packet_need_rekey(session, 0);\n            if (ok) {\n                SSH_LOG(SSH_LOG_PACKET, \"Incoming packet triggered rekey\");\n                rc = ssh_send_rekex(session);\n                if (rc != SSH_OK) {\n                    SSH_LOG(SSH_LOG_PACKET, \"Rekey failed: rc = %d\", rc);\n                    return rc;\n                }\n            }\n\n            return processed;\n        case PACKET_STATE_PROCESSING:\n            SSH_LOG(SSH_LOG_PACKET, \"Nested packet processing. Delaying.\");\n            return 0;\n    }\n\n    ssh_set_error(session,\n                  SSH_FATAL,\n                  \"Invalid state into packet_read2(): %d\",\n                  session->packet_state);\n\nerror:\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    SSH_LOG(SSH_LOG_PACKET, \"Packet: processed %zu bytes\", processed);\n    return processed;\n}\n",
      "line_start": 1155,
      "line_end": 1520,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 357,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex SSH protocol packets from external data, performs decryption, HMAC verification, buffer allocations/memcpy, compression and many input-dependent branches/state transitions. It handles cryptography/authentication and has high attack surface for memory/logic errors \u2014 critical fuzz target."
    },
    {
      "name": "ssh_packet_encrypt",
      "clean_name": "ssh_packet_encrypt",
      "source_file": "/src/libssh/src/packet_crypt.c",
      "source_code": "    }\n\n    return 0;\n}\n\nunsigned char *ssh_packet_encrypt(ssh_session session, void *data, size_t len)\n{\n  struct ssh_crypto_struct *crypto = NULL;\n  struct ssh_cipher_struct *cipher = NULL;\n  HMACCTX ctx = NULL;\n  char *out = NULL;\n  int etm_packet_offset = 0, rc;\n  unsigned int blocksize;\n  size_t finallen = DIGEST_MAX_LEN;\n  uint32_t seq, lenfield_blocksize;\n  enum ssh_hmac_e type;\n  bool etm;\n\n  assert(len);\n\n  crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n  if (crypto == NULL) {\n      return NULL; /* nothing to do here */\n  }\n\n  blocksize = crypto->out_cipher->blocksize;\n  lenfield_blocksize = crypto->out_cipher->lenfield_blocksize;\n\n  type = crypto->out_hmac;\n  etm = crypto->out_hmac_etm;\n\n  if (etm) {\n      etm_packet_offset = sizeof(uint32_t);\n  }\n\n  if ((len - lenfield_blocksize - etm_packet_offset) % blocksize != 0) {\n      ssh_set_error(session, SSH_FATAL, \"Cryptographic functions must be set\"\n                    \" on at least one blocksize (received %zu)\", len);\n      return NULL;\n  }\n  out = calloc(1, len);\n  if (out == NULL) {\n    return NULL;\n  }\n\n  seq = ntohl(session->send_seq);\n  cipher = crypto->out_cipher;\n\n  if (cipher->aead_encrypt != NULL) {\n      cipher->aead_encrypt(cipher, data, out, len,\n            crypto->hmacbuf, session->send_seq);\n      memcpy(data, out, len);\n  } else {\n      if (type != SSH_HMAC_NONE) {\n          ctx = hmac_init(crypto->encryptMAC, hmac_digest_len(type), type);\n          if (ctx == NULL) {\n              SAFE_FREE(out);\n              return NULL;\n          }\n\n          if (!etm) {\n              rc = hmac_update(ctx, (unsigned char *)&seq, sizeof(uint32_t));\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_update(ctx, data, len);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_final(ctx, crypto->hmacbuf, &finallen);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n          }\n      }\n\n      cipher->encrypt(cipher, (uint8_t*)data + etm_packet_offset, out, len - etm_packet_offset);\n      memcpy((uint8_t*)data + etm_packet_offset, out, len - etm_packet_offset);\n\n      if (type != SSH_HMAC_NONE) {\n          if (etm) {\n              PUSH_BE_U32(data, 0, len - etm_packet_offset);\n              rc = hmac_update(ctx, (unsigned char *)&seq, sizeof(uint32_t));\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_update(ctx, data, len);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n              rc = hmac_final(ctx, crypto->hmacbuf, &finallen);\n              if (rc != 1) {\n                  SAFE_FREE(out);\n                  return NULL;\n              }\n          }\n#ifdef DEBUG_CRYPTO\n          ssh_log_hexdump(\"mac: \", data, len);\n          if (finallen != hmac_digest_len(type)) {\n              printf(\"Final len is %zu\\n\", finallen);\n          }\n          ssh_log_hexdump(\"Packet hmac\", crypto->hmacbuf, hmac_digest_len(type));\n#endif\n      }\n  }\n  explicit_bzero(out, len);\n  SAFE_FREE(out);\n\n  return crypto->hmacbuf;\n}\n",
      "line_start": 132,
      "line_end": 242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 206,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Performs security-critical cryptographic operations (HMAC, AEAD/non-AEAD encryption), manipulates and memcpy's untrusted packet data, writes into caller buffer, and has multiple input-dependent branches (ETM vs non-ETM, AEAD path). High risk and valuable as a fuzz target."
    },
    {
      "name": "pki_import_privkey_buffer",
      "clean_name": "pki_import_privkey_buffer",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "#endif /* HAVE_LIBCRYPTO */\n\n    return privkey;\n}\n\nint pki_import_privkey_buffer(enum ssh_keytypes_e type,\n                              ssh_buffer buffer,\n                              ssh_key *pkey)\n{\n    ssh_key key = NULL;\n    int rc;\n\n    key = ssh_key_new();\n    if (key == NULL) {\n        return SSH_ERROR;\n    }\n\n    key->type = type;\n    key->type_c = ssh_key_type_to_char(type);\n    key->flags = SSH_KEY_FLAG_PRIVATE | SSH_KEY_FLAG_PUBLIC;\n\n    switch (type) {\n    case SSH_KEYTYPE_RSA: {\n        ssh_string n = NULL;\n        ssh_string e = NULL;\n        ssh_string d = NULL;\n        ssh_string iqmp = NULL;\n        ssh_string p = NULL;\n        ssh_string q = NULL;\n\n        rc = ssh_buffer_unpack(buffer, \"SSSSSS\", &n, &e, &d, &iqmp, &p, &q);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n            goto fail;\n        }\n\n        rc = pki_privkey_build_rsa(key, n, e, d, iqmp, p, q);\n#ifdef DEBUG_CRYPTO\n        ssh_log_hexdump(\"n\", ssh_string_data(n), ssh_string_len(n));\n        ssh_log_hexdump(\"e\", ssh_string_data(e), ssh_string_len(e));\n        ssh_log_hexdump(\"d\", ssh_string_data(d), ssh_string_len(d));\n        ssh_log_hexdump(\"iqmp\", ssh_string_data(iqmp), ssh_string_len(iqmp));\n        ssh_log_hexdump(\"p\", ssh_string_data(p), ssh_string_len(p));\n        ssh_log_hexdump(\"q\", ssh_string_data(q), ssh_string_len(q));\n#endif /* DEBUG_CRYPTO */\n        ssh_string_burn(n);\n        SSH_STRING_FREE(n);\n        ssh_string_burn(e);\n        SSH_STRING_FREE(e);\n        ssh_string_burn(d);\n        SSH_STRING_FREE(d);\n        ssh_string_burn(iqmp);\n        SSH_STRING_FREE(iqmp);\n        ssh_string_burn(p);\n        SSH_STRING_FREE(p);\n        ssh_string_burn(q);\n        SSH_STRING_FREE(q);\n        if (rc == SSH_ERROR) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to build RSA private key\");\n            goto fail;\n        }\n        break;\n    }\n#ifdef HAVE_ECC\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521: {\n        ssh_string e = NULL;\n        ssh_string exp = NULL;\n        ssh_string i = NULL;\n        int nid;\n\n        rc = ssh_buffer_unpack(buffer, \"SSS\", &i, &e, &exp);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n            goto fail;\n        }\n\n        nid = pki_key_ecdsa_nid_from_name(ssh_string_get_char(i));\n        SSH_STRING_FREE(i);\n        if (nid == -1) {\n            ssh_string_burn(e);\n            SSH_STRING_FREE(e);\n            ssh_string_burn(exp);\n            SSH_STRING_FREE(exp);\n            goto fail;\n        }\n\n        rc = pki_privkey_build_ecdsa(key, nid, e, exp);\n        ssh_string_burn(e);\n        SSH_STRING_FREE(e);\n        ssh_string_burn(exp);\n        SSH_STRING_FREE(exp);\n        if (rc < 0) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to build ECDSA private key\");\n            goto fail;\n        }\n        break;\n    }\n    case SSH_KEYTYPE_SK_ECDSA: {\n        ssh_string type_str = NULL;\n        ssh_string pubkey = NULL;\n        int nid;\n\n        rc = ssh_buffer_unpack(buffer, \"SS\", &type_str, &pubkey);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n\n        rc = pki_buffer_unpack_sk_priv_data(buffer, key);\n        if (rc != SSH_OK) {\n            SSH_STRING_FREE(type_str);\n            SSH_STRING_FREE(pubkey);\n            goto fail;\n        }\n\n        nid = pki_key_ecdsa_nid_from_name(ssh_string_get_char(type_str));\n        SSH_STRING_FREE(type_str);\n\n        if (nid == -1) {\n            SSH_STRING_FREE(pubkey);\n            goto fail;\n        }\n\n        rc = pki_pubkey_build_ecdsa(key, nid, pubkey);\n        SSH_STRING_FREE(pubkey);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n        break;\n    }\n#endif /* HAVE_ECC */\n    case SSH_KEYTYPE_ED25519: {\n        ssh_string pubkey = NULL, privkey = NULL;\n\n        if (ssh_fips_mode()) {\n            SSH_LOG(SSH_LOG_TRACE, \"Ed25519 keys not supported in FIPS mode\");\n            goto fail;\n        }\n\n        rc = ssh_buffer_unpack(buffer, \"SS\", &pubkey, &privkey);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n            goto fail;\n        }\n\n        rc = pki_privkey_build_ed25519(key, pubkey, privkey);\n        ssh_string_burn(privkey);\n        SSH_STRING_FREE(privkey);\n        SSH_STRING_FREE(pubkey);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to build ed25519 key\");\n            goto fail;\n        }\n        break;\n    }\n    case SSH_KEYTYPE_SK_ED25519: {\n        ssh_string pubkey = NULL;\n\n        if (ssh_fips_mode()) {\n            SSH_LOG(SSH_LOG_TRACE, \"Ed25519 keys not supported in FIPS mode\");\n            goto fail;\n        }\n\n        rc = ssh_buffer_unpack(buffer, \"S\", &pubkey);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n\n        rc = pki_buffer_unpack_sk_priv_data(buffer, key);\n        if (rc != SSH_OK) {\n            SSH_STRING_FREE(pubkey);\n            goto fail;\n        }\n\n        rc = pki_pubkey_build_ed25519(key, pubkey);\n        SSH_STRING_FREE(pubkey);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n        break;\n    }\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_SK_ECDSA_CERT01:\n    case SSH_KEYTYPE_SK_ED25519_CERT01:\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown private key type (%d)\", type);\n        goto fail;\n    }\n\n    *pkey = key;\n    return SSH_OK;\nfail:\n    ssh_key_free(key);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 1371,
      "line_end": 1569,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 429,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex serialized input (buffer unpacking), builds cryptographic private keys, and performs memory/string operations on untrusted data with many type-dependent branches \u2014 security-critical and high-risk, making it a top-priority fuzz target."
    },
    {
      "name": "ssh_pki_signature_verify",
      "clean_name": "ssh_pki_signature_verify",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "            key->type, hash_type);\n\n    return SSH_ERROR;\n}\n\nint ssh_pki_signature_verify(ssh_session session,\n                             ssh_signature sig,\n                             const ssh_key key,\n                             const unsigned char *input,\n                             size_t input_len)\n{\n    int rc;\n    bool allowed;\n    enum ssh_keytypes_e key_type;\n\n    if (session == NULL || sig == NULL || key == NULL || input == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad parameter provided to \"\n                               \"ssh_pki_signature_verify()\");\n        return SSH_ERROR;\n    }\n    key_type = ssh_key_type_plain(key->type);\n\n    SSH_LOG(SSH_LOG_FUNCTIONS,\n            \"Going to verify a %s type signature\",\n            sig->type_c);\n\n    if (key_type != sig->type) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Can not verify %s signature with %s key\",\n                sig->type_c, key->type_c);\n        return SSH_ERROR;\n    }\n\n    allowed = ssh_key_size_allowed(session, key);\n    if (!allowed) {\n        ssh_set_error(session, SSH_FATAL, \"The '%s' key of size %d is not \"\n                      \"allowed by RSA_MIN_SIZE\", key->type_c, ssh_key_size(key));\n        return SSH_ERROR;\n    }\n\n    /* Check if public key and hash type are compatible */\n    rc = pki_key_check_hash_compatible(key, sig->hash_type);\n    if (rc != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    if (is_sk_key_type(key->type)) {\n        ssh_buffer sk_buffer = NULL;\n        SHA256CTX ctx = NULL;\n        unsigned char application_hash[SHA256_DIGEST_LEN] = {0};\n        unsigned char input_hash[SHA256_DIGEST_LEN] = {0};\n\n        ctx = sha256_init();\n        if (ctx == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Can not create SHA256CTX for application hash\");\n           return SSH_ERROR;\n        }\n        sha256_update(ctx, ssh_string_data(key->sk_application),\n               ssh_string_len(key->sk_application));\n        sha256_final(application_hash, ctx);\n\n        ctx = sha256_init();\n        if (ctx == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Can not create SHA256CTX for input hash\");\n           return SSH_ERROR;\n        }\n        sha256_update(ctx, input, input_len);\n        sha256_final(input_hash, ctx);\n\n        sk_buffer = ssh_buffer_new();\n        if (sk_buffer == NULL) {\n            return SSH_ERROR;\n        }\n\n        rc = ssh_buffer_pack(sk_buffer,\n                             \"PbdP\",\n                             (size_t)SHA256_DIGEST_LEN,\n                             application_hash,\n                             sig->sk_flags,\n                             sig->sk_counter,\n                             (size_t)SHA256_DIGEST_LEN,\n                             input_hash);\n        if (rc != SSH_OK) {\n            SSH_BUFFER_FREE(sk_buffer);\n            explicit_bzero(input_hash, SHA256_DIGEST_LEN);\n            explicit_bzero(application_hash, SHA256_DIGEST_LEN);\n            return SSH_ERROR;\n        }\n\n        rc = pki_verify_data_signature(sig, key, ssh_buffer_get(sk_buffer),\n                                       ssh_buffer_get_len(sk_buffer));\n\n        SSH_BUFFER_FREE(sk_buffer);\n        explicit_bzero(input_hash, SHA256_DIGEST_LEN);\n        explicit_bzero(application_hash, SHA256_DIGEST_LEN);\n\n        return rc;\n    }\n\n    return pki_verify_data_signature(sig, key, input, input_len);\n}\n",
      "line_start": 2810,
      "line_end": 2908,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 162,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Security-critical signature verification that operates on untrusted input and key/signature objects, performs memory/buffer operations (sha256 of input, ssh_buffer_pack), branches on key types (sk vs non-sk), and delegates to pki_verify_data_signature (likely complex parsing/crypto). High risk and high value as a fuzz target."
    },
    {
      "name": "sshsig_verify",
      "clean_name": "sshsig_verify",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *                       caller needs to compare it with expected signer key\n *                       using ssh_key_cmp().\n *\n * @return SSH_OK on success, SSH_ERROR on verification failure\n */\nint sshsig_verify(const void *data,\n                  size_t data_length,\n                  const char *signature,\n                  const char *sig_namespace,\n                  ssh_key *sign_key)\n{\n    ssh_buffer sig_buf = NULL;\n    ssh_buffer tosign = NULL;\n    ssh_key key = NULL;\n    char *hash_alg_str = NULL;\n    ssh_string sig_data = NULL;\n    ssh_string sig_namespace_str = NULL;\n    ssh_string reserved_str = NULL;\n    ssh_string pubkey_blob = NULL;\n    int rc = SSH_ERROR;\n    ssh_signature signature_obj = NULL;\n    uint32_t sig_version;\n\n    if (sign_key != NULL) {\n        *sign_key = NULL;\n    }\n\n    if (signature == NULL || data == NULL || sig_namespace == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid parameters provided to sshsig_verify\");\n        return SSH_ERROR;\n    }\n\n    if (strlen(sig_namespace) == 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Invalid parameters provided to sshsig_verify: empty namespace \"\n                \"string\");\n        return SSH_ERROR;\n    }\n\n    rc = sshsig_dearmor(signature, &sig_buf);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to dearmor signature\");\n        return SSH_ERROR;\n    }\n\n    if (ssh_buffer_get_len(sig_buf) < SSHSIG_MAGIC_PREAMBLE_LEN ||\n        memcmp(ssh_buffer_get(sig_buf),\n               SSHSIG_MAGIC_PREAMBLE,\n               SSHSIG_MAGIC_PREAMBLE_LEN) != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid signature magic preamble\");\n        SSH_BUFFER_FREE(sig_buf);\n        return SSH_ERROR;\n    }\n\n    ssh_buffer_pass_bytes(sig_buf, SSHSIG_MAGIC_PREAMBLE_LEN);\n    rc = ssh_buffer_unpack(sig_buf,\n                           \"dSSSsS\",\n                           &sig_version,\n                           &pubkey_blob,\n                           &sig_namespace_str,\n                           &reserved_str,\n                           &hash_alg_str,\n                           &sig_data);\n\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to unpack signature buffer\");\n        SSH_BUFFER_FREE(sig_buf);\n        return SSH_ERROR;\n    }\n\n    if (sig_version != SSHSIG_VERSION) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Unsupported signature version %u, expected %u\",\n                sig_version,\n                SSHSIG_VERSION);\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n\n    rc = ssh_pki_import_pubkey_blob(pubkey_blob, &key);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to import public key from signature\");\n        goto cleanup;\n    }\n\n    if (ssh_string_len(sig_namespace_str) != strlen(sig_namespace) ||\n        memcmp(ssh_string_data(sig_namespace_str),\n               sig_namespace,\n               strlen(sig_namespace)) != 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Signature namespace mismatch: expected '%s', got '%s'\",\n                sig_namespace,\n                ssh_string_get_char(sig_namespace_str));\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n\n    if (strcmp(hash_alg_str, \"sha256\") != 0 &&\n        strcmp(hash_alg_str, \"sha512\") != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported hash algorithm '%s'\", hash_alg_str);\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n\n    rc = sshsig_prepare_data(data,\n                             data_length,\n                             hash_alg_str,\n                             sig_namespace,\n                             &tosign);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to prepare data for sshsig verification\");\n        goto cleanup;\n    }\n\n    rc = ssh_pki_import_signature_blob(sig_data, key, &signature_obj);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to import signature blob\");\n        goto cleanup;\n    }\n\n    rc = pki_verify_data_signature(signature_obj,\n                                   key,\n                                   ssh_buffer_get(tosign),\n                                   ssh_buffer_get_len(tosign));\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Signature verification failed\");\n        goto cleanup;\n    }\n\n    if (sign_key != NULL) {\n        *sign_key = key;\n        key = NULL; /* Transferred ownership */\n    }\n\ncleanup:\n    SSH_STRING_FREE(pubkey_blob);\n    SSH_STRING_FREE(sig_namespace_str);\n    SSH_STRING_FREE(reserved_str);\n    SSH_STRING_FREE(sig_data);\n    SSH_BUFFER_FREE(tosign);\n    SSH_BUFFER_FREE(sig_buf);\n    SSH_KEY_FREE(key);\n    SAFE_FREE(hash_alg_str);\n    SSH_SIGNATURE_FREE(signature_obj);\n\n    return rc;\n}\n",
      "line_start": 3304,
      "line_end": 3447,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 287,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex serialized/armored external input, unpacks multiple fields and does buffer/memory operations on untrusted data, contains numerous branches/validation checks, and performs cryptographic/key import and signature verification \u2014 a high-risk, high-value fuzz target."
    },
    {
      "name": "pki.c:pki_import_pubkey_buffer",
      "clean_name": "pki_import_pubkey_buffer",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    ssh_key_free(key);\n\n    return SSH_ERROR;\n}\n\nstatic int pki_import_pubkey_buffer(ssh_buffer buffer,\n                                    enum ssh_keytypes_e type,\n                                    ssh_key *pkey)\n{\n    ssh_key key = NULL;\n    int rc;\n\n    key = ssh_key_new();\n    if (key == NULL) {\n        return SSH_ERROR;\n    }\n\n    key->type = type;\n    key->type_c = ssh_key_type_to_char(type);\n    key->flags = SSH_KEY_FLAG_PUBLIC;\n\n    switch (type) {\n        case SSH_KEYTYPE_RSA:\n            {\n                ssh_string e = NULL;\n                ssh_string n = NULL;\n\n                rc = ssh_buffer_unpack(buffer, \"SS\", &e, &n);\n                if (rc != SSH_OK) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n                    goto fail;\n                }\n\n                rc = pki_pubkey_build_rsa(key, e, n);\n#ifdef DEBUG_CRYPTO\n                ssh_log_hexdump(\"e\", ssh_string_data(e), ssh_string_len(e));\n                ssh_log_hexdump(\"n\", ssh_string_data(n), ssh_string_len(n));\n#endif /* DEBUG_CRYPTO */\n                ssh_string_burn(e);\n                SSH_STRING_FREE(e);\n                ssh_string_burn(n);\n                SSH_STRING_FREE(n);\n                if (rc == SSH_ERROR) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Failed to build RSA public key\");\n                    goto fail;\n                }\n            }\n            break;\n#ifdef HAVE_ECC\n        case SSH_KEYTYPE_ECDSA: /* deprecated */\n        case SSH_KEYTYPE_ECDSA_P256:\n        case SSH_KEYTYPE_ECDSA_P384:\n        case SSH_KEYTYPE_ECDSA_P521:\n        case SSH_KEYTYPE_SK_ECDSA:\n            {\n                ssh_string e = NULL;\n                ssh_string i = NULL;\n                int nid;\n\n                rc = ssh_buffer_unpack(buffer, \"SS\", &i, &e);\n                if (rc != SSH_OK) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n                    goto fail;\n                }\n\n                nid = pki_key_ecdsa_nid_from_name(ssh_string_get_char(i));\n                SSH_STRING_FREE(i);\n                if (nid == -1) {\n                    ssh_string_burn(e);\n                    SSH_STRING_FREE(e);\n                    goto fail;\n                }\n\n                rc = pki_pubkey_build_ecdsa(key, nid, e);\n                ssh_string_burn(e);\n                SSH_STRING_FREE(e);\n                if (rc < 0) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Failed to build ECDSA public key\");\n                    goto fail;\n                }\n\n                /* Unpack SK specific parameters */\n                if (type == SSH_KEYTYPE_SK_ECDSA) {\n                    ssh_string application = ssh_buffer_get_ssh_string(buffer);\n                    if (application == NULL) {\n                        SSH_LOG(SSH_LOG_TRACE, \"SK Unpack error\");\n                        goto fail;\n                    }\n                    key->sk_application = application;\n                    key->type_c = ssh_key_type_to_char(key->type);\n                }\n            }\n            break;\n#endif /* HAVE_ECC */\n        case SSH_KEYTYPE_ED25519:\n        case SSH_KEYTYPE_SK_ED25519:\n        {\n            ssh_string pubkey = ssh_buffer_get_ssh_string(buffer);\n\n            if (ssh_string_len(pubkey) != ED25519_KEY_LEN) {\n                SSH_LOG(SSH_LOG_TRACE, \"Invalid public key length\");\n                ssh_string_burn(pubkey);\n                SSH_STRING_FREE(pubkey);\n                goto fail;\n            }\n\n            rc = pki_pubkey_build_ed25519(key, pubkey);\n            ssh_string_burn(pubkey);\n            SSH_STRING_FREE(pubkey);\n            if (rc < 0) {\n                SSH_LOG(SSH_LOG_TRACE, \"Failed to build ED25519 public key\");\n                goto fail;\n            }\n\n            if (type == SSH_KEYTYPE_SK_ED25519) {\n                ssh_string application = ssh_buffer_get_ssh_string(buffer);\n                if (application == NULL) {\n                    SSH_LOG(SSH_LOG_TRACE, \"SK Unpack error\");\n                    goto fail;\n                }\n                key->sk_application = application;\n            }\n        }\n        break;\n        case SSH_KEYTYPE_RSA_CERT01:\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n        case SSH_KEYTYPE_ED25519_CERT01:\n        case SSH_KEYTYPE_SK_ED25519_CERT01:\n        case SSH_KEYTYPE_RSA1:\n        case SSH_KEYTYPE_UNKNOWN:\n        default:\n            SSH_LOG(SSH_LOG_TRACE, \"Unknown public key type %d\", type);\n            goto fail;\n    }\n\n    *pkey = key;\n    return SSH_OK;\nfail:\n    ssh_key_free(key);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 1570,
      "line_end": 1710,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 226,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses structured external input (SSH public-key buffers) with many type-dependent code paths, does memory/string operations on untrusted data, and builds cryptographic keys (security-critical). High branching/cyclomatic complexity and use of unpack/get operations make it a high-value, critical fuzz target."
    },
    {
      "name": "ssh_pki_openssh_privkey_export",
      "clean_name": "ssh_pki_openssh_privkey_export",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": " * @param privkey[in] private key to export\n * @returns an SSH string containing the text representation of the exported key.\n * @warning currently only supports ED25519 key types.\n */\n\nssh_string ssh_pki_openssh_privkey_export(const ssh_key privkey,\n                                          const char *passphrase,\n                                          ssh_auth_callback auth_fn,\n                                          void *auth_data)\n{\n    ssh_buffer buffer = NULL;\n    ssh_string str = NULL, blob = NULL;\n    ssh_string pubkey_s = NULL;\n    ssh_buffer privkey_buffer = NULL;\n    uint32_t rnd;\n    uint32_t rounds = 16;\n    ssh_string salt = NULL;\n    ssh_string kdf_options = NULL;\n    int to_encrypt=0;\n    unsigned char *b64 = NULL;\n    uint32_t str_len, len;\n    uint8_t padding = 1;\n    int ok;\n    int rc;\n\n    if (privkey == NULL) {\n        return NULL;\n    }\n    if (passphrase != NULL || auth_fn != NULL){\n        SSH_LOG(SSH_LOG_DEBUG, \"Enabling encryption for private key export\");\n        to_encrypt = 1;\n    }\n    buffer = ssh_buffer_new();\n    rc = ssh_pki_export_pubkey_blob(privkey, &pubkey_s);\n    if (buffer == NULL || rc != SSH_OK) {\n        goto error;\n    }\n\n    ok = ssh_get_random(&rnd, sizeof(rnd), 0);\n    if (!ok) {\n        goto error;\n    }\n\n    privkey_buffer = ssh_buffer_new();\n    if (privkey_buffer == NULL) {\n        goto error;\n    }\n\n    rc = ssh_pki_export_privkey_blob(privkey, &blob);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(privkey_buffer,\n                         \"ddPs\",\n                         rnd, /* checkint 1 & 2 */\n                         rnd,\n                         ssh_string_len(blob),\n                         ssh_string_data(blob),\n                         \"\" /* comment */);\n    if (rc == SSH_ERROR){\n        goto error;\n    }\n\n    /* Add padding regardless encryption because it is expected\n     * by OpenSSH tools.\n     * XXX Using 16 B as we use only AES cipher below anyway.\n     */\n    while (ssh_buffer_get_len(privkey_buffer) % 16 != 0) {\n        rc = ssh_buffer_add_u8(privkey_buffer, padding);\n        if (rc < 0) {\n            goto error;\n        }\n        padding++;\n    }\n\n    if (to_encrypt){\n        ssh_buffer kdf_buf;\n\n        kdf_buf = ssh_buffer_new();\n        if (kdf_buf == NULL) {\n            goto error;\n        }\n\n        salt = ssh_string_new(16);\n        if (salt == NULL){\n            SSH_BUFFER_FREE(kdf_buf);\n            goto error;\n        }\n\n        ok = ssh_get_random(ssh_string_data(salt), 16, 0);\n        if (!ok) {\n            SSH_BUFFER_FREE(kdf_buf);\n            goto error;\n        }\n\n        rc = ssh_buffer_pack(kdf_buf, \"Sd\", salt, rounds);\n        if (rc != SSH_OK) {\n            SSH_BUFFER_FREE(kdf_buf);\n            goto error;\n        }\n        kdf_options = ssh_string_new(ssh_buffer_get_len(kdf_buf));\n        if (kdf_options == NULL){\n            SSH_BUFFER_FREE(kdf_buf);\n            goto error;\n        }\n        memcpy(ssh_string_data(kdf_options),\n               ssh_buffer_get(kdf_buf),\n               ssh_buffer_get_len(kdf_buf));\n        SSH_BUFFER_FREE(kdf_buf);\n        rc = pki_private_key_encrypt(privkey_buffer,\n                                     passphrase,\n                                     \"aes128-cbc\",\n                                     \"bcrypt\",\n                                     auth_fn,\n                                     auth_data,\n                                     rounds,\n                                     salt);\n        if (rc != SSH_OK){\n            goto error;\n        }\n    } else {\n        kdf_options = ssh_string_new(0);\n    }\n\n    rc = ssh_buffer_pack(buffer,\n                         \"PssSdSdP\",\n                         strlen(OPENSSH_AUTH_MAGIC) + 1,\n                         OPENSSH_AUTH_MAGIC,\n                         to_encrypt ? \"aes128-cbc\" : \"none\", /* ciphername */\n                         to_encrypt ? \"bcrypt\" : \"none\",     /* kdfname */\n                         kdf_options,                        /* kdfoptions */\n                         (uint32_t)1,                        /* nkeys */\n                         pubkey_s,\n                         ssh_buffer_get_len(privkey_buffer),\n                         /* rest of buffer is a string */\n                         (size_t)ssh_buffer_get_len(privkey_buffer),\n                         ssh_buffer_get(privkey_buffer));\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    b64 = bin_to_base64(ssh_buffer_get(buffer),\n                        ssh_buffer_get_len(buffer));\n    if (b64 == NULL){\n        goto error;\n    }\n\n    /* we can reuse the buffer */\n    ssh_buffer_reinit(buffer);\n    rc = ssh_buffer_pack(buffer,\n                         \"tttttt\",\n                         OPENSSH_HEADER_BEGIN,\n                         \"\\n\",\n                         b64,\n                         \"\\n\",\n                         OPENSSH_HEADER_END,\n                         \"\\n\");\n    explicit_bzero(b64, strlen((char *)b64));\n    SAFE_FREE(b64);\n\n    if (rc != SSH_OK){\n        goto error;\n    }\n\n    str = ssh_string_new(ssh_buffer_get_len(buffer));\n    if (str == NULL){\n        goto error;\n    }\n\n    str_len = ssh_buffer_get_len(buffer);\n    len = ssh_buffer_get_data(buffer, ssh_string_data(str), str_len);\n    if (str_len != len) {\n        SSH_STRING_FREE(str);\n        str = NULL;\n    }\n\nerror:\n    ssh_string_burn(blob);\n    ssh_string_free(blob);\n    if (privkey_buffer != NULL) {\n        void *bufptr = ssh_buffer_get(privkey_buffer);\n        explicit_bzero(bufptr, ssh_buffer_get_len(privkey_buffer));\n        SSH_BUFFER_FREE(privkey_buffer);\n    }\n    SAFE_FREE(pubkey_s);\n    SAFE_FREE(kdf_options);\n    SAFE_FREE(salt);\n    if (buffer != NULL) {\n        SSH_BUFFER_FREE(buffer);\n    }\n\n    return str;\n}\n",
      "line_start": 502,
      "line_end": 691,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 320,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Exports OpenSSH private keys and performs cryptographic operations (bcrypt/AES path), base64 encoding and direct memory operations (memcpy, buffer packing, padding). It processes structured/complex external input (key blobs), calls auth callbacks, and has multiple branches/error paths \u2014 security-critical and high value for fuzzing."
    },
    {
      "name": "pki_container_openssh.c:ssh_pki_openssh_import",
      "clean_name": "ssh_pki_openssh_import",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": "/** @internal\n * @brief Import a private key in OpenSSH (new) format. This format is\n * typically used with ed25519 keys but can be used for others.\n */\nstatic ssh_key\nssh_pki_openssh_import(const char *text_key,\n                       const char *passphrase,\n                       ssh_auth_callback auth_fn,\n                       void *auth_data,\n                       bool private)\n{\n    const char *ptr = text_key;\n    const char *end = NULL;\n    char *base64 = NULL;\n    int cmp;\n    int rc;\n    int i;\n    ssh_buffer buffer = NULL, privkey_buffer = NULL;\n    char *magic = NULL, *ciphername = NULL, *kdfname = NULL;\n    uint32_t nkeys = 0, checkint1 = 0, checkint2 = 0xFFFF;\n    ssh_string kdfoptions = NULL;\n    ssh_string pubkey0 = NULL;\n    ssh_string privkeys = NULL;\n    ssh_string comment = NULL;\n    ssh_key key = NULL;\n    uint8_t padding;\n\n    cmp = strncmp(ptr, OPENSSH_HEADER_BEGIN, strlen(OPENSSH_HEADER_BEGIN));\n    if (cmp != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Not an OpenSSH private key (no header)\");\n        goto out;\n    }\n    ptr += strlen(OPENSSH_HEADER_BEGIN);\n    while(ptr[0] != '\\0' && !isspace((int)ptr[0])) {\n        ptr++;\n    }\n    end = strstr(ptr, OPENSSH_HEADER_END);\n    if (end == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Not an OpenSSH private key (no footer)\");\n        goto out;\n    }\n    base64 = malloc(end - ptr + 1);\n    if (base64 == NULL) {\n        goto out;\n    }\n    for (i = 0; ptr < end; ptr++) {\n        if (!isspace((int)ptr[0])) {\n            base64[i] = ptr[0];\n            i++;\n        }\n    }\n    base64[i] = '\\0';\n    buffer = base64_to_bin(base64);\n    SAFE_FREE(base64);\n    if (buffer == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Not an OpenSSH private key (base64 error)\");\n        goto out;\n    }\n    rc = ssh_buffer_unpack(buffer, \"PssSdSS\",\n                           strlen(OPENSSH_AUTH_MAGIC) + 1,\n                           &magic,\n                           &ciphername,\n                           &kdfname,\n                           &kdfoptions,\n                           &nkeys,\n                           &pubkey0,\n                           &privkeys);\n    if (rc == SSH_ERROR) {\n        SSH_LOG(SSH_LOG_TRACE, \"Not an OpenSSH private key (unpack error)\");\n        goto out;\n    }\n    cmp = strncmp(magic, OPENSSH_AUTH_MAGIC, strlen(OPENSSH_AUTH_MAGIC));\n    if (cmp != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Not an OpenSSH private key (bad magic)\");\n        goto out;\n    }\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Opening OpenSSH private key: ciphername: %s, kdf: %s, nkeys: %\" PRIu32,\n            ciphername,\n            kdfname,\n            nkeys);\n    if (nkeys != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"Opening OpenSSH private key: only 1 key supported (%\" PRIu32 \" available)\", nkeys);\n        goto out;\n    }\n\n    /* If we are interested only in public key do not progress\n     * to the key decryption later\n     */\n    if (!private) {\n        rc = ssh_pki_import_pubkey_blob(pubkey0, &key);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to import public key blob\");\n        }\n        /* in either case we clean up here */\n        goto out;\n    }\n\n    rc = pki_private_key_decrypt(privkeys,\n                                 passphrase,\n                                 ciphername,\n                                 kdfname,\n                                 kdfoptions,\n                                 auth_fn,\n                                 auth_data);\n    if (rc == SSH_ERROR) {\n        goto out;\n    }\n\n    privkey_buffer = ssh_buffer_new();\n    if (privkey_buffer == NULL) {\n        goto out;\n    }\n\n    ssh_buffer_set_secure(privkey_buffer);\n    ssh_buffer_add_data(privkey_buffer,\n                        ssh_string_data(privkeys),\n                        (uint32_t)ssh_string_len(privkeys));\n\n    rc = ssh_buffer_unpack(privkey_buffer, \"dd\", &checkint1, &checkint2);\n    if (rc == SSH_ERROR || checkint1 != checkint2) {\n        SSH_LOG(SSH_LOG_TRACE, \"OpenSSH private key unpack error (correct password?)\");\n        goto out;\n    }\n    rc = pki_openssh_import_privkey_blob(privkey_buffer, &key);\n    if (rc == SSH_ERROR) {\n        goto out;\n    }\n    comment = ssh_buffer_get_ssh_string(privkey_buffer);\n    SAFE_FREE(comment);\n    /* verify that the remaining data is correct padding */\n    for (i = 1; ssh_buffer_get_len(privkey_buffer) > 0; ++i) {\n        ssh_buffer_get_u8(privkey_buffer, &padding);\n        if (padding != i) {\n            ssh_key_free(key);\n            key = NULL;\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid padding\");\n            goto out;\n        }\n    }\nout:\n    if (buffer != NULL) {\n        SSH_BUFFER_FREE(buffer);\n        buffer = NULL;\n    }\n    if (privkey_buffer != NULL) {\n        SSH_BUFFER_FREE(privkey_buffer);\n        privkey_buffer = NULL;\n    }\n    SAFE_FREE(magic);\n    SAFE_FREE(ciphername);\n    SAFE_FREE(kdfname);\n    SAFE_FREE(kdfoptions);\n    SAFE_FREE(pubkey0);\n    SAFE_FREE(privkeys);\n    return key;\n}\n",
      "line_start": 229,
      "line_end": 381,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 277,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses a complex external format (OpenSSH private-key text), performs base64 decoding and multiple buffer/string operations on untrusted data, unpacks structured fields, optionally decrypts key material, and validates padding/checkints. Multiple branches and security/crypto-critical logic make this a high-value (critical) fuzz target."
    },
    {
      "name": "pki_container_openssh.c:pki_private_key_decrypt",
      "clean_name": "pki_private_key_decrypt",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": "\n/**\n * @brief decrypts an encrypted private key blob in OpenSSH format.\n *\n */\nstatic int pki_private_key_decrypt(ssh_string blob,\n                                   const char* passphrase,\n                                   const char *ciphername,\n                                   const char *kdfname,\n                                   ssh_string kdfoptions,\n                                   ssh_auth_callback auth_fn,\n                                   void *auth_data)\n{\n    struct ssh_cipher_struct *ciphers = ssh_get_ciphertab();\n    struct ssh_cipher_struct cipher;\n    uint8_t key_material[128] = {0};\n    char passphrase_buffer[128] = {0};\n    size_t key_material_len;\n    ssh_buffer buffer = NULL;\n    ssh_string salt = NULL;\n    uint32_t rounds;\n    int cmp;\n    int rc;\n    int i;\n\n    cmp = strcmp(ciphername, \"none\");\n    if (cmp == 0){\n        /* no decryption required */\n        return SSH_OK;\n    }\n\n    for (i = 0; ciphers[i].name != NULL; i++) {\n        cmp = strcmp(ciphername, ciphers[i].name);\n        if (cmp == 0){\n            memcpy(&cipher, &ciphers[i], sizeof(cipher));\n            break;\n        }\n    }\n\n    if (ciphers[i].name == NULL){\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported cipher %s\", ciphername);\n        return SSH_ERROR;\n    }\n\n    cmp = strcmp(kdfname, \"bcrypt\");\n    if (cmp != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported KDF %s\", kdfname);\n        return SSH_ERROR;\n    }\n    if (ssh_string_len(blob) % cipher.blocksize != 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Encrypted string not multiple of blocksize: %zu\",\n                ssh_string_len(blob));\n        return SSH_ERROR;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL){\n        return SSH_ERROR;\n    }\n    rc = ssh_buffer_add_data(buffer,\n                             ssh_string_data(kdfoptions),\n                             (uint32_t)ssh_string_len(kdfoptions));\n    if (rc != SSH_ERROR){\n        rc = ssh_buffer_unpack(buffer, \"Sd\", &salt, &rounds);\n    }\n    SSH_BUFFER_FREE(buffer);\n    if (rc == SSH_ERROR){\n        return SSH_ERROR;\n    }\n\n    /* We need material for key (keysize bits / 8) and IV (blocksize)  */\n    key_material_len =  cipher.keysize/8 + cipher.blocksize;\n    if (key_material_len > sizeof(key_material)) {\n        SSH_LOG(SSH_LOG_TRACE, \"Key material too big\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Decryption: %d key, %d IV, %\" PRIu32 \" rounds, %zu bytes salt\",\n            cipher.keysize/8,\n            cipher.blocksize,\n            rounds,\n            ssh_string_len(salt));\n\n    if (passphrase == NULL) {\n        if (auth_fn == NULL) {\n            SAFE_FREE(salt);\n            SSH_LOG(SSH_LOG_TRACE, \"No passphrase provided\");\n            return SSH_ERROR;\n        }\n        rc = auth_fn(\"Passphrase\",\n                     passphrase_buffer,\n                     sizeof(passphrase_buffer),\n                     0,\n                     0,\n                     auth_data);\n        if (rc != SSH_OK) {\n            SAFE_FREE(salt);\n            return SSH_ERROR;\n        }\n        passphrase = passphrase_buffer;\n    }\n\n    rc = bcrypt_pbkdf(passphrase,\n                      strlen(passphrase),\n                      ssh_string_data(salt),\n                      ssh_string_len(salt),\n                      key_material,\n                      key_material_len,\n                      rounds);\n    SAFE_FREE(salt);\n    if (rc < 0){\n        return SSH_ERROR;\n    }\n    explicit_bzero(passphrase_buffer, sizeof(passphrase_buffer));\n\n    cipher.set_decrypt_key(&cipher,\n                           key_material,\n                           key_material + cipher.keysize/8);\n    cipher.decrypt(&cipher,\n                   ssh_string_data(blob),\n                   ssh_string_data(blob),\n                   ssh_string_len(blob));\n    ssh_cipher_clear(&cipher);\n    return SSH_OK;\n}\n",
      "line_start": 100,
      "line_end": 222,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 162,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses a complex external format (OpenSSH encrypted private-key blob and KDF options), performs cryptographic operations (bcrypt_pbkdf, cipher key setup) and in-place memory manipulation (cipher.decrypt), has branching and lookup logic, and uses an auth callback \u2014 high-risk, high-value fuzz target."
    },
    {
      "name": "pki_privkey_build_ecdsa",
      "clean_name": "pki_privkey_build_ecdsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return -1;\n}\n\nint pki_privkey_build_ecdsa(ssh_key key, int nid, ssh_string e, ssh_string exp)\n{\n    int rc = 0;\n    BIGNUM *bexp = NULL;\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    EC_POINT *p = NULL;\n    const EC_GROUP *g = NULL;\n    EC_KEY *ecdsa = NULL;\n#else\n    const char *group_name = OSSL_EC_curve_nid2name(nid);\n    OSSL_PARAM_BLD *param_bld = NULL;\n\n    if (group_name == NULL) {\n        return -1;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    bexp = ssh_make_string_bn(exp);\n    if (bexp == NULL) {\n        return -1;\n    }\n\n    key->ecdsa_nid = nid;\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid);\n    if (ecdsa == NULL) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    g = EC_KEY_get0_group(ecdsa);\n\n    p = EC_POINT_new(g);\n    if (p == NULL) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    rc = EC_POINT_oct2point(g,\n                            p,\n                            ssh_string_data(e),\n                            ssh_string_len(e),\n                            NULL);\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    /* EC_KEY_set_public_key duplicates p */\n    rc = EC_KEY_set_public_key(ecdsa, p);\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    /* EC_KEY_set_private_key duplicates exp */\n    rc = EC_KEY_set_private_key(ecdsa, bexp);\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    /* ecdsa will be freed when the EVP_PKEY key->key is freed */\n    rc = EVP_PKEY_assign_EC_KEY(key->key, ecdsa);\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n    /* ssh_key is now the owner of this memory */\n    ecdsa = NULL;\n\n    /* set rc to 0 if everything went well */\n    rc = 0;\n\ncleanup:\n    EC_KEY_free(ecdsa);\n    EC_POINT_free(p);\n    BN_free(bexp);\n    return rc;\n#else\n    param_bld = OSSL_PARAM_BLD_new();\n    if (param_bld == NULL){\n        rc = -1;\n        goto cleanup;\n    }\n\n    rc = OSSL_PARAM_BLD_push_utf8_string(param_bld, OSSL_PKEY_PARAM_GROUP_NAME,\n                                         group_name, strlen(group_name));\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    rc = OSSL_PARAM_BLD_push_octet_string(param_bld, OSSL_PKEY_PARAM_PUB_KEY,\n                                          ssh_string_data(e), ssh_string_len(e));\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_PRIV_KEY, bexp);\n    if (rc != 1) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    rc = evp_build_pkey(\"EC\", param_bld, &(key->key), EVP_PKEY_KEYPAIR);\n\ncleanup:\n    OSSL_PARAM_BLD_free(param_bld);\n    BN_free(bexp);\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 205,
      "line_end": 327,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses external serialized crypto material (EC point octet string and BN), invokes OpenSSL parsing functions (EC_POINT_oct2point, BN conversion) that operate on untrusted bytes, and performs security-critical key construction \u2014 high risk and high value as a fuzz target."
    },
    {
      "name": "pki_pubkey_build_ecdsa",
      "clean_name": "pki_pubkey_build_ecdsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    BN_free(bexp);\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n\nint pki_pubkey_build_ecdsa(ssh_key key, int nid, ssh_string e)\n{\n    int rc;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    EC_POINT *p = NULL;\n    const EC_GROUP *g = NULL;\n    EC_KEY *ecdsa = NULL;\n    int ok;\n#else\n    const char *group_name = OSSL_EC_curve_nid2name(nid);\n    OSSL_PARAM_BLD *param_bld = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    key->ecdsa_nid = nid;\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid);\n    if (ecdsa == NULL) {\n        return -1;\n    }\n\n    g = EC_KEY_get0_group(ecdsa);\n\n    p = EC_POINT_new(g);\n    if (p == NULL) {\n        EC_KEY_free(ecdsa);\n        return -1;\n    }\n\n    ok = EC_POINT_oct2point(g,\n                            p,\n                            ssh_string_data(e),\n                            ssh_string_len(e),\n                            NULL);\n    if (!ok) {\n        EC_KEY_free(ecdsa);\n        EC_POINT_free(p);\n        return -1;\n    }\n\n    /* EC_KEY_set_public_key duplicates p */\n    ok = EC_KEY_set_public_key(ecdsa, p);\n    EC_POINT_free(p);\n    if (!ok) {\n        EC_KEY_free(ecdsa);\n        return -1;\n    }\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        EC_KEY_free(ecdsa);\n        return -1;\n    }\n\n    rc = EVP_PKEY_assign_EC_KEY(key->key, ecdsa);\n    if (rc != 1) {\n        EC_KEY_free(ecdsa);\n        return -1;\n    }\n\n    return 0;\n#else\n    param_bld = OSSL_PARAM_BLD_new();\n    if (param_bld == NULL)\n        goto err;\n\n    rc = OSSL_PARAM_BLD_push_utf8_string(param_bld, OSSL_PKEY_PARAM_GROUP_NAME,\n                                         group_name, strlen(group_name));\n    if (rc != 1)\n        goto err;\n    rc = OSSL_PARAM_BLD_push_octet_string(param_bld, OSSL_PKEY_PARAM_PUB_KEY,\n                                          ssh_string_data(e), ssh_string_len(e));\n    if (rc != 1)\n        goto err;\n\n    rc = evp_build_pkey(\"EC\", param_bld, &(key->key), EVP_PKEY_PUBLIC_KEY);\n    OSSL_PARAM_BLD_free(param_bld);\n\n    return rc;\nerr:\n    OSSL_PARAM_BLD_free(param_bld);\n    return -1;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 328,
      "line_end": 412,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex external input (EC point octet string) and builds cryptographic structures via OpenSSL (EC_POINT_oct2point / evp_build_pkey). It operates on untrusted bytes, performs memory-heavy parsing, has multiple error paths and is security/crypto-critical \u2014 high-value fuzz target."
    },
    {
      "name": "pki_private_key_from_base64",
      "clean_name": "pki_private_key_from_base64",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    EVP_PKEY_free(pkey);\n    BIO_free(mem);\n    return NULL;\n}\n\nssh_key pki_private_key_from_base64(const char *b64_key,\n                                    const char *passphrase,\n                                    ssh_auth_callback auth_fn,\n                                    void *auth_data)\n{\n    BIO *mem = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    EC_KEY *ecdsa = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n    ssh_key key = NULL;\n    enum ssh_keytypes_e type = SSH_KEYTYPE_UNKNOWN;\n    EVP_PKEY *pkey = NULL;\n\n    mem = BIO_new_mem_buf((void*)b64_key, -1);\n\n    if (passphrase == NULL) {\n        if (auth_fn) {\n            struct pem_get_password_struct pgp = { auth_fn, auth_data };\n\n            pkey = PEM_read_bio_PrivateKey(mem, NULL, pem_get_password, &pgp);\n        } else {\n            /* openssl uses its own callback to get the passphrase here */\n            pkey = PEM_read_bio_PrivateKey(mem, NULL, NULL, NULL);\n        }\n    } else {\n        pkey = PEM_read_bio_PrivateKey(mem, NULL, NULL, (void *) passphrase);\n    }\n\n    BIO_free(mem);\n\n    if (pkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Error parsing private key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return NULL;\n    }\n    switch (EVP_PKEY_base_id(pkey)) {\n    case EVP_PKEY_RSA:\n        type = SSH_KEYTYPE_RSA;\n        break;\n    case EVP_PKEY_EC:\n#ifdef HAVE_OPENSSL_ECC\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        ecdsa = EVP_PKEY_get0_EC_KEY(pkey);\n        if (ecdsa == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n\t\t    \"Error parsing private key: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n        /* pki_privatekey_type_from_string always returns P256 for ECDSA\n         * keys, so we need to figure out the correct type here */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        type = pki_key_ecdsa_to_key_type(ecdsa);\n#else\n        type = pki_key_ecdsa_to_key_type(pkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n        if (type == SSH_KEYTYPE_UNKNOWN) {\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid private key.\");\n            goto fail;\n        }\n\n        break;\n#endif /* HAVE_OPENSSL_ECC */\n    case EVP_PKEY_ED25519:\n        type = SSH_KEYTYPE_ED25519;\n        break;\n    default:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown or invalid private key type %d\",\n                EVP_PKEY_base_id(pkey));\n        EVP_PKEY_free(pkey);\n        return NULL;\n    }\n\n    key = ssh_key_new();\n    if (key == NULL) {\n        goto fail;\n    }\n\n    key->type = type;\n    key->type_c = ssh_key_type_to_char(type);\n    key->flags = SSH_KEY_FLAG_PRIVATE | SSH_KEY_FLAG_PUBLIC;\n    key->key = pkey;\n#ifdef HAVE_OPENSSL_ECC\n    if (is_ecdsa_key_type(key->type)) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        key->ecdsa_nid = pki_key_ecdsa_to_nid(ecdsa);\n#else\n        key->ecdsa_nid = pki_key_ecdsa_to_nid(key->key);\n#endif /* OPENSSL_VERSION_NUMBER */\n    }\n#endif /* HAVE_OPENSSL_ECC */\n\n    return key;\nfail:\n    EVP_PKEY_free(pkey);\n    ssh_key_free(key);\n    return NULL;\n}\n",
      "line_start": 1126,
      "line_end": 1227,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 97,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses complex external input (base64/PEM private keys) using OpenSSL (PEM_read_bio_PrivateKey), handles passphrases/callbacks and cryptographic key types, performs memory operations on untrusted data and has multiple code paths \u2014 security-critical and high-value fuzz target."
    },
    {
      "name": "pki_privkey_build_rsa",
      "clean_name": "pki_privkey_build_rsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    EVP_PKEY_free(pkey);\n    ssh_key_free(key);\n    return NULL;\n}\n\nint pki_privkey_build_rsa(ssh_key key,\n                          ssh_string n,\n                          ssh_string e,\n                          ssh_string d,\n                          ssh_string iqmp,\n                          ssh_string p,\n                          ssh_string q)\n{\n    int rc;\n    BIGNUM *be = NULL, *bn = NULL, *bd = NULL;\n    BIGNUM *biqmp = NULL, *bp = NULL, *bq = NULL;\n    BIGNUM *aux = NULL, *d_consttime = NULL;\n    BIGNUM *bdmq1 = NULL, *bdmp1 = NULL;\n    BN_CTX *ctx = NULL;\n\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    OSSL_PARAM_BLD *param_bld = OSSL_PARAM_BLD_new();\n    if (param_bld == NULL) {\n        return SSH_ERROR;\n    }\n#else\n    RSA *key_rsa = RSA_new();\n    if (key_rsa == NULL) {\n        return SSH_ERROR;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    bn = ssh_make_string_bn(n);\n    be = ssh_make_string_bn(e);\n    bd = ssh_make_string_bn(d);\n    biqmp = ssh_make_string_bn(iqmp);\n    bp = ssh_make_string_bn(p);\n    bq = ssh_make_string_bn(q);\n    if (be == NULL || bn == NULL || bd == NULL ||\n        /*biqmp == NULL ||*/ bp == NULL || bq == NULL) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    /* Calculate remaining CRT parameters for OpenSSL to be happy\n     * taken from OpenSSH */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    if ((aux = BN_new()) == NULL ||\n        (bdmq1 = BN_new()) == NULL ||\n        (bdmp1 = BN_new()) == NULL) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    if ((d_consttime = BN_dup(bd)) == NULL) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    BN_set_flags(aux, BN_FLG_CONSTTIME);\n    BN_set_flags(d_consttime, BN_FLG_CONSTTIME);\n\n    if ((BN_sub(aux, bq, BN_value_one()) == 0) ||\n        (BN_mod(bdmq1, d_consttime, aux, ctx) == 0) ||\n        (BN_sub(aux, bp, BN_value_one()) == 0) ||\n        (BN_mod(bdmp1, d_consttime, aux, ctx) == 0)) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    /* Memory management of be, bn and bd is transferred to RSA object */\n    rc = RSA_set0_key(key_rsa, bn, be, bd);\n    if (rc == 0) {\n        goto fail;\n    }\n\n    /* Memory management of bp and bq is transferred to RSA object */\n    rc = RSA_set0_factors(key_rsa, bp, bq);\n    if (rc == 0) {\n        goto fail;\n    }\n\n    /* p, q, dmp1, dmq1 and iqmp may be NULL in private keys, but the RSA\n     * operations are much faster when these values are available.\n     * https://www.openssl.org/docs/man1.0.2/crypto/rsa.html\n     * And OpenSSL fails to export these keys to PEM if these are missing:\n     * https://github.com/openssl/openssl/issues/21826\n     */\n    rc = RSA_set0_crt_params(key_rsa, bdmp1, bdmq1, biqmp);\n    if (rc == 0) {\n        goto fail;\n    }\n    bignum_safe_free(aux);\n    bignum_safe_free(d_consttime);\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        goto fail;\n    }\n\n    rc = EVP_PKEY_assign_RSA(key->key, key_rsa);\n    if (rc != 1) {\n        goto fail;\n    }\n\n    return SSH_OK;\nfail:\n    RSA_free(key_rsa);\n    EVP_PKEY_free(key->key);\n    return SSH_ERROR;\n#else\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_N, bn);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_E, be);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_D, bd);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_FACTOR1, bp);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_FACTOR2, bq);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_EXPONENT1, bdmp1);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_EXPONENT2, bdmq1);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_COEFFICIENT1, biqmp);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = evp_build_pkey(\"RSA\", param_bld, &(key->key), EVP_PKEY_KEYPAIR);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_WARNING,\n                \"Failed to import private key: %s\\n\",\n                ERR_error_string(ERR_get_error(), NULL));\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\nfail:\n    OSSL_PARAM_BLD_free(param_bld);\n    bignum_safe_free(bn);\n    bignum_safe_free(be);\n    bignum_safe_free(bd);\n    bignum_safe_free(bp);\n    bignum_safe_free(bq);\n    bignum_safe_free(biqmp);\n\n    bignum_safe_free(aux);\n    bignum_safe_free(d_consttime);\n    bignum_safe_free(bdmp1);\n    bignum_safe_free(bdmq1);\n    BN_CTX_free(ctx);\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 1228,
      "line_end": 1408,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 169,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses external serialized key material into BIGNUMs and performs BN arithmetic/CRT calculations while interacting with OpenSSL crypto APIs; security\u2011critical, handles untrusted input and memory operations with many error paths\u2014high value for fuzzing."
    },
    {
      "name": "ecdh_build_k",
      "clean_name": "ecdh_build_k",
      "source_file": "/src/libssh/src/ecdh_crypto.c",
      "source_code": "    rc = ssh_packet_send(session);\n\n    return rc;\n}\n\nint ecdh_build_k(ssh_session session)\n{\n  struct ssh_crypto_struct *next_crypto = session->next_crypto;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n  const EC_GROUP *group = EC_KEY_get0_group(next_crypto->ecdh_privkey);\n  EC_POINT *pubkey = NULL;\n  void *buffer = NULL;\n  int rc;\n  int len = (EC_GROUP_get_degree(group) + 7) / 8;\n  bignum_CTX ctx = bignum_ctx_new();\n  if (ctx == NULL) {\n    return -1;\n  }\n  pubkey = EC_POINT_new(group);\n  if (pubkey == NULL) {\n    bignum_ctx_free(ctx);\n    return -1;\n  }\n\n  if (session->server) {\n      rc = EC_POINT_oct2point(group,\n                              pubkey,\n                              ssh_string_data(next_crypto->ecdh_client_pubkey),\n                              ssh_string_len(next_crypto->ecdh_client_pubkey),\n                              ctx);\n  } else {\n      rc = EC_POINT_oct2point(group,\n                              pubkey,\n                              ssh_string_data(next_crypto->ecdh_server_pubkey),\n                              ssh_string_len(next_crypto->ecdh_server_pubkey),\n                              ctx);\n  }\n  bignum_ctx_free(ctx);\n  if (rc <= 0) {\n      EC_POINT_clear_free(pubkey);\n      return -1;\n  }\n\n  buffer = malloc(len);\n  if (buffer == NULL) {\n      EC_POINT_clear_free(pubkey);\n      return -1;\n  }\n\n  rc = ECDH_compute_key(buffer,\n                        len,\n                        pubkey,\n                        next_crypto->ecdh_privkey,\n                        NULL);\n  EC_POINT_clear_free(pubkey);\n  if (rc <= 0) {\n      free(buffer);\n      return -1;\n  }\n\n  bignum_bin2bn(buffer, len, &next_crypto->shared_secret);\n  free(buffer);\n#else\n  const char *curve = NULL;\n  EVP_PKEY *pubkey = NULL;\n  void *secret = NULL;\n  size_t secret_len;\n  int rc;\n  ssh_string peer_pubkey = NULL;\n  OSSL_PARAM_BLD *param_bld = OSSL_PARAM_BLD_new();\n  EVP_PKEY_CTX *dh_ctx = EVP_PKEY_CTX_new_from_pkey(NULL,\n                                                    next_crypto->ecdh_privkey,\n                                                    NULL);\n\n  if (dh_ctx == NULL || param_bld == NULL) {\n      ssh_set_error_oom(session);\n      EVP_PKEY_CTX_free(dh_ctx);\n      OSSL_PARAM_BLD_free(param_bld);\n      return -1;\n  }\n\n  rc = EVP_PKEY_derive_init(dh_ctx);\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not init PKEY derive: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      OSSL_PARAM_BLD_free(param_bld);\n      return -1;\n  }\n\n  if (session->server) {\n      peer_pubkey = next_crypto->ecdh_client_pubkey;\n  } else {\n      peer_pubkey = next_crypto->ecdh_server_pubkey;\n  }\n  rc = OSSL_PARAM_BLD_push_octet_string(param_bld,\n                                        OSSL_PKEY_PARAM_PUB_KEY,\n                                        ssh_string_data(peer_pubkey),\n                                        ssh_string_len(peer_pubkey));\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not push the pub key: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      OSSL_PARAM_BLD_free(param_bld);\n      return -1;\n  }\n  curve = ecdh_kex_type_to_curve(next_crypto->kex_type);\n  rc = OSSL_PARAM_BLD_push_utf8_string(param_bld,\n                                       OSSL_PKEY_PARAM_GROUP_NAME,\n                                       (char *)curve,\n                                       strlen(curve));\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not push the group name: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      OSSL_PARAM_BLD_free(param_bld);\n      return -1;\n  }\n\n  rc = evp_build_pkey(\"EC\", param_bld, &pubkey, EVP_PKEY_PUBLIC_KEY);\n  OSSL_PARAM_BLD_free(param_bld);\n  if (rc != SSH_OK) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not build the pkey: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      return -1;\n  }\n\n  rc = EVP_PKEY_derive_set_peer(dh_ctx, pubkey);\n  EVP_PKEY_free(pubkey);\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not set peer pubkey: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      return -1;\n  }\n\n  /* get the max length of the secret */\n  rc = EVP_PKEY_derive(dh_ctx, NULL, &secret_len);\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not set peer pubkey: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      return -1;\n  }\n\n  secret = malloc(secret_len);\n  if (secret == NULL) {\n      ssh_set_error_oom(session);\n      EVP_PKEY_CTX_free(dh_ctx);\n      return -1;\n  }\n\n  rc = EVP_PKEY_derive(dh_ctx, secret, &secret_len);\n  if (rc != 1) {\n      ssh_set_error(session,\n                    SSH_FATAL,\n                    \"Could not derive shared key: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n      EVP_PKEY_CTX_free(dh_ctx);\n      free(secret);\n      return -1;\n  }\n\n  EVP_PKEY_CTX_free(dh_ctx);\n\n  bignum_bin2bn(secret, secret_len, &next_crypto->shared_secret);\n  free(secret);\n#endif /* OPENSSL_VERSION_NUMBER */\n  if (next_crypto->shared_secret == NULL) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n      EC_KEY_free(next_crypto->ecdh_privkey);\n#else\n      EVP_PKEY_free(next_crypto->ecdh_privkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n      next_crypto->ecdh_privkey = NULL;\n      return -1;\n  }\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n  EC_KEY_free(next_crypto->ecdh_privkey);\n#else\n  EVP_PKEY_free(next_crypto->ecdh_privkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n  next_crypto->ecdh_privkey = NULL;\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"Session server cookie\",\n                   next_crypto->server_kex.cookie, 16);\n    ssh_log_hexdump(\"Session client cookie\",\n                   next_crypto->client_kex.cookie, 16);\n    ssh_print_bignum(\"Shared secret key\", next_crypto->shared_secret);\n#endif /* DEBUG_CRYPTO */\n\n  return 0;\n}\n",
      "line_start": 244,
      "line_end": 446,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 68,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Computes an ECDH shared secret from peer-supplied public key material (network/file input), performs memory allocations and binary parsing, and is cryptography/security-critical. Multiple branches (OpenSSL versions), external-input-dependent lengths and buffer operations make this a high-impact fuzz target."
    },
    {
      "name": "ssh_packet_server_ecdh_init",
      "clean_name": "ssh_packet_server_ecdh_init",
      "source_file": "/src/libssh/src/ecdh_crypto.c",
      "source_code": "#ifdef WITH_SERVER\n\n/** @brief Handle a SSH_MSG_KEXDH_INIT packet (server) and send a\n * SSH_MSG_KEXDH_REPLY\n */\nSSH_PACKET_CALLBACK(ssh_packet_server_ecdh_init)\n{\n    /* ECDH keys */\n    ssh_string q_c_string = NULL;\n    ssh_string q_s_string = NULL;\n    /* SSH host keys (rsa, ed25519 and ecdsa) */\n    ssh_key privkey = NULL;\n    enum ssh_digest_e digest = SSH_DIGEST_AUTO;\n    ssh_string sig_blob = NULL;\n    ssh_string pubkey_blob = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    SSH_LOG(SSH_LOG_TRACE, \"Processing SSH_MSG_KEXDH_INIT\");\n\n    ssh_packet_remove_callbacks(session, &ssh_ecdh_server_callbacks);\n    /* Extract the client pubkey from the init packet */\n    q_c_string = ssh_buffer_get_ssh_string(packet);\n    if (q_c_string == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No Q_C ECC point in packet\");\n        goto error;\n    }\n    session->next_crypto->ecdh_client_pubkey = q_c_string;\n\n    q_s_string = ssh_ecdh_generate(session);\n    if (q_s_string == NULL) {\n        goto error;\n    }\n\n    session->next_crypto->ecdh_server_pubkey = q_s_string;\n\n    /* build k and session_id */\n    rc = ecdh_build_k(session);\n    if (rc < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* privkey is not allocated */\n    rc = ssh_get_key_params(session, &privkey, &digest);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_make_sessionid(session);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not create a session id\");\n        goto error;\n    }\n\n    sig_blob = ssh_srv_pki_do_sign_sessionid(session, privkey, digest);\n    if (sig_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Could not sign the session id\");\n        goto error;\n    }\n\n    rc = ssh_dh_get_next_server_publickey_blob(session, &pubkey_blob);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Could not export server public key\");\n        SSH_STRING_FREE(sig_blob);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bSSS\",\n                         SSH2_MSG_KEXDH_REPLY,\n                         pubkey_blob, /* host's pubkey */\n                         q_s_string, /* ecdh public key */\n                         sig_blob); /* signature blob */\n\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(pubkey_blob);\n\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_KEXDH_REPLY sent\");\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_packet_send_newkeys(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    return SSH_PACKET_USED;\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 452,
      "line_end": 550,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 151,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Parses a complex external protocol packet (SSH KEX ECDH init), extracts untrusted client public-key data, performs ECDH/key-derivation and signing (crypto/authentication), and builds/serializes responses \u2014 security-critical code operating on attacker-controlled input, making it a top fuzzing priority."
    },
    {
      "name": "curve25519_do_create_k",
      "clean_name": "curve25519_do_create_k",
      "source_file": "/src/libssh/src/curve25519_crypto.c",
      "source_code": "    pkey = NULL;\n\n    return SSH_OK;\n}\n\nint curve25519_do_create_k(ssh_session session, ssh_curve25519_pubkey k)\n{\n    ssh_curve25519_pubkey *peer_pubkey_loc = NULL;\n    int rc, ret = SSH_ERROR;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *pkey = NULL, *pubkey = NULL;\n    size_t shared_key_len = CURVE25519_PUBKEY_SIZE;\n\n    if (session->server) {\n        peer_pubkey_loc = &session->next_crypto->curve25519_client_pubkey;\n    } else {\n        peer_pubkey_loc = &session->next_crypto->curve25519_server_pubkey;\n    }\n\n    pkey = session->next_crypto->curve25519_privkey;\n    if (pkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create X25519 EVP_PKEY: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (pctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to initialize X25519 context: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    rc = EVP_PKEY_derive_init(pctx);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to initialize X25519 key derivation: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    pubkey = EVP_PKEY_new_raw_public_key(EVP_PKEY_X25519,\n                                         NULL,\n                                         *peer_pubkey_loc,\n                                         CURVE25519_PUBKEY_SIZE);\n    if (pubkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create X25519 public key EVP_PKEY: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    rc = EVP_PKEY_derive_set_peer(pctx, pubkey);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to set peer X25519 public key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    rc = EVP_PKEY_derive(pctx, k, &shared_key_len);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to derive X25519 shared secret: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n    ret = SSH_OK;\n\nout:\n    EVP_PKEY_free(pubkey);\n    EVP_PKEY_CTX_free(pctx);\n    return ret;\n}\n",
      "line_start": 93,
      "line_end": 164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 78,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Performs X25519 key derivation (cryptographic, security-critical) using a peer public key from session (likely network-controlled); invokes OpenSSL raw public key and derive APIs that write into a buffer \u2014 high-value fuzz target for memory/crypto implementation bugs."
    },
    {
      "name": "server.c:ssh_server_connection_callback",
      "clean_name": "ssh_server_connection_callback",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " * @internal\n *\n * @brief A function to be called each time a step has been done in the\n * connection.\n */\nstatic void ssh_server_connection_callback(ssh_session session)\n{\n    int rc;\n\n    switch (session->session_state) {\n    case SSH_SESSION_STATE_NONE:\n    case SSH_SESSION_STATE_CONNECTING:\n    case SSH_SESSION_STATE_SOCKET_CONNECTED:\n        break;\n    case SSH_SESSION_STATE_BANNER_RECEIVED:\n        if (session->clientbanner == NULL) {\n            goto error;\n        }\n        set_status(session, 0.4f);\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"SSH client banner: %s\", session->clientbanner);\n\n        /* Here we analyze the different protocols the server allows. */\n        rc = ssh_analyze_banner(session, 1);\n        if (rc < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                    \"No version of SSH protocol usable (banner: %s)\",\n                    session->clientbanner);\n            goto error;\n        }\n\n        /* from now, the packet layer is handling incoming packets */\n        ssh_packet_register_socket_callback(session, session->socket);\n\n        ssh_packet_set_default_callbacks(session);\n        set_status(session, 0.5f);\n        session->session_state = SSH_SESSION_STATE_INITIAL_KEX;\n        rc = ssh_send_kex(session);\n        if (rc < 0) {\n            goto error;\n        }\n        break;\n    case SSH_SESSION_STATE_INITIAL_KEX:\n        /* TODO: This state should disappear in favor of get_key handle */\n        break;\n    case SSH_SESSION_STATE_KEXINIT_RECEIVED:\n        set_status(session, 0.6f);\n        if ((session->flags & SSH_SESSION_FLAG_KEXINIT_SENT) == 0) {\n            rc = server_set_kex(session);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n            /* We are in a rekeying, so we need to send the server kex */\n            rc = ssh_send_kex(session);\n            if (rc < 0) {\n                goto error;\n            }\n        }\n        ssh_list_kex(&session->next_crypto->client_kex); // log client kex\n        rc = ssh_kex_select_methods(session);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = crypt_set_algorithms_server(session);\n        if (rc == SSH_ERROR) {\n            goto error;\n        }\n        set_status(session, 0.8f);\n        session->session_state = SSH_SESSION_STATE_DH;\n        break;\n    case SSH_SESSION_STATE_DH:\n        if (session->dh_handshake_state == DH_STATE_FINISHED) {\n\n            rc = ssh_packet_set_newkeys(session, SSH_DIRECTION_IN);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n\n            /*\n             * If the client supports extension negotiation, we will send\n             * our supported extensions now. This is the first message after\n             * sending NEWKEYS message and after turning on crypto.\n             */\n            if (session->extensions & SSH_EXT_NEGOTIATION &&\n                session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n                /*\n                 * Only send an SSH_MSG_EXT_INFO message the first time the\n                 * client undergoes NEWKEYS.  It is unexpected for this message\n                 * to be sent upon rekey, and may cause clients to log error\n                 * messages.\n                 *\n                 * The session_state can not be used for this purpose because it\n                 * is re-set to SSH_SESSION_STATE_KEXINIT_RECEIVED during rekey.\n                 * So, use the connected flag which transitions from non-zero\n                 * below.\n                 *\n                 * See also:\n                 * - https://bugzilla.mindrot.org/show_bug.cgi?id=2929\n                 */\n                if (session->connected == 0) {\n                    ssh_server_send_extensions(session);\n                }\n            }\n\n            set_status(session, 1.0f);\n            session->connected = 1;\n            session->session_state = SSH_SESSION_STATE_AUTHENTICATING;\n            if (session->flags & SSH_SESSION_FLAG_AUTHENTICATED)\n                session->session_state = SSH_SESSION_STATE_AUTHENTICATED;\n\n        }\n        break;\n    case SSH_SESSION_STATE_AUTHENTICATING:\n        break;\n    case SSH_SESSION_STATE_ERROR:\n        goto error;\n    default:\n        ssh_set_error(session, SSH_FATAL, \"Invalid state %d\",\n                      session->session_state);\n    }\n\n    return;\nerror:\n    ssh_socket_close(session->socket);\n    session->alive = 0;\n    session->session_state = SSH_SESSION_STATE_ERROR;\n}\n",
      "line_start": 339,
      "line_end": 461,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 155,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Security-critical SSH connection state machine that processes external network input (client banner, KEX, extensions), drives cryptographic/key-exchange and authentication code paths, and has high branching complexity \u2014 an excellent high-value fuzzing target (exercise numerous parsers and memory-handling routines)."
    },
    {
      "name": "dh-gex.c:ssh_packet_client_dhgex_group",
      "clean_name": "ssh_packet_client_dhgex_group",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "\n/** @internal\n *  @brief handle a DH_GEX_GROUP packet, client side. This packet contains\n *         the group parameters.\n */\nSSH_PACKET_CALLBACK(ssh_packet_client_dhgex_group)\n{\n    int rc;\n    int blen;\n    bignum pmin1 = NULL, one = NULL;\n    bignum_CTX ctx = bignum_ctx_new();\n    bignum modulus = NULL, generator = NULL;\n#if !defined(HAVE_LIBCRYPTO) || OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum pubkey;\n#else\n    bignum pubkey = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n    (void) type;\n    (void) user;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_KEX_DH_GEX_GROUP received\");\n\n    if (bignum_ctx_invalid(ctx)) {\n        goto error;\n    }\n\n    if (session->dh_handshake_state != DH_STATE_REQUEST_SENT) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Received DH_GEX_GROUP in invalid state\");\n        goto error;\n    }\n    one = bignum_new();\n    pmin1 = bignum_new();\n    if (one == NULL || pmin1 == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    rc = ssh_buffer_unpack(packet,\n                           \"BB\",\n                           &modulus,\n                           &generator);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid DH_GEX_GROUP packet\");\n        goto error;\n    }\n    /* basic checks */\n    if (ssh_fips_mode() &&\n        !ssh_dh_is_known_group(modulus, generator)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"The received DH group is not FIPS approved\");\n        goto error;\n    }\n    rc = bignum_set_word(one, 1);\n    if (rc != 1) {\n        goto error;\n    }\n    blen = bignum_num_bits(modulus);\n    if (blen < DH_PMIN || blen > DH_PMAX) {\n        ssh_set_error(session,\n                SSH_FATAL,\n                \"Invalid dh group parameter p: %d not in [%d:%d]\",\n                blen,\n                DH_PMIN,\n                DH_PMAX);\n        goto error;\n    }\n    if (bignum_cmp(modulus, one) <= 0) {\n        /* p must be positive and preferably bigger than one */\n        ssh_set_error(session, SSH_FATAL, \"Invalid dh group parameter p\");\n    }\n    if (!bignum_is_bit_set(modulus, 0)) {\n        /* p must be a prime and therefore not divisible by 2 */\n        ssh_set_error(session, SSH_FATAL, \"Invalid dh group parameter p\");\n        goto error;\n    }\n    bignum_sub(pmin1, modulus, one);\n    if (bignum_cmp(generator, one) <= 0 ||\n        bignum_cmp(generator, pmin1) > 0) {\n        /* generator must be at least 2 and smaller than p-1*/\n        ssh_set_error(session, SSH_FATAL, \"Invalid dh group parameter g\");\n        goto error;\n    }\n    bignum_ctx_free(ctx);\n    ctx = NULL;\n\n    /* all checks passed, set parameters (the BNs are copied in openssl backend) */\n    rc = ssh_dh_set_parameters(session->next_crypto->dh_ctx,\n                               modulus, generator);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n#ifdef HAVE_LIBCRYPTO\n    bignum_safe_free(modulus);\n    bignum_safe_free(generator);\n#endif\n    modulus = NULL;\n    generator = NULL;\n\n    /* compute and send DH public parameter */\n    rc = ssh_dh_keypair_gen_keys(session->next_crypto->dh_ctx,\n                                 DH_CLIENT_KEYPAIR);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    rc = ssh_dh_keypair_get_keys(session->next_crypto->dh_ctx,\n                                 DH_CLIENT_KEYPAIR, NULL, &pubkey);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bB\",\n                         SSH2_MSG_KEX_DH_GEX_INIT,\n                         pubkey);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(pubkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    bignum_safe_free(one);\n    bignum_safe_free(pmin1);\n    return SSH_PACKET_USED;\n\nerror:\n    bignum_safe_free(modulus);\n    bignum_safe_free(generator);\n    bignum_safe_free(one);\n    bignum_safe_free(pmin1);\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(pubkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n    if(!bignum_ctx_invalid(ctx)) {\n        bignum_ctx_free(ctx);\n    }\n    ssh_dh_cleanup(session->next_crypto);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 103,
      "line_end": 249,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 284,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses complex network input (SSH DH_GEX_GROUP), performs many bignum/memory operations and validations on untrusted data, contains multiple input-dependent branches and security-critical cryptographic handling \u2014 high-value fuzz target."
    },
    {
      "name": "dh-gex.c:ssh_packet_client_dhgex_reply",
      "clean_name": "ssh_packet_client_dhgex_reply",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "void ssh_client_dhgex_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_dhgex_client_callbacks);\n}\n\nstatic SSH_PACKET_CALLBACK(ssh_packet_client_dhgex_reply)\n{\n    struct ssh_crypto_struct *crypto=session->next_crypto;\n    int rc;\n    ssh_string pubkey_blob = NULL;\n    bignum server_pubkey = NULL;\n    (void)type;\n    (void)user;\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_KEX_DH_GEX_REPLY received\");\n\n    ssh_client_dhgex_remove_callbacks(session);\n    rc = ssh_buffer_unpack(packet,\n                           \"SBS\",\n                           &pubkey_blob, &server_pubkey,\n                           &crypto->dh_server_signature);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid DH_GEX_REPLY packet\");\n        goto error;\n    }\n    rc = ssh_dh_keypair_set_keys(crypto->dh_ctx, DH_SERVER_KEYPAIR,\n                                 NULL, server_pubkey);\n    if (rc != SSH_OK) {\n        bignum_safe_free(server_pubkey);\n        goto error;\n    }\n    /* The ownership was passed to the crypto structure */\n    server_pubkey = NULL;\n\n    rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n    SSH_STRING_FREE(pubkey_blob);\n    if (rc != 0) {\n        goto error;\n    }\n\n    rc = ssh_dh_compute_shared_secret(session->next_crypto->dh_ctx,\n                                      DH_CLIENT_KEYPAIR, DH_SERVER_KEYPAIR,\n                                      &session->next_crypto->shared_secret);\n    ssh_dh_debug_crypto(session->next_crypto);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session, SSH_FATAL, \"Could not generate shared secret\");\n        goto error;\n    }\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_packet_send_newkeys(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n\n    return SSH_PACKET_USED;\nerror:\n    SSH_STRING_FREE(pubkey_blob);\n    ssh_dh_cleanup(session->next_crypto);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 255,
      "line_end": 313,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 100,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses complex network input (KEX DH GEX reply), unpacks string/bignum/signature from untrusted packet, and performs cryptographic operations (key import, DH shared-secret computation) and buffer/ownership handling \u2014 high security impact and likely to expose memory/logic bugs."
    },
    {
      "name": "config.c:ssh_config_parse_line",
      "clean_name": "ssh_config_parse_line",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "    return (found == (negate ? 0 : 1));\n}\n#endif /* HAVE_IFADDRS_H */\n\nstatic int\nssh_config_parse_line(ssh_session session,\n                      const char *line,\n                      unsigned int count,\n                      int *parsing,\n                      unsigned int depth,\n                      bool global)\n{\n  enum ssh_config_opcode_e opcode;\n  const char *p = NULL, *p2 = NULL;\n  char *s = NULL, *x = NULL;\n  char *keyword = NULL;\n  char *lowerhost = NULL;\n  size_t len;\n  int i, rv;\n  uint8_t *seen = session->opts.options_seen;\n  long l;\n  int64_t ll;\n\n  /* Ignore empty lines */\n  if (line == NULL || *line == '\\0') {\n    return 0;\n  }\n\n  x = s = strdup(line);\n  if (s == NULL) {\n    ssh_set_error_oom(session);\n    return -1;\n  }\n\n  /* Remove trailing spaces */\n  for (len = strlen(s) - 1; len > 0; len--) {\n    if (! isspace(s[len])) {\n      break;\n    }\n    s[len] = '\\0';\n  }\n\n  keyword = ssh_config_get_token(&s);\n  if (keyword == NULL || *keyword == '#' ||\n      *keyword == '\\0' || *keyword == '\\n') {\n    SAFE_FREE(x);\n    return 0;\n  }\n\n  opcode = ssh_config_get_opcode(keyword);\n  if (*parsing == 1 &&\n      opcode != SOC_HOST &&\n      opcode != SOC_MATCH &&\n      opcode != SOC_INCLUDE &&\n      opcode != SOC_IDENTITY &&\n      opcode != SOC_CERTIFICATE &&\n      opcode > SOC_UNSUPPORTED &&\n      opcode < SOC_MAX) { /* Ignore all unknown types here */\n      /* Skip all the options that were already applied */\n      if (seen[opcode] != 0) {\n          SAFE_FREE(x);\n          return 0;\n      }\n      seen[opcode] = 1;\n  }\n\n  switch (opcode) {\n    case SOC_INCLUDE: /* recursive include of other files */\n\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        char *path = ssh_config_make_absolute(session, p, global);\n        if (path == NULL) {\n          SSH_LOG(SSH_LOG_WARN, \"line %d: Failed to allocate memory \"\n                  \"for the include path expansion\", count);\n          SAFE_FREE(x);\n          return -1;\n        }\n#if defined(HAVE_GLOB) && defined(HAVE_GLOB_GL_FLAGS_MEMBER)\n        local_parse_glob(session, path, parsing, depth + 1, global);\n#else\n        local_parse_file(session, path, parsing, depth + 1, global);\n#endif /* HAVE_GLOB */\n        free(path);\n      }\n      break;\n\n    case SOC_MATCH: {\n        bool negate;\n        int result = 1;\n        size_t args = 0;\n        enum ssh_config_match_e opt;\n        char *localuser = NULL;\n\n        *parsing = 0;\n        do {\n            p = p2 = ssh_config_get_str_tok(&s, NULL);\n            if (p == NULL || p[0] == '\\0') {\n                break;\n            }\n            args++;\n            SSH_LOG(SSH_LOG_DEBUG, \"line %d: Processing Match keyword '%s'\",\n                    count, p);\n\n            /* If the option is prefixed with ! the result should be negated */\n            negate = false;\n            if (p[0] == '!') {\n                negate = true;\n                p++;\n            }\n\n            opt = ssh_config_get_match_opcode(p);\n            switch (opt) {\n            case MATCH_ALL:\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (args <= 2 && (p == NULL || p[0] == '\\0')) {\n                    /* The first or second, but last argument. The \"all\" keyword\n                     * can be prefixed with either \"final\" or \"canonical\"\n                     * keywords which do not have any effect here. */\n                    if (negate == true) {\n                        result = 0;\n                    }\n                    break;\n                }\n\n                ssh_set_error(session, SSH_FATAL,\n                              \"line %d: ERROR - Match all cannot be combined with \"\n                              \"other Match attributes\", count);\n                SAFE_FREE(x);\n                return -1;\n\n            case MATCH_FINAL:\n            case MATCH_CANONICAL:\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"line %d: Unsupported Match keyword '%s', skipping\",\n                        count,\n                        p);\n                /* Not set any result here -- the result is dependent on the\n                 * following matches after this keyword */\n                break;\n\n            case MATCH_EXEC:\n                /* Skip one argument (including in quotes) */\n                p = ssh_config_get_token(&s);\n                if (p == NULL || p[0] == '\\0') {\n                    SSH_LOG(SSH_LOG_TRACE, \"line %d: Match keyword \"\n                            \"'%s' requires argument\", count, p2);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                if (result != 1) {\n                    SSH_LOG(SSH_LOG_DEBUG, \"line %d: Skipped match exec \"\n                            \"'%s' as previous conditions already failed.\",\n                            count, p2);\n                    continue;\n                }\n                result &= ssh_match_exec(session, p, negate);\n                args++;\n                break;\n\n            case MATCH_LOCALUSER:\n                /* Here we match only one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"line %d: ERROR - Match localuser keyword \"\n                                  \"requires argument\",\n                                  count);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                localuser = ssh_get_local_username();\n                if (localuser == NULL) {\n                    SSH_LOG(SSH_LOG_TRACE, \"line %d: Can not get local username \"\n                            \"for conditional matching.\", count);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                result &= ssh_config_match(localuser, p, negate);\n                SAFE_FREE(localuser);\n                args++;\n                break;\n\n            case MATCH_ORIGINALHOST:\n                /* Skip one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    SSH_LOG(SSH_LOG_TRACE, \"line %d: Match keyword \"\n                            \"'%s' requires argument\", count, p2);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                args++;\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"line %d: Unsupported Match keyword '%s', ignoring\",\n                        count,\n                        p2);\n                result = 0;\n                break;\n\n            case MATCH_HOST:\n                /* Here we match only one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    ssh_set_error(session, SSH_FATAL,\n                                  \"line %d: ERROR - Match host keyword \"\n                                  \"requires argument\", count);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                result &= ssh_config_match(session->opts.host, p, negate);\n                args++;\n                break;\n\n            case MATCH_USER:\n                /* Here we match only one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    ssh_set_error(session, SSH_FATAL,\n                                  \"line %d: ERROR - Match user keyword \"\n                                  \"requires argument\", count);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                result &= ssh_config_match(session->opts.username, p, negate);\n                args++;\n                break;\n\n            case MATCH_LOCALNETWORK:\n                /* Here we match only one argument */\n                p = ssh_config_get_str_tok(&s, NULL);\n                if (p == NULL || p[0] == '\\0') {\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"line %d: ERROR - Match local network keyword\"\n                                  \"requires argument\",\n                                  count);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n#ifdef HAVE_IFADDRS_H\n                rv = match_cidr_address_list(NULL, p, -1);\n                if (rv == -1) {\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"line %d: ERROR - List invalid entry: %s\",\n                                  count,\n                                  p);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n                rv = ssh_match_localnetwork(p, negate);\n                if (rv == -1) {\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"line %d: ERROR - Error while retrieving \"\n                                  \"network interface information -\"\n                                  \" List entry: %s\",\n                                  count,\n                                  p);\n                    SAFE_FREE(x);\n                    return -1;\n                }\n\n                result &= rv;\n#else /* HAVE_IFADDRS_H */\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"line %d: ERROR - match localnetwork \"\n                              \"not supported on this platform\",\n                              count);\n                SAFE_FREE(x);\n                return -1;\n#endif /* HAVE_IFADDRS_H */\n                args++;\n                break;\n\n            case MATCH_UNKNOWN:\n            default:\n                SSH_LOG(SSH_LOG_WARN,\n                        \"Unknown argument '%s' for Match keyword. Not matching\",\n                        p);\n                result = 0;\n                break;\n            }\n        } while (p != NULL && p[0] != '\\0');\n        if (args == 0) {\n            SSH_LOG(SSH_LOG_WARN,\n                    \"ERROR - Match keyword requires an argument. Not matching\");\n            result = 0;\n        }\n        *parsing = result;\n        break;\n    }\n    case SOC_HOST: {\n        int ok = 0, result = -1;\n\n        *parsing = 0;\n        lowerhost = (session->opts.host) ? ssh_lowercase(session->opts.host) : NULL;\n        for (p = ssh_config_get_str_tok(&s, NULL);\n             p != NULL && p[0] != '\\0';\n             p = ssh_config_get_str_tok(&s, NULL)) {\n             if (ok >= 0) {\n               ok = match_hostname(lowerhost, p, strlen(p));\n               if (result == -1 && ok < 0) {\n                   result = 0;\n               } else if (result == -1 && ok > 0) {\n                   result = 1;\n               }\n            }\n        }\n        SAFE_FREE(lowerhost);\n        if (result != -1) {\n            *parsing = result;\n        }\n        break;\n    }\n    case SOC_HOSTNAME:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        char *z = ssh_path_expand_escape(session, p);\n        if (z == NULL) {\n            z = strdup(p);\n        }\n        ssh_options_set(session, SSH_OPTIONS_HOST, z);\n        free(z);\n      }\n      break;\n    case SOC_PORT:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_PORT_STR, p);\n        }\n        break;\n    case SOC_USERNAME:\n      if (session->opts.username == NULL) {\n          p = ssh_config_get_str_tok(&s, NULL);\n          if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_USER, p);\n         }\n      }\n      break;\n    case SOC_IDENTITY:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_ADD_IDENTITY, p);\n      }\n      break;\n    case SOC_CIPHERS:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_CIPHERS_C_S, p);\n        ssh_options_set(session, SSH_OPTIONS_CIPHERS_S_C, p);\n      }\n      break;\n    case SOC_MACS:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_HMAC_C_S, p);\n        ssh_options_set(session, SSH_OPTIONS_HMAC_S_C, p);\n      }\n      break;\n    case SOC_COMPRESSION:\n      i = ssh_config_get_yesno(&s, -1);\n      if (i >= 0 && *parsing) {\n        if (i) {\n          ssh_options_set(session, SSH_OPTIONS_COMPRESSION, \"yes\");\n        } else {\n          ssh_options_set(session, SSH_OPTIONS_COMPRESSION, \"no\");\n        }\n      }\n      break;\n    case SOC_TIMEOUT:\n      l = ssh_config_get_long(&s, -1);\n      if (l >= 0 && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_TIMEOUT, &l);\n      }\n      break;\n    case SOC_STRICTHOSTKEYCHECK:\n      i = ssh_config_get_yesno(&s, -1);\n      if (i >= 0 && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_STRICTHOSTKEYCHECK, &i);\n      }\n      break;\n    case SOC_KNOWNHOSTS:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_KNOWNHOSTS, p);\n      }\n      break;\n    case SOC_PROXYCOMMAND:\n      p = ssh_config_get_cmd(&s);\n      /* We share the seen value with the ProxyJump */\n      if (p && *parsing && !seen[SOC_PROXYJUMP]) {\n        ssh_options_set(session, SSH_OPTIONS_PROXYCOMMAND, p);\n      }\n      break;\n    case SOC_PROXYJUMP:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p == NULL) {\n            SAFE_FREE(x);\n            return -1;\n        }\n        /* We share the seen value with the ProxyCommand */\n        rv = ssh_config_parse_proxy_jump(session,\n                                         p,\n                                         (*parsing && !seen[SOC_PROXYCOMMAND]));\n        if (rv != SSH_OK) {\n            SAFE_FREE(x);\n            return -1;\n        }\n        break;\n    case SOC_GSSAPISERVERIDENTITY:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_GSSAPI_SERVER_IDENTITY, p);\n      }\n      break;\n    case SOC_GSSAPICLIENTIDENTITY:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_GSSAPI_CLIENT_IDENTITY, p);\n      }\n      break;\n    case SOC_GSSAPIDELEGATECREDENTIALS:\n      i = ssh_config_get_yesno(&s, -1);\n      if (i >=0 && *parsing) {\n        ssh_options_set(session, SSH_OPTIONS_GSSAPI_DELEGATE_CREDENTIALS, &i);\n      }\n      break;\n    case SOC_BINDADDRESS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_BINDADDR, p);\n        }\n        break;\n    case SOC_GLOBALKNOWNHOSTSFILE:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_GLOBAL_KNOWNHOSTS, p);\n        }\n        break;\n    case SOC_LOGLEVEL:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            int value = -1;\n\n            if (strcasecmp(p, \"quiet\") == 0) {\n                value = SSH_LOG_NONE;\n            } else if (strcasecmp(p, \"fatal\") == 0 ||\n                    strcasecmp(p, \"error\")== 0) {\n                value = SSH_LOG_WARN;\n            } else if (strcasecmp(p, \"verbose\") == 0 ||\n                    strcasecmp(p, \"info\") == 0) {\n                value = SSH_LOG_INFO;\n            } else if (strcasecmp(p, \"DEBUG\") == 0 ||\n                    strcasecmp(p, \"DEBUG1\") == 0) {\n                value = SSH_LOG_DEBUG;\n            } else if (strcasecmp(p, \"DEBUG2\") == 0 ||\n                    strcasecmp(p, \"DEBUG3\") == 0) {\n                value = SSH_LOG_TRACE;\n            }\n            if (value != -1) {\n                ssh_options_set(session, SSH_OPTIONS_LOG_VERBOSITY, &value);\n            }\n        }\n        break;\n    case SOC_HOSTKEYALGORITHMS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_HOSTKEYS, p);\n        }\n        break;\n    case SOC_PUBKEYACCEPTEDKEYTYPES:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_PUBLICKEY_ACCEPTED_TYPES, p);\n        }\n        break;\n    case SOC_KEXALGORITHMS:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_KEY_EXCHANGE, p);\n        }\n        break;\n    case SOC_REKEYLIMIT:\n        /* Parse the data limit */\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p == NULL) {\n            break;\n        } else if (strcmp(p, \"default\") == 0) {\n            /* Default rekey limits enforced automatically */\n            ll = 0;\n        } else {\n            char *endp = NULL;\n            ll = strtoll(p, &endp, 10);\n            if (p == endp || ll < 0) {\n                /* No number or negative */\n                SSH_LOG(SSH_LOG_TRACE, \"Invalid argument to rekey limit\");\n                break;\n            }\n            switch (*endp) {\n            case 'G':\n                if (ll > LLONG_MAX / 1024) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 1024;\n                FALL_THROUGH;\n            case 'M':\n                if (ll > LLONG_MAX / 1024) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 1024;\n                FALL_THROUGH;\n            case 'K':\n                if (ll > LLONG_MAX / 1024) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 1024;\n                endp++;\n                FALL_THROUGH;\n            case '\\0':\n                /* just the number */\n                break;\n            default:\n                /* Invalid suffix */\n                ll = -1;\n                break;\n            }\n            if (*endp != ' ' && *endp != '\\0') {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Invalid trailing characters after the rekey limit: %s\",\n                        endp);\n                break;\n            }\n        }\n        if (ll > -1 && *parsing) {\n            uint64_t v = (uint64_t)ll;\n            ssh_options_set(session, SSH_OPTIONS_REKEY_DATA, &v);\n        }\n        /* Parse the time limit */\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p == NULL) {\n            break;\n        } else if (strcmp(p, \"none\") == 0) {\n            ll = 0;\n        } else {\n            char *endp = NULL;\n            ll = strtoll(p, &endp, 10);\n            if (p == endp || ll < 0) {\n                /* No number or negative */\n                SSH_LOG(SSH_LOG_TRACE, \"Invalid argument to rekey limit\");\n                break;\n            }\n            switch (*endp) {\n            case 'w':\n            case 'W':\n                if (ll > LLONG_MAX / 7) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 7;\n                FALL_THROUGH;\n            case 'd':\n            case 'D':\n                if (ll > LLONG_MAX / 24) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 24;\n                FALL_THROUGH;\n            case 'h':\n            case 'H':\n                if (ll > LLONG_MAX / 60) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 60;\n                FALL_THROUGH;\n            case 'm':\n            case 'M':\n                if (ll > LLONG_MAX / 60) {\n                    SSH_LOG(SSH_LOG_TRACE, \"Possible overflow of rekey limit\");\n                    ll = -1;\n                    break;\n                }\n                ll = ll * 60;\n                FALL_THROUGH;\n            case 's':\n            case 'S':\n                endp++;\n                FALL_THROUGH;\n            case '\\0':\n                /* just the number */\n                break;\n            default:\n                /* Invalid suffix */\n                ll = -1;\n                break;\n            }\n            if (*endp != '\\0') {\n                SSH_LOG(SSH_LOG_TRACE, \"Invalid trailing characters after the\"\n                        \" rekey limit: %s\", endp);\n                break;\n            }\n        }\n        if (ll > -1 && *parsing) {\n            uint32_t v = (uint32_t)ll;\n            ssh_options_set(session, SSH_OPTIONS_REKEY_TIME, &v);\n        }\n        break;\n    case SOC_GSSAPIAUTHENTICATION:\n    case SOC_KBDINTERACTIVEAUTHENTICATION:\n    case SOC_PASSWORDAUTHENTICATION:\n    case SOC_PUBKEYAUTHENTICATION:\n        i = ssh_config_get_yesno(&s, 0);\n        if (i>=0 && *parsing) {\n            switch(opcode){\n            case SOC_GSSAPIAUTHENTICATION:\n                ssh_options_set(session, SSH_OPTIONS_GSSAPI_AUTH, &i);\n                break;\n            case SOC_KBDINTERACTIVEAUTHENTICATION:\n                ssh_options_set(session, SSH_OPTIONS_KBDINT_AUTH, &i);\n                break;\n            case SOC_PASSWORDAUTHENTICATION:\n                ssh_options_set(session, SSH_OPTIONS_PASSWORD_AUTH, &i);\n                break;\n            case SOC_PUBKEYAUTHENTICATION:\n                ssh_options_set(session, SSH_OPTIONS_PUBKEY_AUTH, &i);\n                break;\n            /* make gcc happy */\n            default:\n                break;\n            }\n        }\n        break;\n    case SOC_NA:\n      SSH_LOG(SSH_LOG_TRACE, \"Unapplicable option: %s, line: %d\",\n              keyword, count);\n      break;\n    case SOC_UNSUPPORTED:\n      SSH_LOG(SSH_LOG_RARE, \"Unsupported option: %s, line: %d\",\n              keyword, count);\n      break;\n    case SOC_UNKNOWN:\n      SSH_LOG(SSH_LOG_TRACE, \"Unknown option: %s, line: %d\",\n              keyword, count);\n      break;\n    case SOC_IDENTITYAGENT:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n          ssh_options_set(session, SSH_OPTIONS_IDENTITY_AGENT, p);\n      }\n      break;\n    case SOC_IDENTITIESONLY:\n      i = ssh_config_get_yesno(&s, -1);\n      if (i >= 0 && *parsing) {\n        bool b = i;\n        ssh_options_set(session, SSH_OPTIONS_IDENTITIES_ONLY, &b);\n      }\n      break;\n    case SOC_CONTROLMASTER:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p && *parsing) {\n          int value = -1;\n\n          if (strcasecmp(p, \"auto\") == 0) {\n              value = SSH_CONTROL_MASTER_AUTO;\n          } else if (strcasecmp(p, \"yes\") == 0) {\n              value = SSH_CONTROL_MASTER_YES;\n          } else if (strcasecmp(p, \"no\") == 0) {\n              value = SSH_CONTROL_MASTER_NO;\n          } else if (strcasecmp(p, \"autoask\") == 0) {\n              value = SSH_CONTROL_MASTER_AUTOASK;\n          } else if (strcasecmp(p, \"ask\") == 0) {\n              value = SSH_CONTROL_MASTER_ASK;\n          }\n\n          if (value != -1) {\n              ssh_options_set(session, SSH_OPTIONS_CONTROL_MASTER, &value);\n          }\n      }\n      break;\n    case SOC_CONTROLPATH:\n      p = ssh_config_get_str_tok(&s, NULL);\n      if (p == NULL) {\n        SAFE_FREE(x);\n        return -1;\n      }\n      if (*parsing) {\n          ssh_options_set(session, SSH_OPTIONS_CONTROL_PATH, p);\n      }\n      break;\n    case SOC_CERTIFICATE:\n        p = ssh_config_get_str_tok(&s, NULL);\n        if (p && *parsing) {\n            ssh_options_set(session, SSH_OPTIONS_CERTIFICATE, p);\n        }\n        break;\n    default:\n      ssh_set_error(session, SSH_FATAL, \"ERROR - unimplemented opcode: %d\",\n              opcode);\n      SAFE_FREE(x);\n      return -1;\n      break;\n  }\n\n  SAFE_FREE(x);\n  return 0;\n}\n",
      "line_start": 737,
      "line_end": 1452,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1087,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses a complex external input (SSH config lines), with extensive tokenization, recursion (Include), loops over input-dependent tokens, many branches (large switch and nested match logic), numeric parsing with suffixes, and memory/string operations on untrusted data. It also influences authentication/crypto-related options (ciphers, hostkeys, rekeying, auth methods), making it a high-risk, high-value fuzz target."
    },
    {
      "name": "ecdh.c:ssh_packet_client_ecdh_reply",
      "clean_name": "ssh_packet_client_ecdh_reply",
      "source_file": "/src/libssh/src/ecdh.c",
      "source_code": "\n/** @internal\n * @brief parses a SSH_MSG_KEX_ECDH_REPLY packet and sends back\n * a SSH_MSG_NEWKEYS\n */\nSSH_PACKET_CALLBACK(ssh_packet_client_ecdh_reply){\n  ssh_string q_s_string = NULL;\n  ssh_string pubkey_blob = NULL;\n  ssh_string signature = NULL;\n  int rc;\n  (void)type;\n  (void)user;\n\n  ssh_client_ecdh_remove_callbacks(session);\n  pubkey_blob = ssh_buffer_get_ssh_string(packet);\n  if (pubkey_blob == NULL) {\n    ssh_set_error(session,SSH_FATAL, \"No public key in packet\");\n    goto error;\n  }\n\n  rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n  SSH_STRING_FREE(pubkey_blob);\n  if (rc != 0) {\n      goto error;\n  }\n\n  q_s_string = ssh_buffer_get_ssh_string(packet);\n  if (q_s_string == NULL) {\n    ssh_set_error(session,SSH_FATAL, \"No Q_S ECC point in packet\");\n    goto error;\n  }\n  session->next_crypto->ecdh_server_pubkey = q_s_string;\n  signature = ssh_buffer_get_ssh_string(packet);\n  if (signature == NULL) {\n    ssh_set_error(session, SSH_FATAL, \"No signature in packet\");\n    goto error;\n  }\n  session->next_crypto->dh_server_signature = signature;\n  signature=NULL; /* ownership changed */\n  /* TODO: verify signature now instead of waiting for NEWKEYS */\n  if (ecdh_build_k(session) < 0) {\n    ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n    goto error;\n  }\n\n  /* Send the MSG_NEWKEYS */\n  rc = ssh_packet_send_newkeys(session);\n  if (rc == SSH_ERROR) {\n    goto error;\n  }\n  session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n\n  return SSH_PACKET_USED;\n\nerror:\n  session->session_state=SSH_SESSION_STATE_ERROR;\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 54,
      "line_end": 107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses a complex SSH ECDH reply from untrusted input, imports public-key blobs and signatures and performs cryptographic operations (ecdh_build_k and key negotiation) \u2014 high risk for memory/crypto-related bugs and logic branches."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_client_fuzzer.c",
      "source_code": "    ssh_connector_free(connector_err);\n\n    ssh_event_free(event);\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_session session = NULL;\n    ssh_channel channel = NULL;\n    const char *env = NULL;\n    int socket_fds[2] = {-1, -1};\n    ssize_t nwritten;\n    bool no = false;\n    int rc;\n    long timeout = 1; /* use short timeout to avoid timeouts during fuzzing */\n\n    /* This is the maximum that can be handled by the socket buffer before the\n     * other side will read some data. Other option would be feeding the socket\n     * from different thread which would not mind if it would be blocked, but I\n     * believe all the important inputs should fit into this size */\n    if (size > 219264) {\n        return -1;\n    }\n\n    /* Set up the socket to send data */\n    rc = socketpair(AF_UNIX, SOCK_STREAM, 0, socket_fds);\n    assert(rc == 0);\n\n    nwritten = send(socket_fds[1], data, size, 0);\n    assert((size_t)nwritten == size);\n\n    rc = shutdown(socket_fds[1], SHUT_WR);\n    assert(rc == 0);\n\n    ssh_init();\n\n    session = ssh_new();\n    assert(session != NULL);\n\n    env = getenv(\"LIBSSH_VERBOSITY\");\n    if (env != NULL && strlen(env) > 0) {\n        ssh_options_set(session, SSH_OPTIONS_LOG_VERBOSITY_STR, env);\n    }\n    rc = ssh_options_set(session, SSH_OPTIONS_FD, &socket_fds[0]);\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_HOST, \"127.0.0.1\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_USER, \"alice\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_CIPHERS_C_S, \"none\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_CIPHERS_S_C, \"none\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_HMAC_C_S, \"none\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_HMAC_S_C, \"none\");\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_PROCESS_CONFIG, &no);\n    assert(rc == 0);\n    rc = ssh_options_set(session, SSH_OPTIONS_TIMEOUT, &timeout);\n    assert(rc == 0);\n\n    ssh_callbacks_init(&cb);\n    ssh_set_callbacks(session, &cb);\n\n    rc = ssh_connect(session);\n    if (rc != SSH_OK) {\n        goto out;\n    }\n\n    rc = ssh_userauth_none(session, NULL);\n    if (rc != SSH_OK) {\n        goto out;\n    }\n\n    channel = ssh_channel_new(session);\n    if (channel == NULL) {\n        goto out;\n    }\n\n    rc = ssh_channel_open_session(channel);\n    if (rc != SSH_OK) {\n        goto out;\n    }\n\n    rc = ssh_channel_request_exec(channel, \"ls\");\n    if (rc != SSH_OK) {\n        goto out;\n    }\n\n    select_loop(session, channel);\n\nout:\n    ssh_channel_free(channel);\n    ssh_disconnect(session);\n    ssh_free(session);\n\n    ssh_finalize();\n\n    close(socket_fds[0]);\n    close(socket_fds[1]);\n\n    return 0;\n}\n",
      "line_start": 86,
      "line_end": 185,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 238,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Feeds untrusted data into libssh over a socket to exercise SSH protocol parsing and session/channel handling \u2014 complex external input (network protocol), memory/buffer handling, branching and looped I/O, and security/crypto-related code paths. High-value fuzz target."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:match_hashed_hostname",
      "clean_name": "match_hashed_hostname",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "        return SSH_ERROR;\n\n    return SSH_OK;\n}\n\nstatic int match_hashed_hostname(const char *host, const char *hashed_host)\n{\n    char *hashed = NULL;\n    char *b64_hash = NULL;\n    ssh_buffer salt = NULL;\n    ssh_buffer hash = NULL;\n    unsigned char hashed_buf[256] = {0};\n    unsigned char *hashed_buf_ptr = hashed_buf;\n    size_t hashed_buf_size = sizeof(hashed_buf);\n    int cmp;\n    int rc;\n    int match = 0;\n\n    cmp = strncmp(hashed_host, \"|1|\", 3);\n    if (cmp != 0) {\n        return 0;\n    }\n\n    hashed = strdup(hashed_host + 3);\n    if (hashed == NULL) {\n        return 0;\n    }\n\n    b64_hash = strchr(hashed, '|');\n    if (b64_hash == NULL) {\n        goto error;\n    }\n    *b64_hash = '\\0';\n    b64_hash++;\n\n    salt = base64_to_bin(hashed);\n    if (salt == NULL) {\n        goto error;\n    }\n\n    hash = base64_to_bin(b64_hash);\n    if (hash == NULL) {\n        goto error;\n    }\n\n    rc = hash_hostname(host,\n                       ssh_buffer_get(salt),\n                       ssh_buffer_get_len(salt),\n                       &hashed_buf_ptr,\n                       &hashed_buf_size);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    if (hashed_buf_size != ssh_buffer_get_len(hash)) {\n        goto error;\n    }\n\n    cmp = memcmp(hashed_buf, ssh_buffer_get(hash), hashed_buf_size);\n    if (cmp == 0) {\n        match = 1;\n    }\n\nerror:\n    free(hashed);\n    SSH_BUFFER_FREE(salt);\n    SSH_BUFFER_FREE(hash);\n\n    return match;\n}\n",
      "line_start": 81,
      "line_end": 146,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 10.0,
      "reason": "Parses structured external input (\"|1|salt|hash\"), performs base64 decoding and memory operations on untrusted data, and is part of security-critical host-matching logic \u2014 high potential for parsing/crypto-related bugs and thus a top-priority fuzz target."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_server_fuzzer.c",
      "source_code": "    }\n\n    return 0;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    int socket_fds[2] = {-1, -1};\n    ssize_t nwritten;\n    bool no = false;\n    const char *env = NULL;\n    int rc;\n\n    /* Our struct holding information about the session. */\n    struct session_data_struct sdata = {\n        .channel       = NULL,\n        .auth_attempts = 0,\n        .authenticated = false,\n    };\n\n    struct ssh_server_callbacks_struct server_cb = {\n        .userdata = &sdata,\n        .auth_none_function = auth_none,\n        .channel_open_request_session_function = channel_open,\n    };\n\n    /* This is the maximum that can be handled by the socket buffer before the\n     * other side will read some data. Other option would be feeding the socket\n     * from different thread which would not mind if it would be blocked, but I\n     * believe all the important inputs should fit into this size */\n    if (size > 219264) {\n        return -1;\n    }\n\n    /* Write SSH RSA host key to disk */\n    rc = write_rsa_hostkey(\"/tmp/libssh_fuzzer_private_key\");\n    assert(rc == 0);\n\n    /* Set up the socket to send data */\n    rc = socketpair(AF_UNIX, SOCK_STREAM, 0, socket_fds);\n    assert(rc == 0);\n\n    nwritten = send(socket_fds[1], data, size, 0);\n    assert((size_t)nwritten == size);\n\n    rc = shutdown(socket_fds[1], SHUT_WR);\n    assert(rc == 0);\n\n    /* Set up the libssh server */\n    ssh_bind sshbind = ssh_bind_new();\n    assert(sshbind != NULL);\n\n    ssh_session session = ssh_new();\n    assert(session != NULL);\n\n\n    env = getenv(\"LIBSSH_VERBOSITY\");\n    if (env != NULL && strlen(env) > 0) {\n        rc = ssh_bind_options_set(sshbind,\n                                  SSH_BIND_OPTIONS_LOG_VERBOSITY_STR,\n                                  env);\n        assert(rc == 0);\n    }\n    rc = ssh_bind_options_set(sshbind,\n                              SSH_BIND_OPTIONS_HOSTKEY,\n                              \"/tmp/libssh_fuzzer_private_key\");\n    assert(rc == 0);\n    rc = ssh_bind_options_set(sshbind, SSH_BIND_OPTIONS_CIPHERS_C_S, \"none\");\n    assert(rc == 0);\n    rc = ssh_bind_options_set(sshbind, SSH_BIND_OPTIONS_CIPHERS_S_C, \"none\");\n    assert(rc == 0);\n    rc = ssh_bind_options_set(sshbind, SSH_BIND_OPTIONS_HMAC_C_S, \"none\");\n    assert(rc == 0);\n    rc = ssh_bind_options_set(sshbind, SSH_BIND_OPTIONS_HMAC_S_C, \"none\");\n    assert(rc == 0);\n    rc = ssh_bind_options_set(sshbind, SSH_BIND_OPTIONS_PROCESS_CONFIG, &no);\n    assert(rc == 0);\n\n    ssh_set_auth_methods(session, SSH_AUTH_METHOD_NONE);\n\n    ssh_callbacks_init(&server_cb);\n    ssh_set_server_callbacks(session, &server_cb);\n\n    rc = ssh_bind_accept_fd(sshbind, session, socket_fds[0]);\n    assert(rc == SSH_OK);\n\n    ssh_event event = ssh_event_new();\n    assert(event != NULL);\n\n    if (ssh_handle_key_exchange(session) == SSH_OK) {\n        ssh_event_add_session(event, session);\n\n        size_t n = 0;\n        while (sdata.authenticated == false || sdata.channel == NULL) {\n            if (sdata.auth_attempts >= 3 || n >= 100) {\n                break;\n            }\n\n            if (ssh_event_dopoll(event, 100) == SSH_ERROR) {\n                break;\n            }\n\n            n++;\n        }\n    }\n\n    ssh_event_free(event);\n\n    close(socket_fds[0]);\n    close(socket_fds[1]);\n\n    ssh_disconnect(session);\n    ssh_free(session);\n    ssh_bind_free(sshbind);\n\n    return 0;\n}\n",
      "line_start": 120,
      "line_end": 232,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 261,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 10.0,
      "reason": "Feeds raw external data into a full SSH server stack: complex protocol parsing (SSH), key exchange/cryptography, authentication/channel handling, socket I/O, and event-driven branches. This exercises many security-critical codepaths and memory operations in libssh, making it a high-value (critical) fuzz target."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_bind_config_fuzzer.c",
      "source_code": "#define LIBSSH_STATIC 1\n#include \"libssh/libssh.h\"\n#include \"libssh/server.h\"\n#include \"libssh/bind_config.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_bind bind = NULL;\n    char *input = NULL;\n\n    input = (char *)malloc(size + 1);\n    if (!input) {\n        return 1;\n    }\n    strncpy(input, (const char *)data, size);\n    input[size] = '\\0';\n\n    ssh_init();\n\n    bind = ssh_bind_new();\n    assert(bind != NULL);\n\n    ssh_bind_config_parse_string(bind, input);\n\n    ssh_bind_free(bind);\n    ssh_finalize();\n\n    free(input);\n\n    return 0;\n}\n",
      "line_start": 26,
      "line_end": 52,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Feeds untrusted data into libssh's configuration parser (complex, structured external input). This exercises parsing logic in a security-sensitive library and can trigger memory-corruption or logic bugs; high-value fuzz target for finding serious issues."
    },
    {
      "name": "socket.c:jump_thread_func",
      "clean_name": "jump_thread_func",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n    return SSH_OK;\n}\n\nstatic void *\njump_thread_func(void *arg)\n{\n    struct jump_thread_data_struct *jump_thread_data = NULL;\n    struct ssh_jump_info_struct *jis = NULL;\n    struct ssh_jump_callbacks_struct *cb = NULL;\n    ssh_session jump_session = NULL;\n    ssh_channel caa = NULL;\n    int rc;\n    ssh_event event = NULL;\n    ssh_connector connector_in = NULL, connector_out = NULL;\n    ssh_session session = NULL;\n    int next_port;\n    char *next_hostname = NULL;\n\n    jump_thread_data = (struct jump_thread_data_struct *)arg;\n    session = jump_thread_data->session;\n\n    next_port = session->opts.port;\n    next_hostname = strdup(session->opts.host);\n\n    jump_session = ssh_new();\n    if (jump_session == NULL) {\n        goto exit;\n    }\n\n    jump_session->proxy_root = false;\n    /* Reset the global variable if it was previously 1 */\n    if (session->proxy_root) {\n        proxy_disconnect = 0;\n    }\n\n    for (jis = ssh_list_pop_head(struct ssh_jump_info_struct *,\n                                 session->opts.proxy_jumps);\n         jis != NULL;\n         jis = ssh_list_pop_head(struct ssh_jump_info_struct *,\n                                 session->opts.proxy_jumps)) {\n        rc = ssh_list_append(jump_session->opts.proxy_jumps, jis);\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto exit;\n        }\n    }\n    for (jis =\n            ssh_list_pop_head(struct ssh_jump_info_struct *,\n                              session->opts.proxy_jumps_user_cb);\n         jis != NULL;\n         jis = ssh_list_pop_head(struct ssh_jump_info_struct *,\n                                 session->opts.proxy_jumps_user_cb)) {\n        rc = ssh_list_append(jump_session->opts.proxy_jumps_user_cb, jis);\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto exit;\n        }\n    }\n\n    ssh_options_set(jump_session,\n                    SSH_OPTIONS_LOG_VERBOSITY,\n                    &session->common.log_verbosity);\n\n    /* Pop the information about the current jump */\n    jis = ssh_list_pop_head(struct ssh_jump_info_struct *,\n                            jump_session->opts.proxy_jumps);\n    if (jis == NULL) {\n        SSH_LOG(SSH_LOG_WARN, \"Inconsistent list of proxy jumps received\");\n        goto exit;\n    }\n\n    ssh_options_set(jump_session, SSH_OPTIONS_HOST, jis->hostname);\n    ssh_options_set(jump_session, SSH_OPTIONS_USER, jis->username);\n    ssh_options_set(jump_session, SSH_OPTIONS_PORT, &jis->port);\n\n    /* Pop the callbacks for the current jump */\n    cb = ssh_list_pop_head(struct ssh_jump_callbacks_struct *,\n                           jump_session->opts.proxy_jumps_user_cb);\n\n    if (cb != NULL) {\n        rc = cb->before_connection(jump_session, cb->userdata);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_WARN, \"%s\", ssh_get_error(jump_session));\n            goto exit;\n        }\n    }\n\n    /* If there are more jumps then this will make a new thread and call the\n     * current function again, until there are no jumps. When there are no jumps\n     * it connects normally. */\n    rc = ssh_connect(jump_session);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_WARN, \"%s\", ssh_get_error(jump_session));\n        goto exit;\n    }\n\n    /* Use the callback or default implementation for verifying knownhost */\n    if (cb != NULL && cb->verify_knownhost != NULL) {\n        rc = cb->verify_knownhost(jump_session, cb->userdata);\n    } else {\n        rc = verify_knownhost(jump_session);\n    }\n    if (rc != SSH_OK) {\n        goto exit;\n    }\n\n    /* Use the callback or publickey method to authenticate */\n    if (cb != NULL && cb->authenticate != NULL) {\n        rc = cb->authenticate(jump_session, cb->userdata);\n    } else {\n        rc = ssh_userauth_publickey_auto(jump_session, NULL, NULL);\n    }\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_WARN, \"%s\", ssh_get_error(jump_session));\n        goto exit;\n    }\n\n    caa = ssh_channel_new(jump_session);\n    if (caa == NULL) {\n        goto exit;\n    }\n    /* The origin hostname and port are set to match OpenSSH implementation\n     * they are only used for logging on the server */\n    rc = ssh_channel_open_forward(caa,\n                                  next_hostname,\n                                  next_port,\n                                  \"127.0.0.1\",\n                                  65535);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_WARN,\n                \"Error opening port forwarding channel: %s\",\n                ssh_get_error(jump_session));\n        goto exit;\n    }\n\n    event = ssh_event_new();\n    if (event == NULL) {\n        goto exit;\n    }\n\n    connector_in = ssh_connector_new(jump_session);\n    if (connector_in == NULL) {\n        goto exit;\n    }\n    ssh_connector_set_out_channel(connector_in, caa, SSH_CONNECTOR_STDINOUT);\n    ssh_connector_set_in_fd(connector_in, jump_thread_data->fd);\n    ssh_event_add_connector(event, connector_in);\n\n    connector_out = ssh_connector_new(jump_session);\n    if (connector_out == NULL) {\n        goto exit;\n    }\n    ssh_connector_set_out_fd(connector_out, jump_thread_data->fd);\n    ssh_connector_set_in_channel(connector_out, caa, SSH_CONNECTOR_STDINOUT);\n    ssh_event_add_connector(event, connector_out);\n\n    while (ssh_channel_is_open(caa)) {\n        if (proxy_disconnect == 1) {\n            break;\n        }\n        rc = ssh_event_dopoll(event, 60000);\n        if (rc == SSH_ERROR) {\n            SSH_LOG(SSH_LOG_WARN,\n                    \"Error in ssh_event_dopoll() during proxy jump\");\n            break;\n        }\n    }\n\nexit:\n    if (connector_in != NULL) {\n        ssh_event_remove_connector(event, connector_in);\n        ssh_connector_free(connector_in);\n    }\n    if (connector_out != NULL) {\n        ssh_event_remove_connector(event, connector_out);\n        ssh_connector_free(connector_out);\n    }\n    SAFE_FREE(next_hostname);\n    if (jis != NULL) {\n        SAFE_FREE(jis->hostname);\n        SAFE_FREE(jis->username);\n    }\n    SAFE_FREE(jis);\n\n    ssh_disconnect(jump_session);\n    ssh_event_free(event);\n    ssh_free(jump_session);\n\n    SAFE_FREE(jump_thread_data);\n\n    pthread_exit(NULL);\n}\n",
      "line_start": 1033,
      "line_end": 1221,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 257,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This function drives an SSH proxy/jump connection: it consumes external session/options and proxy_jumps entries (hostnames, usernames, ports), performs memory operations (strdup, list moves, frees), invokes authentication/known-host verification (crypto/security-critical), opens channels/FD connectors and contains multiple branches and loops. That combination of structured external input, network/protocol handling, and auth/crypto makes it a high-risk, high-value fuzz target (requires a harness to emulate sessions/network)."
    },
    {
      "name": "hmac_final",
      "clean_name": "hmac_final",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "int hmac_update(HMACCTX ctx, const void *data, size_t len)\n{\n    return EVP_DigestSignUpdate(ctx, data, len);\n}\n\nint hmac_final(HMACCTX ctx, unsigned char *hashmacbuf, size_t *len)\n{\n    size_t res = *len;\n    int rc;\n    rc = EVP_DigestSignFinal(ctx, hashmacbuf, &res);\n    EVP_MD_CTX_free(ctx);\n    if (rc == 1) {\n        *len = res;\n    }\n\n    return rc;\n}\n",
      "line_start": 390,
      "line_end": 402,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Finalizes a cryptographic HMAC using caller-supplied buffer/length: security-critical operation that writes into untrusted memory and frees the context \u2014 high value for fuzzing (memory-corruption, misuse, API abuse)."
    },
    {
      "name": "libcrypto.c:evp_cipher_set_encrypt_key",
      "clean_name": "evp_cipher_set_encrypt_key",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "        SSH_LOG(SSH_LOG_TRACE, \"No valid ciphertype found\");\n        break;\n    }\n}\n\nstatic int evp_cipher_set_encrypt_key(struct ssh_cipher_struct *cipher,\n            void *key, void *IV)\n{\n    int rc;\n\n    evp_cipher_init(cipher);\n\n    rc = EVP_EncryptInit_ex(cipher->ctx, cipher->cipher, NULL, key, IV);\n    if (rc != 1){\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptInit_ex failed\");\n        return SSH_ERROR;\n    }\n\n    /* For AES-GCM we need to set IV in specific way */\n    if (cipher->ciphertype == SSH_AEAD_AES128_GCM ||\n        cipher->ciphertype == SSH_AEAD_AES256_GCM) {\n        rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                                 EVP_CTRL_GCM_SET_IV_FIXED,\n                                 -1,\n                                 (uint8_t *)IV);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_SET_IV_FIXED failed\");\n            return SSH_ERROR;\n        }\n    }\n\n    EVP_CIPHER_CTX_set_padding(cipher->ctx, 0);\n\n    return SSH_OK;\n}\n",
      "line_start": 454,
      "line_end": 484,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Cryptography-critical wrapper that sets key/IV and calls into OpenSSL EVP APIs. Although simple and low branching, it handles security-sensitive input (key/IV) and delegates to complex native library code that will read/interpret untrusted data."
    },
    {
      "name": "libcrypto.c:evp_cipher_set_decrypt_key",
      "clean_name": "evp_cipher_set_decrypt_key",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    EVP_CIPHER_CTX_set_padding(cipher->ctx, 0);\n\n    return SSH_OK;\n}\n\nstatic int evp_cipher_set_decrypt_key(struct ssh_cipher_struct *cipher,\n            void *key, void *IV) {\n    int rc;\n\n    evp_cipher_init(cipher);\n\n    rc = EVP_DecryptInit_ex(cipher->ctx, cipher->cipher, NULL, key, IV);\n    if (rc != 1){\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DecryptInit_ex failed\");\n        return SSH_ERROR;\n    }\n\n    /* For AES-GCM we need to set IV in specific way */\n    if (cipher->ciphertype == SSH_AEAD_AES128_GCM ||\n        cipher->ciphertype == SSH_AEAD_AES256_GCM) {\n        rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                                 EVP_CTRL_GCM_SET_IV_FIXED,\n                                 -1,\n                                 (uint8_t *)IV);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_SET_IV_FIXED failed\");\n            return SSH_ERROR;\n        }\n    }\n\n    EVP_CIPHER_CTX_set_padding(cipher->ctx, 0);\n\n    return SSH_OK;\n}\n",
      "line_start": 485,
      "line_end": 514,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This function performs security-critical cryptographic initialization: it installs decryption key/IV into an OpenSSL EVP context (including AEAD GCM-specific EVP_CIPHER_CTX_ctrl). While its internal logic is simple, it operates directly on untrusted key/IV data and invokes complex library APIs that have historically contained exploitable edge cases \u2014 making it a high-value fuzz target."
    },
    {
      "name": "libcrypto.c:evp_cipher_decrypt",
      "clean_name": "evp_cipher_decrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "                len);\n        return;\n    }\n}\n\nstatic void evp_cipher_decrypt(struct ssh_cipher_struct *cipher,\n                               void *in,\n                               void *out,\n                               size_t len)\n{\n    int outlen = 0;\n    int rc = 0;\n\n    rc = EVP_DecryptUpdate(cipher->ctx,\n                           (unsigned char *)out,\n                           &outlen,\n                           (unsigned char *)in,\n                           (int)len);\n    if (rc != 1){\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DecryptUpdate failed\");\n        return;\n    }\n    if (outlen != (int)len){\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"EVP_DecryptUpdate: output size %d for %zu in\",\n                outlen,\n                len);\n        return;\n    }\n}\n",
      "line_start": 542,
      "line_end": 567,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Performs cryptographic decryption (EVP_DecryptUpdate) on externally-controlled input and writes to an output buffer \u2014 security-critical and memory-manipulating code. Although simple, it exercises crypto library code (high-value for fuzzing and uncovering vulnerabilities)."
    },
    {
      "name": "libcrypto.c:evp_cipher_aead_encrypt",
      "clean_name": "evp_cipher_aead_encrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n    return SSH_OK;\n}\n\nstatic void\nevp_cipher_aead_encrypt(struct ssh_cipher_struct *cipher,\n                        void *in,\n                        void *out,\n                        size_t len,\n                        uint8_t *tag,\n                        uint64_t seq)\n{\n    size_t authlen, aadlen;\n    uint8_t lastiv[1];\n    int tmplen = 0;\n    size_t outlen;\n    int rc;\n\n    (void) seq;\n\n    aadlen = cipher->lenfield_blocksize;\n    authlen = cipher->tag_size;\n\n    /* increment IV */\n    rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                             EVP_CTRL_GCM_IV_GEN,\n                             1,\n                             lastiv);\n    if (rc == 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_IV_GEN failed\");\n        return;\n    }\n\n    /* Pass over the authenticated data (not encrypted) */\n    rc = EVP_EncryptUpdate(cipher->ctx,\n                           NULL,\n                           &tmplen,\n                           (unsigned char *)in,\n                           (int)aadlen);\n    outlen = tmplen;\n    if (rc == 0 || outlen != aadlen) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to pass authenticated data\");\n        return;\n    }\n    memcpy(out, in, aadlen);\n\n    /* Encrypt the rest of the data */\n    rc = EVP_EncryptUpdate(cipher->ctx,\n                           (unsigned char *)out + aadlen,\n                           &tmplen,\n                           (unsigned char *)in + aadlen,\n                           (int)(len - aadlen));\n    outlen = tmplen;\n    if (rc != 1 || outlen != (int)len - aadlen) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptUpdate failed\");\n        return;\n    }\n\n    /* compute tag */\n    rc = EVP_EncryptFinal(cipher->ctx,\n                          NULL,\n                          &tmplen);\n    if (rc < 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptFinal failed: Failed to create a tag\");\n        return;\n    }\n\n    rc = EVP_CIPHER_CTX_ctrl(cipher->ctx,\n                             EVP_CTRL_GCM_GET_TAG,\n                             (int)authlen,\n                             (unsigned char *)tag);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CTRL_GCM_GET_TAG failed\");\n        return;\n    }\n}\n",
      "line_start": 591,
      "line_end": 662,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "AEAD encryption routine that operates on untrusted input, performs memory operations (memcpy, buffer writes), and handles security\u2011critical cryptographic operations and tag handling via OpenSSL APIs\u2014high value for fuzzing to find memory/API misuse or logic errors."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_aead_encrypt",
      "clean_name": "chacha20_poly1305_aead_encrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "out:\n    return ret;\n}\n\nstatic void\nchacha20_poly1305_aead_encrypt(struct ssh_cipher_struct *cipher,\n                               void *in,\n                               void *out,\n                               size_t len,\n                               uint8_t *tag,\n                               uint64_t seq)\n{\n    struct ssh_packet_header *in_packet = in, *out_packet = out;\n    struct chacha20_poly1305_keysched *ctx = cipher->chacha20_schedule;\n    size_t taglen = POLY1305_TAGLEN;\n    int ret, outlen = 0;\n\n    /* Prepare the Poly1305 key */\n    ret = chacha20_poly1305_packet_setup(cipher, seq, 1);\n    if (ret != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to setup packet\");\n        return;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"plaintext length\",\n                    (unsigned char *)&in_packet->length, sizeof(uint32_t));\n#endif /* DEBUG_CRYPTO */\n    /* step 2, encrypt length field */\n    ret = EVP_CipherUpdate(ctx->header_evp,\n                           (unsigned char *)&out_packet->length,\n                           &outlen,\n                           (unsigned char *)&in_packet->length,\n                           sizeof(uint32_t));\n    if (ret != 1 || outlen != sizeof(uint32_t)) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherUpdate failed\");\n        return;\n    }\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"encrypted length\",\n                    (unsigned char *)&out_packet->length, outlen);\n#endif /* DEBUG_CRYPTO */\n    ret = EVP_CipherFinal_ex(ctx->header_evp, (uint8_t *)out + outlen, &outlen);\n    if (ret != 1 || outlen != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptFinal_ex failed\");\n        return;\n    }\n\n    /* step 3, encrypt packet payload (main_evp counter == 1) */\n    /* We already did encrypt one block so the counter should be in the correct position */\n    ret = EVP_CipherUpdate(ctx->main_evp,\n                           out_packet->payload,\n                           &outlen,\n                           in_packet->payload,\n                           (int)(len - sizeof(uint32_t)));\n    if (ret != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherUpdate failed\");\n        return;\n    }\n\n    /* step 4, compute the MAC */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    ret = EVP_DigestSignUpdate(ctx->mctx, out_packet, len);\n    if (ret <= 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DigestSignUpdate failed\");\n        return;\n    }\n    ret = EVP_DigestSignFinal(ctx->mctx, tag, &taglen);\n    if (ret <= 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_DigestSignFinal failed\");\n        return;\n    }\n#else\n    ret = EVP_MAC_update(ctx->mctx, (void*)out_packet, len);\n    if (ret != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_update failed\");\n        return;\n    }\n\n    ret = EVP_MAC_final(ctx->mctx, tag, &taglen, POLY1305_TAGLEN);\n    if (ret != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_final failed\");\n        return;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 1109,
      "line_end": 1190,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "AEAD encryption routine operating on untrusted packet data and performing buffer/memory operations and MAC computation. It invokes OpenSSL EVP APIs, manipulates header+payload lengths, and is security-critical (cryptography) with multiple error paths \u2014 high-priority fuzz target."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_packet_setup",
      "clean_name": "chacha20_poly1305_packet_setup",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n    return SSH_OK;\n}\n\nstatic int\nchacha20_poly1305_packet_setup(struct ssh_cipher_struct *cipher,\n                               uint64_t seq,\n                               int do_encrypt)\n{\n    struct chacha20_poly1305_keysched *ctx = cipher->chacha20_schedule;\n    uint8_t poly_key[CHACHA20_BLOCKSIZE];\n    int ret = SSH_ERROR, len, rv;\n\n    /* The initialization for decrypt was already done with the length block */\n    if (do_encrypt) {\n        rv = chacha20_poly1305_set_iv(cipher, seq, do_encrypt);\n        if (rv != SSH_OK) {\n            return SSH_ERROR;\n        }\n    }\n\n    /* Output full ChaCha block so that counter increases by one for\n     * next step. */\n    rv = EVP_CipherUpdate(ctx->main_evp, poly_key, &len,\n                           (unsigned char *)zero_block, sizeof(zero_block));\n    if (rv != 1 || len != CHACHA20_BLOCKSIZE) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptUpdate failed\");\n        goto out;\n    }\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"poly_key\", poly_key, POLY1305_KEYLEN);\n#endif /* DEBUG_CRYPTO */\n\n    /* Set the Poly1305 key */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    if (ctx->key == NULL) {\n        /* Poly1305 Initialization needs to know the actual key */\n        ctx->key = EVP_PKEY_new_mac_key(EVP_PKEY_POLY1305, NULL,\n                                        poly_key, POLY1305_KEYLEN);\n        if (ctx->key == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"EVP_PKEY_new_mac_key failed\");\n            goto out;\n        }\n        rv = EVP_DigestSignInit(ctx->mctx, &ctx->pctx, NULL, NULL, ctx->key);\n        if (rv != 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"EVP_DigestSignInit failed\");\n            goto out;\n        }\n    } else {\n        /* Updating the key is easier but less obvious */\n        rv = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_SIGNCTX,\n                                EVP_PKEY_CTRL_SET_MAC_KEY,\n                                POLY1305_KEYLEN, (void *)poly_key);\n        if (rv <= 0) {\n            SSH_LOG(SSH_LOG_TRACE, \"EVP_PKEY_CTX_ctrl failed\");\n            goto out;\n        }\n    }\n#else\n    rv = EVP_MAC_init(ctx->mctx, poly_key, POLY1305_KEYLEN, NULL);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_init failed\");\n        goto out;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    ret = SSH_OK;\nout:\n    explicit_bzero(poly_key, sizeof(poly_key));\n    return ret;\n}\n",
      "line_start": 909,
      "line_end": 975,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Security-critical crypto setup for ChaCha20-Poly1305: it initializes IV, derives the Poly1305 key by encrypting data, and configures OpenSSL MAC contexts. It handles sensitive key material, performs memory operations on buffers, and has multiple branching code paths (version-dependent and ctx->key cases), making it a high-value fuzz target for finding misuse or API/edge-case bugs."
    },
    {
      "name": "ssh_bind_accept_fd",
      "clean_name": "ssh_bind_accept_fd",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "  }\n\n  SAFE_FREE(sshbind);\n}\n\nint ssh_bind_accept_fd(ssh_bind sshbind, ssh_session session, socket_t fd)\n{\n    ssh_poll_handle handle = NULL;\n    int i, rc;\n\n    if (sshbind == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (session == NULL){\n        ssh_set_error(sshbind, SSH_FATAL,\"session is null\");\n        return SSH_ERROR;\n    }\n\n    session->server = 1;\n\n    /* Copy options from bind to session */\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n      if (sshbind->wanted_methods[i]) {\n        session->opts.wanted_methods[i] = strdup(sshbind->wanted_methods[i]);\n        if (session->opts.wanted_methods[i] == NULL) {\n          return SSH_ERROR;\n        }\n      }\n    }\n\n    if (sshbind->bindaddr == NULL)\n      session->opts.bindaddr = NULL;\n    else {\n      SAFE_FREE(session->opts.bindaddr);\n      session->opts.bindaddr = strdup(sshbind->bindaddr);\n      if (session->opts.bindaddr == NULL) {\n        return SSH_ERROR;\n      }\n    }\n\n    if (sshbind->pubkey_accepted_key_types != NULL) {\n        if (session->opts.pubkey_accepted_types == NULL) {\n            session->opts.pubkey_accepted_types = strdup(sshbind->pubkey_accepted_key_types);\n            if (session->opts.pubkey_accepted_types == NULL) {\n                ssh_set_error_oom(sshbind);\n                return SSH_ERROR;\n            }\n        } else {\n            char *p = NULL;\n            /* If something was set to the session prior to calling this\n             * function, keep only what is allowed by the options set in\n             * sshbind */\n            p = ssh_find_all_matching(sshbind->pubkey_accepted_key_types,\n                                      session->opts.pubkey_accepted_types);\n            if (p == NULL) {\n                return SSH_ERROR;\n            }\n\n            SAFE_FREE(session->opts.pubkey_accepted_types);\n            session->opts.pubkey_accepted_types = p;\n        }\n    }\n\n    session->common.log_verbosity = sshbind->common.log_verbosity;\n\n    if (sshbind->banner != NULL) {\n        session->server_opts.custombanner = strdup(sshbind->banner);\n        if (session->server_opts.custombanner == NULL) {\n            ssh_set_error_oom(sshbind);\n            return SSH_ERROR;\n        }\n    }\n\n    if (sshbind->moduli_file != NULL) {\n        session->server_opts.moduli_file = strdup(sshbind->moduli_file);\n        if (session->server_opts.moduli_file == NULL) {\n            ssh_set_error_oom(sshbind);\n            return SSH_ERROR;\n        }\n    }\n\n    session->opts.rsa_min_size = sshbind->rsa_min_size;\n\n    ssh_socket_free(session->socket);\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n      /* perhaps it may be better to copy the error from session to sshbind */\n      ssh_set_error_oom(sshbind);\n      return SSH_ERROR;\n    }\n    rc = ssh_socket_set_fd(session->socket, fd);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n    handle = ssh_socket_get_poll_handle(session->socket);\n    if (handle == NULL) {\n        ssh_set_error_oom(sshbind);\n        return SSH_ERROR;\n    }\n    ssh_socket_set_connected(session->socket, handle);\n\n    /* We must try to import any keys that could be imported in case\n     * we are not using ssh_bind_listen (which is the other place\n     * where keys can be imported) on this ssh_bind and are instead\n     * only using ssh_bind_accept_fd to manage sockets ourselves.\n     */\n    if (sshbind->rsa == NULL &&\n        sshbind->ecdsa == NULL &&\n        sshbind->ed25519 == NULL) {\n        rc = ssh_bind_import_keys(sshbind);\n        if (rc != SSH_OK) {\n            return SSH_ERROR;\n        }\n    }\n\n#ifdef HAVE_ECC\n    if (sshbind->ecdsa) {\n        session->srv.ecdsa_key = ssh_key_dup(sshbind->ecdsa);\n        if (session->srv.ecdsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n#endif\n    if (sshbind->rsa) {\n        session->srv.rsa_key = ssh_key_dup(sshbind->rsa);\n        if (session->srv.rsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    if (sshbind->ed25519 != NULL) {\n        session->srv.ed25519_key = ssh_key_dup(sshbind->ed25519);\n        if (session->srv.ed25519_key == NULL){\n            ssh_set_error_oom(sshbind);\n            return SSH_ERROR;\n        }\n    }\n\n    /* force PRNG to change state in case we fork after ssh_bind_accept */\n    ssh_reseed();\n    return SSH_OK;\n}\n",
      "line_start": 421,
      "line_end": 560,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 232,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "High-value fuzz target: security-critical accept path that manipulates cryptographic keys and server options, duplicates and allocates many strings, loops over method lists, sets a socket fd, and may call ssh_bind_import_keys (which parses key material). Contains multiple allocation/error branches and NULL checks \u2014 good surface for crashes/memory issues and potential logic bugs. Not directly parsing network protocol bytes here, but the crypto/key handling and memory ops make it critical to fuzz."
    },
    {
      "name": "bind.c:ssh_bind_import_keys",
      "clean_name": "ssh_bind_import_keys",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "    ptr->common.log_verbosity = 0;\n\n    return ptr;\n}\n\nstatic int ssh_bind_import_keys(ssh_bind sshbind) {\n  int rc;\n\n#ifdef HAVE_ECC\n  if (sshbind->ecdsa == NULL && sshbind->ecdsakey != NULL) {\n      rc = ssh_pki_import_privkey_file(sshbind->ecdsakey,\n                                       NULL,\n                                       NULL,\n                                       NULL,\n                                       &sshbind->ecdsa);\n      if (rc == SSH_ERROR || rc == SSH_EOF) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"Failed to import private ECDSA host key\");\n          return SSH_ERROR;\n      }\n\n      if (!is_ecdsa_key_type(ssh_key_type(sshbind->ecdsa))) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"The ECDSA host key has the wrong type\");\n          ssh_key_free(sshbind->ecdsa);\n          sshbind->ecdsa = NULL;\n          return SSH_ERROR;\n      }\n  }\n#endif\n\n  if (sshbind->rsa == NULL && sshbind->rsakey != NULL) {\n      rc = ssh_pki_import_privkey_file(sshbind->rsakey,\n                                       NULL,\n                                       NULL,\n                                       NULL,\n                                       &sshbind->rsa);\n      if (rc == SSH_ERROR || rc == SSH_EOF) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"Failed to import private RSA host key\");\n          return SSH_ERROR;\n      }\n\n      if (ssh_key_type(sshbind->rsa) != SSH_KEYTYPE_RSA) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"The RSA host key has the wrong type\");\n          ssh_key_free(sshbind->rsa);\n          sshbind->rsa = NULL;\n          return SSH_ERROR;\n      }\n  }\n\n  if (sshbind->ed25519 == NULL && sshbind->ed25519key != NULL) {\n      rc = ssh_pki_import_privkey_file(sshbind->ed25519key,\n                                       NULL,\n                                       NULL,\n                                       NULL,\n                                       &sshbind->ed25519);\n      if (rc == SSH_ERROR || rc == SSH_EOF) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"Failed to import private ED25519 host key\");\n          return SSH_ERROR;\n      }\n\n      if (ssh_key_type(sshbind->ed25519) != SSH_KEYTYPE_ED25519) {\n          ssh_set_error(sshbind, SSH_FATAL,\n                  \"The ED25519 host key has the wrong type\");\n          ssh_key_free(sshbind->ed25519);\n          sshbind->ed25519 = NULL;\n          return SSH_ERROR;\n      }\n  }\n\n  return SSH_OK;\n}\n",
      "line_start": 149,
      "line_end": 219,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 131,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Imports private host keys (cryptographic material) and drives parsing/validation of external key files via ssh_pki_import_privkey_file, with branching/error-handling per key type. Although it does not do raw buffer manipulation itself, it triggers complex input parsing and handles security-critical operations, making it a high-value fuzz target."
    },
    {
      "name": "ssh_userauth_try_publickey",
      "clean_name": "ssh_userauth_try_publickey",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @note Most server implementations do not permit changing the username during\n * authentication. The username should only be set with ssh_options_set() only\n * before you connect to the server.\n */\nint ssh_userauth_try_publickey(ssh_session session,\n                               const char *username,\n                               const ssh_key pubkey)\n{\n    ssh_string pubkey_s = NULL;\n    const char *sig_type_c = NULL;\n    bool allowed;\n    int rc;\n\n    if (session == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n\n    if (pubkey == NULL || !ssh_key_is_public(pubkey)) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid pubkey\");\n        return SSH_AUTH_ERROR;\n    }\n\n    switch (session->pending_call_state) {\n    case SSH_PENDING_CALL_NONE:\n        break;\n    case SSH_PENDING_CALL_AUTH_OFFER_PUBKEY:\n        goto pending;\n    default:\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Wrong state (%d) during pending SSH call\",\n                      session->pending_call_state);\n        return SSH_AUTH_ERROR;\n    }\n\n    /* Note, that this is intentionally before checking the signature type\n     * compatibility to make sure the possible EXT_INFO packet is processed,\n     * extensions recorded and the right signature type is used below\n     */\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* Check if the given public key algorithm is allowed */\n    sig_type_c = ssh_key_get_signature_algorithm(session, pubkey->type);\n    if (sig_type_c == NULL) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Invalid key type (unknown)\");\n        return SSH_AUTH_DENIED;\n    }\n    rc = ssh_key_algorithm_allowed(session, sig_type_c);\n    if (!rc) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The key algorithm '%s' is not allowed to be used by\"\n                      \" PUBLICKEY_ACCEPTED_TYPES configuration option\",\n                      sig_type_c);\n        return SSH_AUTH_DENIED;\n    }\n    allowed = ssh_key_size_allowed(session, pubkey);\n    if (!allowed) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The '%s' key type of size %d is not allowed by \"\n                      \"RSA_MIN_SIZE\",\n                      sig_type_c,\n                      ssh_key_size(pubkey));\n        return SSH_AUTH_DENIED;\n    }\n\n    /* public key */\n    rc = ssh_pki_export_pubkey_blob(pubkey, &pubkey_s);\n    if (rc < 0) {\n        goto fail;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"Trying signature type %s\", sig_type_c);\n    rc = build_pubkey_auth_request(session, username, 0, sig_type_c, pubkey_s);\n    if (rc < 0) {\n        goto fail;\n    }\n    SSH_STRING_FREE(pubkey_s);\n\n    session->auth.current_method = SSH_AUTH_METHOD_PUBLICKEY;\n    session->auth.state = SSH_AUTH_STATE_PUBKEY_OFFER_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_OFFER_PUBKEY;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n\n    return rc;\nfail:\n    SSH_STRING_FREE(pubkey_s);\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 595,
      "line_end": 700,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 123,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Security-critical authentication path that processes untrusted public keys and username, exports key blobs and builds/sends packets (buffer/memory ops), and has multiple branches and state-dependent logic \u2014 high value for fuzzing."
    },
    {
      "name": "ssh_userauth_publickey",
      "clean_name": "ssh_userauth_publickey",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @note Most server implementations do not permit changing the username during\n * authentication. The username should only be set with ssh_options_set() only\n * before you connect to the server.\n */\nint ssh_userauth_publickey(ssh_session session,\n                           const char *username,\n                           const ssh_key privkey)\n{\n    ssh_string str = NULL;\n    bool allowed;\n    int rc;\n    const char *sig_type_c = NULL;\n    enum ssh_keytypes_e key_type;\n    enum ssh_digest_e hash_type;\n\n    if (session == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n\n    if (privkey == NULL || !ssh_key_is_private(privkey)) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid private key\");\n        return SSH_AUTH_ERROR;\n    }\n\n    switch (session->pending_call_state) {\n    case SSH_PENDING_CALL_NONE:\n        break;\n    case SSH_PENDING_CALL_AUTH_PUBKEY:\n        goto pending;\n    default:\n        ssh_set_error(\n            session,\n            SSH_FATAL,\n            \"Bad call during pending SSH call in ssh_userauth_try_publickey\");\n        return SSH_AUTH_ERROR;\n    }\n\n    /* Note, that this is intentionally before checking the signature type\n     * compatibility to make sure the possible EXT_INFO packet is processed,\n     * extensions recorded and the right signature type is used below\n     */\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* Cert auth requires presenting the cert type name (*-cert@openssh.com) */\n    key_type = privkey->cert != NULL ? privkey->cert_type : privkey->type;\n\n    /* Check if the given public key algorithm is allowed */\n    sig_type_c = ssh_key_get_signature_algorithm(session, key_type);\n    if (sig_type_c == NULL) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Invalid key type (unknown)\");\n        return SSH_AUTH_DENIED;\n    }\n    rc = ssh_key_algorithm_allowed(session, sig_type_c);\n    if (!rc) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The key algorithm '%s' is not allowed to be used by\"\n                      \" PUBLICKEY_ACCEPTED_TYPES configuration option\",\n                      sig_type_c);\n        return SSH_AUTH_DENIED;\n    }\n    allowed = ssh_key_size_allowed(session, privkey);\n    if (!allowed) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The '%s' key type of size %d is not allowed by \"\n                      \"RSA_MIN_SIZE\",\n                      sig_type_c,\n                      ssh_key_size(privkey));\n        return SSH_AUTH_DENIED;\n    }\n\n    /* get public key or cert */\n    rc = ssh_pki_export_pubkey_blob(privkey, &str);\n    if (rc < 0) {\n        goto fail;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"Sending signature type %s\", sig_type_c);\n    rc = build_pubkey_auth_request(session, username, 1, sig_type_c, str);\n    if (rc < 0) {\n        goto fail;\n    }\n    SSH_STRING_FREE(str);\n\n    /* Get the hash type to be used in the signature based on the key type */\n    hash_type = ssh_key_type_to_hash(session, privkey->type);\n\n    /* sign the buffer with the private key */\n    str = ssh_pki_do_sign(session, session->out_buffer, privkey, hash_type);\n    if (str == NULL) {\n        goto fail;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, str);\n    SSH_STRING_FREE(str);\n    str = NULL;\n    if (rc < 0) {\n        goto fail;\n    }\n\n    session->auth.current_method = SSH_AUTH_METHOD_PUBLICKEY;\n    session->auth.state = SSH_AUTH_STATE_PUBKEY_AUTH_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_PUBKEY;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n\n    return rc;\nfail:\n    SSH_STRING_FREE(str);\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 724,
      "line_end": 850,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 152,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Handles authentication and cryptography (key export, signing, signature algorithm selection), builds/sends protocol packets and processes responses, and has multiple input-dependent branches/state transitions. It exercises parsing/serialization and memory operations via key/blob handling, making it a high-value fuzz target for finding security-critical bugs."
    },
    {
      "name": "ssh_userauth_publickey_auto",
      "clean_name": "ssh_userauth_publickey_auto",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * before you connect to the server.\n *\n * The OpenSSH iterates over the identities and first try the plain public key\n * and then the certificate if it is in place.\n */\nint ssh_userauth_publickey_auto(ssh_session session,\n                                const char *username,\n                                const char *passphrase)\n{\n    ssh_auth_callback auth_fn = NULL;\n    void *auth_data = NULL;\n    struct ssh_auth_auto_state_struct *state = NULL;\n    int rc;\n\n    if (session == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n    if (! (session->opts.flags & SSH_OPT_FLAG_PUBKEY_AUTH)) {\n        session->auth.supported_methods &= ~SSH_AUTH_METHOD_PUBLICKEY;\n        return SSH_AUTH_DENIED;\n    }\n    if (session->common.callbacks) {\n        auth_fn = session->common.callbacks->auth_function;\n        auth_data = session->common.callbacks->userdata;\n    }\n    if (!session->auth.auto_state) {\n        session->auth.auto_state =\n                calloc(1, sizeof(struct ssh_auth_auto_state_struct));\n        if (!session->auth.auto_state) {\n            ssh_set_error_oom(session);\n            return SSH_AUTH_ERROR;\n        }\n\n        /* Set state explicitly */\n        session->auth.auto_state->state = SSH_AUTH_AUTO_STATE_NONE;\n    }\n    state = session->auth.auto_state;\n    if (state->state == SSH_AUTH_AUTO_STATE_NONE) {\n        /* Try authentication with ssh-agent first */\n        rc = ssh_userauth_agent(session, username);\n        if (rc == SSH_AUTH_SUCCESS ||\n            rc == SSH_AUTH_PARTIAL ||\n            rc == SSH_AUTH_AGAIN) {\n            return rc;\n        }\n        state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n    }\n    if (state->it == NULL) {\n        state->it = ssh_list_get_iterator(session->opts.identity);\n    }\n\n    while (state->it != NULL) {\n        const char *privkey_file = state->it->data;\n        char pubkey_file[PATH_MAX] = {0};\n\n        if (state->state == SSH_AUTH_AUTO_STATE_PUBKEY) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Trying to authenticate with %s\",\n                    privkey_file);\n            state->cert = NULL;\n            state->privkey = NULL;\n            state->pubkey = NULL;\n\n#ifdef WITH_PKCS11_URI\n            if (ssh_pki_is_uri(privkey_file)) {\n                char *pub_uri_from_priv = NULL;\n                SSH_LOG(SSH_LOG_INFO,\n                        \"Authenticating with PKCS #11 URI.\");\n                pub_uri_from_priv = ssh_pki_export_pub_uri_from_priv_uri(privkey_file);\n                if (pub_uri_from_priv == NULL) {\n                    return SSH_ERROR;\n                } else {\n                    snprintf(pubkey_file,\n                             sizeof(pubkey_file),\n                             \"%s\",\n                             pub_uri_from_priv);\n                    SAFE_FREE(pub_uri_from_priv);\n                }\n            } else\n#endif /* WITH_PKCS11_URI */\n            {\n                snprintf(pubkey_file,\n                         sizeof(pubkey_file),\n                         \"%s.pub\",\n                         privkey_file);\n            }\n\n            rc = ssh_pki_import_pubkey_file(pubkey_file, &state->pubkey);\n            if (rc == SSH_ERROR) {\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Failed to import public key: %s\",\n                              pubkey_file);\n                SAFE_FREE(session->auth.auto_state);\n                return SSH_AUTH_ERROR;\n            } else if (rc == SSH_EOF) {\n                /* Read the private key and save the public key to file */\n                rc = ssh_pki_import_privkey_file(privkey_file,\n                                                 passphrase,\n                                                 auth_fn,\n                                                 auth_data,\n                                                 &state->privkey);\n                if (rc == SSH_ERROR) {\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"Failed to read private key: %s\",\n                                  privkey_file);\n                    state->it = state->it->next;\n                    continue;\n                } else if (rc == SSH_EOF) {\n                    /* If the file doesn't exist, continue */\n                    SSH_LOG(SSH_LOG_DEBUG,\n                            \"Private key %s doesn't exist.\",\n                            privkey_file);\n                    state->it = state->it->next;\n                    continue;\n                }\n\n                rc = ssh_pki_export_privkey_to_pubkey(state->privkey,\n                                                      &state->pubkey);\n                if (rc == SSH_ERROR) {\n                    SSH_KEY_FREE(state->privkey);\n                    SAFE_FREE(session->auth.auto_state);\n                    return SSH_AUTH_ERROR;\n                }\n\n                rc = ssh_pki_export_pubkey_file(state->pubkey, pubkey_file);\n                if (rc == SSH_ERROR) {\n                    SSH_LOG(SSH_LOG_TRACE,\n                            \"Could not write public key to file: %s\",\n                            pubkey_file);\n                }\n            }\n            state->state = SSH_AUTH_AUTO_STATE_KEY_IMPORTED;\n        }\n        if (state->state == SSH_AUTH_AUTO_STATE_KEY_IMPORTED ||\n            state->state == SSH_AUTH_AUTO_STATE_CERTIFICATE_FILE ||\n            state->state == SSH_AUTH_AUTO_STATE_CERTIFICATE_OPTION) {\n            ssh_key k = state->pubkey;\n            if (state->state != SSH_AUTH_AUTO_STATE_KEY_IMPORTED) {\n                k = state->cert;\n            }\n            rc = ssh_userauth_try_publickey(session, username, k);\n            if (rc == SSH_AUTH_ERROR) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Public key authentication error for %s\",\n                        privkey_file);\n                SSH_KEY_FREE(state->cert);\n                SSH_KEY_FREE(state->privkey);\n                SSH_KEY_FREE(state->pubkey);\n                SAFE_FREE(session->auth.auto_state);\n                return rc;\n            } else if (rc == SSH_AUTH_AGAIN) {\n                return rc;\n            } else if (rc != SSH_AUTH_SUCCESS) {\n                int r; /* do not reuse `rc` as it is used to return from here */\n                SSH_KEY_FREE(state->cert);\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"Public key for %s%s refused by server\",\n                        privkey_file,\n                        (state->state != SSH_AUTH_AUTO_STATE_KEY_IMPORTED\n                            ? \" (with certificate)\" : \"\"));\n                /* Try certificate file by appending -cert.pub (if present) */\n                if (state->state == SSH_AUTH_AUTO_STATE_KEY_IMPORTED) {\n                    char cert_file[PATH_MAX] = {0};\n                    ssh_key cert = NULL;\n\n                    snprintf(cert_file,\n                             sizeof(cert_file),\n                             \"%s-cert.pub\",\n                             privkey_file);\n                    SSH_LOG(SSH_LOG_TRACE,\n                            \"Trying to load the certificate %s (default path)\",\n                            cert_file);\n                    r = ssh_pki_import_cert_file(cert_file, &cert);\n                    if (r == SSH_OK) {\n                        /* TODO check the pubkey and certs match */\n                        SSH_LOG(SSH_LOG_TRACE,\n                                \"Certificate loaded %s. Retry the authentication.\",\n                                cert_file);\n                        state->state = SSH_AUTH_AUTO_STATE_CERTIFICATE_FILE;\n                        SSH_KEY_FREE(state->cert);\n                        state->cert = cert;\n                        /* try to authenticate with this certificate */\n                        continue;\n                    }\n                    /* if the file does not exists, try configuration options */\n                    state->state = SSH_AUTH_AUTO_STATE_CERTIFICATE_OPTION;\n                }\n                /* Try certificate files loaded through options */\n                if (state->state == SSH_AUTH_AUTO_STATE_CERTIFICATE_OPTION) {\n                    SSH_KEY_FREE(state->cert);\n                    if (state->cert_it == NULL) {\n                        state->cert_it = ssh_list_get_iterator(session->opts.certificate);\n                    }\n                    while (state->cert_it != NULL) {\n                        const char *cert_file = state->cert_it->data;\n                        ssh_key cert = NULL;\n\n                        SSH_LOG(SSH_LOG_TRACE,\n                                \"Trying to load the certificate %s (options)\",\n                                cert_file);\n                        r = ssh_pki_import_cert_file(cert_file, &cert);\n                        if (r == SSH_OK) {\n                            int cmp = ssh_key_cmp(cert,\n                                                  state->pubkey,\n                                                  SSH_KEY_CMP_PUBLIC);\n                            if (cmp != 0) {\n                                state->cert_it = state->cert_it->next;\n                                SSH_KEY_FREE(cert);\n                                continue; /* with next cert */\n                            }\n                            SSH_LOG(SSH_LOG_TRACE,\n                                    \"Found matching certificate %s in options. Retry the authentication.\",\n                                    cert_file);\n                            state->cert = cert;\n                            cert = NULL;\n                            state->state = SSH_AUTH_AUTO_STATE_CERTIFICATE_OPTION;\n                            /* try to authenticate with this identity */\n                            break; /* try this cert */\n                        }\n                        /* continue with next identity */\n                    }\n                    if (state->cert != NULL) {\n                        continue; /* retry with the certificate */\n                    }\n                }\n                SSH_KEY_FREE(state->cert);\n                SSH_KEY_FREE(state->privkey);\n                SSH_KEY_FREE(state->pubkey);\n                state->it = state->it->next;\n                state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n                continue;\n            }\n            state->state = SSH_AUTH_AUTO_STATE_PUBKEY_ACCEPTED;\n        }\n        if (state->state == SSH_AUTH_AUTO_STATE_PUBKEY_ACCEPTED) {\n            /* Public key has been accepted by the server */\n            if (state->privkey == NULL) {\n                rc = ssh_pki_import_privkey_file(privkey_file,\n                                                 passphrase,\n                                                 auth_fn,\n                                                 auth_data,\n                                                 &state->privkey);\n                if (rc == SSH_ERROR) {\n                    SSH_KEY_FREE(state->cert);\n                    SSH_KEY_FREE(state->pubkey);\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"Failed to read private key: %s\",\n                                  privkey_file);\n                    state->it = state->it->next;\n                    state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n                    continue;\n                } else if (rc == SSH_EOF) {\n                    /* If the file doesn't exist, continue */\n                    SSH_KEY_FREE(state->cert);\n                    SSH_KEY_FREE(state->pubkey);\n                    SSH_LOG(SSH_LOG_DEBUG,\n                            \"Private key %s doesn't exist.\",\n                            privkey_file);\n                    state->it = state->it->next;\n                    state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n                    continue;\n                }\n            }\n            if (state->cert != NULL && !is_cert_type(state->privkey->cert_type)) {\n                rc = ssh_pki_copy_cert_to_privkey(state->cert, state->privkey);\n                if (rc != SSH_OK) {\n                    SSH_KEY_FREE(state->cert);\n                    SSH_KEY_FREE(state->privkey);\n                    SSH_KEY_FREE(state->pubkey);\n                    ssh_set_error(session,\n                                  SSH_FATAL,\n                                  \"Failed to copy cert to private key\");\n                    state->it = state->it->next;\n                    state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n                    continue;\n                }\n            }\n\n            rc = ssh_userauth_publickey(session, username, state->privkey);\n            if (rc != SSH_AUTH_AGAIN && rc != SSH_AUTH_DENIED) {\n                bool cert_used = (state->cert != NULL);\n                SSH_KEY_FREE(state->cert);\n                SSH_KEY_FREE(state->privkey);\n                SSH_KEY_FREE(state->pubkey);\n                SAFE_FREE(session->auth.auto_state);\n                if (rc == SSH_AUTH_SUCCESS) {\n                    SSH_LOG(SSH_LOG_DEBUG,\n                            \"Successfully authenticated using %s%s\",\n                            privkey_file,\n                            (cert_used ? \" and certificate\" : \"\"));\n                }\n                return rc;\n            }\n            if (rc == SSH_AUTH_AGAIN) {\n                return rc;\n            }\n\n            SSH_KEY_FREE(state->cert);\n            SSH_KEY_FREE(state->privkey);\n            SSH_KEY_FREE(state->pubkey);\n\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"The server accepted the public key but refused the signature\");\n            state->it = state->it->next;\n            state->state = SSH_AUTH_AUTO_STATE_PUBKEY;\n            /* continue */\n        }\n    }\n    SSH_LOG(SSH_LOG_WARN,\n            \"Access denied: Tried every public key, none matched\");\n    SAFE_FREE(session->auth.auto_state);\n    return SSH_AUTH_DENIED;\n}\n",
      "line_start": 1372,
      "line_end": 1683,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 542,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Handles security-critical public-key authentication: iterates user-controlled identity lists, builds file paths, reads/parses public/private key and certificate files (and PKCS#11 URIs), and performs cryptographic key operations. It has a state machine with many branches and input-dependent loops and delegates to key import/export/parsing routines that operate on untrusted data \u2014 high-value fuzz target."
    },
    {
      "name": "auth.c:ssh_userauth_agent_publickey",
      "clean_name": "ssh_userauth_agent_publickey",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n\nstatic int ssh_userauth_agent_publickey(ssh_session session,\n                                        const char *username,\n                                        ssh_key pubkey)\n{\n    ssh_string pubkey_s = NULL;\n    ssh_string sig_blob = NULL;\n    const char *sig_type_c = NULL;\n    bool allowed;\n    int rc;\n\n    switch (session->pending_call_state) {\n    case SSH_PENDING_CALL_NONE:\n        break;\n    case SSH_PENDING_CALL_AUTH_AGENT:\n        goto pending;\n    default:\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Bad call during pending SSH call in %s\",\n                      __func__);\n        return SSH_ERROR;\n    }\n\n    /* Note, that this is intentionally before checking the signature type\n     * compatibility to make sure the possible EXT_INFO packet is processed,\n     * extensions recorded and the right signature type is used below\n     */\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* public key */\n    rc = ssh_pki_export_pubkey_blob(pubkey, &pubkey_s);\n    if (rc < 0) {\n        goto fail;\n    }\n\n    /* Check if the given public key algorithm is allowed */\n    sig_type_c = ssh_key_get_signature_algorithm(session, pubkey->type);\n    if (sig_type_c == NULL) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Invalid key type (unknown)\");\n        SSH_STRING_FREE(pubkey_s);\n        return SSH_AUTH_DENIED;\n    }\n    rc = ssh_key_algorithm_allowed(session, sig_type_c);\n    if (!rc) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The key algorithm '%s' is not allowed to be used by\"\n                      \" PUBLICKEY_ACCEPTED_TYPES configuration option\",\n                      sig_type_c);\n        SSH_STRING_FREE(pubkey_s);\n        return SSH_AUTH_DENIED;\n    }\n    allowed = ssh_key_size_allowed(session, pubkey);\n    if (!allowed) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"The '%s' key type of size %d is not allowed by \"\n                      \"RSA_MIN_SIZE\",\n                      sig_type_c,\n                      ssh_key_size(pubkey));\n        SSH_STRING_FREE(pubkey_s);\n        return SSH_AUTH_DENIED;\n    }\n\n    rc = build_pubkey_auth_request(session, username, 1, sig_type_c, pubkey_s);\n    if (rc < 0) {\n        goto fail;\n    }\n    SSH_STRING_FREE(pubkey_s);\n\n    /* sign the buffer with the private key */\n    sig_blob = ssh_pki_do_sign_agent(session, session->out_buffer, pubkey);\n    if (sig_blob == NULL) {\n        goto fail;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    if (rc < 0) {\n        goto fail;\n    }\n\n    session->auth.current_method = SSH_AUTH_METHOD_PUBLICKEY;\n    session->auth.state = SSH_AUTH_STATE_PUBKEY_AUTH_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_AGENT;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n\n    return rc;\nfail:\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n    SSH_STRING_FREE(pubkey_s);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 851,
      "line_end": 962,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 149,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Security\u2011critical SSH publickey auth path: exports/validates public key blobs, checks algorithms/sizes, invokes agent signing, builds/sends buffers and updates session state. Involves cryptography, buffer operations and multiple conditional codepaths \u2014 high value for fuzzing (though some heavy parsing may occur in called routines)."
    },
    {
      "name": "ssh_buffer_unpack_va",
      "clean_name": "ssh_buffer_unpack_va",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @param[in] ap        A va_list of arguments.\n * @returns             SSH_OK on success\n *                      SSH_ERROR on error\n * @see ssh_buffer_get_format() for format list values.\n */\nint ssh_buffer_unpack_va(struct ssh_buffer_struct *buffer,\n                         const char *format,\n                         size_t argc,\n                         va_list ap)\n{\n    int rc = SSH_ERROR;\n    const char *p = format, *last = NULL;\n    union {\n        uint8_t *byte;\n        uint16_t *word;\n        uint32_t *dword;\n        uint64_t *qword;\n        ssh_string *string;\n        char **cstring;\n        bignum *bignum;\n        void **data;\n    } o;\n    size_t len;\n    uint32_t rlen, max_len;\n    ssh_string tmp_string = NULL;\n    va_list ap_copy;\n    size_t count;\n\n    max_len = ssh_buffer_get_len(buffer);\n\n    /* copy the argument list in case a rollback is needed */\n    va_copy(ap_copy, ap);\n\n    if (argc > 256) {\n        rc = SSH_ERROR;\n        goto cleanup;\n    }\n\n    for (count = 0; *p != '\\0'; p++, count++) {\n        /* Invalid number of arguments passed */\n        if (count > argc) {\n            rc = SSH_ERROR;\n            goto cleanup;\n        }\n\n        rc = SSH_ERROR;\n        switch (*p) {\n        case 'b':\n            o.byte = va_arg(ap, uint8_t *);\n            rlen = ssh_buffer_get_u8(buffer, o.byte);\n            rc = rlen==1 ? SSH_OK : SSH_ERROR;\n            break;\n        case 'w':\n            o.word = va_arg(ap,  uint16_t *);\n            rlen = ssh_buffer_get_data(buffer, o.word, sizeof(uint16_t));\n            if (rlen == 2) {\n                *o.word = ntohs(*o.word);\n                rc = SSH_OK;\n            }\n            break;\n        case 'd':\n            o.dword = va_arg(ap, uint32_t *);\n            rlen = ssh_buffer_get_u32(buffer, o.dword);\n            if (rlen == 4) {\n                *o.dword = ntohl(*o.dword);\n                rc = SSH_OK;\n            }\n            break;\n        case 'q':\n            o.qword = va_arg(ap, uint64_t*);\n            rlen = ssh_buffer_get_u64(buffer, o.qword);\n            if (rlen == 8) {\n                *o.qword = ntohll(*o.qword);\n                rc = SSH_OK;\n            }\n            break;\n        case 'B':\n            o.bignum = va_arg(ap, bignum *);\n            *o.bignum = NULL;\n            tmp_string = ssh_buffer_get_ssh_string(buffer);\n            if (tmp_string == NULL) {\n                break;\n            }\n            *o.bignum = ssh_make_string_bn(tmp_string);\n            ssh_string_burn(tmp_string);\n            SSH_STRING_FREE(tmp_string);\n            rc = (*o.bignum != NULL) ? SSH_OK : SSH_ERROR;\n            break;\n        case 'S':\n            o.string = va_arg(ap, ssh_string *);\n            *o.string = ssh_buffer_get_ssh_string(buffer);\n            rc = *o.string != NULL ? SSH_OK : SSH_ERROR;\n            o.string = NULL;\n            break;\n        case 's': {\n            uint32_t u32len = 0;\n\n            o.cstring = va_arg(ap, char **);\n            *o.cstring = NULL;\n            rlen = ssh_buffer_get_u32(buffer, &u32len);\n            if (rlen != 4){\n                break;\n            }\n            u32len = ntohl(u32len);\n            if (u32len > max_len - 1) {\n                break;\n            }\n\n            rc = ssh_buffer_validate_length(buffer, u32len);\n            if (rc != SSH_OK) {\n                break;\n            }\n\n            *o.cstring = malloc(u32len + 1);\n            if (*o.cstring == NULL){\n                rc = SSH_ERROR;\n                break;\n            }\n            rlen = ssh_buffer_get_data(buffer, *o.cstring, u32len);\n            if (rlen != u32len) {\n                SAFE_FREE(*o.cstring);\n                rc = SSH_ERROR;\n                break;\n            }\n            (*o.cstring)[u32len] = '\\0';\n            o.cstring = NULL;\n            rc = SSH_OK;\n            break;\n        }\n        case 'P':\n            len = va_arg(ap, size_t);\n            if (len > max_len - 1) {\n                rc = SSH_ERROR;\n                break;\n            }\n\n            rc = ssh_buffer_validate_length(buffer, len);\n            if (rc != SSH_OK) {\n                break;\n            }\n\n            o.data = va_arg(ap, void **);\n            count++;\n\n            *o.data = malloc(len);\n            if(*o.data == NULL){\n                rc = SSH_ERROR;\n                break;\n            }\n            rlen = ssh_buffer_get_data(buffer, *o.data, (uint32_t)len);\n            if (rlen != len){\n                SAFE_FREE(*o.data);\n                rc = SSH_ERROR;\n                break;\n            }\n            o.data = NULL;\n            rc = SSH_OK;\n            break;\n        default:\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid buffer format %c\", *p);\n        }\n        if (rc != SSH_OK) {\n            break;\n        }\n    }\n\n    if (argc != count) {\n        rc = SSH_ERROR;\n    }\n\ncleanup:\n    if (rc != SSH_ERROR){\n        /* Check if our canary is intact, if not something really bad happened */\n        uint32_t canary = va_arg(ap, uint32_t);\n        if (canary != SSH_BUFFER_PACK_END){\n            abort();\n        }\n    }\n\n    if (rc != SSH_OK){\n        /* Reset the format string and erase everything that was allocated */\n        last = p;\n        for(p=format;p<last;++p){\n            switch(*p){\n            case 'b':\n                o.byte = va_arg(ap_copy, uint8_t *);\n                if (buffer->secure) {\n                    explicit_bzero(o.byte, sizeof(uint8_t));\n                    break;\n                }\n                break;\n            case 'w':\n                o.word = va_arg(ap_copy, uint16_t *);\n                if (buffer->secure) {\n                    explicit_bzero(o.word, sizeof(uint16_t));\n                    break;\n                }\n                break;\n            case 'd':\n                o.dword = va_arg(ap_copy, uint32_t *);\n                if (buffer->secure) {\n                    explicit_bzero(o.dword, sizeof(uint32_t));\n                    break;\n                }\n                break;\n            case 'q':\n                o.qword = va_arg(ap_copy, uint64_t *);\n                if (buffer->secure) {\n                    explicit_bzero(o.qword, sizeof(uint64_t));\n                    break;\n                }\n                break;\n            case 'B':\n                o.bignum = va_arg(ap_copy, bignum *);\n                bignum_safe_free(*o.bignum);\n                break;\n            case 'S':\n                o.string = va_arg(ap_copy, ssh_string *);\n                if (buffer->secure) {\n                    ssh_string_burn(*o.string);\n                }\n                SAFE_FREE(*o.string);\n                break;\n            case 's':\n                o.cstring = va_arg(ap_copy, char **);\n                if (buffer->secure) {\n                    explicit_bzero(*o.cstring, strlen(*o.cstring));\n                }\n                SAFE_FREE(*o.cstring);\n                break;\n            case 'P':\n                len = va_arg(ap_copy, size_t);\n                o.data = va_arg(ap_copy, void **);\n                if (buffer->secure) {\n                    explicit_bzero(*o.data, len);\n                }\n                SAFE_FREE(*o.data);\n                break;\n            default:\n                (void)va_arg(ap_copy, void *);\n                break;\n            }\n        }\n    }\n    va_end(ap_copy);\n\n    return rc;\n}\n",
      "line_start": 1125,
      "line_end": 1368,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 339,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Unpacks serialized SSH data according to a format string, performing many memory operations (malloc, data copies, ntoh conversions), handling variable-length inputs, bignums and strings, and complex branching controlled by external input \u2014 high attack surface and good fuzz target for discovering memory/logic bugs."
    },
    {
      "name": "channel_rcv_data",
      "clean_name": "channel_rcv_data",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "\n    return SSH_PACKET_USED;\n}\n\n/* is_stderr is set to 1 if the data are extended, ie stderr */\nSSH_PACKET_CALLBACK(channel_rcv_data)\n{\n    ssh_channel channel = NULL;\n    ssh_string str = NULL;\n    ssh_buffer buf = NULL;\n    void *data = NULL;\n    uint32_t len;\n    int extended, is_stderr = 0;\n    int rest;\n\n    (void)user;\n\n    if (type == SSH2_MSG_CHANNEL_DATA) {\n        extended = 0;\n    } else { /* SSH_MSG_CHANNEL_EXTENDED_DATA */\n        extended = 1;\n    }\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n        return SSH_PACKET_USED;\n    }\n\n    if (extended) {\n        uint32_t data_type_code, rc;\n        rc = ssh_buffer_get_u32(packet, &data_type_code);\n        if (rc != sizeof(uint32_t)) {\n            SSH_LOG(SSH_LOG_PACKET,\n                    \"Failed to read data type code: rc = %\" PRIu32, rc);\n\n            return SSH_PACKET_USED;\n        }\n        is_stderr = 1;\n        data_type_code = ntohl(data_type_code);\n        if (data_type_code != SSH2_EXTENDED_DATA_STDERR) {\n            SSH_LOG(SSH_LOG_PACKET, \"Invalid data type code %\" PRIu32 \"!\",\n                    data_type_code);\n        }\n    }\n\n    str = ssh_buffer_get_ssh_string(packet);\n    if (str == NULL) {\n        SSH_LOG(SSH_LOG_PACKET, \"Invalid data packet!\");\n\n        return SSH_PACKET_USED;\n    }\n    /* STRING_SIZE_MAX < UINT32_MAX */\n    len = (uint32_t)ssh_string_len(str);\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Channel receiving %\" PRIu32 \" bytes data%s (local win=%\" PRIu32\n            \" remote win=%\" PRIu32 \")\",\n            len,\n            is_stderr ? \" in stderr\"  : \"\",\n            channel->local_window,\n            channel->remote_window);\n\n    if (len > channel->local_window) {\n        SSH_LOG(SSH_LOG_RARE,\n                \"Data packet too big for our window(%\" PRIu32 \" vs %\" PRIu32 \")\",\n                len,\n                channel->local_window);\n\n        SSH_STRING_FREE(str);\n\n        ssh_set_error(session, SSH_FATAL, \"Window exceeded\");\n\n        return SSH_PACKET_USED;\n    }\n\n    data = ssh_string_data(str);\n    if (channel_default_bufferize(channel, data, len, is_stderr) < 0) {\n        SSH_STRING_FREE(str);\n\n        return SSH_PACKET_USED;\n    }\n\n    channel->local_window -= len;\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Channel windows are now (local win=%\" PRIu32 \" remote win=%\" PRIu32 \")\",\n            channel->local_window,\n            channel->remote_window);\n\n    SSH_STRING_FREE(str);\n\n    if (is_stderr) {\n        buf = channel->stderr_buffer;\n    } else {\n        buf = channel->stdout_buffer;\n    }\n\n    ssh_callbacks_iterate(channel->callbacks,\n                          ssh_channel_callbacks,\n                          channel_data_function) {\n        if (ssh_buffer_get(buf) == NULL) {\n            break;\n        }\n        rest = ssh_callbacks_iterate_exec(channel_data_function,\n                                          channel->session,\n                                          channel,\n                                          ssh_buffer_get(buf),\n                                          ssh_buffer_get_len(buf),\n                                          is_stderr);\n        if (rest > 0) {\n            int rc;\n            if (channel->counter != NULL) {\n                channel->counter->in_bytes += rest;\n            }\n            ssh_buffer_pass_bytes(buf, rest);\n\n            rc = grow_window(session, channel);\n            if (rc == SSH_ERROR) {\n              return -1;\n            }\n        }\n    }\n    ssh_callbacks_iterate_end();\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 585,
      "line_end": 708,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 181,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses structured external network input (SSH packets and extended-data codes), performs buffer operations on untrusted data (bufferize/pass bytes), includes input-dependent bounds checks and loops and multiple branching paths (extended vs data, callback-driven processing). High risk for memory/logic bugs and thus a high-priority fuzz target."
    },
    {
      "name": "channel_rcv_request",
      "clean_name": "channel_rcv_request",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "        ssh_channel_do_free(channel);\n\n    return SSH_PACKET_USED;\n}\n\nSSH_PACKET_CALLBACK(channel_rcv_request)\n{\n    ssh_channel channel = NULL;\n    char *request = NULL;\n    uint8_t want_reply;\n    int rc;\n    (void)user;\n    (void)type;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n        return SSH_PACKET_USED;\n    }\n\n    rc = ssh_buffer_unpack(packet, \"sb\", &request, &want_reply);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_PACKET, \"Invalid MSG_CHANNEL_REQUEST\");\n        return SSH_PACKET_USED;\n    }\n\n    if (strcmp(request, \"exit-status\") == 0) {\n        SAFE_FREE(request);\n        rc = ssh_buffer_unpack(packet, \"d\", &channel->exit.code);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_PACKET, \"Invalid exit-status packet\");\n            return SSH_PACKET_USED;\n        }\n        channel->exit.status = true;\n\n        SSH_LOG(SSH_LOG_PACKET,\n                \"received exit-status %u\",\n                channel->exit.code);\n\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_exit_status_function,\n                                   channel->session,\n                                   channel,\n                                   channel->exit.code);\n\n        return SSH_PACKET_USED;\n    }\n\n    if (strcmp(request, \"signal\") == 0) {\n        char *sig = NULL;\n\n        SAFE_FREE(request);\n        SSH_LOG(SSH_LOG_PACKET, \"received signal\");\n\n        rc = ssh_buffer_unpack(packet, \"s\", &sig);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_PACKET, \"Invalid MSG_CHANNEL_REQUEST\");\n            return SSH_PACKET_USED;\n        }\n\n        SSH_LOG(SSH_LOG_PACKET, \"Remote connection sent a signal SIG %s\", sig);\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_signal_function,\n                                   channel->session,\n                                   channel,\n                                   sig);\n        SAFE_FREE(sig);\n\n        return SSH_PACKET_USED;\n    }\n\n    if (strcmp(request, \"exit-signal\") == 0) {\n        const char *core = \"(core dumped)\";\n        char *sig = NULL;\n        char *errmsg = NULL;\n        char *lang = NULL;\n        uint8_t core_dumped;\n\n        SAFE_FREE(request);\n\n        rc = ssh_buffer_unpack(packet,\n                               \"sbss\",\n                               &sig,         /* signal name */\n                               &core_dumped, /* core dumped */\n                               &errmsg,      /* error message */\n                               &lang);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_PACKET, \"Invalid MSG_CHANNEL_REQUEST\");\n            return SSH_PACKET_USED;\n        }\n\n        if (core_dumped == 0) {\n            core = \"\";\n        }\n\n        SSH_LOG(SSH_LOG_PACKET,\n                \"Remote connection closed by signal SIG %s %s\",\n                sig,\n                core);\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_exit_signal_function,\n                                   channel->session,\n                                   channel,\n                                   sig,\n                                   core_dumped,\n                                   errmsg,\n                                   lang);\n\n        channel->exit.core_dumped = core_dumped;\n        if (sig != NULL) {\n            SAFE_FREE(channel->exit.signal);\n            channel->exit.signal = sig;\n        }\n        channel->exit.status = true;\n\n        SAFE_FREE(lang);\n        SAFE_FREE(errmsg);\n\n        return SSH_PACKET_USED;\n    }\n    if (strcmp(request, \"keepalive@openssh.com\") == 0) {\n        SAFE_FREE(request);\n        SSH_LOG(SSH_LOG_DEBUG, \"Responding to Openssh's keepalive\");\n\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bd\",\n                             SSH2_MSG_CHANNEL_FAILURE,\n                             channel->remote_channel);\n        if (rc != SSH_OK) {\n            return SSH_PACKET_USED;\n        }\n        ssh_packet_send(session);\n\n        return SSH_PACKET_USED;\n    }\n\n    if (strcmp(request, \"auth-agent-req@openssh.com\") == 0) {\n        int status;\n\n        SAFE_FREE(request);\n        SSH_LOG(SSH_LOG_DEBUG, \"Received an auth-agent-req request\");\n\n        status = SSH2_MSG_CHANNEL_FAILURE;\n        ssh_callbacks_iterate (channel->callbacks,\n                               ssh_channel_callbacks,\n                               channel_auth_agent_req_function) {\n            ssh_callbacks_iterate_exec(channel_auth_agent_req_function,\n                                       channel->session,\n                                       channel);\n            /* in lieu of a return value, if the callback exists it's supported\n             */\n            status = SSH2_MSG_CHANNEL_SUCCESS;\n            break;\n        }\n        ssh_callbacks_iterate_end();\n\n        if (want_reply) {\n            rc = ssh_buffer_pack(session->out_buffer,\n                                 \"bd\",\n                                 status,\n                                 channel->remote_channel);\n            if (rc != SSH_OK) {\n                return SSH_PACKET_USED;\n            }\n            ssh_packet_send(session);\n        }\n\n        return SSH_PACKET_USED;\n    }\n#ifdef WITH_SERVER\n    /* If we are here, that means we have a request that is not in the\n     * understood client requests. That means we need to create a ssh message to\n     * be passed to the user code handling ssh messages\n     */\n    ssh_message_handle_channel_request(session,\n                                       channel,\n                                       packet,\n                                       request,\n                                       want_reply);\n#else\n    SSH_LOG(SSH_LOG_DEBUG, \"Unhandled channel request %s\", request);\n#endif\n\n    SAFE_FREE(request);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 802,
      "line_end": 987,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 416,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses complex external network input (SSH channel requests), unpacks strings/bytes from untrusted packets, performs memory allocations/frees and updates channel state, and has many input-dependent branches and callbacks. High potential for memory/logic bugs and security impact, making it a critical fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_accept",
      "clean_name": "ssh_channel_accept",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "error:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n\nstatic ssh_channel ssh_channel_accept(ssh_session session, int channeltype,\n    int timeout_ms, int *destination_port, char **originator, int *originator_port)\n{\n#ifndef _WIN32\n  static const struct timespec ts = {\n    .tv_sec = 0,\n    .tv_nsec = 50000000 /* 50ms */\n  };\n#endif\n  ssh_message msg = NULL;\n  ssh_channel channel = NULL;\n  struct ssh_iterator *iterator = NULL;\n  int t;\n\n  /*\n   * We sleep for 50 ms in ssh_handle_packets() and later sleep for\n   * 50 ms. So we need to decrement by 100 ms.\n   */\n  for (t = timeout_ms; t >= 0; t -= 100) {\n    if (timeout_ms == 0) {\n        ssh_handle_packets(session, 0);\n    } else {\n        ssh_handle_packets(session, 50);\n    }\n\n    if (session->ssh_message_list) {\n      iterator = ssh_list_get_iterator(session->ssh_message_list);\n      while (iterator) {\n        msg = (ssh_message)iterator->data;\n        if (ssh_message_type(msg) == SSH_REQUEST_CHANNEL_OPEN &&\n            ssh_message_subtype(msg) == channeltype) {\n          ssh_list_remove(session->ssh_message_list, iterator);\n          channel = ssh_message_channel_request_open_reply_accept(msg);\n          if(destination_port) {\n            *destination_port=msg->channel_request_open.destination_port;\n          }\n          if(originator) {\n            *originator=strdup(msg->channel_request_open.originator);\n          }\n          if(originator_port) {\n            *originator_port=msg->channel_request_open.originator_port;\n          }\n\n          ssh_message_free(msg);\n          return channel;\n        }\n        iterator = iterator->next;\n      }\n    }\n    if(t>0){\n#ifdef _WIN32\n      Sleep(50); /* 50ms */\n#else\n      nanosleep(&ts, NULL);\n#endif\n    }\n  }\n\n  ssh_set_error(session, SSH_NO_ERROR, \"No channel request of this type from server\");\n  return NULL;\n}\n",
      "line_start": 2311,
      "line_end": 2372,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Accepts and processes structured network messages (SSH channel open requests) derived from untrusted input, performs memory operations (strdup, list removal, channel creation), has looping/branching based on message types and timeout, and exercises complex parsing/dispatch paths \u2014 high value as a fuzz target."
    },
    {
      "name": "curve25519.c:ssh_curve25519_build_k",
      "clean_name": "ssh_curve25519_build_k",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "void ssh_client_curve25519_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_curve25519_client_callbacks);\n}\n\nstatic int ssh_curve25519_build_k(ssh_session session)\n{\n    ssh_curve25519_pubkey k;\n    int rc;\n\n    rc = ssh_curve25519_create_k(session, k);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    bignum_bin2bn(k,\n                  CURVE25519_PUBKEY_SIZE,\n                  &session->next_crypto->shared_secret);\n    if (session->next_crypto->shared_secret == NULL) {\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_print_bignum(\"Shared secret key\", session->next_crypto->shared_secret);\n#endif\n\n    return SSH_OK;\n}\n",
      "line_start": 103,
      "line_end": 126,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Although the function is small and low in cyclomatic complexity, it performs cryptographic operations (building a Curve25519 shared secret) and converts raw public-key bytes into a bignum; this is security-critical and involves memory/binary handling of potentially untrusted data, making it a high-priority fuzz target."
    },
    {
      "name": "crypto_hash_sha512",
      "clean_name": "crypto_hash_sha512",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "#include \"libssh/pki.h\"\n#include \"libssh/priv.h\"\n#include \"libssh/session.h\"\n#include \"libssh/ssh2.h\"\n\nvoid crypto_hash_sha512(unsigned char *out,\n                        const unsigned char *in,\n                        unsigned long long inlen)\n{\n    sha512(in, inlen, out);\n}\n",
      "line_start": 39,
      "line_end": 45,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Thin wrapper around SHA-512 that hashes external/untrusted input \u2014 a security-critical cryptographic operation performing memory ops on caller-controlled buffers. Minimal internal logic (low complexity) but high fuzz priority because it invokes crypto code that processes external data and may contain subtle memory/logic bugs."
    },
    {
      "name": "sntrup761.c:ssh_packet_client_sntrup761x25519_reply",
      "clean_name": "ssh_packet_client_sntrup761x25519_reply",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "\n/** @internal\n * @brief parses a SSH_MSG_KEX_ECDH_REPLY packet and sends back\n * a SSH_MSG_NEWKEYS\n */\nstatic SSH_PACKET_CALLBACK(ssh_packet_client_sntrup761x25519_reply)\n{\n    ssh_string q_s_string = NULL;\n    ssh_string pubkey_blob = NULL;\n    ssh_string signature = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    ssh_client_sntrup761x25519_remove_callbacks(session);\n\n    pubkey_blob = ssh_buffer_get_ssh_string(packet);\n    if (pubkey_blob == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No public key in packet\");\n        goto error;\n    }\n\n    rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n    SSH_STRING_FREE(pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL, \"Failed to import next public key\");\n        goto error;\n    }\n\n    q_s_string = ssh_buffer_get_ssh_string(packet);\n    if (q_s_string == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No sntrup761x25519 Q_S in packet\");\n        goto error;\n    }\n    if (ssh_string_len(q_s_string) != (SNTRUP761_CIPHERTEXT_SIZE + CURVE25519_PUBKEY_SIZE)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Incorrect size for server sntrup761x25519 ciphertext+key: %d\",\n                      (int)ssh_string_len(q_s_string));\n        SSH_STRING_FREE(q_s_string);\n        goto error;\n    }\n    memcpy(session->next_crypto->sntrup761_ciphertext,\n           ssh_string_data(q_s_string),\n           SNTRUP761_CIPHERTEXT_SIZE);\n    memcpy(session->next_crypto->curve25519_server_pubkey,\n           (char *)ssh_string_data(q_s_string) + SNTRUP761_CIPHERTEXT_SIZE,\n           CURVE25519_PUBKEY_SIZE);\n    SSH_STRING_FREE(q_s_string);\n\n    signature = ssh_buffer_get_ssh_string(packet);\n    if (signature == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No signature in packet\");\n        goto error;\n    }\n    session->next_crypto->dh_server_signature = signature;\n    signature = NULL; /* ownership changed */\n    /* TODO: verify signature now instead of waiting for NEWKEYS */\n    if (ssh_sntrup761x25519_build_k(session) < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Cannot build k number\");\n        goto error;\n    }\n\n    /* Send the MSG_NEWKEYS */\n    if (ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_NEWKEYS) < 0) {\n        goto error;\n    }\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_NEWKEYS sent\");\n    session->dh_handshake_state = DH_STATE_NEWKEYS_SENT;\n\n    return SSH_PACKET_USED;\n\nerror:\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 240,
      "line_end": 317,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 117,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses structured network packet data and extracts multiple ssh_string blobs, performs memcpy into crypto buffers and hands off a signature; this is part of a key-exchange (security-critical) path and operates on untrusted input \u2014 high value for fuzzing."
    },
    {
      "name": "sntrup761.c:ssh_sntrup761x25519_build_k",
      "clean_name": "ssh_sntrup761x25519_build_k",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "void ssh_client_sntrup761x25519_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_sntrup761x25519_client_callbacks);\n}\n\nstatic int ssh_sntrup761x25519_build_k(ssh_session session)\n{\n    unsigned char ssk[SNTRUP761_SIZE + CURVE25519_PUBKEY_SIZE];\n    unsigned char *k = ssk + SNTRUP761_SIZE;\n    unsigned char hss[SHA512_DIGEST_LEN];\n    int rc;\n\n    rc = ssh_curve25519_create_k(session, k);\n    if (rc != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"Curve25519 shared secret\", k, CURVE25519_PUBKEY_SIZE);\n#endif\n\n#ifdef HAVE_LIBGCRYPT\n    if (session->server) {\n        gcry_error_t err;\n        err = gcry_kem_encap(GCRY_KEM_SNTRUP761,\n                             session->next_crypto->sntrup761_client_pubkey,\n                             SNTRUP761_PUBLICKEY_SIZE,\n                             session->next_crypto->sntrup761_ciphertext,\n                             SNTRUP761_CIPHERTEXT_SIZE,\n                             ssk,\n                             SNTRUP761_SIZE,\n                             NULL,\n                             0);\n        if (err) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to encapsulate sntrup761 shared secret: %s\",\n                    gpg_strerror(err));\n            return SSH_ERROR;\n        }\n    } else {\n        gcry_error_t err;\n        err = gcry_kem_decap(GCRY_KEM_SNTRUP761,\n                             session->next_crypto->sntrup761_privkey,\n                             SNTRUP761_SECRETKEY_SIZE,\n                             session->next_crypto->sntrup761_ciphertext,\n                             SNTRUP761_CIPHERTEXT_SIZE,\n                             ssk,\n                             SNTRUP761_SIZE,\n                             NULL,\n                             0);\n        if (err) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to decapsulate sntrup761 shared secret: %s\",\n                    gpg_strerror(err));\n            return SSH_ERROR;\n        }\n    }\n#else\n    if (session->server) {\n        sntrup761_enc(session->next_crypto->sntrup761_ciphertext,\n                      ssk,\n                      session->next_crypto->sntrup761_client_pubkey,\n                      &rc,\n                      crypto_random);\n        if (rc != 1) {\n            return SSH_ERROR;\n        }\n    } else {\n        sntrup761_dec(ssk,\n                      session->next_crypto->sntrup761_ciphertext,\n                      session->next_crypto->sntrup761_privkey);\n    }\n#endif /* HAVE_LIBGCRYPT */\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"server cipher text\",\n                    session->next_crypto->sntrup761_ciphertext,\n                    SNTRUP761_CIPHERTEXT_SIZE);\n    ssh_log_hexdump(\"kem key\", ssk, SNTRUP761_SIZE);\n#endif\n\n    sha512(ssk, sizeof ssk, hss);\n\n    bignum_bin2bn(hss, sizeof hss, &session->next_crypto->shared_secret);\n    if (session->next_crypto->shared_secret == NULL) {\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_print_bignum(\"Shared secret key\", session->next_crypto->shared_secret);\n#endif\n\n    return 0;\n}\n",
      "line_start": 146,
      "line_end": 235,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Performs security\u2011critical cryptographic operations (Curve25519 + SNTRUP761 KEM), manipulates buffers derived from session/peer data (ciphertext/keys), performs hashing and bignum conversion, and has branching paths (encap/decap). High value as a fuzz target due to untrusted input affecting memory and crypto logic."
    },
    {
      "name": "ssh_kex_select_methods",
      "clean_name": "ssh_kex_select_methods",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "}\n\n/** @brief Select the different methods on basis of client's and\n * server's kex messages, and watches out if a match is possible.\n */\nint ssh_kex_select_methods (ssh_session session)\n{\n    struct ssh_crypto_struct *crypto = session->next_crypto;\n    struct ssh_kex_struct *server = &crypto->server_kex;\n    struct ssh_kex_struct *client = &crypto->client_kex;\n    char *ext_start = NULL;\n    const char *aead_hmac = NULL;\n    enum ssh_key_exchange_e kex_type;\n    int i;\n\n    /* Here we should drop the extensions from the list so we avoid matching.\n     * it. We added it to the end, so we can just truncate the string here */\n    if (session->client) {\n        ext_start = strstr(client->methods[SSH_KEX], \",\" KEX_EXTENSION_CLIENT);\n        if (ext_start != NULL) {\n            ext_start[0] = '\\0';\n        }\n    }\n    if (session->server) {\n        ext_start = strstr(server->methods[SSH_KEX], \",\" KEX_STRICT_SERVER);\n        if (ext_start != NULL) {\n            ext_start[0] = '\\0';\n        }\n    }\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        crypto->kex_methods[i] = ssh_find_matching(server->methods[i],\n                                                   client->methods[i]);\n\n        if (i == SSH_MAC_C_S || i == SSH_MAC_S_C) {\n            aead_hmac = ssh_find_aead_hmac(crypto->kex_methods[i - 2]);\n            if (aead_hmac) {\n                free(crypto->kex_methods[i]);\n                crypto->kex_methods[i] = strdup(aead_hmac);\n            }\n        }\n        if (crypto->kex_methods[i] == NULL && i < SSH_LANG_C_S) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"kex error : no match for method %s: server [%s], \"\n                          \"client [%s]\", ssh_kex_descriptions[i],\n                          server->methods[i], client->methods[i]);\n            return SSH_ERROR;\n        } else if ((i >= SSH_LANG_C_S) && (crypto->kex_methods[i] == NULL)) {\n            /* we can safely do that for languages */\n            crypto->kex_methods[i] = strdup(\"\");\n        }\n    }\n\n    /* We can not set this value directly as the old value is needed to revert\n     * callbacks if we are client */\n    kex_type = kex_select_kex_type(crypto->kex_methods[SSH_KEX]);\n    if (session->client && session->first_kex_follows_guess_wrong) {\n        SSH_LOG(SSH_LOG_DEBUG, \"Our guess was wrong. Restarting the KEX\");\n        /* We need to remove the wrong callbacks and start kex again */\n        revert_kex_callbacks(session);\n        session->dh_handshake_state = DH_STATE_INIT;\n        session->first_kex_follows_guess_wrong = false;\n    }\n    crypto->kex_type = kex_type;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Negotiated %s,%s,%s,%s,%s,%s,%s,%s,%s,%s\",\n            session->next_crypto->kex_methods[SSH_KEX],\n            session->next_crypto->kex_methods[SSH_HOSTKEYS],\n            session->next_crypto->kex_methods[SSH_CRYPT_C_S],\n            session->next_crypto->kex_methods[SSH_CRYPT_S_C],\n            session->next_crypto->kex_methods[SSH_MAC_C_S],\n            session->next_crypto->kex_methods[SSH_MAC_S_C],\n            session->next_crypto->kex_methods[SSH_COMP_C_S],\n            session->next_crypto->kex_methods[SSH_COMP_S_C],\n            session->next_crypto->kex_methods[SSH_LANG_C_S],\n            session->next_crypto->kex_methods[SSH_LANG_S_C]\n    );\n    return SSH_OK;\n}\n",
      "line_start": 977,
      "line_end": 1051,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 79,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses and mutates SSH negotiation strings (network protocol) from peer messages, performs memory ops (strstr, truncation, free/strdup) on untrusted data, contains branching and selection logic, and is part of cryptographic key-exchange negotiation \u2014 high security impact and a strong fuzz target."
    },
    {
      "name": "ssh_generate_session_keys",
      "clean_name": "ssh_generate_session_keys",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n\n    return 0;\n}\n\nint ssh_generate_session_keys(ssh_session session)\n{\n    ssh_string k_string = NULL;\n    struct ssh_crypto_struct *crypto = session->next_crypto;\n    unsigned char *key = NULL;\n    unsigned char *IV_cli_to_srv = NULL;\n    unsigned char *IV_srv_to_cli = NULL;\n    unsigned char *enckey_cli_to_srv = NULL;\n    unsigned char *enckey_srv_to_cli = NULL;\n    unsigned char *intkey_cli_to_srv = NULL;\n    unsigned char *intkey_srv_to_cli = NULL;\n    size_t key_len = 0;\n    size_t IV_len = 0;\n    size_t enckey_cli_to_srv_len = 0;\n    size_t enckey_srv_to_cli_len = 0;\n    size_t intkey_cli_to_srv_len = 0;\n    size_t intkey_srv_to_cli_len = 0;\n    int rc = -1;\n\n    if (session->next_crypto->kex_type == SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM) {\n        k_string = ssh_make_padded_bignum_string(crypto->shared_secret,\n                                                 SHA512_DIGEST_LEN);\n    } else {\n        k_string = ssh_make_bignum_string(crypto->shared_secret);\n    }\n    if (k_string == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    /* See RFC4251 Section 5 for the definition of mpint which is the\n     * encoding we need to use for key in the SSH KDF */\n    key = (unsigned char *)k_string;\n    key_len = ssh_string_len(k_string) + 4;\n\n    IV_len = crypto->digest_len;\n    if (session->client) {\n        enckey_cli_to_srv_len = crypto->out_cipher->keysize / 8;\n        enckey_srv_to_cli_len = crypto->in_cipher->keysize / 8;\n        intkey_cli_to_srv_len = hmac_digest_len(crypto->out_hmac);\n        intkey_srv_to_cli_len = hmac_digest_len(crypto->in_hmac);\n    } else {\n        enckey_cli_to_srv_len = crypto->in_cipher->keysize / 8;\n        enckey_srv_to_cli_len = crypto->out_cipher->keysize / 8;\n        intkey_cli_to_srv_len = hmac_digest_len(crypto->in_hmac);\n        intkey_srv_to_cli_len = hmac_digest_len(crypto->out_hmac);\n    }\n\n    IV_cli_to_srv = malloc(IV_len);\n    IV_srv_to_cli = malloc(IV_len);\n    enckey_cli_to_srv = malloc(enckey_cli_to_srv_len);\n    enckey_srv_to_cli = malloc(enckey_srv_to_cli_len);\n    intkey_cli_to_srv = malloc(intkey_cli_to_srv_len);\n    intkey_srv_to_cli = malloc(intkey_srv_to_cli_len);\n    if (IV_cli_to_srv == NULL || IV_srv_to_cli == NULL ||\n        enckey_cli_to_srv == NULL || enckey_srv_to_cli == NULL ||\n        intkey_cli_to_srv == NULL || intkey_srv_to_cli == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    /* IV */\n    rc = ssh_kdf(crypto, key, key_len, 'A', IV_cli_to_srv, IV_len);\n    if (rc < 0) {\n        goto error;\n    }\n    rc = ssh_kdf(crypto, key, key_len, 'B', IV_srv_to_cli, IV_len);\n    if (rc < 0) {\n        goto error;\n    }\n    /* Encryption Key */\n    rc = ssh_kdf(crypto, key, key_len, 'C', enckey_cli_to_srv,\n                 enckey_cli_to_srv_len);\n    if (rc < 0) {\n        goto error;\n    }\n    rc = ssh_kdf(crypto, key, key_len, 'D', enckey_srv_to_cli,\n                 enckey_srv_to_cli_len);\n    if (rc < 0) {\n        goto error;\n    }\n    /* Integrity Key */\n    rc = ssh_kdf(crypto, key, key_len, 'E', intkey_cli_to_srv,\n                 intkey_cli_to_srv_len);\n    if (rc < 0) {\n        goto error;\n    }\n    rc = ssh_kdf(crypto, key, key_len, 'F', intkey_srv_to_cli,\n                 intkey_srv_to_cli_len);\n    if (rc < 0) {\n        goto error;\n    }\n\n    if (session->client) {\n        crypto->encryptIV = IV_cli_to_srv;\n        crypto->decryptIV = IV_srv_to_cli;\n        crypto->encryptkey = enckey_cli_to_srv;\n        crypto->decryptkey = enckey_srv_to_cli;\n        crypto->encryptMAC = intkey_cli_to_srv;\n        crypto->decryptMAC = intkey_srv_to_cli;\n    } else {\n        crypto->encryptIV = IV_srv_to_cli;\n        crypto->decryptIV = IV_cli_to_srv;\n        crypto->encryptkey = enckey_srv_to_cli;\n        crypto->decryptkey = enckey_cli_to_srv;\n        crypto->encryptMAC = intkey_srv_to_cli;\n        crypto->decryptMAC = intkey_cli_to_srv;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"Client to Server IV\", IV_cli_to_srv, IV_len);\n    ssh_log_hexdump(\"Server to Client IV\", IV_srv_to_cli, IV_len);\n    ssh_log_hexdump(\"Client to Server Encryption Key\", enckey_cli_to_srv,\n                   enckey_cli_to_srv_len);\n    ssh_log_hexdump(\"Server to Client Encryption Key\", enckey_srv_to_cli,\n                   enckey_srv_to_cli_len);\n    ssh_log_hexdump(\"Client to Server Integrity Key\", intkey_cli_to_srv,\n                   intkey_cli_to_srv_len);\n    ssh_log_hexdump(\"Server to Client Integrity Key\", intkey_srv_to_cli,\n                   intkey_srv_to_cli_len);\n#endif /* DEBUG_CRYPTO */\n\n    rc = 0;\nerror:\n    ssh_string_burn(k_string);\n    SSH_STRING_FREE(k_string);\n    if (rc != 0) {\n        free(IV_cli_to_srv);\n        free(IV_srv_to_cli);\n        free(enckey_cli_to_srv);\n        free(enckey_srv_to_cli);\n        free(intkey_cli_to_srv);\n        free(intkey_srv_to_cli);\n    }\n\n    return rc;\n}\n",
      "line_start": 1740,
      "line_end": 1876,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 121,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Generates SSH session keys using a KDF on the (remote-influenced) shared_secret, does many heap allocations and buffer writes, and performs security\u2011critical cryptographic operations. It has branching (kex_type, client/server) and calls into bignum/string and KDF routines \u2014 a high-value target for fuzzing (memory and crypto handling) though not a complex parser."
    },
    {
      "name": "knownhosts.c:match_hashed_hostname",
      "clean_name": "match_hashed_hostname",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "        return SSH_ERROR;\n\n    return SSH_OK;\n}\n\nstatic int match_hashed_hostname(const char *host, const char *hashed_host)\n{\n    char *hashed = NULL;\n    char *b64_hash = NULL;\n    ssh_buffer salt = NULL;\n    ssh_buffer hash = NULL;\n    unsigned char hashed_buf[256] = {0};\n    unsigned char *hashed_buf_ptr = hashed_buf;\n    size_t hashed_buf_size = sizeof(hashed_buf);\n    int cmp;\n    int rc;\n    int match = 0;\n\n    cmp = strncmp(hashed_host, \"|1|\", 3);\n    if (cmp != 0) {\n        return 0;\n    }\n\n    hashed = strdup(hashed_host + 3);\n    if (hashed == NULL) {\n        return 0;\n    }\n\n    b64_hash = strchr(hashed, '|');\n    if (b64_hash == NULL) {\n        goto error;\n    }\n    *b64_hash = '\\0';\n    b64_hash++;\n\n    salt = base64_to_bin(hashed);\n    if (salt == NULL) {\n        goto error;\n    }\n\n    hash = base64_to_bin(b64_hash);\n    if (hash == NULL) {\n        goto error;\n    }\n\n    rc = hash_hostname(host,\n                       ssh_buffer_get(salt),\n                       ssh_buffer_get_len(salt),\n                       &hashed_buf_ptr,\n                       &hashed_buf_size);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    if (hashed_buf_size != ssh_buffer_get_len(hash)) {\n        goto error;\n    }\n\n    cmp = memcmp(hashed_buf, ssh_buffer_get(hash), hashed_buf_size);\n    if (cmp == 0) {\n        match = 1;\n    }\n\nerror:\n    free(hashed);\n    SSH_BUFFER_FREE(salt);\n    SSH_BUFFER_FREE(hash);\n\n    return match;\n}\n",
      "line_start": 81,
      "line_end": 146,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses structured external input (hashed known-host format \"|1|salt|b64hash\"), performs base64 decoding and memory operations on untrusted data, and invokes hostname hashing/crypto code. It has multiple error branches and compares binary blobs \u2014 security\u2011critical logic and a high\u2011value fuzz target."
    },
    {
      "name": "knownhosts.c:ssh_known_hosts_check_server_key",
      "clean_name": "ssh_known_hosts_check_server_key",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "    fclose(fp);\n    return SSH_OK;\n}\n\nstatic enum ssh_known_hosts_e\nssh_known_hosts_check_server_key(const char *hosts_entry,\n                                 const char *filename,\n                                 ssh_key server_key,\n                                 struct ssh_knownhosts_entry **pentry)\n{\n    struct ssh_list *entry_list = NULL;\n    struct ssh_iterator *it = NULL;\n    enum ssh_known_hosts_e found = SSH_KNOWN_HOSTS_UNKNOWN;\n    int rc;\n\n    rc = ssh_known_hosts_read_entries(hosts_entry,\n                                      filename,\n                                      &entry_list);\n    if (rc != 0) {\n        ssh_list_free(entry_list);\n        return SSH_KNOWN_HOSTS_UNKNOWN;\n    }\n\n    it = ssh_list_get_iterator(entry_list);\n    if (it == NULL) {\n        ssh_list_free(entry_list);\n        return SSH_KNOWN_HOSTS_UNKNOWN;\n    }\n\n    for (;it != NULL; it = it->next) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        int cmp;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n\n        cmp = ssh_key_cmp(server_key, entry->publickey, SSH_KEY_CMP_PUBLIC);\n        if (cmp == 0) {\n            found = SSH_KNOWN_HOSTS_OK;\n            if (pentry != NULL) {\n                *pentry = entry;\n                ssh_list_remove(entry_list, it);\n            }\n            break;\n        }\n\n        if (ssh_key_type(server_key) == ssh_key_type(entry->publickey)) {\n            found = SSH_KNOWN_HOSTS_CHANGED;\n            continue;\n        }\n\n        if (found != SSH_KNOWN_HOSTS_CHANGED) {\n            found = SSH_KNOWN_HOSTS_OTHER;\n        }\n    }\n\n    for (it = ssh_list_get_iterator(entry_list);\n         it != NULL;\n         it = ssh_list_get_iterator(entry_list)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entry_list, it);\n    }\n    ssh_list_free(entry_list);\n\n    return found;\n}\n",
      "line_start": 1073,
      "line_end": 1136,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Security-critical host key checking: it compares an untrusted server_key against entries (from hosts_entry/filename), manipulates lists and returns OK/CHANGED/OTHER. While it delegates parsing, it exercises complex, input-dependent control flow and calls key comparison/typing code (likely memory/crypto operations). High value as a fuzz target."
    },
    {
      "name": "match_cidr_address_list",
      "clean_name": "match_cidr_address_list",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " * @return  1 only on positive match.\n * @return  0 on negative match or valid CIDR list.\n * @return  -1 on errors or invalid CIDR list.\n */\nint\nmatch_cidr_address_list(const char *address,\n                        const char *addrlist,\n                        int sa_family)\n{\n    char *list = NULL, *cp = NULL, *a = NULL, *b = NULL, *sp = NULL;\n    char addr_buffer[64], addr[NI_MAXHOST];\n    struct in_addr try_addr, match_addr;\n    struct in6_addr try_addr6, match_addr6;\n    unsigned long mask_len;\n    size_t addr_len, tmp_len;\n    int rc = 0, r, ai_family;\n\n    ZERO_STRUCT(try_addr);\n    ZERO_STRUCT(try_addr6);\n    ZERO_STRUCT(match_addr);\n    ZERO_STRUCT(match_addr6);\n\n    if (sa_family != AF_INET && sa_family != AF_INET6 && sa_family != -1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Invalid argument: sa_family %d is not valid\",\n                sa_family);\n        return -1;\n    }\n\n    if (address != NULL) {\n        strncpy(addr, address, NI_MAXHOST - 1);\n\n        /* Remove interface in case of IPv6 address: addr%interface */\n        a = strchr(addr, '%');\n        if (a != NULL) {\n            *a = '\\0';\n        }\n\n        /*\n         * If sa_family is set to -1 and address is not NULL then\n         * the socket address family should be derived\n         */\n        if (sa_family == -1) {\n            r = get_address_family(addr);\n            if (r == -1) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Failed to derive address family for address \"\n                        \"\\\"%.100s\\\"\",\n                        addr);\n                return -1;\n            }\n            sa_family = r;\n        }\n\n        /*\n         * Translate host address from dot notation to binary network format\n         * according to family type,\n         * i.e. IPv4 (store in in_addr) or IPv6 (store in in6_addr)\n         */\n        if (sa_family == AF_INET) {\n            if (inet_pton(AF_INET, addr, &try_addr) == 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Couldn't parse IPv4 address \\\"%.100s\\\"\",\n                        addr);\n                return -1;\n            }\n        } else if (sa_family == AF_INET6) {\n            if (inet_pton(AF_INET6, addr, &try_addr6) == 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Couldn't parse IPv6 address \\\"%.100s\\\"\",\n                        addr);\n                return -1;\n            }\n        } else {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Address family %d for address \\\"%.100s\\\" \"\n                    \"is not recognized\",\n                    sa_family,\n                    addr);\n            return -1;\n        }\n    }\n\n    b = list = strdup(addrlist);\n    if (b == NULL) {\n        return -1;\n    }\n\n    while ((cp = strsep(&list, \",\")) != NULL) {\n        if (*cp == '\\0') {\n            SSH_LOG(SSH_LOG_TRACE, \"Empty entry in list \\\"%.100s\\\"\", b);\n            rc = -1;\n            break;\n        }\n\n        /*\n         * Stop junk from reaching address translation. +3 for the \"/prefix\".\n         * INET6_ADDRSTRLEN is 46 and includes space for '\\0' terminator. The\n         * maximum IPv6 address printable is the one that carries IPv4 too.\n         * E.g. ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255 is 46 chars\n         * long ('\\0' included) and the maximum prefix length possible is 96.\n         * This explains why +3. All the other IPv6 addresses with maximum /127\n         * prefix length (39 + 4) are covered just by INET6_ADDRSTRLEN itself\n         */\n        addr_len = strlen(cp);\n        if (addr_len > INET6_ADDRSTRLEN + 3) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"List entry \\\"%.100s\\\" too long: %zu > %d (MAX ALLOWED)\",\n                    cp,\n                    addr_len,\n                    INET6_ADDRSTRLEN + 3);\n            rc = -1;\n            break;\n        }\n\n#define VALID_CIDR_CHARS \"0123456789abcdefABCDEF.:/\"\n        tmp_len = strspn(cp, VALID_CIDR_CHARS);\n        if (tmp_len != addr_len) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"List entry \\\"%.100s\\\" contains invalid characters \"\n                    \"-> \\\"%c\\\" is an invalid character\",\n                    cp,\n                    cp[tmp_len]);\n            rc = -1;\n            break;\n        }\n#undef VALID_CIDR_CHARS\n\n        strncpy(addr_buffer, cp, sizeof(addr_buffer) - 1);\n        sp = strchr(addr_buffer, '/');\n        if (sp != NULL) {\n            *sp = '\\0';\n            sp++;\n            mask_len = strtoul(sp, &cp, 10);\n            if (*sp < '0' || *sp > '9' || *cp != '\\0') {\n                SSH_LOG(SSH_LOG_TRACE, \"Error while parsing prefix: %s\", sp);\n                rc = -1;\n                break;\n            }\n            if (mask_len > 128) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Invalid prefix: %lu exceeds the maximum allowed \"\n                        \"(>128)\",\n                        mask_len);\n                rc = -1;\n                break;\n            }\n        } else {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Missing prefix length for list entry \\\"%.100s\\\"\",\n                    addr_buffer);\n            rc = -1;\n            break;\n        }\n\n        ai_family = get_address_family(addr_buffer);\n        if (ai_family == -1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Couldn't get address family for \\\"%.100s\\\"\",\n                    addr_buffer);\n            rc = -1;\n            break;\n        }\n\n        if (ai_family == AF_INET) {\n            if (inet_pton(AF_INET, addr_buffer, &match_addr) == 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Couldn't parse IPv4 address \\\"%.100s\\\"\",\n                        addr_buffer);\n                rc = -1;\n                break;\n            }\n        } else if (ai_family == AF_INET6) {\n            if (inet_pton(AF_INET6, addr_buffer, &match_addr6) == 0) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Couldn't parse IPv6 address \\\"%.100s\\\"\",\n                        addr_buffer);\n                rc = -1;\n                break;\n            }\n        } else {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Address family %d for address \\\"%.100s\\\" \"\n                    \"is not recognized\",\n                    ai_family,\n                    addr_buffer);\n            rc = -1;\n            break;\n        }\n\n        if (masklen_valid(ai_family, mask_len) != true) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Invalid mask length %lu for list entry \\\"%.100s\\\"\",\n                    mask_len,\n                    addr_buffer);\n            rc = -1;\n            break;\n        }\n\n        /* Verify match between host address and network address*/\n        if (((ai_family == AF_INET && sa_family == AF_INET) &&\n             cidr_match_4(&try_addr, &match_addr, mask_len)) ||\n            ((ai_family == AF_INET6 && sa_family == AF_INET6) &&\n             cidr_match_6(&try_addr6, &match_addr6, mask_len))) {\n            rc = 1;\n            break;\n        }\n    }\n    SAFE_FREE(b);\n\n    return rc;\n}\n",
      "line_start": 378,
      "line_end": 585,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 251,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "High-value fuzz target: it parses structured external input (comma-separated CIDR list and optional address), performs many string/buffer operations (strdup, strsep, strncpy, strchr, strtoul), calls inet_pton and other validation routines, and exercises multiple branches (IPv4 vs IPv6, parsing/validation failures). The loop over list entries, input-dependent bounds and several subtle parsing cases (e.g. mask parsing, allowed-char checks, possible strncpy non-termination) make it likely to reveal memory, parsing, and logic bugs."
    },
    {
      "name": "ssh_packet_channel_open",
      "clean_name": "ssh_packet_channel_open",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "\n  return SSH_PACKET_USED;\n}\n#endif /* WITH_SERVER */\n\nSSH_PACKET_CALLBACK(ssh_packet_channel_open){\n  ssh_message msg = NULL;\n  char *type_c = NULL;\n  uint32_t originator_port, destination_port;\n  int rc;\n\n  (void)type;\n  (void)user;\n  msg = ssh_message_new(session);\n  if (msg == NULL) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  msg->type = SSH_REQUEST_CHANNEL_OPEN;\n  rc = ssh_buffer_unpack(packet, \"s\", &type_c);\n  if (rc != SSH_OK){\n      goto error;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Clients wants to open a %s channel\", type_c);\n\n  ssh_buffer_unpack(packet,\"ddd\",\n          &msg->channel_request_open.sender,\n          &msg->channel_request_open.window,\n          &msg->channel_request_open.packet_size);\n\n  if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED){\n    ssh_set_error(session,SSH_FATAL, \"Invalid state when receiving channel open request (must be authenticated)\");\n    goto error;\n  }\n\n  if (strcmp(type_c, \"session\") == 0) {\n    if (session->flags & SSH_SESSION_FLAG_NO_MORE_SESSIONS) {\n        ssh_session_set_disconnect_message(session, \"No more sessions allowed!\");\n        ssh_set_error(session, SSH_FATAL, \"No more sessions allowed!\");\n        session->session_state = SSH_SESSION_STATE_ERROR;\n        ssh_send_disconnect(session);\n        goto error;\n    }\n\n    msg->channel_request_open.type = SSH_CHANNEL_SESSION;\n    SAFE_FREE(type_c);\n    goto end;\n  }\n\n  if (strcmp(type_c,\"direct-tcpip\") == 0) {\n    rc = ssh_buffer_unpack(packet,\n                           \"sdsd\",\n                           &msg->channel_request_open.destination,\n                           &destination_port,\n                           &msg->channel_request_open.originator,\n                           &originator_port);\n    if (rc != SSH_OK) {\n      goto error;\n    }\n\n    msg->channel_request_open.destination_port = (uint16_t) destination_port;\n    msg->channel_request_open.originator_port = (uint16_t) originator_port;\n    msg->channel_request_open.type = SSH_CHANNEL_DIRECT_TCPIP;\n    goto end;\n  }\n\n  if (strcmp(type_c,\"forwarded-tcpip\") == 0) {\n    rc = ssh_buffer_unpack(packet, \"sdsd\",\n            &msg->channel_request_open.destination,\n            &destination_port,\n            &msg->channel_request_open.originator,\n            &originator_port\n        );\n    if (rc != SSH_OK){\n        goto error;\n    }\n    msg->channel_request_open.destination_port = (uint16_t) destination_port;\n    msg->channel_request_open.originator_port = (uint16_t) originator_port;\n    msg->channel_request_open.type = SSH_CHANNEL_FORWARDED_TCPIP;\n    goto end;\n  }\n\n  if (strcmp(type_c,\"x11\") == 0) {\n    rc = ssh_buffer_unpack(packet, \"sd\",\n            &msg->channel_request_open.originator,\n            &originator_port);\n    if (rc != SSH_OK){\n        goto error;\n    }\n    msg->channel_request_open.originator_port = (uint16_t) originator_port;\n    msg->channel_request_open.type = SSH_CHANNEL_X11;\n    goto end;\n  }\n\n  if (strcmp(type_c,\"auth-agent@openssh.com\") == 0) {\n    msg->channel_request_open.type = SSH_CHANNEL_AUTH_AGENT;\n    goto end;\n  }\n\n  msg->channel_request_open.type = SSH_CHANNEL_UNKNOWN;\n  goto end;\n\nerror:\n  SSH_MESSAGE_FREE(msg);\nend:\n  SAFE_FREE(type_c);\n  if(msg != NULL)\n    ssh_message_queue(session,msg);\n\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 1307,
      "line_end": 1416,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 191,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses complex network input (SSH channel-open packets) and unpacks strings/integers from an untrusted buffer, performs string ops and casts, has multiple branches for channel types and stateful/authentication checks (can trigger disconnects). High security impact and good fuzzing surface (memory/format parsing, many code paths)."
    },
    {
      "name": "ssh_packet_global_request",
      "clean_name": "ssh_packet_global_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "\n    return SSH_OK;\n}\n\n#ifdef WITH_SERVER\nSSH_PACKET_CALLBACK(ssh_packet_global_request)\n{\n    ssh_message msg = NULL;\n    char *request = NULL;\n    uint8_t want_reply;\n    int rc = SSH_PACKET_USED;\n    int r;\n\n    (void)user;\n    (void)type;\n    (void)packet;\n\n    SSH_LOG(SSH_LOG_DEBUG,\"Received SSH_MSG_GLOBAL_REQUEST packet\");\n    r = ssh_buffer_unpack(packet, \"sb\", &request, &want_reply);\n    if (r != SSH_OK){\n        goto error;\n    }\n\n    msg = ssh_message_new(session);\n    if (msg == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    msg->type = SSH_REQUEST_GLOBAL;\n\n    if (strcmp(request, \"tcpip-forward\") == 0) {\n\n        /* According to RFC4254, the client SHOULD reject this message */\n        if (session->client) {\n            goto reply_with_failure;\n        }\n\n        r = ssh_buffer_unpack(packet,\n                              \"sd\",\n                              &msg->global_request.bind_address,\n                              &msg->global_request.bind_port);\n        if (r != SSH_OK){\n            goto reply_with_failure;\n        }\n        msg->global_request.type = SSH_GLOBAL_REQUEST_TCPIP_FORWARD;\n        msg->global_request.want_reply = want_reply;\n\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Received SSH_MSG_GLOBAL_REQUEST %s %hhu %s:%d\",\n                request,\n                want_reply,\n                msg->global_request.bind_address,\n                msg->global_request.bind_port);\n\n        if (ssh_callbacks_exists(session->common.callbacks,\n                                 global_request_function)) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Calling callback for SSH_MSG_GLOBAL_REQUEST %s %hhu %s:%d\",\n                    request,\n                    want_reply,\n                    msg->global_request.bind_address,\n                    msg->global_request.bind_port);\n            session->common.callbacks->global_request_function(\n                session,\n                msg,\n                session->common.callbacks->userdata);\n        } else {\n            SAFE_FREE(request);\n            ssh_message_queue(session, msg);\n            return rc;\n        }\n    } else if (strcmp(request, \"cancel-tcpip-forward\") == 0) {\n\n        /* According to RFC4254, the client SHOULD reject this message */\n        if (session->client) {\n            goto reply_with_failure;\n        }\n\n        r = ssh_buffer_unpack(packet,\n                              \"sd\",\n                              &msg->global_request.bind_address,\n                              &msg->global_request.bind_port);\n        if (r != SSH_OK){\n            goto reply_with_failure;\n        }\n        msg->global_request.type = SSH_GLOBAL_REQUEST_CANCEL_TCPIP_FORWARD;\n        msg->global_request.want_reply = want_reply;\n\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Received SSH_MSG_GLOBAL_REQUEST %s %hhu %s:%d\",\n                request,\n                want_reply,\n                msg->global_request.bind_address,\n                msg->global_request.bind_port);\n\n        if (ssh_callbacks_exists(session->common.callbacks,\n                                 global_request_function)) {\n            session->common.callbacks->global_request_function(\n                session,\n                msg,\n                session->common.callbacks->userdata);\n        } else {\n            SAFE_FREE(request);\n            ssh_message_queue(session, msg);\n            return rc;\n        }\n    } else if(strcmp(request, \"keepalive@openssh.com\") == 0) {\n        msg->global_request.type = SSH_GLOBAL_REQUEST_KEEPALIVE;\n        msg->global_request.want_reply = want_reply;\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Received keepalive@openssh.com %hhu\",\n                want_reply);\n        if (ssh_callbacks_exists(session->common.callbacks,\n                                 global_request_function)) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Calling callback for SSH_MSG_GLOBAL_REQUEST %s %hhu\",\n                    request,\n                    want_reply);\n            session->common.callbacks->global_request_function(\n                session,\n                msg,\n                session->common.callbacks->userdata);\n        } else if (want_reply) {\n            ssh_message_global_request_reply_success(msg, 0);\n        }\n    } else if (strcmp(request, \"no-more-sessions@openssh.com\") == 0) {\n        msg->global_request.type = SSH_GLOBAL_REQUEST_NO_MORE_SESSIONS;\n        msg->global_request.want_reply = want_reply;\n\n        SSH_LOG(SSH_LOG_PROTOCOL,\n                \"Received no-more-sessions@openssh.com %hhu\",\n                want_reply);\n        if (ssh_callbacks_exists(session->common.callbacks,\n                                 global_request_function)) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Calling callback for SSH_MSG_GLOBAL_REQUEST %s %hhu\",\n                    request,\n                    want_reply);\n            session->common.callbacks->global_request_function(\n                session,\n                msg,\n                session->common.callbacks->userdata);\n        } else if (want_reply) {\n            ssh_message_global_request_reply_success(msg, 0);\n        }\n\n        session->flags |= SSH_SESSION_FLAG_NO_MORE_SESSIONS;\n    } else {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"UNKNOWN SSH_MSG_GLOBAL_REQUEST %s, want_reply = %hhu\",\n                request,\n                want_reply);\n        goto reply_with_failure;\n    }\n\n    SAFE_FREE(msg);\n    SAFE_FREE(request);\n    return rc;\n\nreply_with_failure:\n    /* Only report the failure if requested */\n    if (want_reply) {\n        r = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_REQUEST_FAILURE);\n        if (r < 0) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n\n        r = ssh_packet_send(session);\n        if (r != SSH_OK) {\n            goto error;\n        }\n    } else {\n        SSH_LOG(SSH_LOG_PACKET,\n                \"The requester doesn't want to know the request failed!\");\n    }\n\n    /* Consume the message to avoid sending UNIMPLEMENTED later */\n    rc = SSH_PACKET_USED;\nerror:\n    SAFE_FREE(msg);\n    SAFE_FREE(request);\n    SSH_LOG(SSH_LOG_TRACE, \"Invalid SSH_MSG_GLOBAL_REQUEST packet\");\n    return rc;\n}\n",
      "line_start": 1686,
      "line_end": 1866,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 273,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses complex external input (SSH network packet), unpacks/copies strings and numeric fields from untrusted data, has multiple distinct branches/paths based on request strings and interacts with session state and reply logic \u2014 high-risk and a valuable fuzz target."
    },
    {
      "name": "messages.c:ssh_msg_userauth_build_digest",
      "clean_name": "ssh_msg_userauth_build_digest",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "\n/*\n * This function concats in a buffer the values needed to do a signature\n * verification.\n */\nstatic ssh_buffer ssh_msg_userauth_build_digest(ssh_session session,\n                                                ssh_message msg,\n                                                const char *service,\n                                                ssh_string algo,\n                                                const char *method)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    ssh_buffer buffer = NULL;\n    ssh_string str = NULL;\n    int rc;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto == NULL) {\n        return NULL;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        return NULL;\n    }\n    rc = ssh_pki_export_pubkey_blob(msg->auth_request.pubkey, &str);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(buffer);\n        return NULL;\n    }\n\n    rc = ssh_buffer_pack(buffer,\n                         \"dPbsssbsS\",\n                         (uint32_t)crypto->session_id_len, /* session ID string */\n                         crypto->session_id_len,\n                         crypto->session_id,\n                         SSH2_MSG_USERAUTH_REQUEST, /* type */\n                         msg->auth_request.username,\n                         service,\n                         method,\n                         1, /* has to be signed (true) */\n                         ssh_string_get_char(algo), /* pubkey algorithm */\n                         str);                      /* public key as a blob */\n\n    SSH_STRING_FREE(str);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(buffer);\n        return NULL;\n    }\n\n    /* Add server public key for hostbound extension */\n    if (strcmp(method, \"publickey-hostbound-v00@openssh.com\") == 0 &&\n        msg->auth_request.server_pubkey != NULL) {\n\n        rc = ssh_pki_export_pubkey_blob(msg->auth_request.server_pubkey, &str);\n        if (rc < 0) {\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n\n        rc = ssh_buffer_add_ssh_string(buffer, str);\n        SSH_STRING_FREE(str);\n        if (rc < 0) {\n            ssh_set_error_oom(session);\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n    }\n\n    return buffer;\n}\n",
      "line_start": 766,
      "line_end": 833,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 124,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Builds a signature verification digest from untrusted SSH message fields (public key blob, username, service, method) and session data, performing buffer packing/copies and conditional logic (hostbound extension). It is security/crypto-related and operates on external structured input, making it a high-value fuzzing target (critical priority)."
    },
    {
      "name": "ssh_options_set",
      "clean_name": "ssh_options_set",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " * @warning      If the value parameter has an invalid type (e.g if its not a\n *               pointer when it should have been a pointer, or if its a pointer\n *               to a pointer when it should have just been a pointer), then the\n *               behaviour is undefined.\n */\nint ssh_options_set(ssh_session session, enum ssh_options_e type,\n                    const void *value)\n{\n    const char *v = NULL;\n    char *p = NULL, *q = NULL;\n    long int i;\n    unsigned int u;\n    int rc;\n    char **wanted_methods = session->opts.wanted_methods;\n    struct ssh_jump_callbacks_struct *j = NULL;\n\n    if (session == NULL) {\n        return -1;\n    }\n\n    switch (type) {\n        case SSH_OPTIONS_HOST:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                char *username = NULL, *hostname = NULL;\n                rc = ssh_config_parse_uri(value, &username, &hostname, NULL, true);\n                if (rc != SSH_OK) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n                if (username != NULL) {\n                    SAFE_FREE(session->opts.username);\n                    session->opts.username = username;\n                }\n                if (hostname != NULL) {\n                    SAFE_FREE(session->opts.host);\n                    session->opts.host = hostname;\n                }\n            }\n            break;\n        case SSH_OPTIONS_PORT:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *) value;\n                if (*x <= 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->opts.port = *x & 0xffffU;\n            }\n            break;\n        case SSH_OPTIONS_PORT_STR:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                q = strdup(v);\n                if (q == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                i = strtol(q, &p, 10);\n                if (q == p) {\n                    SSH_LOG(SSH_LOG_DEBUG, \"No port number was parsed\");\n                    SAFE_FREE(q);\n                    return -1;\n                }\n                SAFE_FREE(q);\n                if (i <= 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->opts.port = i & 0xffffU;\n            }\n            break;\n        case SSH_OPTIONS_FD:\n            if (value == NULL) {\n                session->opts.fd = SSH_INVALID_SOCKET;\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                socket_t *x = (socket_t *) value;\n                if (*x < 0) {\n                    session->opts.fd = SSH_INVALID_SOCKET;\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->opts.fd = *x & 0xffff;\n            }\n            break;\n        case SSH_OPTIONS_BINDADDR:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            }\n\n            q = strdup(v);\n            if (q == NULL) {\n                return -1;\n            }\n            SAFE_FREE(session->opts.bindaddr);\n            session->opts.bindaddr = q;\n            break;\n        case SSH_OPTIONS_USER:\n            v = value;\n            SAFE_FREE(session->opts.username);\n            if (v == NULL) {\n                q = ssh_get_local_username();\n                if (q == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                session->opts.username = q;\n            } else if (v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else { /* username provided */\n                session->opts.username = strdup(value);\n                if (session->opts.username == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                rc = ssh_check_username_syntax(session->opts.username);\n                if (rc != SSH_OK) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n            }\n            break;\n        case SSH_OPTIONS_SSH_DIR:\n            v = value;\n            SAFE_FREE(session->opts.sshdir);\n            if (v == NULL) {\n                session->opts.sshdir = ssh_path_expand_tilde(\"~/.ssh\");\n                if (session->opts.sshdir == NULL) {\n                    return -1;\n                }\n            } else if (v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                session->opts.sshdir = ssh_path_expand_tilde(v);\n                if (session->opts.sshdir == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n            }\n            break;\n        case SSH_OPTIONS_IDENTITY:\n        case SSH_OPTIONS_ADD_IDENTITY:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            }\n            q = strdup(v);\n            if (q == NULL) {\n                return -1;\n            }\n            if (session->opts.exp_flags & SSH_OPT_EXP_FLAG_IDENTITY) {\n                rc = ssh_list_append(session->opts.identity_non_exp, q);\n            } else {\n                rc = ssh_list_prepend(session->opts.identity_non_exp, q);\n            }\n            if (rc < 0) {\n                free(q);\n                return -1;\n            }\n            break;\n        case SSH_OPTIONS_CERTIFICATE:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            }\n            q = strdup(v);\n            if (q == NULL) {\n                return -1;\n            }\n            rc = ssh_list_append(session->opts.certificate_non_exp, q);\n            if (rc < 0) {\n                free(q);\n                return -1;\n            }\n            break;\n        case SSH_OPTIONS_KNOWNHOSTS:\n            v = value;\n            SAFE_FREE(session->opts.knownhosts);\n            if (v == NULL) {\n                /* The default value will be set by the ssh_options_apply() */\n            } else if (v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                session->opts.knownhosts = strdup(v);\n                if (session->opts.knownhosts == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                session->opts.exp_flags &= ~SSH_OPT_EXP_FLAG_KNOWNHOSTS;\n            }\n            break;\n        case SSH_OPTIONS_GLOBAL_KNOWNHOSTS:\n            v = value;\n            SAFE_FREE(session->opts.global_knownhosts);\n            if (v == NULL) {\n                session->opts.global_knownhosts =\n                    strdup(\"/etc/ssh/ssh_known_hosts\");\n                if (session->opts.global_knownhosts == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n            } else if (v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                session->opts.global_knownhosts = strdup(v);\n                if (session->opts.global_knownhosts == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                session->opts.exp_flags &= ~SSH_OPT_EXP_FLAG_GLOBAL_KNOWNHOSTS;\n            }\n            break;\n        case SSH_OPTIONS_TIMEOUT:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                long *x = (long *) value;\n                if (*x < 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->opts.timeout = *x & 0xffffffffU;\n            }\n            break;\n        case SSH_OPTIONS_TIMEOUT_USEC:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                long *x = (long *) value;\n                if (*x < 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->opts.timeout_usec = *x & 0xffffffffU;\n            }\n            break;\n        case SSH_OPTIONS_SSH1:\n            break;\n        case SSH_OPTIONS_SSH2:\n            break;\n        case SSH_OPTIONS_LOG_VERBOSITY:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *) value;\n                if (*x < 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->common.log_verbosity = *x & 0xffffU;\n                ssh_set_log_level(*x & 0xffffU);\n            }\n            break;\n        case SSH_OPTIONS_LOG_VERBOSITY_STR:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                session->common.log_verbosity = 0;\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                q = strdup(v);\n                if (q == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                i = strtol(q, &p, 10);\n                if (q == p) {\n                    SSH_LOG(SSH_LOG_DEBUG, \"No log verbositiy was parsed\");\n                    SAFE_FREE(q);\n                    return -1;\n                }\n                SAFE_FREE(q);\n                if (i < 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                session->common.log_verbosity = i & 0xffffU;\n                ssh_set_log_level(i & 0xffffU);\n            }\n            break;\n        case SSH_OPTIONS_CIPHERS_C_S:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_CRYPT_C_S,\n                                          v,\n                                          &wanted_methods[SSH_CRYPT_C_S]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_CIPHERS_S_C:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_CRYPT_S_C,\n                                          v,\n                                          &wanted_methods[SSH_CRYPT_S_C]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_KEY_EXCHANGE:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_KEX,\n                                          v,\n                                          &wanted_methods[SSH_KEX]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_HOSTKEYS:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_HOSTKEYS,\n                                          v,\n                                          &wanted_methods[SSH_HOSTKEYS]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_PUBLICKEY_ACCEPTED_TYPES:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_HOSTKEYS,\n                                          v,\n                                          &session->opts.pubkey_accepted_types);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_HMAC_C_S:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_MAC_C_S,\n                                          v,\n                                          &wanted_methods[SSH_MAC_C_S]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n         case SSH_OPTIONS_HMAC_S_C:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_options_set_algo(session,\n                                          SSH_MAC_S_C,\n                                          v,\n                                          &wanted_methods[SSH_MAC_S_C]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_COMPRESSION_C_S:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                const char *tmp = v;\n                if (strcasecmp(value, \"yes\") == 0){\n                    tmp = \"zlib@openssh.com,none\";\n                } else if (strcasecmp(value, \"no\") == 0){\n                    tmp = \"none,zlib@openssh.com\";\n                }\n                rc = ssh_options_set_algo(session,\n                                          SSH_COMP_C_S,\n                                          tmp,\n                                          &wanted_methods[SSH_COMP_C_S]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_COMPRESSION_S_C:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                const char *tmp = v;\n                if (strcasecmp(value, \"yes\") == 0){\n                    tmp = \"zlib@openssh.com,none\";\n                } else if (strcasecmp(value, \"no\") == 0){\n                    tmp = \"none,zlib@openssh.com\";\n                }\n\n                rc = ssh_options_set_algo(session,\n                                          SSH_COMP_S_C,\n                                          tmp,\n                                          &wanted_methods[SSH_COMP_S_C]);\n                if (rc < 0)\n                    return -1;\n            }\n            break;\n        case SSH_OPTIONS_COMPRESSION:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            }\n            if(ssh_options_set(session,SSH_OPTIONS_COMPRESSION_C_S, v) < 0)\n                return -1;\n            if(ssh_options_set(session,SSH_OPTIONS_COMPRESSION_S_C, v) < 0)\n                return -1;\n            break;\n        case SSH_OPTIONS_COMPRESSION_LEVEL:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *)value;\n                if (*x < 1 || *x > 9) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n                session->opts.compressionlevel = *x & 0xff;\n            }\n            break;\n        case SSH_OPTIONS_STRICTHOSTKEYCHECK:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *) value;\n\n                session->opts.StrictHostKeyChecking = (*x & 0xff) > 0 ? 1 : 0;\n            }\n            break;\n        case SSH_OPTIONS_PROXYCOMMAND:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                SAFE_FREE(session->opts.ProxyCommand);\n                /* Setting the command to 'none' disables this option. */\n                rc = strcasecmp(v, \"none\");\n                if (rc != 0) {\n                    q = strdup(v);\n                    if (q == NULL) {\n                        return -1;\n                    }\n                    session->opts.ProxyCommand = q;\n                    session->opts.exp_flags &= ~SSH_OPT_EXP_FLAG_PROXYCOMMAND;\n                }\n            }\n            break;\n        case SSH_OPTIONS_PROXYJUMP:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                ssh_proxyjumps_free(session->opts.proxy_jumps);\n                rc = ssh_config_parse_proxy_jump(session, v, true);\n                if (rc != SSH_OK) {\n                    return SSH_ERROR;\n                }\n            }\n            break;\n        case SSH_OPTIONS_PROXYJUMP_CB_LIST_APPEND:\n            j = (struct ssh_jump_callbacks_struct *)value;\n            if (j == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                rc = ssh_list_prepend(session->opts.proxy_jumps_user_cb, j);\n                if (rc != SSH_OK) {\n                    ssh_set_error_oom(session);\n                    return SSH_ERROR;\n                }\n            }\n            break;\n        case SSH_OPTIONS_GSSAPI_SERVER_IDENTITY:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                SAFE_FREE(session->opts.gss_server_identity);\n                session->opts.gss_server_identity = strdup(v);\n                if (session->opts.gss_server_identity == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n            }\n            break;\n        case SSH_OPTIONS_GSSAPI_CLIENT_IDENTITY:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                SAFE_FREE(session->opts.gss_client_identity);\n                session->opts.gss_client_identity = strdup(v);\n                if (session->opts.gss_client_identity == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n            }\n            break;\n        case SSH_OPTIONS_GSSAPI_DELEGATE_CREDENTIALS:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int x = *(int *)value;\n\n                session->opts.gss_delegate_creds = (x & 0xff);\n            }\n            break;\n        case SSH_OPTIONS_PASSWORD_AUTH:\n        case SSH_OPTIONS_PUBKEY_AUTH:\n        case SSH_OPTIONS_KBDINT_AUTH:\n        case SSH_OPTIONS_GSSAPI_AUTH:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int x = *(int *)value;\n                u = type == SSH_OPTIONS_PASSWORD_AUTH ?\n                    SSH_OPT_FLAG_PASSWORD_AUTH:\n                    type == SSH_OPTIONS_PUBKEY_AUTH ?\n                        SSH_OPT_FLAG_PUBKEY_AUTH:\n                        type == SSH_OPTIONS_KBDINT_AUTH ?\n                            SSH_OPT_FLAG_KBDINT_AUTH:\n                            SSH_OPT_FLAG_GSSAPI_AUTH;\n                if (x != 0){\n                    session->opts.flags |= u;\n                } else {\n                    session->opts.flags &= ~u;\n                }\n            }\n            break;\n        case SSH_OPTIONS_NODELAY:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *) value;\n                session->opts.nodelay = (*x & 0xff) > 0 ? 1 : 0;\n            }\n            break;\n        case SSH_OPTIONS_PROCESS_CONFIG:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                bool *x = (bool *)value;\n                session->opts.config_processed = !(*x);\n            }\n            break;\n        case SSH_OPTIONS_REKEY_DATA:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                uint64_t *x = (uint64_t *)value;\n                session->opts.rekey_data = *x;\n            }\n            break;\n        case SSH_OPTIONS_REKEY_TIME:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                uint32_t *x = (uint32_t *)value;\n                if ((*x * 1000) < *x) {\n                    ssh_set_error(session, SSH_REQUEST_DENIED,\n                                  \"The provided value (%\" PRIu32 \") for rekey\"\n                                  \" time is too large\", *x);\n                    return -1;\n                }\n                session->opts.rekey_time = (*x) * 1000;\n            }\n            break;\n        case SSH_OPTIONS_RSA_MIN_SIZE:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *)value;\n\n                if (*x < 0) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n\n                /* (*x == 0) is allowed as it is used to revert to default */\n\n                if (*x > 0 && *x < RSA_MIN_KEY_SIZE) {\n                    ssh_set_error(session,\n                                  SSH_REQUEST_DENIED,\n                                  \"The provided value (%d) for minimal RSA key \"\n                                  \"size is too small. Use at least %d bits.\",\n                                  *x,\n                                  RSA_MIN_KEY_SIZE);\n                    return -1;\n                }\n                session->opts.rsa_min_size = *x;\n            }\n            break;\n        case SSH_OPTIONS_IDENTITY_AGENT:\n            v = value;\n            SAFE_FREE(session->opts.agent_socket);\n            if (v == NULL) {\n                /* The default value will be set by the ssh_options_apply() */\n            } else if (v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                session->opts.agent_socket = ssh_path_expand_tilde(v);\n                if (session->opts.agent_socket == NULL) {\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n            }\n            break;\n        case SSH_OPTIONS_IDENTITIES_ONLY:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                bool *x = (bool *)value;\n                session->opts.identities_only = *x;\n            }\n            break;\n        case SSH_OPTIONS_CONTROL_MASTER:\n            if (value == NULL) {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                int *x = (int *) value;\n                if (*x < SSH_CONTROL_MASTER_NO || *x > SSH_CONTROL_MASTER_AUTOASK) {\n                    ssh_set_error_invalid(session);\n                    return -1;\n                }\n                session->opts.control_master = *x;\n            }\n            break;\n        case SSH_OPTIONS_CONTROL_PATH:\n            v = value;\n            if (v == NULL || v[0] == '\\0') {\n                ssh_set_error_invalid(session);\n                return -1;\n            } else {\n                SAFE_FREE(session->opts.control_path);\n                rc = strcasecmp(v, \"none\");\n                if (rc != 0) {\n                    session->opts.control_path = ssh_path_expand_tilde(v);\n                    if (session->opts.control_path == NULL) {\n                        ssh_set_error_oom(session);\n                        return -1;\n                    }\n                    session->opts.exp_flags &= ~SSH_OPT_EXP_FLAG_CONTROL_PATH;\n                }\n            }\n            break;\n        default:\n            ssh_set_error(session, SSH_REQUEST_DENIED, \"Unknown ssh option %d\", type);\n            return -1;\n            break;\n    }\n\n    return 0;\n}\n",
      "line_start": 652,
      "line_end": 1367,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1174,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "High-value fuzz target: very high cyclomatic complexity with dozens of branches, handles many string/memory ops on untrusted data (strdup, strtol, strcpy-like logic), performs type conversions and parsing (URIs, algorithm lists, proxy jumps), and controls authentication/cryptography-related options. Calls into other parsers (increasing attack surface)."
    },
    {
      "name": "ssh_bind_options_set",
      "clean_name": "ssh_bind_options_set",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *                      not a pointer when it should have been a pointer, or if\n *                      its a pointer to a pointer when it should have just been\n *                      a pointer), then the behaviour is undefined.\n */\nint\nssh_bind_options_set(ssh_bind sshbind,\n                     enum ssh_bind_options_e type,\n                     const void *value)\n{\n    bool allowed;\n    char *p = NULL, *q = NULL;\n    const char *v = NULL;\n    int i, rc;\n    char **wanted_methods = sshbind->wanted_methods;\n\n    if (sshbind == NULL) {\n        return -1;\n    }\n\n    switch (type) {\n    case SSH_BIND_OPTIONS_RSAKEY:\n    case SSH_BIND_OPTIONS_ECDSAKEY:\n        /* deprecated */\n    case SSH_BIND_OPTIONS_HOSTKEY:\n    case SSH_BIND_OPTIONS_IMPORT_KEY:\n    case SSH_BIND_OPTIONS_IMPORT_KEY_STR:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            int key_type;\n            ssh_key *bind_key_loc = NULL;\n            ssh_key key = NULL;\n            char **bind_key_path_loc = NULL;\n\n            if (type == SSH_BIND_OPTIONS_IMPORT_KEY_STR) {\n                const char *key_str = (const char *)value;\n                rc = ssh_pki_import_privkey_base64(key_str,\n                                                   NULL,\n                                                   NULL,\n                                                   NULL,\n                                                   &key);\n                if (rc == SSH_ERROR) {\n                    ssh_set_error(sshbind,\n                                  SSH_FATAL,\n                                  \"Failed to import key from buffer\");\n                    return -1;\n                }\n            } else if (type == SSH_BIND_OPTIONS_IMPORT_KEY) {\n                key = (ssh_key)value;\n            } else {\n                rc = ssh_pki_import_privkey_file(value, NULL, NULL, NULL, &key);\n                if (rc != SSH_OK) {\n                    return -1;\n                }\n            }\n            allowed = ssh_bind_key_size_allowed(sshbind, key);\n            if (!allowed) {\n                ssh_set_error(sshbind,\n                              SSH_FATAL,\n                              \"The host key size %d is too small.\",\n                              ssh_key_size(key));\n                if (type != SSH_BIND_OPTIONS_IMPORT_KEY) {\n                    SSH_KEY_FREE(key);\n                }\n                return -1;\n            }\n            key_type = ssh_key_type(key);\n            switch (key_type) {\n            case SSH_KEYTYPE_ECDSA_P256:\n            case SSH_KEYTYPE_ECDSA_P384:\n            case SSH_KEYTYPE_ECDSA_P521:\n#ifdef HAVE_ECC\n                bind_key_loc = &sshbind->ecdsa;\n                bind_key_path_loc = &sshbind->ecdsakey;\n#else\n                ssh_set_error(sshbind,\n                              SSH_FATAL,\n                              \"ECDSA key used and libssh compiled \"\n                              \"without ECDSA support\");\n#endif\n                break;\n            case SSH_KEYTYPE_RSA:\n                bind_key_loc = &sshbind->rsa;\n                bind_key_path_loc = &sshbind->rsakey;\n                break;\n            case SSH_KEYTYPE_ED25519:\n                bind_key_loc = &sshbind->ed25519;\n                bind_key_path_loc = &sshbind->ed25519key;\n                break;\n            default:\n                ssh_set_error(sshbind,\n                              SSH_FATAL,\n                              \"Unsupported key type %d\",\n                              key_type);\n            }\n            if (type == SSH_BIND_OPTIONS_RSAKEY ||\n                type == SSH_BIND_OPTIONS_ECDSAKEY ||\n                type == SSH_BIND_OPTIONS_HOSTKEY) {\n                if (bind_key_loc == NULL) {\n                    ssh_key_free(key);\n                    return -1;\n                }\n                /* Set the location of the key on disk even though we don't\n                   need it in case some other function wants it */\n                rc = ssh_bind_set_key(sshbind, bind_key_path_loc, value);\n                if (rc < 0) {\n                    ssh_key_free(key);\n                    return -1;\n                }\n            } else if (type == SSH_BIND_OPTIONS_IMPORT_KEY_STR) {\n                if (bind_key_loc == NULL) {\n                    ssh_key_free(key);\n                    return -1;\n                }\n            } else {\n                if (bind_key_loc == NULL) {\n                    return -1;\n                }\n            }\n            ssh_key_free(*bind_key_loc);\n            *bind_key_loc = key;\n        }\n        break;\n    case SSH_BIND_OPTIONS_BINDADDR:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            SAFE_FREE(sshbind->bindaddr);\n            sshbind->bindaddr = strdup(value);\n            if (sshbind->bindaddr == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_BINDPORT:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            int *x = (int *)value;\n            sshbind->bindport = *x & 0xffffU;\n        }\n        break;\n    case SSH_BIND_OPTIONS_BINDPORT_STR:\n        if (value == NULL) {\n            sshbind->bindport = 22 & 0xffffU;\n        } else {\n            q = strdup(value);\n            if (q == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n            i = strtol(q, &p, 10);\n            if (q == p) {\n                SSH_LOG(SSH_LOG_DEBUG, \"No bind port was parsed\");\n                SAFE_FREE(q);\n                return -1;\n            }\n            SAFE_FREE(q);\n\n            sshbind->bindport = i & 0xffffU;\n        }\n        break;\n    case SSH_BIND_OPTIONS_LOG_VERBOSITY:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            int *x = (int *)value;\n            ssh_set_log_level(*x & 0xffffU);\n        }\n        break;\n    case SSH_BIND_OPTIONS_LOG_VERBOSITY_STR:\n        if (value == NULL) {\n            ssh_set_log_level(0);\n        } else {\n            q = strdup(value);\n            if (q == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n            i = strtol(q, &p, 10);\n            if (q == p) {\n                SSH_LOG(SSH_LOG_DEBUG, \"No log verbositiy was parsed\");\n                SAFE_FREE(q);\n                return -1;\n            }\n            SAFE_FREE(q);\n\n            ssh_set_log_level(i & 0xffffU);\n        }\n        break;\n    case SSH_BIND_OPTIONS_BANNER:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            SAFE_FREE(sshbind->banner);\n            sshbind->banner = strdup(value);\n            if (sshbind->banner == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_CIPHERS_C_S:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_CRYPT_C_S,\n                                   v,\n                                   &wanted_methods[SSH_CRYPT_C_S]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_CIPHERS_S_C:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_CRYPT_S_C,\n                                   v,\n                                   &wanted_methods[SSH_CRYPT_S_C]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_KEY_EXCHANGE:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_KEX,\n                                   v,\n                                   &wanted_methods[SSH_KEX]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_HMAC_C_S:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_MAC_C_S,\n                                   v,\n                                   &wanted_methods[SSH_MAC_C_S]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_HMAC_S_C:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_MAC_S_C,\n                                   v,\n                                   &wanted_methods[SSH_MAC_S_C]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_CONFIG_DIR:\n        v = value;\n        SAFE_FREE(sshbind->config_dir);\n        if (v == NULL) {\n            break;\n        } else if (v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            sshbind->config_dir = ssh_path_expand_tilde(v);\n            if (sshbind->config_dir == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_PUBKEY_ACCEPTED_KEY_TYPES:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_HOSTKEYS,\n                                   v,\n                                   &sshbind->pubkey_accepted_key_types);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_HOSTKEY_ALGORITHMS:\n        v = value;\n        if (v == NULL || v[0] == '\\0') {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            rc = ssh_bind_set_algo(sshbind,\n                                   SSH_HOSTKEYS,\n                                   v,\n                                   &wanted_methods[SSH_HOSTKEYS]);\n            if (rc < 0) {\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_PROCESS_CONFIG:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            bool *x = (bool *)value;\n            sshbind->config_processed = !(*x);\n        }\n        break;\n    case SSH_BIND_OPTIONS_MODULI:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            SAFE_FREE(sshbind->moduli_file);\n            sshbind->moduli_file = strdup(value);\n            if (sshbind->moduli_file == NULL) {\n                ssh_set_error_oom(sshbind);\n                return -1;\n            }\n        }\n        break;\n    case SSH_BIND_OPTIONS_RSA_MIN_SIZE:\n        if (value == NULL) {\n            ssh_set_error_invalid(sshbind);\n            return -1;\n        } else {\n            int *x = (int *)value;\n\n            if (*x < 0) {\n                ssh_set_error_invalid(sshbind);\n                return -1;\n            }\n\n            /* (*x == 0) is allowed as it is used to revert to default */\n\n            if (*x > 0 && *x < RSA_MIN_KEY_SIZE) {\n                ssh_set_error(sshbind,\n                              SSH_REQUEST_DENIED,\n                              \"The provided value (%d) for minimal RSA key \"\n                              \"size is too small. Use at least %d bits.\",\n                              *x,\n                              RSA_MIN_KEY_SIZE);\n                return -1;\n            }\n            sshbind->rsa_min_size = *x;\n        }\n        break;\n    default:\n        ssh_set_error(sshbind,\n                      SSH_REQUEST_DENIED,\n                      \"Unknown ssh option %d\",\n                      type);\n        return -1;\n        break;\n    }\n\n    return 0;\n}\n",
      "line_start": 2235,
      "line_end": 2618,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 538,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "High-value target: accepts many forms of external input (strings, paths, integer strings, base64/key blobs), imports/parses private keys (crypto-critical), performs memory operations (strdup, frees, key allocation), and has extensive branching/validation logic. This combination makes it likely to contain memory/logic bugs and security-relevant issues\u2014critical for fuzzing."
    },
    {
      "name": "ssh_packet_set_newkeys",
      "clean_name": "ssh_packet_set_newkeys",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "/*\n * Once we got SSH2_MSG_NEWKEYS we can switch next_crypto and\n * current_crypto for our desired direction\n */\nint\nssh_packet_set_newkeys(ssh_session session,\n                       enum ssh_crypto_direction_e direction)\n{\n    struct ssh_cipher_struct *in_cipher = NULL, *out_cipher = NULL;\n    int rc;\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"called, direction =%s%s\",\n            direction & SSH_DIRECTION_IN ? \" IN \" : \"\",\n            direction & SSH_DIRECTION_OUT ? \" OUT \" : \"\");\n\n    if (session->next_crypto == NULL) {\n        return SSH_ERROR;\n    }\n\n    session->next_crypto->used |= direction;\n    if (session->current_crypto != NULL) {\n        if (session->current_crypto->used & direction) {\n            SSH_LOG(SSH_LOG_TRACE, \"This direction isn't used anymore.\");\n        }\n        /* Mark the current requested direction unused */\n        session->current_crypto->used &= ~direction;\n    }\n\n    /* Both sides switched: do the actual switch now */\n    if (session->next_crypto->used == SSH_DIRECTION_BOTH) {\n        size_t session_id_len;\n\n        if (session->current_crypto != NULL) {\n            crypto_free(session->current_crypto);\n            session->current_crypto = NULL;\n        }\n\n        session->current_crypto = session->next_crypto;\n        session->current_crypto->used = SSH_DIRECTION_BOTH;\n\n        /* Initialize the next_crypto structure */\n        session->next_crypto = crypto_new();\n        if (session->next_crypto == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n\n        session_id_len = session->current_crypto->session_id_len;\n        session->next_crypto->session_id = malloc(session_id_len);\n        if (session->next_crypto->session_id == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n\n        memcpy(session->next_crypto->session_id,\n               session->current_crypto->session_id,\n               session_id_len);\n        session->next_crypto->session_id_len = session_id_len;\n\n        return SSH_OK;\n    }\n\n    /* Initialize common structures so the next context can be used in\n     * either direction */\n    if (session->client) {\n        /* The server has this part already done */\n        rc = ssh_make_sessionid(session);\n        if (rc != SSH_OK) {\n            return SSH_ERROR;\n        }\n\n        /*\n         * Set the cryptographic functions for the next crypto\n         * (it is needed for ssh_generate_session_keys for key lengths)\n         */\n        rc = crypt_set_algorithms_client(session);\n        if (rc < 0) {\n            return SSH_ERROR;\n        }\n    }\n\n    if (ssh_generate_session_keys(session) < 0) {\n        return SSH_ERROR;\n    }\n\n    in_cipher = session->next_crypto->in_cipher;\n    out_cipher = session->next_crypto->out_cipher;\n    if (in_cipher == NULL || out_cipher == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* Initialize rekeying states */\n    ssh_init_rekey_state(session, out_cipher);\n    ssh_init_rekey_state(session, in_cipher);\n    if (session->opts.rekey_time != 0) {\n        ssh_timestamp_init(&session->last_rekey_time);\n        SSH_LOG(SSH_LOG_DEBUG, \"Set rekey after %\" PRIu32 \" seconds\",\n                session->opts.rekey_time/1000);\n    }\n\n    if (in_cipher->set_decrypt_key) {\n        /* Initialize the encryption and decryption keys in next_crypto */\n        rc = in_cipher->set_decrypt_key(in_cipher,\n                                        session->next_crypto->decryptkey,\n                                        session->next_crypto->decryptIV);\n        if (rc < 0) {\n            /* On error, make sure it is not used */\n            session->next_crypto->used = 0;\n            return SSH_ERROR;\n        }\n    }\n\n    if (out_cipher->set_encrypt_key) {\n        rc = out_cipher->set_encrypt_key(out_cipher,\n                                         session->next_crypto->encryptkey,\n                                         session->next_crypto->encryptIV);\n        if (rc < 0) {\n            /* On error, make sure it is not used */\n            session->next_crypto->used = 0;\n            return SSH_ERROR;\n        }\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 2053,
      "line_end": 2174,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 149,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Security-critical crypto state switch: touches authentication/crypto paths, performs malloc/memcpy on session-provided buffers, calls cipher function pointers to set keys, and contains multiple branches for direction/current/next states. High value for fuzzing (memory ops + crypto + branching), though a harness is needed to build valid session state."
    },
    {
      "name": "packet.c:ssh_packet_need_rekey",
      "clean_name": "ssh_packet_need_rekey",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "    return NULL;\n}\n\n#define MAX_PACKETS    (1UL<<31)\n\nstatic bool ssh_packet_need_rekey(ssh_session session,\n                                  const uint32_t payloadsize)\n{\n    bool data_rekey_needed = false;\n    struct ssh_crypto_struct *crypto = NULL;\n    struct ssh_cipher_struct *out_cipher = NULL, *in_cipher = NULL;\n    uint32_t next_blocks;\n\n    /* We can safely rekey only in authenticated state */\n    if ((session->flags & SSH_SESSION_FLAG_AUTHENTICATED) == 0) {\n        return false;\n    }\n\n    /* Do not rekey if the rekey/key-exchange is in progress */\n    if (session->dh_handshake_state != DH_STATE_FINISHED) {\n        return false;\n    }\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_BOTH);\n    if (crypto == NULL) {\n        return false;\n    }\n\n    out_cipher = crypto->out_cipher;\n    in_cipher = crypto->in_cipher;\n\n    /* Make sure we can send at least something for very small limits */\n    if ((out_cipher->packets == 0) && (in_cipher->packets == 0)) {\n        return false;\n    }\n\n    /* Time based rekeying */\n    if (session->opts.rekey_time != 0 &&\n        ssh_timeout_elapsed(&session->last_rekey_time,\n                            session->opts.rekey_time)) {\n        return true;\n    }\n\n    /* RFC4344, Section 3.1 Recommends rekeying after 2^31 packets in either\n     * direction to avoid possible information leakage through the MAC tag\n     */\n    if (out_cipher->packets > MAX_PACKETS ||\n        in_cipher->packets > MAX_PACKETS) {\n        return true;\n    }\n\n    /* Data-based rekeying:\n     *  * For outgoing packets we can still delay them\n     *  * Incoming packets need to be processed anyway, but we can\n     *    signalize our intention to rekey\n     */\n    next_blocks = payloadsize / out_cipher->blocksize;\n    data_rekey_needed = (out_cipher->max_blocks != 0 &&\n                         out_cipher->blocks + next_blocks > out_cipher->max_blocks) ||\n                         (in_cipher->max_blocks != 0 &&\n                         in_cipher->blocks + next_blocks > in_cipher->max_blocks);\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"rekey: [data_rekey_needed=%d, out_blocks=%\" PRIu64 \", in_blocks=%\" PRIu64 \"]\",\n            data_rekey_needed,\n            out_cipher->blocks + next_blocks,\n            in_cipher->blocks + next_blocks);\n\n    return data_rekey_needed;\n}\n",
      "line_start": 1075,
      "line_end": 1140,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 80,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "High-value fuzz target: this function makes security-critical rekey decisions based on complex, attacker-controllable session state and payloadsize. It reads many crypto/session fields and has multiple branches (auth state, handshake state, time-based, packet-count, data-based). It performs arithmetic (including division by out_cipher->blocksize) and comparisons that can trigger edge cases (division-by-zero, integer overflow/underflow, off-by-one logic), making it likely to reveal logic bugs or crashes important to SSH key management."
    },
    {
      "name": "packet.c:packet_send2",
      "clean_name": "packet_send2",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "      ssh_buffer_get_len(session->out_buffer));\n\n  return rc;\n}\n\nstatic int packet_send2(ssh_session session)\n{\n    unsigned int blocksize = 8;\n    unsigned int lenfield_blocksize = 0;\n    enum ssh_hmac_e hmac_type;\n    uint32_t currentlen = ssh_buffer_get_len(session->out_buffer);\n    struct ssh_crypto_struct *crypto = NULL;\n    unsigned char *hmac = NULL;\n    uint8_t padding_data[32] = { 0 };\n    uint8_t padding_size;\n    uint32_t finallen, payloadsize, compsize;\n    uint8_t header[5] = {0};\n    uint8_t type, *payload;\n    int rc = SSH_ERROR;\n    bool etm = false;\n    int etm_packet_offset = 0;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n    if (crypto) {\n        blocksize = crypto->out_cipher->blocksize;\n        lenfield_blocksize = crypto->out_cipher->lenfield_blocksize;\n        hmac_type = crypto->out_hmac;\n        etm = crypto->out_hmac_etm;\n    } else {\n        hmac_type = session->next_crypto->out_hmac;\n    }\n\n    payload = (uint8_t *)ssh_buffer_get(session->out_buffer);\n    type = payload[0]; /* type is the first byte of the packet now */\n\n    payloadsize = currentlen;\n    if (etm) {\n        etm_packet_offset = sizeof(uint32_t);\n        lenfield_blocksize = 0;\n    }\n\n    if (crypto != NULL && crypto->do_compress_out &&\n        ssh_buffer_get_len(session->out_buffer) > 0) {\n        rc = compress_buffer(session,session->out_buffer);\n        if (rc < 0) {\n            goto error;\n        }\n        currentlen = ssh_buffer_get_len(session->out_buffer);\n    }\n    compsize = currentlen;\n    /* compressed payload + packet len (4) + padding_size len (1) */\n    /* totallen - lenfield_blocksize - etm_packet_offset must be equal to 0 (mod blocksize) */\n    padding_size = (blocksize - ((blocksize - lenfield_blocksize - etm_packet_offset + currentlen + 5) % blocksize));\n    if (padding_size < 4) {\n        padding_size += blocksize;\n    }\n\n    if (crypto != NULL) {\n        int ok;\n\n        ok = ssh_get_random(padding_data, padding_size, 0);\n        if (!ok) {\n            ssh_set_error(session, SSH_FATAL, \"PRNG error\");\n            goto error;\n        }\n    }\n\n    finallen = currentlen - etm_packet_offset + padding_size + 1;\n\n    PUSH_BE_U32(header, 0, finallen);\n    PUSH_BE_U8(header, 4, padding_size);\n\n    rc = ssh_buffer_prepend_data(session->out_buffer,\n                                 header,\n                                 sizeof(header));\n    if (rc < 0) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_data(session->out_buffer, padding_data, padding_size);\n    if (rc < 0) {\n        goto error;\n    }\n\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               ssh_buffer_get(session->out_buffer),\n                               ssh_buffer_get_len(session->out_buffer),\n                               ssh_buffer_get_len(session->out_buffer));\n    }\n#endif\n\n    hmac = ssh_packet_encrypt(session,\n                              ssh_buffer_get(session->out_buffer),\n                              ssh_buffer_get_len(session->out_buffer));\n    /* XXX This returns null before switching on crypto, with none MAC\n     * and on various errors.\n     * We should distinguish between these cases to avoid hiding errors. */\n    if (hmac != NULL) {\n        rc = ssh_buffer_add_data(session->out_buffer,\n                                 hmac,\n                                 (uint32_t)hmac_digest_len(hmac_type));\n        if (rc < 0) {\n            goto error;\n        }\n    }\n\n    rc = ssh_packet_write(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    session->send_seq++;\n    if (crypto != NULL) {\n        struct ssh_cipher_struct *cipher = NULL;\n\n        cipher = crypto->out_cipher;\n        cipher->packets++;\n        cipher->blocks += payloadsize / cipher->blocksize;\n    }\n    if (session->raw_counter != NULL) {\n        session->raw_counter->out_bytes += payloadsize;\n        session->raw_counter->out_packets++;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"packet: wrote [type=%u, len=%\" PRIu32 \", padding_size=%hhd, comp=%\" PRIu32 \", \"\n            \"payload=%\" PRIu32 \"]\",\n            type,\n            finallen,\n            padding_size,\n            compsize,\n            payloadsize);\n\n    rc = ssh_buffer_reinit(session->out_buffer);\n    if (rc < 0) {\n        rc = SSH_ERROR;\n        goto error;\n    }\n\n    /* We sent the NEWKEYS so any further packet needs to be encrypted\n     * with the new keys. We can not switch both directions (need to decrypt\n     * peer NEWKEYS) and we do not want to wait for the peer NEWKEYS\n     * too, so we will switch only the OUT direction now.\n     */\n    if (type == SSH2_MSG_NEWKEYS) {\n        rc = ssh_packet_set_newkeys(session, SSH_DIRECTION_OUT);\n    }\nerror:\n    return rc; /* SSH_OK, AGAIN or ERROR */\n}\n",
      "line_start": 1762,
      "line_end": 1909,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 146,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "High-value fuzz target: builds SSH packets from session->out_buffer (untrusted), performs many memory operations (prepend/add), computes padding, uses PRNG, compression, encryption and HMAC (security/crypto-critical), and has multiple branches (crypto vs none, ETM, compression). Also contains risky accesses (e.g. payload[0] without explicit length check) and complex size arithmetic \u2014 likely to expose memory, integer/length, and crypto-state bugs."
    },
    {
      "name": "ssh_packet_newkeys",
      "clean_name": "ssh_packet_newkeys",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "    SAFE_FREE(message);\n\n    return SSH_PACKET_USED;\n}\n\nSSH_PACKET_CALLBACK(ssh_packet_newkeys)\n{\n    ssh_string sig_blob = NULL;\n    ssh_signature sig = NULL;\n    int rc;\n\n    (void)packet;\n    (void)user;\n    (void)type;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Received SSH_MSG_NEWKEYS\");\n\n    if (session->session_state != SSH_SESSION_STATE_DH ||\n        session->dh_handshake_state != DH_STATE_NEWKEYS_SENT) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"ssh_packet_newkeys called in wrong state : %d:%d\",\n                      session->session_state,\n                      session->dh_handshake_state);\n        goto error;\n    }\n\n    if (session->flags & SSH_SESSION_FLAG_KEX_STRICT) {\n        /* reset packet sequence number when running in strict kex mode */\n        session->recv_seq = 0;\n        /* Check that we aren't tainted */\n        if (session->flags & SSH_SESSION_FLAG_KEX_TAINTED) {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Received unexpected packets in strict KEX mode.\");\n            goto error;\n        }\n    }\n\n    if (session->server) {\n        /* server things are done in server.c */\n        session->dh_handshake_state=DH_STATE_FINISHED;\n    } else {\n        ssh_key server_key = NULL;\n\n        /* client */\n\n        /* Verify the host's signature. FIXME do it sooner */\n        sig_blob = session->next_crypto->dh_server_signature;\n        session->next_crypto->dh_server_signature = NULL;\n\n        /* get the server public key */\n        server_key = ssh_dh_get_next_server_publickey(session);\n        if (server_key == NULL) {\n            goto error;\n        }\n\n        rc = ssh_pki_import_signature_blob(sig_blob, server_key, &sig);\n        ssh_string_burn(sig_blob);\n        SSH_STRING_FREE(sig_blob);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n\n        /* Check if signature from server matches user preferences */\n        if (session->opts.wanted_methods[SSH_HOSTKEYS]) {\n            rc = match_group(session->opts.wanted_methods[SSH_HOSTKEYS],\n                             sig->type_c);\n            if (rc == 0) {\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Public key from server (%s) doesn't match user \"\n                              \"preference (%s)\",\n                              sig->type_c,\n                              session->opts.wanted_methods[SSH_HOSTKEYS]);\n                goto error;\n            }\n        }\n\n        rc = ssh_pki_signature_verify(session,\n                                      sig,\n                                      server_key,\n                                      session->next_crypto->secret_hash,\n                                      session->next_crypto->digest_len);\n        SSH_SIGNATURE_FREE(sig);\n        if (rc == SSH_ERROR) {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Failed to verify server hostkey signature\");\n            goto error;\n        }\n        SSH_LOG(SSH_LOG_DEBUG, \"Signature verified and valid\");\n\n        /* When receiving this packet, we switch on the incoming crypto. */\n        rc = ssh_packet_set_newkeys(session, SSH_DIRECTION_IN);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n    }\n    session->dh_handshake_state = DH_STATE_FINISHED;\n    session->ssh_connection_callback(session);\n    return SSH_PACKET_USED;\n\nerror:\n    SSH_SIGNATURE_FREE(sig);\n    ssh_string_burn(sig_blob);\n    SSH_STRING_FREE(sig_blob);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 137,
      "line_end": 242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 124,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Handles security-critical SSH NEWKEYS processing: consumes untrusted signature blob from the network, imports/parses and verifies signatures, checks hostkey algorithm preferences and drives crypto state transitions. This is high-risk authentication/crypto code with multiple branches and external-input-dependent logic \u2014 a strong fuzz target."
    },
    {
      "name": "ssh_packet_decrypt_len",
      "clean_name": "ssh_packet_decrypt_len",
      "source_file": "/src/libssh/src/packet_crypt.c",
      "source_code": "/** @internal\n * @brief decrypt the packet length from a raw encrypted packet, and store the first decrypted\n * blocksize.\n * @returns native byte-ordered decrypted length of the upcoming packet\n */\nuint32_t ssh_packet_decrypt_len(ssh_session session,\n                                uint8_t *destination,\n                                uint8_t *source)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    uint32_t decrypted;\n    int rc;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto != NULL) {\n        if (crypto->in_cipher->aead_decrypt_length != NULL) {\n            rc = crypto->in_cipher->aead_decrypt_length(\n                    crypto->in_cipher, source, destination,\n                    crypto->in_cipher->lenfield_blocksize,\n                    session->recv_seq);\n        } else {\n            rc = ssh_packet_decrypt(\n                    session,\n                    destination,\n                    source,\n                    0,\n                    crypto->in_cipher->blocksize);\n        }\n        if (rc < 0) {\n            return 0;\n        }\n    } else {\n        memcpy(destination, source, 8);\n    }\n    memcpy(&decrypted,destination,sizeof(decrypted));\n\n    return ntohl(decrypted);\n}\n",
      "line_start": 51,
      "line_end": 84,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses SSH protocol packet length (network protocol) and invokes cipher-specific decryption routines on untrusted data. Performs memcpy of external input, branches on cipher/AES-GCM vs non-AEAD, and returns a host-order length used for further parsing \u2014 high value for fuzzing because malformed crypto input or length fields can drive downstream bugs."
    },
    {
      "name": "ssh_packet_decrypt",
      "clean_name": "ssh_packet_decrypt",
      "source_file": "/src/libssh/src/packet_crypt.c",
      "source_code": " * @brief decrypts the content of an SSH packet.\n * @param[source] source packet, including the encrypted length field\n * @param[start] index in the packet that was not decrypted yet.\n * @param[encrypted_size] size of the encrypted data to be decrypted after start.\n */\nint ssh_packet_decrypt(ssh_session session,\n                       uint8_t *destination,\n                       uint8_t *source,\n                       size_t start,\n                       size_t encrypted_size)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    struct ssh_cipher_struct *cipher = NULL;\n\n    if (encrypted_size <= 0) {\n        return SSH_ERROR;\n    }\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto == NULL) {\n        return SSH_ERROR;\n    }\n    cipher = crypto->in_cipher;\n\n    if (encrypted_size % cipher->blocksize != 0) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Cryptographic functions must be used on multiple of \"\n                      \"blocksize (received %zu)\",\n                      encrypted_size);\n        return SSH_ERROR;\n    }\n\n    if (cipher->aead_decrypt != NULL) {\n        return cipher->aead_decrypt(cipher,\n                                    source,\n                                    destination,\n                                    encrypted_size,\n                                    session->recv_seq);\n    } else {\n        cipher->decrypt(cipher, source + start, destination, encrypted_size);\n    }\n\n    return 0;\n}\n",
      "line_start": 91,
      "line_end": 131,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Decrypts untrusted packet data and invokes cipher routines (memory writes/reads) in a security-critical path. It performs input-dependent checks (blocksize modulus), branches between AEAD and legacy decrypt, and uses session state (recv_seq). While small, it operates on external input and calls into complex crypto code\u2014high-value fuzzing target for memory/logic bugs and crypto misuse; minor lack of explicit bounds checks on start/length increases importance."
    },
    {
      "name": "ssh_packet_hmac_verify",
      "clean_name": "ssh_packet_hmac_verify",
      "source_file": "/src/libssh/src/packet_crypt.c",
      "source_code": " * @param  mac          The mac to compare with the hmac.\n *\n * @return              0 if hmac and mac are equal, < 0 if not or an error\n *                      occurred.\n */\nint ssh_packet_hmac_verify(ssh_session session,\n                           const void *data,\n                           size_t len,\n                           uint8_t *mac,\n                           enum ssh_hmac_e type)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    unsigned char hmacbuf[DIGEST_MAX_LEN] = {0};\n    HMACCTX ctx = NULL;\n    size_t hmaclen = DIGEST_MAX_LEN;\n    uint32_t seq;\n    int cmp;\n    int rc;\n\n    /* AEAD types have no mac checking */\n    if (type == SSH_HMAC_AEAD_POLY1305 ||\n        type == SSH_HMAC_AEAD_GCM) {\n        return SSH_OK;\n    }\n\n    crypto = ssh_packet_get_current_crypto(session,\n                                           SSH_DIRECTION_IN);\n    if (crypto == NULL) {\n        return SSH_ERROR;\n    }\n\n    ctx = hmac_init(crypto->decryptMAC,\n                    hmac_digest_len(type),\n                    type);\n    if (ctx == NULL) {\n        return SSH_ERROR;\n    }\n\n    seq = htonl(session->recv_seq);\n\n    rc = hmac_update(ctx,\n                     (unsigned char *) &seq,\n                     sizeof(uint32_t));\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    rc = hmac_update(ctx,\n                     data,\n                     len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    rc = hmac_final(ctx,\n                    hmacbuf,\n                    &hmaclen);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"received mac\",\n                    mac,\n                    hmaclen);\n    ssh_log_hexdump(\"Computed mac\",\n                    hmacbuf,\n                    hmaclen);\n    ssh_log_hexdump(\"seq\",\n                    (unsigned char *)&seq,\n                    sizeof(uint32_t));\n#endif\n    cmp = secure_memcmp(mac,\n                        hmacbuf,\n                        hmaclen);\n    if (cmp == 0) {\n        return SSH_OK;\n    }\n\n    return SSH_ERROR;\n}\n",
      "line_start": 256,
      "line_end": 330,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 70,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This is a security\u2011critical HMAC verification routine: it computes an HMAC over untrusted 'data' (and the sequence number) and compares it to a provided MAC. That makes it a high\u2011value fuzz target because it processes external input, performs memory operations on that input, and is part of authentication/cryptographic checking. The function itself is not deeply branched, but it calls hmac_* implementations that iterate over input and could expose parsing/length/processing bugs, so it merits critical priority."
    },
    {
      "name": "ssh_pki_import_privkey_base64",
      "clean_name": "ssh_pki_import_privkey_base64",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return  SSH_ERROR in case of error, SSH_OK otherwise.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_privkey_base64(const char *b64_key,\n                                  const char *passphrase,\n                                  ssh_auth_callback auth_fn,\n                                  void *auth_data,\n                                  ssh_key *pkey)\n{\n    ssh_key key = NULL;\n    char *openssh_header = NULL;\n\n    if (b64_key == NULL || pkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (b64_key == NULL || !*b64_key) {\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Trying to decode privkey passphrase=%s\",\n            passphrase ? \"true\" : \"false\");\n\n    /* Test for OpenSSH key format first */\n    openssh_header = strstr(b64_key, OPENSSH_HEADER_BEGIN);\n    if (openssh_header != NULL) {\n        key = ssh_pki_openssh_privkey_import(openssh_header,\n                                             passphrase,\n                                             auth_fn,\n                                             auth_data);\n    } else {\n        /* fallback on PEM decoder */\n        key = pki_private_key_from_base64(b64_key,\n                                          passphrase,\n                                          auth_fn,\n                                          auth_data);\n    }\n    if (key == NULL) {\n        return SSH_ERROR;\n    }\n\n    *pkey = key;\n\n    return SSH_OK;\n}\n",
      "line_start": 914,
      "line_end": 957,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This is a high-value fuzz target: it accepts untrusted base64/key material, dispatches to OpenSSH or PEM private-key parsers and invokes passphrase/auth callbacks (cryptographic/security-critical code). While the function itself is simple, it reaches complex parsers that perform memory ops and sensitive handling, so fuzzing here has high impact."
    },
    {
      "name": "ssh_pki_import_pubkey_base64",
      "clean_name": "ssh_pki_import_pubkey_base64",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_pubkey_base64(const char *b64_key,\n                                 enum ssh_keytypes_e type,\n                                 ssh_key *pkey)\n{\n    ssh_buffer buffer = NULL;\n    ssh_string type_s = NULL;\n    int rc;\n\n    if (b64_key == NULL || pkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    buffer = base64_to_bin(b64_key);\n    if (buffer == NULL) {\n        return SSH_ERROR;\n    }\n\n    type_s = ssh_buffer_get_ssh_string(buffer);\n    if (type_s == NULL) {\n        SSH_BUFFER_FREE(buffer);\n        return SSH_ERROR;\n    }\n    SSH_STRING_FREE(type_s);\n\n    if (is_cert_type(type)) {\n        rc = pki_import_cert_buffer(buffer, type, pkey);\n    } else {\n        rc = pki_import_pubkey_buffer(buffer, type, pkey);\n    }\n    SSH_BUFFER_FREE(buffer);\n\n    return rc;\n}\n",
      "line_start": 1811,
      "line_end": 1844,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Accepts external base64 input, decodes to binary and parses SSH string data before calling PKI import routines. Although the wrapper itself is simple, it feeds untrusted data into complex key/certificate parsers and cryptographic import code (memory ops on untrusted data, security-critical), making it a high-value fuzz target."
    },
    {
      "name": "ssh_pki_import_pubkey_file",
      "clean_name": "ssh_pki_import_pubkey_file",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @returns SSH_OK on success, SSH_EOF if the file doesn't exist or permission\n *          denied, SSH_ERROR otherwise.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_pubkey_file(const char *filename, ssh_key *pkey)\n{\n    enum ssh_keytypes_e type;\n    struct stat sb;\n    char *key_buf = NULL, *p = NULL;\n    size_t buflen, i;\n    const char *q = NULL;\n    FILE *file = NULL;\n    off_t size;\n    int rc, cmp;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n    ssh_key priv_key = NULL;\n\n    if (pkey == NULL || filename == NULL || *filename == '\\0') {\n        return SSH_ERROR;\n    }\n\n#ifdef WITH_PKCS11_URI\n    if (ssh_pki_is_uri(filename)) {\n        rc = pki_uri_import(filename, pkey, SSH_KEY_PUBLIC);\n        return rc;\n    }\n#endif /* WITH_PKCS11_URI */\n\n    file = fopen(filename, \"rb\");\n    if (file == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Error opening %s: %s\",\n                    filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_EOF;\n    }\n\n    rc = fstat(fileno(file), &sb);\n    if (rc < 0) {\n        fclose(file);\n        SSH_LOG(SSH_LOG_TRACE, \"Error gettint stat of %s: %s\",\n                    filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        switch (errno) {\n            case ENOENT:\n            case EACCES:\n                return SSH_EOF;\n        }\n        return SSH_ERROR;\n    }\n\n    if (sb.st_size > MAX_PUBKEY_SIZE) {\n        fclose(file);\n        return SSH_ERROR;\n    }\n\n    key_buf = malloc(sb.st_size + 1);\n    if (key_buf == NULL) {\n        fclose(file);\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory!\");\n        return SSH_ERROR;\n    }\n\n    size = fread(key_buf, 1, sb.st_size, file);\n    fclose(file);\n\n    if (size != sb.st_size) {\n        SAFE_FREE(key_buf);\n        SSH_LOG(SSH_LOG_TRACE, \"Error reading %s: %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_ERROR;\n    }\n    key_buf[size] = '\\0';\n    buflen = strlen(key_buf);\n\n    /* Test for new OpenSSH key format first */\n    cmp = strncmp(key_buf, OPENSSH_HEADER_BEGIN, strlen(OPENSSH_HEADER_BEGIN));\n    if (cmp == 0) {\n        *pkey = ssh_pki_openssh_pubkey_import(key_buf);\n        SAFE_FREE(key_buf);\n        if (*pkey == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to import public key from OpenSSH\"\n                                  \" private key file\");\n            return SSH_ERROR;\n        }\n        return SSH_OK;\n    }\n\n    /*\n     * Try to parse key as PEM. Set empty passphrase, so user won't be prompted\n     * for passphrase. Don't try to decrypt encrypted private key.\n     */\n    priv_key = pki_private_key_from_base64(key_buf, \"\", NULL, NULL);\n    if (priv_key) {\n        rc = ssh_pki_export_privkey_to_pubkey(priv_key, pkey);\n        ssh_key_free(priv_key);\n        SAFE_FREE(key_buf);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_WARN, \"Failed to import public key from PEM\"\n                                  \" private key file\");\n            return SSH_ERROR;\n        }\n        return SSH_OK;\n    }\n\n    /* This the old one-line public key format */\n    q = p = key_buf;\n    for (i = 0; i < buflen; i++) {\n        if (isspace((int)p[i])) {\n            p[i] = '\\0';\n            break;\n        }\n    }\n\n    type = ssh_key_type_from_name(q);\n    if (type == SSH_KEYTYPE_UNKNOWN) {\n        SAFE_FREE(key_buf);\n        return SSH_ERROR;\n    }\n\n    if (i >= buflen) {\n        SAFE_FREE(key_buf);\n        return SSH_ERROR;\n    }\n    q = &p[i + 1];\n    for (; i < buflen; i++) {\n        if (isspace((int)p[i])) {\n            p[i] = '\\0';\n            break;\n        }\n    }\n\n    rc = ssh_pki_import_pubkey_base64(q, type, pkey);\n    SAFE_FREE(key_buf);\n\n    return rc;\n}\n",
      "line_start": 1975,
      "line_end": 2105,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 214,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses complex external input (OpenSSH, PEM, base64, one-line pubkey formats) and performs memory operations on untrusted data (malloc, fread, strlen, buffer manipulation). It contains multiple parsing branches and loops driven by file contents and is security-critical (key import/crypto-related). High value as a fuzz target \u2014 exercise multiple parsers and error paths."
    },
    {
      "name": "ssh_pki_import_signature_blob",
      "clean_name": "ssh_pki_import_signature_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    *sig_blob = str;\n\n    return SSH_OK;\n}\n\nint ssh_pki_import_signature_blob(const ssh_string sig_blob,\n                                  const ssh_key pubkey,\n                                  ssh_signature *psig)\n{\n    ssh_signature sig = NULL;\n    enum ssh_keytypes_e type;\n    enum ssh_digest_e hash_type;\n    ssh_string algorithm = NULL, blob = NULL;\n    ssh_buffer buf = NULL;\n    const char *alg = NULL;\n    uint8_t flags = 0;\n    uint32_t counter = 0;\n    int rc;\n\n    if (sig_blob == NULL || psig == NULL) {\n        return SSH_ERROR;\n    }\n\n    buf = ssh_buffer_new();\n    if (buf == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_data(buf,\n                             ssh_string_data(sig_blob),\n                             (uint32_t)ssh_string_len(sig_blob));\n    if (rc < 0) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    algorithm = ssh_buffer_get_ssh_string(buf);\n    if (algorithm == NULL) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    alg = ssh_string_get_char(algorithm);\n    type = ssh_key_type_from_signature_name(alg);\n    hash_type = ssh_key_hash_from_name(alg);\n    SSH_STRING_FREE(algorithm);\n\n    blob = ssh_buffer_get_ssh_string(buf);\n    if (blob == NULL) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    if (type == SSH_KEYTYPE_SK_ECDSA ||\n        type == SSH_KEYTYPE_SK_ED25519) {\n        rc = ssh_buffer_unpack(buf, \"bd\", &flags, &counter);\n        if (rc < 0) {\n            SSH_BUFFER_FREE(buf);\n            SSH_STRING_FREE(blob);\n            return SSH_ERROR;\n        }\n    }\n    SSH_BUFFER_FREE(buf);\n\n    sig = pki_signature_from_blob(pubkey, blob, type, hash_type);\n    SSH_STRING_FREE(blob);\n    if (sig == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* Set SK specific values */\n    sig->sk_flags = flags;\n    sig->sk_counter = counter;\n\n    *psig = sig;\n    return SSH_OK;\n}\n",
      "line_start": 2656,
      "line_end": 2728,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 160,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses an untrusted signature blob (structured external input), performs buffer/string memory operations and conditional unpacking, and constructs/initializes a cryptographic signature object. It has multiple input-dependent code paths and is security-critical (signature handling), making it a high-value fuzz target."
    },
    {
      "name": "sshsig_sign",
      "clean_name": "sshsig_sign",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *                        armored format. Must be freed with\n *                        ssh_string_free_char()\n *\n * @return SSH_OK on success, SSH_ERROR on error\n */\nint sshsig_sign(const void *data,\n                size_t data_length,\n                ssh_key privkey,\n                const char *sig_namespace,\n                enum sshsig_digest_e hash_alg,\n                char **signature)\n{\n    ssh_buffer tosign = NULL;\n    ssh_buffer signature_blob = NULL;\n    ssh_signature sig = NULL;\n    ssh_string sig_string = NULL;\n    ssh_string pub_blob = NULL;\n    enum ssh_digest_e digest_type;\n    const char *hash_alg_str = NULL;\n    int rc = SSH_ERROR;\n\n    if (privkey == NULL || data == NULL || sig_namespace == NULL ||\n        signature == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid parameters provided to sshsig_sign\");\n        return SSH_ERROR;\n    }\n\n    if (strlen(sig_namespace) == 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Invalid parameters provided to sshsig_sign: empty namespace \"\n                \"string\");\n        return SSH_ERROR;\n    }\n\n    *signature = NULL;\n\n    if (hash_alg == SSHSIG_DIGEST_SHA2_256) {\n        hash_alg_str = \"sha256\";\n    } else if (hash_alg == SSHSIG_DIGEST_SHA2_512) {\n        hash_alg_str = \"sha512\";\n    } else {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid hash algorithm %d\", hash_alg);\n        return SSH_ERROR;\n    }\n\n    rc = sshsig_prepare_data(data,\n                             data_length,\n                             hash_alg_str,\n                             sig_namespace,\n                             &tosign);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to prepare data for sshsig signing\");\n        goto cleanup;\n    }\n\n    digest_type = key_type_to_hash(ssh_key_type_plain(privkey->type));\n    sig = pki_sign_data(privkey,\n                        digest_type,\n                        ssh_buffer_get(tosign),\n                        ssh_buffer_get_len(tosign));\n    if (sig == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to sign data with private key\");\n        goto cleanup;\n    }\n\n    rc = ssh_pki_export_pubkey_blob(privkey, &pub_blob);\n    if (rc != SSH_OK || pub_blob == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to export public key blob from private key\");\n        goto cleanup;\n    }\n\n    rc = ssh_pki_export_signature_blob(sig, &sig_string);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to export signature blob\");\n        goto cleanup;\n    }\n\n    signature_blob = ssh_buffer_new();\n    if (signature_blob == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to allocate signature buffer\");\n        goto cleanup;\n    }\n\n    rc = ssh_buffer_pack(signature_blob,\n                         \"tdSsssS\",\n                         SSHSIG_MAGIC_PREAMBLE,\n                         SSHSIG_VERSION,\n                         pub_blob,\n                         sig_namespace,\n                         \"\",\n                         hash_alg_str,\n                         sig_string);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to pack signature blob\");\n        goto cleanup;\n    }\n\n    rc = sshsig_armor(signature_blob, signature);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to armor signature blob\");\n        goto cleanup;\n    }\n\ncleanup:\n    SSH_BUFFER_FREE(tosign);\n    SSH_BUFFER_FREE(signature_blob);\n    SSH_SIGNATURE_FREE(sig);\n    SSH_STRING_FREE(sig_string);\n    SSH_STRING_FREE(pub_blob);\n\n    return rc;\n}\n",
      "line_start": 3179,
      "line_end": 3287,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 189,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This function consumes external input (data, namespace, hash choice), performs substantial memory operations and buffer packing/serialization, and executes cryptographic signing (security-critical). It has multiple error paths and interacts with complex helpers (prepare/pack/armor/export), so it is a high-value fuzz target (critical priority)."
    },
    {
      "name": "ssh_pki_do_sign",
      "clean_name": "ssh_pki_do_sign",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "}\n\n/*\n * This function signs the session id as a string then\n * the content of sigbuf */\nssh_string ssh_pki_do_sign(ssh_session session,\n                           ssh_buffer sigbuf,\n                           const ssh_key privkey,\n                           enum ssh_digest_e hash_type)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n\n    ssh_signature sig = NULL;\n    ssh_string sig_blob = NULL;\n\n    ssh_string session_id = NULL;\n    ssh_buffer sign_input = NULL;\n\n    int rc;\n\n    if (session == NULL || sigbuf == NULL || privkey == NULL ||\n        !ssh_key_is_private(privkey))\n    {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad parameter provided to \"\n                               \"ssh_pki_do_sign()\");\n        return NULL;\n    }\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_BOTH);\n    if (crypto == NULL) {\n        return NULL;\n    }\n\n    /* Get the session ID */\n    session_id = ssh_string_new(crypto->session_id_len);\n    if (session_id == NULL) {\n        return NULL;\n    }\n    rc = ssh_string_fill(session_id, crypto->session_id, crypto->session_id_len);\n    if (rc < 0) {\n        goto end;\n    }\n\n    /* Fill the input */\n    sign_input = ssh_buffer_new();\n    if (sign_input == NULL) {\n        goto end;\n    }\n    ssh_buffer_set_secure(sign_input);\n\n    rc = ssh_buffer_pack(sign_input,\n                         \"SP\",\n                         session_id,\n                         (size_t)ssh_buffer_get_len(sigbuf),\n                         ssh_buffer_get(sigbuf));\n    if (rc != SSH_OK) {\n        goto end;\n    }\n\n    /* Generate the signature */\n    sig = pki_do_sign(privkey,\n            ssh_buffer_get(sign_input),\n            ssh_buffer_get_len(sign_input),\n            hash_type);\n    if (sig == NULL) {\n        goto end;\n    }\n\n    /* Convert the signature to blob */\n    rc = ssh_pki_export_signature_blob(sig, &sig_blob);\n    if (rc < 0) {\n        sig_blob = NULL;\n    }\n\nend:\n    ssh_signature_free(sig);\n    SSH_BUFFER_FREE(sign_input);\n    SSH_STRING_FREE(session_id);\n\n    return sig_blob;\n}\n",
      "line_start": 3451,
      "line_end": 3527,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 113,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Performs cryptographic signing using external/session-controlled data (session_id and sigbuf), manipulates untrusted buffers and memory, and is security-critical. Although control flow is simple, the function exercises crypto and buffer operations that make it a high-risk, high-value fuzz target."
    },
    {
      "name": "pki.c:pki_import_cert_buffer",
      "clean_name": "pki_import_cert_buffer",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    ssh_key_free(key);\n\n    return SSH_ERROR;\n}\n\nstatic int pki_import_cert_buffer(ssh_buffer buffer,\n                                  enum ssh_keytypes_e type,\n                                  ssh_key *pkey)\n{\n    ssh_buffer cert = NULL;\n    ssh_string tmp_s = NULL;\n    const char *type_c = NULL;\n    ssh_key key = NULL;\n    int rc;\n\n    /*\n     * The cert blob starts with the key type as an ssh_string, but this\n     * string has been read out of the buffer to identify the key type.\n     * Simply add it again as first element before copying the rest.\n     */\n    cert = ssh_buffer_new();\n    if (cert == NULL) {\n        goto fail;\n    }\n    type_c = ssh_key_type_to_char(type);\n    tmp_s = ssh_string_from_char(type_c);\n    if (tmp_s == NULL) {\n        goto fail;\n    }\n    rc = ssh_buffer_add_ssh_string(cert, tmp_s);\n    SSH_STRING_FREE(tmp_s);\n    if (rc != 0) {\n        goto fail;\n    }\n    rc = ssh_buffer_add_buffer(cert, buffer);\n    if (rc != 0) {\n        goto fail;\n    }\n\n    /*\n     * After the key type, comes an ssh_string nonce. Just after this comes the\n     * cert public key, which can be parsed out of the buffer.\n     */\n    tmp_s = ssh_buffer_get_ssh_string(buffer);\n    if (tmp_s == NULL) {\n        goto fail;\n    }\n    SSH_STRING_FREE(tmp_s);\n\n    switch (type) {\n        case SSH_KEYTYPE_RSA_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_RSA, &key);\n            break;\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_ECDSA_P256, &key);\n            break;\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_ECDSA_P384, &key);\n            break;\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_ECDSA_P521, &key);\n            break;\n        case SSH_KEYTYPE_ED25519_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_ED25519, &key);\n            break;\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_SK_ECDSA, &key);\n            break;\n        case SSH_KEYTYPE_SK_ED25519_CERT01:\n            rc = pki_import_pubkey_buffer(buffer, SSH_KEYTYPE_SK_ED25519, &key);\n            break;\n        default:\n            key = ssh_key_new();\n    }\n    if (rc != 0 || key == NULL) {\n        goto fail;\n    }\n\n    key->type = type;\n    key->type_c = type_c;\n    key->cert = cert;\n\n    *pkey = key;\n    return SSH_OK;\n\nfail:\n    ssh_key_free(key);\n    SSH_BUFFER_FREE(cert);\n    return SSH_ERROR;\n}\n",
      "line_start": 1711,
      "line_end": 1796,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 96,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses structured SSH certificate blobs (complex external input) and drives cryptographic key import logic. It reads ssh_strings, copies/combines buffers and dispatches by key type (multiple code paths). Security-critical (keys/certs) and likely performs memory operations on untrusted data, making it a high-value fuzz target."
    },
    {
      "name": "pki.c:sshsig_dearmor",
      "clean_name": "sshsig_dearmor",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param[in]  signature    The armored sshsig signature string\n * @param[out] out          Pointer to store the allocated binary buffer\n *\n * @return SSH_OK on success, SSH_ERROR on error\n */\nstatic int sshsig_dearmor(const char *signature, ssh_buffer *out)\n{\n    const char *begin = NULL;\n    const char *end = NULL;\n    char *clean_b64 = NULL;\n    ssh_buffer decoded_buffer = NULL;\n    int i, j;\n    int rc = SSH_ERROR;\n\n    if (signature == NULL || out == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid input parameters\");\n        return SSH_ERROR;\n    }\n\n    *out = NULL;\n\n    rc = strncmp(signature,\n                 SSHSIG_BEGIN_SIGNATURE,\n                 strlen(SSHSIG_BEGIN_SIGNATURE));\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Signature does not start with expected header\");\n        return SSH_ERROR;\n    }\n\n    begin = signature + strlen(SSHSIG_BEGIN_SIGNATURE);\n    while (isspace(*begin)) {\n        begin++;\n    }\n\n    end = strstr(begin, SSHSIG_END_SIGNATURE);\n    if (end == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Signature end marker not found\");\n        return SSH_ERROR;\n    }\n\n    /* Backtrack to find the real end of data */\n    while (end > begin && (isspace(*(end - 1)))) {\n        end--;\n    }\n\n    clean_b64 = calloc(end - begin + 1, 1);\n    if (clean_b64 == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to allocate %td bytes for clean base64 data\",\n                end - begin + 1);\n        return SSH_ERROR;\n    }\n\n    for (i = 0, j = 0; begin + i < end; i++) {\n        if (!isspace(begin[i])) {\n            clean_b64[j++] = begin[i];\n        }\n    }\n    clean_b64[j] = '\\0';\n\n    decoded_buffer = base64_to_bin(clean_b64);\n    SAFE_FREE(clean_b64);\n\n    if (decoded_buffer == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to decode base64 signature data\");\n        return SSH_ERROR;\n    }\n\n    *out = decoded_buffer;\n    return SSH_OK;\n}\n",
      "line_start": 3006,
      "line_end": 3072,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 113,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses structured external input (armored SSH signature), finds headers/footers, strips whitespace, allocates and copies data and calls base64_to_bin \u2014 i.e. memory operations on untrusted data and input-dependent loops. This is security/crypto-adjacent and a high-risk fuzz target (important but moderate cyclomatic complexity), deserving high priority."
    },
    {
      "name": "pki_container_openssh.c:pki_openssh_import_privkey_blob",
      "clean_name": "pki_openssh_import_privkey_blob",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nstatic int pki_openssh_import_privkey_blob(ssh_buffer key_blob_buffer,\n                                           ssh_key *pkey)\n{\n    enum ssh_keytypes_e type;\n    char *type_s = NULL;\n    ssh_key key = NULL;\n    int rc;\n\n    if (pkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_unpack(key_blob_buffer, \"s\", &type_s);\n    if (rc == SSH_ERROR){\n        SSH_LOG(SSH_LOG_TRACE, \"Unpack error\");\n        return SSH_ERROR;\n    }\n\n    type = ssh_key_type_from_name(type_s);\n    if (type == SSH_KEYTYPE_UNKNOWN) {\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown key type '%s' found!\", type_s);\n        return SSH_ERROR;\n    }\n    SAFE_FREE(type_s);\n\n    rc = pki_import_privkey_buffer(type, key_blob_buffer, &key);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to read key in OpenSSH format\");\n        goto fail;\n    }\n\n    *pkey = key;\n    return SSH_OK;\nfail:\n    ssh_key_free(key);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 57,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Wraps parsing of an OpenSSH private-key blob and delegates to pki_import_privkey_buffer: it accepts complex external input (key blobs), performs buffer unpacking on untrusted data, and is crypto/authentication-related. While the function itself is small, it exercises heavy parsing and memory operations in downstream code, making it a high-value fuzz target."
    },
    {
      "name": "pki_container_openssh.c:pki_private_key_encrypt",
      "clean_name": "pki_private_key_encrypt",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": "\n/** @internal\n * @brief encrypts an ed25519 private key blob\n *\n */\nstatic int pki_private_key_encrypt(ssh_buffer privkey_buffer,\n                                   const char* passphrase,\n                                   const char *ciphername,\n                                   const char *kdfname,\n                                   ssh_auth_callback auth_fn,\n                                   void *auth_data,\n                                   uint32_t rounds,\n                                   ssh_string salt)\n{\n    struct ssh_cipher_struct *ciphers = ssh_get_ciphertab();\n    struct ssh_cipher_struct cipher;\n    uint8_t key_material[128] = {0};\n    size_t key_material_len;\n    char passphrase_buffer[128] = {0};\n    int rc;\n    int i;\n    int cmp;\n\n    cmp = strcmp(ciphername, \"none\");\n    if (cmp == 0){\n        /* no encryption required */\n        return SSH_OK;\n    }\n\n    for (i = 0; ciphers[i].name != NULL; i++) {\n        cmp = strcmp(ciphername, ciphers[i].name);\n        if (cmp == 0){\n            memcpy(&cipher, &ciphers[i], sizeof(cipher));\n            break;\n        }\n    }\n\n    if (ciphers[i].name == NULL){\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported cipher %s\", ciphername);\n        return SSH_ERROR;\n    }\n\n    cmp = strcmp(kdfname, \"bcrypt\");\n    if (cmp != 0){\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported KDF %s\", kdfname);\n        return SSH_ERROR;\n    }\n    /* We need material for key (keysize bits / 8) and IV (blocksize)  */\n    key_material_len =  cipher.keysize/8 + cipher.blocksize;\n    if (key_material_len > sizeof(key_material)){\n        SSH_LOG(SSH_LOG_TRACE, \"Key material too big\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Encryption: %d key, %d IV, %\" PRIu32 \" rounds, %zu bytes salt\",\n                cipher.keysize/8,\n                cipher.blocksize, rounds, ssh_string_len(salt));\n\n    if (passphrase == NULL){\n        if (auth_fn == NULL){\n            SSH_LOG(SSH_LOG_TRACE, \"No passphrase provided\");\n            return SSH_ERROR;\n        }\n        rc = auth_fn(\"Passphrase\",\n                     passphrase_buffer,\n                     sizeof(passphrase_buffer),\n                     0,\n                     0,\n                     auth_data);\n        if (rc != SSH_OK){\n            return SSH_ERROR;\n        }\n        passphrase = passphrase_buffer;\n    }\n\n    rc = bcrypt_pbkdf(passphrase,\n                      strlen(passphrase),\n                      ssh_string_data(salt),\n                      ssh_string_len(salt),\n                      key_material,\n                      key_material_len,\n                      rounds);\n    if (rc < 0){\n        return SSH_ERROR;\n    }\n\n    cipher.set_encrypt_key(&cipher,\n                           key_material,\n                           key_material + cipher.keysize/8);\n    cipher.encrypt(&cipher,\n                   ssh_buffer_get(privkey_buffer),\n                   ssh_buffer_get(privkey_buffer),\n                   ssh_buffer_get_len(privkey_buffer));\n    ssh_cipher_clear(&cipher);\n    explicit_bzero(passphrase_buffer, sizeof(passphrase_buffer));\n\n    return SSH_OK;\n}\n",
      "line_start": 400,
      "line_end": 493,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 82,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This is a high-value fuzz target: it performs security-critical cryptographic operations (private-key encryption, KDF bcrypt), does in-place memory operations on untrusted inputs (memcpy, cipher.encrypt on the provided buffer), uses external inputs (passphrase, salt, rounds, ciphername/kdfname) and has branching logic to select ciphers/KDFs. Those facts make it a critical priority for fuzzing to find memory/sanity issues in the cipher/KDF code and misuse of buffers (e.g. passphrase handling). It does not parse a complex file format, so not the absolute top-tier 10, but is still critical (9)."
    },
    {
      "name": "crypt_set_algorithms_server",
      "clean_name": "crypt_set_algorithms_server",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "{\n    return crypt_set_algorithms2(session);\n}\n\n#ifdef WITH_SERVER\nint crypt_set_algorithms_server(ssh_session session){\n    const char *method = NULL;\n    uint8_t i = 0;\n    struct ssh_cipher_struct *ssh_ciphertab=ssh_get_ciphertab();\n    struct ssh_hmac_struct   *ssh_hmactab=ssh_get_hmactab();\n    int cmp;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    /*\n     * We must scan the kex entries to find crypto algorithms and set their\n     * appropriate structure\n     */\n    /* out */\n    method = session->next_crypto->kex_methods[SSH_CRYPT_S_C];\n\n    for (i = 0; ssh_ciphertab[i].name != NULL; i++) {\n        cmp = strcmp(method, ssh_ciphertab[i].name);\n        if (cmp == 0) {\n          break;\n        }\n    }\n\n    if (ssh_ciphertab[i].name == NULL) {\n        ssh_set_error(session,SSH_FATAL,\"crypt_set_algorithms_server : \"\n                \"no crypto algorithm function found for %s\",method);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET,\"Set output algorithm %s\",method);\n\n    session->next_crypto->out_cipher = cipher_new(i);\n    if (session->next_crypto->out_cipher == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    if (session->next_crypto->out_cipher->aead_encrypt != NULL){\n        /* this cipher has integrated MAC */\n        if (session->next_crypto->out_cipher->ciphertype == SSH_AEAD_CHACHA20_POLY1305) {\n            method = \"aead-poly1305\";\n        } else {\n            method = \"aead-gcm\";\n        }\n    } else {\n        /* we must scan the kex entries to find hmac algorithms and set their appropriate structure */\n        /* out */\n        method = session->next_crypto->kex_methods[SSH_MAC_S_C];\n    }\n    /* HMAC algorithm selection */\n\n    for (i = 0; ssh_hmactab[i].name != NULL; i++) {\n        cmp = strcmp(method, ssh_hmactab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_hmactab[i].name == NULL) {\n      ssh_set_error(session, SSH_FATAL,\n          \"crypt_set_algorithms_server: no hmac algorithm function found for %s\",\n          method);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set HMAC output algorithm to %s\", method);\n\n    session->next_crypto->out_hmac = ssh_hmactab[i].hmac_type;\n    session->next_crypto->out_hmac_etm = ssh_hmactab[i].etm;\n\n    /* in */\n    method = session->next_crypto->kex_methods[SSH_CRYPT_C_S];\n\n    for (i = 0; ssh_ciphertab[i].name; i++) {\n        cmp = strcmp(method, ssh_ciphertab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_ciphertab[i].name == NULL) {\n        ssh_set_error(session,SSH_FATAL,\"Crypt_set_algorithms_server :\"\n                \"no crypto algorithm function found for %s\",method);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET,\"Set input algorithm %s\",method);\n\n    session->next_crypto->in_cipher = cipher_new(i);\n    if (session->next_crypto->in_cipher == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    if (session->next_crypto->in_cipher->aead_encrypt != NULL){\n        /* this cipher has integrated MAC */\n        if (session->next_crypto->in_cipher->ciphertype == SSH_AEAD_CHACHA20_POLY1305) {\n            method = \"aead-poly1305\";\n        } else {\n            method = \"aead-gcm\";\n        }\n    } else {\n        /* we must scan the kex entries to find hmac algorithms and set their appropriate structure */\n        method = session->next_crypto->kex_methods[SSH_MAC_C_S];\n    }\n\n    for (i = 0; ssh_hmactab[i].name != NULL; i++) {\n        cmp = strcmp(method, ssh_hmactab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_hmactab[i].name == NULL) {\n      ssh_set_error(session, SSH_FATAL,\n          \"crypt_set_algorithms_server: no hmac algorithm function found for %s\",\n          method);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set HMAC input algorithm to %s\", method);\n\n    session->next_crypto->in_hmac = ssh_hmactab[i].hmac_type;\n    session->next_crypto->in_hmac_etm = ssh_hmactab[i].etm;\n\n    /* compression */\n    method = session->next_crypto->kex_methods[SSH_COMP_C_S];\n    cmp = strcmp(method, \"zlib\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling C->S compression\");\n        compression_enable(session, SSH_DIRECTION_IN, false);\n    }\n    cmp = strcmp(method, \"zlib@openssh.com\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling C->S delayed compression\");\n        compression_enable(session, SSH_DIRECTION_IN, true);\n    }\n\n    method = session->next_crypto->kex_methods[SSH_COMP_S_C];\n    cmp = strcmp(method, \"zlib\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling S->C compression\");\n        compression_enable(session, SSH_DIRECTION_OUT, false);\n    }\n    cmp = strcmp(method, \"zlib@openssh.com\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling S->C delayed compression\");\n        compression_enable(session, SSH_DIRECTION_OUT, true);\n    }\n\n    method = session->next_crypto->kex_methods[SSH_HOSTKEYS];\n    session->srv.hostkey = ssh_key_type_from_signature_name(method);\n    session->srv.hostkey_digest = ssh_key_hash_from_name(method);\n\n    /* setup DH key exchange type */\n    switch (session->next_crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n      ssh_server_dh_init(session);\n      break;\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n    case SSH_KEX_DH_GEX_SHA256:\n      ssh_server_dhgex_init(session);\n      break;\n#endif /* WITH_GEX */\n#ifdef HAVE_ECDH\n    case SSH_KEX_ECDH_SHA2_NISTP256:\n    case SSH_KEX_ECDH_SHA2_NISTP384:\n    case SSH_KEX_ECDH_SHA2_NISTP521:\n      ssh_server_ecdh_init(session);\n      break;\n#endif\n#ifdef HAVE_CURVE25519\n    case SSH_KEX_CURVE25519_SHA256:\n    case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n        ssh_server_curve25519_init(session);\n        break;\n#endif\n#ifdef HAVE_SNTRUP761\n    case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n        ssh_server_sntrup761x25519_init(session);\n        break;\n#endif\n    default:\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"crypt_set_algorithms_server: could not find init \"\n                      \"handler for kex type %d\",\n                      session->next_crypto->kex_type);\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 415,
      "line_end": 610,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 206,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Selects and configures cryptographic algorithms from session-provided kex strings (untrusted input). It performs many strcmp-based lookups, allocates ciphers (cipher_new), enables compression, sets HMACs/AEADs and dispatches key-exchange initializers \u2014 high branching complexity and direct influence on security/crypto behavior. Good fuzz target for protocol-parsing and crypto-related state handling."
    },
    {
      "name": "wrapper.c:crypt_set_algorithms2",
      "clean_name": "crypt_set_algorithms2",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "            session->next_crypto->do_compress_out = 1;\n        }\n    }\n}\n\nstatic int crypt_set_algorithms2(ssh_session session)\n{\n    const char *wanted = NULL;\n    const char *method = NULL;\n    struct ssh_cipher_struct *ssh_ciphertab=ssh_get_ciphertab();\n    struct ssh_hmac_struct *ssh_hmactab=ssh_get_hmactab();\n    uint8_t i = 0;\n    int cmp;\n\n    /*\n     * We must scan the kex entries to find crypto algorithms and set their\n     * appropriate structure.\n     */\n\n    /* out */\n    wanted = session->next_crypto->kex_methods[SSH_CRYPT_C_S];\n    for (i = 0; i < 64 && ssh_ciphertab[i].name != NULL; ++i) {\n        cmp = strcmp(wanted, ssh_ciphertab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_ciphertab[i].name == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                \"crypt_set_algorithms2: no crypto algorithm function found for %s\",\n                wanted);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set output algorithm to %s\", wanted);\n\n    session->next_crypto->out_cipher = cipher_new(i);\n    if (session->next_crypto->out_cipher == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    if (session->next_crypto->out_cipher->aead_encrypt != NULL) {\n        /* this cipher has integrated MAC */\n        if (session->next_crypto->out_cipher->ciphertype == SSH_AEAD_CHACHA20_POLY1305) {\n            wanted = \"aead-poly1305\";\n        } else {\n            wanted = \"aead-gcm\";\n        }\n    } else {\n        /*\n         * We must scan the kex entries to find hmac algorithms and set their\n         * appropriate structure.\n         */\n\n        /* out */\n        wanted = session->next_crypto->kex_methods[SSH_MAC_C_S];\n    }\n\n    for (i = 0; ssh_hmactab[i].name != NULL; i++) {\n        cmp = strcmp(wanted, ssh_hmactab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_hmactab[i].name == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                \"crypt_set_algorithms2: no hmac algorithm function found for %s\",\n                wanted);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set HMAC output algorithm to %s\", wanted);\n\n    session->next_crypto->out_hmac = ssh_hmactab[i].hmac_type;\n    session->next_crypto->out_hmac_etm = ssh_hmactab[i].etm;\n\n    /* in */\n    wanted = session->next_crypto->kex_methods[SSH_CRYPT_S_C];\n\n    for (i = 0; ssh_ciphertab[i].name != NULL; i++) {\n        cmp = strcmp(wanted, ssh_ciphertab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_ciphertab[i].name == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                \"Crypt_set_algorithms: no crypto algorithm function found for %s\",\n                wanted);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set input algorithm to %s\", wanted);\n\n    session->next_crypto->in_cipher = cipher_new(i);\n    if (session->next_crypto->in_cipher == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    if (session->next_crypto->in_cipher->aead_encrypt != NULL){\n        /* this cipher has integrated MAC */\n        if (session->next_crypto->in_cipher->ciphertype == SSH_AEAD_CHACHA20_POLY1305) {\n            wanted = \"aead-poly1305\";\n        } else {\n            wanted = \"aead-gcm\";\n        }\n    } else {\n        /* we must scan the kex entries to find hmac algorithms and set their appropriate structure */\n        wanted = session->next_crypto->kex_methods[SSH_MAC_S_C];\n    }\n\n    for (i = 0; ssh_hmactab[i].name != NULL; i++) {\n        cmp = strcmp(wanted, ssh_hmactab[i].name);\n        if (cmp == 0) {\n            break;\n        }\n    }\n\n    if (ssh_hmactab[i].name == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                \"crypt_set_algorithms2: no hmac algorithm function found for %s\",\n                wanted);\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PACKET, \"Set HMAC input algorithm to %s\", wanted);\n\n    session->next_crypto->in_hmac = ssh_hmactab[i].hmac_type;\n    session->next_crypto->in_hmac_etm = ssh_hmactab[i].etm;\n\n    /* compression: client */\n    method = session->next_crypto->kex_methods[SSH_COMP_C_S];\n    cmp = strcmp(method, \"zlib\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling C->S compression\");\n        compression_enable(session, SSH_DIRECTION_OUT, false);\n    }\n    cmp = strcmp(method, \"zlib@openssh.com\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling C->S delayed compression\");\n        compression_enable(session, SSH_DIRECTION_OUT, true);\n    }\n\n    method = session->next_crypto->kex_methods[SSH_COMP_S_C];\n    cmp = strcmp(method, \"zlib\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling S->C compression\");\n        compression_enable(session, SSH_DIRECTION_IN, false);\n    }\n    cmp = strcmp(method, \"zlib@openssh.com\");\n    if (cmp == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"enabling S->C delayed compression\");\n        compression_enable(session, SSH_DIRECTION_IN, true);\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 255,
      "line_end": 408,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 175,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This routine selects ciphers, HMACs and compression based on negotiated kex strings (network-controlled input). It contains multiple input-dependent loops and branches, allocates cipher objects, and drives security-critical crypto setup \u2014 making it high-risk and valuable to fuzz (exposed to external input, many code paths, and potential for allocation/selection-related errors)."
    },
    {
      "name": "ssh_config_get_token",
      "clean_name": "ssh_config_get_token",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "}\n\n/* Returns the next token delimited by whitespace or equal sign (=)\n * respecting the quotes creating separate token (including whitespaces).\n */\nchar *ssh_config_get_token(char **str)\n{\n    register char *c = NULL;\n    bool had_equal = false;\n    char *r = NULL;\n\n    /* Ignore leading spaces */\n    for (c = *str; *c; c++) {\n        if (! isblank(*c)) {\n            break;\n        }\n    }\n\n    /* If we start with quote, return the whole quoted block */\n    if (*c == '\\\"') {\n        for (r = ++c; *c; c++) {\n            if (*c == '\\\"' || *c == '\\n') {\n                if (*c == '\\\"' && r != c && *(c - 1) == '\\\\') {\n                    /* Escaped quote: Move the remaining one char left */\n                    int remaining_len = strlen(c);\n                    memmove(c - 1, c, remaining_len);\n                    c[remaining_len - 1] = '\\0';\n                    continue;\n                }\n                *c = '\\0';\n                c++;\n                break;\n            }\n            /* XXX Unmatched quotes extend to the end of line */\n        }\n    } else {\n        /* Otherwise terminate on space, equal or newline */\n        for (r = c; *c; c++) {\n            if (*c == '\\0') {\n                goto out;\n            } else if (isblank(*c) || *c == '=' || *c == '\\n') {\n                had_equal = (*c == '=');\n                *c = '\\0';\n                c++;\n                break;\n            }\n        }\n    }\n\n    /* Skip any other remaining whitespace */\n    while (isblank(*c) || *c == '\\n' || (!had_equal && *c == '=')) {\n        if (*c == '=') {\n            had_equal = true;\n        }\n        c++;\n    }\nout:\n    *str = c;\n    return r;\n}\n",
      "line_start": 67,
      "line_end": 122,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 87,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses SSH config input (file format) and performs in-place memory operations on untrusted data (memmove, strlen, writes). Contains multiple branches/loops for quote/escape handling and input-dependent bounds, making it high-value for fuzzing (potential off-by-one/logic/memory-corruption issues)."
    },
    {
      "name": "ssh_config_parse_uri",
      "clean_name": "ssh_config_parse_uri",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "    }\n\n    return notfound;\n}\n\nint ssh_config_parse_uri(const char *tok,\n                         char **username,\n                         char **hostname,\n                         char **port,\n                         bool ignore_port)\n{\n    char *endp = NULL;\n    long port_n;\n    int rc;\n\n    /* Sanitize inputs */\n    if (username != NULL) {\n        *username = NULL;\n    }\n    if (hostname != NULL) {\n        *hostname = NULL;\n    }\n    if (port != NULL) {\n        *port = NULL;\n    }\n\n    /* Username part (optional) */\n    endp = strrchr(tok, '@');\n    if (endp != NULL) {\n        /* Zero-length username is not valid */\n        if (tok == endp) {\n            goto error;\n        }\n        if (username != NULL) {\n            *username = strndup(tok, endp - tok);\n            if (*username == NULL) {\n                goto error;\n            }\n            rc = ssh_check_username_syntax(*username);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n        }\n        tok = endp + 1;\n        /* If there is second @ character, this does not look like our URI */\n        endp = strchr(tok, '@');\n        if (endp != NULL) {\n            goto error;\n        }\n    }\n\n    /* Hostname */\n    if (*tok == '[') {\n        /* IPv6 address is enclosed with square brackets */\n        tok++;\n        endp = strchr(tok, ']');\n        if (endp == NULL) {\n            goto error;\n        }\n    } else if (!ignore_port) {\n        /* Hostnames or aliases expand to the last colon (if port is requested)\n         * or to the end */\n        endp = strrchr(tok, ':');\n        if (endp == NULL) {\n            endp = strchr(tok, '\\0');\n        }\n    } else {\n        /* If no port is requested, expand to the end of line\n         * (to accommodate the IPv6 addresses) */\n        endp = strchr(tok, '\\0');\n    }\n    if (tok == endp) {\n        /* Zero-length hostnames are not valid */\n        goto error;\n    }\n    if (hostname != NULL) {\n        *hostname = strndup(tok, endp - tok);\n        if (*hostname == NULL) {\n            goto error;\n        }\n        /* if not an ip, check syntax */\n        rc = ssh_is_ipaddr(*hostname);\n        if (rc == 0) {\n            rc = ssh_check_hostname_syntax(*hostname);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n        }\n    }\n    /* Skip also the closing bracket */\n    if (*endp == ']') {\n        endp++;\n    }\n\n    /* Port (optional) */\n    if (*endp != '\\0') {\n        char *port_end = NULL;\n\n        /* Verify the port is valid positive number */\n        port_n = strtol(endp + 1, &port_end, 10);\n        if (port_n < 1 || *port_end != '\\0') {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to parse port number.\"\n                    \" The value '%ld' is invalid or there are some\"\n                    \" trailing characters: '%s'\", port_n, port_end);\n            goto error;\n        }\n        if (port != NULL) {\n            *port = strdup(endp + 1);\n            if (*port == NULL) {\n                goto error;\n            }\n        }\n    }\n\n    return SSH_OK;\n\nerror:\n    if (username != NULL) {\n        SAFE_FREE(*username);\n    }\n    if (hostname != NULL) {\n        SAFE_FREE(*hostname);\n    }\n    if (port != NULL) {\n        SAFE_FREE(*port);\n    }\n    return SSH_ERROR;\n}\n",
      "line_start": 170,
      "line_end": 293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 178,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses a URI-like external input with username, hostname (including [IPv6]) and port; uses string ops/allocations (strndup/strdup/strtol/strchr/strrchr) on untrusted data and has multiple branches and validation checks (ssh_check_*, ssh_is_ipaddr). High potential for parsing edge-cases and memory-related bugs, making it a high-value fuzz target."
    },
    {
      "name": "pki_key_generate_rsa",
      "clean_name": "pki_key_generate_rsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "fail:\n    ssh_key_free(new);\n    return NULL;\n}\n\nint pki_key_generate_rsa(ssh_key key, int parameter){\n\tint rc;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    BIGNUM *e = NULL;\n    RSA *key_rsa = NULL;\n#else\n    OSSL_PARAM params[3];\n    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_from_name(NULL, \"RSA\", NULL);\n    unsigned e = 65537;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    e = BN_new();\n    key_rsa = RSA_new();\n    if (key_rsa == NULL) {\n        return SSH_ERROR;\n    }\n\n    BN_set_word(e, 65537);\n    rc = RSA_generate_key_ex(key_rsa, parameter, e, NULL);\n\n    BN_free(e);\n\n    if (rc <= 0 || key_rsa == NULL) {\n        return SSH_ERROR;\n    }\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        RSA_free(key_rsa);\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_assign_RSA(key->key, key_rsa);\n    if (rc != 1) {\n        RSA_free(key_rsa);\n        EVP_PKEY_free(key->key);\n        return SSH_ERROR;\n    }\n\n    key_rsa = NULL;\n#else\n    key->key = NULL;\n\n    rc = EVP_PKEY_keygen_init(pctx);\n    if (rc != 1) {\n        EVP_PKEY_CTX_free(pctx);\n        return SSH_ERROR;\n    }\n\n    params[0] = OSSL_PARAM_construct_int(\"bits\", &parameter);\n    params[1] = OSSL_PARAM_construct_uint(\"e\", &e);\n    params[2] = OSSL_PARAM_construct_end();\n    rc = EVP_PKEY_CTX_set_params(pctx, params);\n    if (rc != 1) {\n        EVP_PKEY_CTX_free(pctx);\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_generate(pctx, &(key->key));\n\n    EVP_PKEY_CTX_free(pctx);\n\n    if (rc != 1 || key->key == NULL)\n        return SSH_ERROR;\n#endif /* OPENSSL_VERSION_NUMBER */\n\treturn SSH_OK;\n}\n",
      "line_start": 794,
      "line_end": 862,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Performs cryptographic key generation (security-critical). It calls complex OpenSSL APIs, has input-dependent behavior (key size parameter) and multiple code paths (pre/post-OpenSSL3), so fuzzing can reveal serious flaws even though it doesn't parse external file formats."
    },
    {
      "name": "pki_key_generate_ecdsa",
      "clean_name": "pki_key_generate_ecdsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "#endif /* OPENSSL_VERSION_NUMBER */\n\treturn SSH_OK;\n}\n\n#ifdef HAVE_OPENSSL_ECC\nint pki_key_generate_ecdsa(ssh_key key, int parameter)\n{\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    EC_KEY *ecdsa = NULL;\n    int ok;\n#else\n    const char *group_name = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n    switch (parameter) {\n        case 256:\n            key->ecdsa_nid = NID_X9_62_prime256v1;\n            key->type = SSH_KEYTYPE_ECDSA_P256;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n            group_name = NISTP256;\n#endif /* OPENSSL_VERSION_NUMBER */\n            break;\n        case 384:\n            key->ecdsa_nid = NID_secp384r1;\n            key->type = SSH_KEYTYPE_ECDSA_P384;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n            group_name = NISTP384;\n#endif /* OPENSSL_VERSION_NUMBER */\n            break;\n        case 521:\n            key->ecdsa_nid = NID_secp521r1;\n            key->type = SSH_KEYTYPE_ECDSA_P521;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n            group_name = NISTP521;\n#endif /* OPENSSL_VERSION_NUMBER */\n            break;\n        default:\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid parameter %d for ECDSA key \"\n                    \"generation\", parameter);\n            return SSH_ERROR;\n    }\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid);\n    if (ecdsa == NULL) {\n        return SSH_ERROR;\n    }\n    ok = EC_KEY_generate_key(ecdsa);\n    if (!ok) {\n        EC_KEY_free(ecdsa);\n        return SSH_ERROR;\n    }\n\n    EC_KEY_set_asn1_flag(ecdsa, OPENSSL_EC_NAMED_CURVE);\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        EC_KEY_free(ecdsa);\n        return SSH_ERROR;\n    }\n\n    ok = EVP_PKEY_assign_EC_KEY(key->key, ecdsa);\n    if (ok != 1) {\n        return SSH_ERROR;\n    }\n\n#else\n    key->key = EVP_EC_gen(group_name);\n    if (key->key == NULL) {\n        return SSH_ERROR;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    return SSH_OK;\n}\n",
      "line_start": 864,
      "line_end": 932,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Performs security\u2011critical cryptographic key generation (ECDSA) based on an external parameter, which can exercise OpenSSL internals and cause security\u2011relevant failures. Input surface is small and logic is simple (curve selection + calls into OpenSSL), so lower complexity but high value for fuzzing."
    },
    {
      "name": "pki_key_compare",
      "clean_name": "pki_key_compare",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "#endif /* HAVE_OPENSSL_ECC */\n\n/* With OpenSSL 3.0 and higher the parameter 'what'\n * is ignored and the comparison is done by OpenSSL\n */\nint pki_key_compare(const ssh_key k1, const ssh_key k2, enum ssh_keycmp_e what)\n{\n    int rc, cmp;\n\n    (void)what;\n\n    /* We got here only if the types match */\n    switch (ssh_key_type_plain(k1->type)) {\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_SK_ECDSA:\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n#ifdef HAVE_OPENSSL_ECC\n    {\n        const EC_KEY *ec1 = EVP_PKEY_get0_EC_KEY(k1->key);\n        const EC_KEY *ec2 = EVP_PKEY_get0_EC_KEY(k2->key);\n        const EC_POINT *p1 = NULL;\n        const EC_POINT *p2 = NULL;\n        const EC_GROUP *g1 = NULL;\n        const EC_GROUP *g2 = NULL;\n\n        if (ec1 == NULL || ec2 == NULL) {\n            return 1;\n        }\n\n        p1 = EC_KEY_get0_public_key(ec1);\n        p2 = EC_KEY_get0_public_key(ec2);\n        g1 = EC_KEY_get0_group(ec1);\n        g2 = EC_KEY_get0_group(ec2);\n\n        if (p1 == NULL || p2 == NULL || g1 == NULL || g2 == NULL) {\n            return 1;\n        }\n\n        if (EC_GROUP_cmp(g1, g2, NULL) != 0) {\n            return 1;\n        }\n\n        if (EC_POINT_cmp(g1, p1, p2, NULL) != 0) {\n            return 1;\n        }\n\n        if (what == SSH_KEY_CMP_PRIVATE && !is_sk_key_type(k1->type)) {\n            if (bignum_cmp(EC_KEY_get0_private_key(ec1),\n                           EC_KEY_get0_private_key(ec2))) {\n                return 1;\n            }\n        }\n        break;\n    }\n#endif /* HAVE_OPENSSL_ECC */\n#endif /* OPENSSL_VERSION_NUMBER */\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_SK_ED25519:\n        /* In FIPS mode, we can not use OpenSSL to compare Ed25519 keys.\n         * The OpenSSL < 3.0 also crashes in EVP_PKEY_eq() when either of\n         * keys keys is NULL so catch it here. */\n        if (ssh_fips_mode() && k1->key == NULL && k2->key == NULL) {\n            if (what == SSH_KEY_CMP_PRIVATE) {\n                /* we should never have Ed25519 private key in FIPS mode */\n                return 1;\n            }\n            cmp = memcmp(k1->ed25519_pubkey,\n                         k2->ed25519_pubkey,\n                         ED25519_KEY_LEN);\n            if (cmp != 0) {\n                return 1;\n            }\n            /* they match */\n            return 0;\n        }\n        FALL_THROUGH;\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA1:\n        rc = EVP_PKEY_eq(k1->key, k2->key);\n        if (rc != 1) {\n            return 1;\n        }\n        break;\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        return 1;\n    }\n    return 0;\n}\n",
      "line_start": 937,
      "line_end": 1023,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 132,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This is security-critical crypto code that compares SSH keys: it calls OpenSSL APIs (EVP_PKEY_eq, EC_GROUP_cmp, EC_POINT_cmp), does bignum and memcmp operations on key material, and has multiple type-dependent code paths. Although it does not parse file formats itself, it operates on untrusted key data and touches complex crypto/data structures, so it is a high-risk, high-value fuzz target."
    },
    {
      "name": "pki_private_key_to_pem",
      "clean_name": "pki_private_key_to_pem",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "        return 1;\n    }\n    return 0;\n}\n\nssh_string pki_private_key_to_pem(const ssh_key key,\n                                  const char *passphrase,\n                                  ssh_auth_callback auth_fn,\n                                  void *auth_data)\n{\n    ssh_string blob = NULL;\n    BUF_MEM *buf = NULL;\n    BIO *mem = NULL;\n    EVP_PKEY *pkey = NULL;\n    int rc;\n\n    mem = BIO_new(BIO_s_mem());\n    if (mem == NULL) {\n        return NULL;\n    }\n\n    switch (key->type) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_ED25519:\n        rc = EVP_PKEY_up_ref(key->key);\n        if (rc != 1) {\n            goto err;\n        }\n        pkey = key->key;\n\n        /* Mark the operation as successful as for the other key types */\n        rc = 1;\n\n        break;\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Unknown or invalid private key type %d\",\n                key->type);\n        goto err;\n    }\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to initialize EVP_PKEY structure\");\n        goto err;\n    }\n\n    if (passphrase == NULL) {\n        struct pem_get_password_struct pgp = { auth_fn, auth_data };\n\n        rc = PEM_write_bio_PrivateKey(mem,\n                                      pkey,\n                                      NULL, /* cipher */\n                                      NULL, /* kstr */\n                                      0, /* klen */\n                                      pem_get_password,\n                                      &pgp);\n    } else {\n        rc = PEM_write_bio_PrivateKey(mem,\n                                      pkey,\n                                      EVP_aes_128_cbc(),\n                                      NULL, /* kstr */\n                                      0, /* klen */\n                                      NULL, /* auth_fn */\n                                      (void*) passphrase);\n    }\n    EVP_PKEY_free(pkey);\n    pkey = NULL;\n\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_WARNING,\n                \"Failed to write private key: %s\\n\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto err;\n    }\n\n    BIO_get_mem_ptr(mem, &buf);\n\n    blob = ssh_string_new(buf->length);\n    if (blob == NULL) {\n        goto err;\n    }\n\n    rc = ssh_string_fill(blob, buf->data, buf->length);\n    if (rc < 0) {\n        ssh_string_free(blob);\n        goto err;\n    }\n\n    BIO_free(mem);\n\n    return blob;\n\nerr:\n    EVP_PKEY_free(pkey);\n    BIO_free(mem);\n    return NULL;\n}\n",
      "line_start": 1024,
      "line_end": 1125,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 90,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Serializes private keys (security-critical/cryptographic operation) using OpenSSL PEM_write_bio_PrivateKey, performs memory operations (BIO/BUF_MEM/ssh_string), branches on many key types and uses passphrase/callbacks \u2014 high likelihood of discovering memory/crypto-related issues. (Note: input is an ssh_key object rather than raw file parsing, but the function remains a high-value fuzz target.)"
    },
    {
      "name": "pki_pubkey_build_rsa",
      "clean_name": "pki_pubkey_build_rsa",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    BN_CTX_free(ctx);\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n\nint pki_pubkey_build_rsa(ssh_key key,\n                         ssh_string e,\n                         ssh_string n) {\n    int rc;\n    BIGNUM *be = NULL, *bn = NULL;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    OSSL_PARAM_BLD *param_bld = OSSL_PARAM_BLD_new();\n    if (param_bld == NULL) {\n        return SSH_ERROR;\n    }\n#else\n    RSA *key_rsa = RSA_new();\n    if (key_rsa == NULL) {\n        return SSH_ERROR;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    be = ssh_make_string_bn(e);\n    bn = ssh_make_string_bn(n);\n    if (be == NULL || bn == NULL) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    /* Memory management of bn and be is transferred to RSA object */\n    rc = RSA_set0_key(key_rsa, bn, be, NULL);\n    if (rc == 0) {\n        goto fail;\n    }\n\n    key->key = EVP_PKEY_new();\n    if (key->key == NULL) {\n        goto fail;\n    }\n\n    rc = EVP_PKEY_assign_RSA(key->key, key_rsa);\n    if (rc != 1) {\n        goto fail;\n    }\n\n    return SSH_OK;\nfail:\n    EVP_PKEY_free(key->key);\n    RSA_free(key_rsa);\n    return SSH_ERROR;\n#else\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_N, bn);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n    rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_RSA_E, be);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto fail;\n    }\n\n    rc = evp_build_pkey(\"RSA\", param_bld, &(key->key), EVP_PKEY_PUBLIC_KEY);\n\nfail:\n    OSSL_PARAM_BLD_free(param_bld);\n    bignum_safe_free(bn);\n    bignum_safe_free(be);\n\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 1409,
      "line_end": 1477,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 59,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Parses untrusted serialized input (SSH integer strings) into BIGNUMs and builds RSA/EVP structures using OpenSSL. This performs memory operations on attacker-controlled data and exercises crypto code paths (RSA/EVP/OSSL_PARAM), making it a high-value fuzz target for discovering parsing/memory bugs in library integrations."
    },
    {
      "name": "pki_sign_data",
      "clean_name": "pki_sign_data",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": " * @param[in]   input       The data to be signed.\n * @param[in]   input_len   The length of the data to be signed.\n *\n * @return  a newly allocated ssh_signature or NULL on error.\n */\nssh_signature pki_sign_data(const ssh_key privkey,\n                            enum ssh_digest_e hash_type,\n                            const unsigned char *input,\n                            size_t input_len)\n{\n    const EVP_MD *md = NULL;\n    EVP_MD_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    unsigned char *raw_sig_data = NULL;\n    size_t raw_sig_len;\n\n    ssh_signature sig = NULL;\n\n    int rc;\n\n    if (privkey == NULL || !ssh_key_is_private(privkey) || input == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad parameter provided to \"\n                               \"pki_sign_data()\");\n        return NULL;\n    }\n\n    /* Check if public key and hash type are compatible */\n    rc = pki_key_check_hash_compatible(privkey, hash_type);\n    if (rc != SSH_OK) {\n        return NULL;\n    }\n\n    /* Set hash algorithm to be used */\n    md = pki_digest_to_md(hash_type);\n    if (md == NULL) {\n        if (hash_type != SSH_DIGEST_AUTO) {\n            return NULL;\n        }\n    }\n\n    /* Setup private key EVP_PKEY */\n    pkey = pki_key_to_pkey(privkey);\n    if (pkey == NULL) {\n        return NULL;\n    }\n\n    /* Allocate buffer for signature */\n    raw_sig_len = (size_t)EVP_PKEY_size(pkey);\n    raw_sig_data = (unsigned char *)malloc(raw_sig_len);\n    if (raw_sig_data == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n        goto out;\n    }\n\n    /* Create the context */\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n        goto out;\n    }\n\n    /* Sign the data */\n    rc = EVP_DigestSignInit(ctx, NULL, md, NULL, pkey);\n    if (rc != 1){\n        SSH_LOG(SSH_LOG_TRACE,\n                \"EVP_DigestSignInit() failed: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    rc = EVP_DigestSign(ctx, raw_sig_data, &raw_sig_len, input, input_len);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"EVP_DigestSign() failed: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n#ifdef DEBUG_CRYPTO\n        ssh_log_hexdump(\"Generated signature\", raw_sig_data, raw_sig_len);\n#endif\n\n    /* Allocate and fill output signature */\n    sig = ssh_signature_new();\n    if (sig == NULL) {\n        goto out;\n    }\n\n    sig->raw_sig = ssh_string_new(raw_sig_len);\n    if (sig->raw_sig == NULL) {\n        ssh_signature_free(sig);\n        sig = NULL;\n        goto out;\n    }\n\n    rc = ssh_string_fill(sig->raw_sig, raw_sig_data, raw_sig_len);\n    if (rc < 0) {\n        ssh_signature_free(sig);\n        sig = NULL;\n        goto out;\n    }\n\n    sig->type = privkey->type;\n    sig->hash_type = hash_type;\n    sig->type_c = ssh_key_signature_to_char(privkey->type, hash_type);\n\nout:\n    if (ctx != NULL) {\n        EVP_MD_CTX_free(ctx);\n    }\n    if (raw_sig_data != NULL) {\n        explicit_bzero(raw_sig_data, raw_sig_len);\n    }\n    SAFE_FREE(raw_sig_data);\n    EVP_PKEY_free(pkey);\n    return sig;\n}\n",
      "line_start": 2531,
      "line_end": 2644,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 132,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Performs security-critical cryptographic signing on external input and calls into OpenSSL EVP APIs (memory ops, allocations, and native library code). While internal control flow is simple, the function handles crypto/auth operations and writes to buffers based on key-derived sizes \u2014 high-value fuzz target for uncovering crashes/crypto-related bugs."
    },
    {
      "name": "pki_verify_data_signature",
      "clean_name": "pki_verify_data_signature",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": " * @param[in]   input       The signed data.\n * @param[in]   input_len   The length of the signed data.\n *\n * @return  SSH_OK if the signature is valid; SSH_ERROR otherwise.\n */\nint pki_verify_data_signature(ssh_signature signature,\n                              const ssh_key pubkey,\n                              const unsigned char *input,\n                              size_t input_len)\n{\n    const EVP_MD *md = NULL;\n    EVP_MD_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    unsigned char *raw_sig_data = NULL;\n    size_t raw_sig_len;\n\n    /* Function return code\n     * Do not change this variable throughout the function until the signature\n     * is successfully verified!\n     */\n    int rc = SSH_ERROR;\n    int ok;\n\n    if (pubkey == NULL || ssh_key_is_private(pubkey) || input == NULL ||\n        signature == NULL || signature->raw_sig == NULL)\n    {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad parameter provided to \"\n                               \"pki_verify_data_signature()\");\n        return SSH_ERROR;\n    }\n\n    /* Check if public key and hash type are compatible */\n    ok = pki_key_check_hash_compatible(pubkey, signature->hash_type);\n    if (ok != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    /* Get the signature to be verified */\n    raw_sig_data = ssh_string_data(signature->raw_sig);\n    raw_sig_len = ssh_string_len(signature->raw_sig);\n    if (raw_sig_data == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* Set hash algorithm to be used */\n    md = pki_digest_to_md(signature->hash_type);\n    if (md == NULL) {\n        if (signature->hash_type != SSH_DIGEST_AUTO) {\n            return SSH_ERROR;\n        }\n    }\n\n    /* Setup public key EVP_PKEY */\n    pkey = pki_key_to_pkey(pubkey);\n    if (pkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* Create the context */\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create EVP_MD_CTX: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    /* Verify the signature */\n    ok = EVP_DigestVerifyInit(ctx, NULL, md, NULL, pkey);\n    if (ok != 1){\n        SSH_LOG(SSH_LOG_TRACE,\n                \"EVP_DigestVerifyInit() failed: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    ok = EVP_DigestVerify(ctx, raw_sig_data, raw_sig_len, input, input_len);\n    if (ok != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Signature invalid: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto out;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"Signature valid\");\n    rc = SSH_OK;\n\nout:\n    EVP_MD_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    return rc;\n}\n",
      "line_start": 2658,
      "line_end": 2746,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 111,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Verifies signatures using external inputs (raw signature bytes, public key, and data) and invokes crypto parsing/verification (EVP_PKEY conversion, digest verify). This is a security-critical operation handling untrusted data and interacting with complex libraries/formats (key and signature parsing), making it a high-value fuzz target."
    },
    {
      "name": "pki_crypto.c:pki_ecdsa_signature_to_blob",
      "clean_name": "pki_ecdsa_signature_to_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return NULL;\n}\n\nstatic ssh_string pki_ecdsa_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string r = NULL;\n    ssh_string s = NULL;\n\n    ssh_buffer buf = NULL;\n    ssh_string sig_blob = NULL;\n\n    const BIGNUM *pr = NULL, *ps = NULL;\n\n    const unsigned char *raw_sig_data = NULL;\n    long raw_sig_len;\n\n    ECDSA_SIG *ecdsa_sig = NULL;\n\n    int rc;\n\n    if (sig == NULL || sig->raw_sig == NULL) {\n        return NULL;\n    }\n    raw_sig_data = ssh_string_data(sig->raw_sig);\n    if (raw_sig_data == NULL) {\n        return NULL;\n    }\n    raw_sig_len = (long)ssh_string_len(sig->raw_sig);\n\n    ecdsa_sig = d2i_ECDSA_SIG(NULL, &raw_sig_data, raw_sig_len);\n    if (ecdsa_sig == NULL) {\n        return NULL;\n    }\n\n    ECDSA_SIG_get0(ecdsa_sig, &pr, &ps);\n    if (pr == NULL || ps == NULL) {\n        goto error;\n    }\n\n    r = ssh_make_bignum_string((BIGNUM *)pr);\n    if (r == NULL) {\n        goto error;\n    }\n\n    s = ssh_make_bignum_string((BIGNUM *)ps);\n    if (s == NULL) {\n        goto error;\n    }\n\n    buf = ssh_buffer_new();\n    if (buf == NULL) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(buf, r);\n    if (rc < 0) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(buf, s);\n    if (rc < 0) {\n        goto error;\n    }\n\n    sig_blob = ssh_string_new(ssh_buffer_get_len(buf));\n    if (sig_blob == NULL) {\n        goto error;\n    }\n\n    rc = ssh_string_fill(sig_blob, ssh_buffer_get(buf), ssh_buffer_get_len(buf));\n    if (rc < 0) {\n        goto error;\n    }\n\n    SSH_STRING_FREE(r);\n    SSH_STRING_FREE(s);\n    ECDSA_SIG_free(ecdsa_sig);\n    SSH_BUFFER_FREE(buf);\n\n    return sig_blob;\n\nerror:\n    SSH_STRING_FREE(sig_blob);\n    SSH_STRING_FREE(r);\n    SSH_STRING_FREE(s);\n    ECDSA_SIG_free(ecdsa_sig);\n    SSH_BUFFER_FREE(buf);\n    return NULL;\n}\n",
      "line_start": 2034,
      "line_end": 2120,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 163,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses untrusted DER ECDSA signatures (d2i_ECDSA_SIG) and converts BIGNUMs into buffers, performing memory allocations/copies on external input; security\u2011critical cryptographic parsing makes this a high\u2011value fuzz target."
    },
    {
      "name": "pki_crypto.c:pki_signature_from_ecdsa_blob",
      "clean_name": "pki_signature_from_ecdsa_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "errout:\n    SSH_STRING_FREE(sig_blob_padded);\n    return SSH_ERROR;\n}\n\nstatic int pki_signature_from_ecdsa_blob(UNUSED_PARAM(const ssh_key pubkey),\n                                         const ssh_string sig_blob,\n                                         ssh_signature sig)\n{\n    ECDSA_SIG *ecdsa_sig = NULL;\n    BIGNUM *pr = NULL, *ps = NULL;\n\n    ssh_string r = NULL;\n    ssh_string s = NULL;\n\n    ssh_buffer buf = NULL;\n    uint32_t rlen;\n\n    unsigned char *raw_sig_data = NULL;\n    unsigned char *temp_raw_sig = NULL;\n    size_t raw_sig_len = 0;\n\n    int rc;\n\n    /* build ecdsa signature */\n    buf = ssh_buffer_new();\n    if (buf == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* The buffer will contain sensitive information. Make sure it is erased */\n    ssh_buffer_set_secure(buf);\n\n    rc = ssh_buffer_add_data(buf,\n                             ssh_string_data(sig_blob),\n                             (uint32_t)ssh_string_len(sig_blob));\n    if (rc < 0) {\n        goto error;\n    }\n\n    r = ssh_buffer_get_ssh_string(buf);\n    if (r == NULL) {\n        goto error;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"r\", ssh_string_data(r), ssh_string_len(r));\n#endif\n\n    pr = ssh_make_string_bn(r);\n    ssh_string_burn(r);\n    SSH_STRING_FREE(r);\n    if (pr == NULL) {\n        goto error;\n    }\n\n    s = ssh_buffer_get_ssh_string(buf);\n    rlen = ssh_buffer_get_len(buf);\n    SSH_BUFFER_FREE(buf);\n    if (s == NULL) {\n        goto error;\n    }\n\n    if (rlen != 0) {\n        ssh_string_burn(s);\n        SSH_STRING_FREE(s);\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Signature has remaining bytes in inner \"\n                \"sigblob: %lu\",\n                (unsigned long)rlen);\n        goto error;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"s\", ssh_string_data(s), ssh_string_len(s));\n#endif\n\n    ps = ssh_make_string_bn(s);\n    ssh_string_burn(s);\n    SSH_STRING_FREE(s);\n    if (ps == NULL) {\n        goto error;\n    }\n\n    ecdsa_sig = ECDSA_SIG_new();\n    if (ecdsa_sig == NULL) {\n        goto error;\n    }\n\n    /* Memory management of pr and ps is transferred to\n     * ECDSA signature object */\n    rc = ECDSA_SIG_set0(ecdsa_sig, pr, ps);\n    if (rc == 0) {\n        goto error;\n    }\n    pr = NULL;\n    ps = NULL;\n\n    /* Get the expected size of the buffer */\n    rc = i2d_ECDSA_SIG(ecdsa_sig, NULL);\n    if (rc <= 0) {\n        goto error;\n    }\n    raw_sig_len = rc;\n\n    raw_sig_data = (unsigned char *)calloc(1, raw_sig_len);\n    if (raw_sig_data == NULL) {\n        goto error;\n    }\n    temp_raw_sig = raw_sig_data;\n\n    /* It is necessary to use a temporary pointer as i2d_* \"advances\" the\n     * pointer */\n    rc = i2d_ECDSA_SIG(ecdsa_sig, &temp_raw_sig);\n    if (rc <= 0) {\n        goto error;\n    }\n\n    sig->raw_sig = ssh_string_new(raw_sig_len);\n    if (sig->raw_sig == NULL) {\n        explicit_bzero(raw_sig_data, raw_sig_len);\n        goto error;\n    }\n\n    rc = ssh_string_fill(sig->raw_sig, raw_sig_data, raw_sig_len);\n    if (rc < 0) {\n        explicit_bzero(raw_sig_data, raw_sig_len);\n        goto error;\n    }\n\n    explicit_bzero(raw_sig_data, raw_sig_len);\n    SAFE_FREE(raw_sig_data);\n    ECDSA_SIG_free(ecdsa_sig);\n    return SSH_OK;\n\nerror:\n    SSH_BUFFER_FREE(buf);\n    bignum_safe_free(ps);\n    bignum_safe_free(pr);\n    SAFE_FREE(raw_sig_data);\n    if (ecdsa_sig != NULL) {\n        ECDSA_SIG_free(ecdsa_sig);\n    }\n    return SSH_ERROR;\n}\n",
      "line_start": 2234,
      "line_end": 2374,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 199,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses untrusted signature blobs and performs multiple memory operations (alloc/free, buf copies, explicit_bzero), converts SSH strings to BIGNUMs and builds an ASN.1 ECDSA structure (i2d_ECDSA_SIG) \u2014 i.e. complex parsing, data transformation and crypto handling with many error paths. High value for fuzzing due to potential ASN.1/length/alloc issues and security relevance."
    },
    {
      "name": "ecdh_crypto.c:ssh_ecdh_generate",
      "clean_name": "ssh_ecdh_generate",
      "source_file": "/src/libssh/src/ecdh_crypto.c",
      "source_code": "\n/* @internal\n * @brief Generate ECDH key pair for ecdh key exchange and store it in the\n * session->next_crypto structure\n */\nstatic ssh_string ssh_ecdh_generate(ssh_session session)\n{\n    ssh_string pubkey_string = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    const EC_POINT *point = NULL;\n    const EC_GROUP *group = NULL;\n    EC_KEY *key = NULL;\n    int curve;\n#else\n    EC_POINT *point = NULL;\n    EC_GROUP *group = NULL;\n    const char *curve = NULL;\n    EVP_PKEY *key = NULL;\n    OSSL_PARAM *out_params = NULL;\n    const OSSL_PARAM *pubkey_param = NULL;\n    const void *pubkey = NULL;\n    size_t pubkey_len;\n    int nid;\n    int rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    curve = ecdh_kex_type_to_curve(session->next_crypto->kex_type);\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    if (curve == SSH_ERROR) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to get curve name\");\n        return NULL;\n    }\n\n    key = EC_KEY_new_by_curve_name(curve);\n#else\n    if (curve == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to get curve name\");\n        return NULL;\n    }\n\n    key = EVP_EC_gen(curve);\n#endif /* OPENSSL_VERSION_NUMBER */\n    if (key == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to generate key\");\n        return NULL;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    group = EC_KEY_get0_group(key);\n\n    EC_KEY_generate_key(key);\n\n    point = EC_KEY_get0_public_key(key);\n\n    pubkey_string = pki_key_make_ecpoint_string(group, point);\n#else\n    rc = EVP_PKEY_todata(key, EVP_PKEY_PUBLIC_KEY, &out_params);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to export public key\");\n        EVP_PKEY_free(key);\n        return NULL;\n    }\n\n    pubkey_param = OSSL_PARAM_locate_const(out_params, OSSL_PKEY_PARAM_PUB_KEY);\n    if (pubkey_param == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to find public key\");\n        EVP_PKEY_free(key);\n        OSSL_PARAM_free(out_params);\n        return NULL;\n    }\n\n    rc = OSSL_PARAM_get_octet_string_ptr(pubkey_param,\n                                         (const void**)&pubkey,\n                                         &pubkey_len);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to read public key\");\n        OSSL_PARAM_free(out_params);\n        EVP_PKEY_free(key);\n        return NULL;\n    }\n\n    /* Convert the data to low-level representation */\n    nid = pki_key_ecgroup_name_to_nid(curve);\n    group = EC_GROUP_new_by_curve_name_ex(NULL, NULL, nid);\n    if (group == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Could not create group: %s\",\n                      ERR_error_string(ERR_get_error(), NULL));\n        OSSL_PARAM_free(out_params);\n        EVP_PKEY_free(key);\n        return NULL;\n    }\n    point = EC_POINT_new(group);\n    if (point == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Could not create point: %s\",\n                      ERR_error_string(ERR_get_error(), NULL));\n        EC_GROUP_free(group);\n        OSSL_PARAM_free(out_params);\n        EVP_PKEY_free(key);\n        return NULL;\n    }\n    rc = EC_POINT_oct2point(group, point, pubkey, pubkey_len, NULL);\n    OSSL_PARAM_free(out_params);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to export public key\");\n        EC_GROUP_free(group);\n        EC_POINT_free(point);\n        EVP_PKEY_free(key);\n        return NULL;\n    }\n\n    pubkey_string = pki_key_make_ecpoint_string(group, point);\n    EC_GROUP_free(group);\n    EC_POINT_free(point);\n#endif /* OPENSSL_VERSION_NUMBER */\n    if (pubkey_string == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to convert public key\");\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        EC_KEY_free(key);\n#else\n        EVP_PKEY_free(key);\n#endif /* OPENSSL_VERSION_NUMBER */\n        return NULL;\n    }\n\n    /* Free any previously allocated privkey */\n    if (session->next_crypto->ecdh_privkey != NULL) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        EC_KEY_free(session->next_crypto->ecdh_privkey);\n#else\n        EVP_PKEY_free(session->next_crypto->ecdh_privkey);\n#endif\n        session->next_crypto->ecdh_privkey = NULL;\n    }\n\n    session->next_crypto->ecdh_privkey = key;\n    return pubkey_string;\n}\n",
      "line_start": 71,
      "line_end": 207,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "This is a security\u2011critical cryptographic routine: it generates ECDH keys, mutates session state, and performs public\u2011key export/parse operations (EVP_PKEY_todata, OSSL_PARAM, EC_POINT_oct2point) with multiple platform-dependent branches. While the direct attacker-controlled input is limited (kex_type in session), the function exercises complex library code paths and memory operations where bugs could lead to serious vulnerabilities, so it is a high/critical fuzz target."
    },
    {
      "name": "ssh_curve25519_init",
      "clean_name": "ssh_curve25519_init",
      "source_file": "/src/libssh/src/curve25519_crypto.c",
      "source_code": "#include \"libssh/session.h\"\n\n#include <openssl/err.h>\n#include <openssl/evp.h>\n\nint ssh_curve25519_init(ssh_session session)\n{\n    ssh_curve25519_pubkey *pubkey_loc = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    size_t pubkey_len = CURVE25519_PUBKEY_SIZE;\n    int rc;\n\n    if (session->server) {\n        pubkey_loc = &session->next_crypto->curve25519_server_pubkey;\n    } else {\n        pubkey_loc = &session->next_crypto->curve25519_client_pubkey;\n    }\n\n    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_X25519, NULL);\n    if (pctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to initialize X25519 context: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_keygen_init(pctx);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to initialize X25519 keygen: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        EVP_PKEY_CTX_free(pctx);\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_keygen(pctx, &pkey);\n    EVP_PKEY_CTX_free(pctx);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to generate X25519 keys: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_get_raw_public_key(pkey, *pubkey_loc, &pubkey_len);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to get X25519 raw public key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        EVP_PKEY_free(pkey);\n        return SSH_ERROR;\n    }\n\n    /* Free any previously allocated privkey */\n    if (session->next_crypto->curve25519_privkey != NULL) {\n        EVP_PKEY_free(session->next_crypto->curve25519_privkey);\n        session->next_crypto->curve25519_privkey = NULL;\n    }\n\n    session->next_crypto->curve25519_privkey = pkey;\n    pkey = NULL;\n\n    return SSH_OK;\n}\n",
      "line_start": 32,
      "line_end": 92,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 67,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Performs security\u2011critical cryptographic operations (X25519 keygen, raw public key extraction) and manipulates session buffers via OpenSSL APIs \u2014 high value as a fuzz target due to interactions with crypto library and memory handling. Lower complexity and no complex input parsing prevent a full 10."
    },
    {
      "name": "sha256_final",
      "clean_name": "sha256_final",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha256_final(unsigned char *md, SHA256CTX c)\n{\n    unsigned int mdlen = 0;\n    int rc = EVP_DigestFinal(c, md, &mdlen);\n\n    EVP_MD_CTX_free(c);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 127,
      "line_end": 138,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Wrapper around a cryptographic operation (EVP_DigestFinal) that writes digest bytes into md and frees the context. Although the function itself is small and low-complexity, it performs security-critical crypto operations and memory writes on caller-supplied pointers, so fuzzing can expose memory-management or crypto-related issues and is high priority."
    },
    {
      "name": "sha256",
      "clean_name": "sha256",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha256(const unsigned char *digest, size_t len, unsigned char *hash)\n{\n    SHA256CTX c = sha256_init();\n    int rc;\n\n    if (c == NULL) {\n        return SSH_ERROR;\n    }\n    rc = sha256_update(c, digest, len);\n    if (rc != SSH_OK) {\n        EVP_MD_CTX_free(c);\n        return SSH_ERROR;\n    }\n    return sha256_final(hash, c);\n}\n",
      "line_start": 140,
      "line_end": 155,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This is a cryptographic wrapper that consumes external/untrusted input and feeds it into a SHA-256 implementation \u2014 a security\u2011critical operation. Although the function itself is simple, it invokes crypto/update/final routines that operate on user data and could expose memory/implementation bugs, so it is a high-priority fuzz target."
    },
    {
      "name": "sha384",
      "clean_name": "sha384",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha384(const unsigned char *digest, size_t len, unsigned char *hash)\n{\n    SHA384CTX c = sha384_init();\n    int rc;\n\n    if (c == NULL) {\n        return SSH_ERROR;\n    }\n    rc = sha384_update(c, digest, len);\n    if (rc != SSH_OK) {\n        EVP_MD_CTX_free(c);\n        return SSH_ERROR;\n    }\n    return sha384_final(hash, c);\n}\n",
      "line_start": 202,
      "line_end": 217,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "A thin wrapper performing SHA-384 on caller-controlled data \u2014 a security-critical cryptographic operation on external input. Although the function itself is simple, it processes untrusted buffers and delegates to lower-level crypto routines (potential memory ops), making it a high-value fuzz target."
    },
    {
      "name": "sha512_update",
      "clean_name": "sha512_update",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "{\n    EVP_MD_CTX_free(c);\n}\n\nint\nsha512_update(SHA512CTX c, const void *data, size_t len)\n{\n    int rc = EVP_DigestUpdate(c, data, len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 241,
      "line_end": 249,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Security-critical cryptographic operation that consumes external data (passes untrusted buffer/length into EVP_DigestUpdate). Although a simple wrapper (low internal complexity), it performs memory operations on untrusted input and is high priority for fuzzing to find memory/crypto-related issues."
    },
    {
      "name": "sha512_final",
      "clean_name": "sha512_final",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha512_final(unsigned char *md, SHA512CTX c)\n{\n    unsigned int mdlen = 0;\n    int rc = EVP_DigestFinal(c, md, &mdlen);\n\n    EVP_MD_CTX_free(c);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 251,
      "line_end": 262,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Wrapper around cryptographic finalization (EVP_DigestFinal) and freeing of the digest context \u2014 a security\u2011critical operation. Although the function is small and low complexity, it performs crypto operations and writes output into a caller-provided buffer (potential memory/ownership issues), so it is a high-risk, high-value fuzzing target."
    },
    {
      "name": "sha512",
      "clean_name": "sha512",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha512(const unsigned char *digest, size_t len, unsigned char *hash)\n{\n    SHA512CTX c = sha512_init();\n    int rc;\n\n    if (c == NULL) {\n        return SSH_ERROR;\n    }\n    rc = sha512_update(c, digest, len);\n    if (rc != SSH_OK) {\n        EVP_MD_CTX_free(c);\n        return SSH_ERROR;\n    }\n    return sha512_final(hash, c);\n}\n",
      "line_start": 264,
      "line_end": 279,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Accepts external data and length and performs a cryptographic operation (SHA-512) on untrusted input. Although the function itself is a small wrapper with little branching, it invokes memory-processing crypto routines (potentially exposing memory/implementation bugs) and is security-critical, making it a high-priority fuzz target."
    },
    {
      "name": "ssh_dh_keypair_set_keys",
      "clean_name": "ssh_dh_keypair_set_keys",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "\n    return SSH_OK;\n}\n#endif /* OPENSSL_VERSION_NUMBER */\n\nint ssh_dh_keypair_set_keys(struct dh_ctx *ctx, int peer,\n                            bignum priv, bignum pub)\n{\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    int rc;\n    OSSL_PARAM *params = NULL, *out_params = NULL, *merged_params = NULL;\n    OSSL_PARAM_BLD *param_bld = NULL;\n    EVP_PKEY_CTX *evp_ctx = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    if (((peer != DH_CLIENT_KEYPAIR) && (peer != DH_SERVER_KEYPAIR)) ||\n        ((priv == NULL) && (pub == NULL)) || (ctx == NULL) ||\n        (ctx->keypair[peer] == NULL)) {\n        return SSH_ERROR;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    (void)DH_set0_key(ctx->keypair[peer], pub, priv);\n\n    return SSH_OK;\n#else\n    rc = EVP_PKEY_todata(ctx->keypair[peer], EVP_PKEY_KEYPAIR, &out_params);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n\n    param_bld = OSSL_PARAM_BLD_new();\n    if (param_bld == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    evp_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, ctx->keypair[peer], NULL);\n    if (evp_ctx == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    rc = EVP_PKEY_fromdata_init(evp_ctx);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    if (priv) {\n        rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_PRIV_KEY, priv);\n        if (rc != 1) {\n            rc = SSH_ERROR;\n            goto out;\n        }\n    }\n    if (pub) {\n        rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_PUB_KEY, pub);\n        if (rc != 1) {\n            rc = SSH_ERROR;\n            goto out;\n        }\n    }\n\n    params = OSSL_PARAM_BLD_to_param(param_bld);\n    if (params == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n    OSSL_PARAM_BLD_free(param_bld);\n\n    merged_params = OSSL_PARAM_merge(out_params, params);\n    if (merged_params == NULL) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    rc = EVP_PKEY_fromdata(evp_ctx,\n                           &(ctx->keypair[peer]),\n                           EVP_PKEY_PUBLIC_KEY,\n                           merged_params);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto out;\n    }\n\n    rc = SSH_OK;\nout:\n    bignum_safe_free(priv);\n    bignum_safe_free(pub);\n    EVP_PKEY_CTX_free(evp_ctx);\n    OSSL_PARAM_free(out_params);\n    OSSL_PARAM_free(params);\n    OSSL_PARAM_free(merged_params);\n\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n",
      "line_start": 155,
      "line_end": 248,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Security-critical function that sets DH key material using OpenSSL EVP APIs. It consumes external bignum inputs (untrusted), builds/merges OSSL_PARAM structures and calls complex library routines (EVP_PKEY_fromdata/EVP_PKEY_todata), so there are multiple code paths and potential memory/formatting work inside OpenSSL. High priority for fuzzing due to cryptographic context and surface for memory/validation bugs."
    },
    {
      "name": "ssh_dh_set_parameters",
      "clean_name": "ssh_dh_set_parameters",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "\n    return SSH_OK;\n}\n#endif /* OPENSSL_VERSION_NUMBER */\n\nint ssh_dh_set_parameters(struct dh_ctx *ctx,\n                          const bignum modulus, const bignum generator)\n{\n    size_t i;\n    int rc;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    OSSL_PARAM *params = NULL;\n    OSSL_PARAM_BLD *param_bld = NULL;\n    EVP_PKEY_CTX *evp_ctx = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    if ((ctx == NULL) || (modulus == NULL) || (generator == NULL)) {\n        return SSH_ERROR;\n    }\n\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    evp_ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DHX\", NULL);\n#endif\n\n    for (i = 0; i < 2; i++) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        bignum p = NULL;\n        bignum g = NULL;\n\n        /* when setting modulus or generator,\n         * make sure to invalidate existing keys */\n        DH_free(ctx->keypair[i]);\n        ctx->keypair[i] = DH_new();\n        if (ctx->keypair[i] == NULL) {\n            rc = SSH_ERROR;\n            goto done;\n        }\n\n        p = BN_dup(modulus);\n        g = BN_dup(generator);\n        rc = DH_set0_pqg(ctx->keypair[i], p, NULL, g);\n        if (rc != 1) {\n            BN_free(p);\n            BN_free(g);\n            rc = SSH_ERROR;\n            goto done;\n        }\n#else\n        param_bld = OSSL_PARAM_BLD_new();\n\n        if (param_bld == NULL) {\n            rc = SSH_ERROR;\n            goto done;\n        }\n\n        rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_FFC_P, modulus);\n        if (rc != 1) {\n            rc = SSH_ERROR;\n            goto done;\n        }\n        rc = OSSL_PARAM_BLD_push_BN(param_bld, OSSL_PKEY_PARAM_FFC_G, generator);\n        if (rc != 1) {\n            rc = SSH_ERROR;\n            goto done;\n        }\n        params = OSSL_PARAM_BLD_to_param(param_bld);\n        if (params == NULL) {\n            OSSL_PARAM_BLD_free(param_bld);\n            rc = SSH_ERROR;\n            goto done;\n        }\n        OSSL_PARAM_BLD_free(param_bld);\n\n        rc = EVP_PKEY_fromdata_init(evp_ctx);\n        if (rc != 1) {\n            OSSL_PARAM_free(params);\n            rc = SSH_ERROR;\n            goto done;\n        }\n\n        /* make sure to invalidate existing keys */\n        EVP_PKEY_free(ctx->keypair[i]);\n        ctx->keypair[i] = NULL;\n\n        rc = EVP_PKEY_fromdata(evp_ctx,\n                               &(ctx->keypair[i]),\n                               EVP_PKEY_KEY_PARAMETERS,\n                               params);\n        if (rc != 1) {\n            OSSL_PARAM_free(params);\n            rc = SSH_ERROR;\n            goto done;\n        }\n\n        OSSL_PARAM_free(params);\n#endif /* OPENSSL_VERSION_NUMBER */\n    }\n\n    rc = SSH_OK;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\ndone:\n    if (rc != SSH_OK) {\n        DH_free(ctx->keypair[0]);\n        DH_free(ctx->keypair[1]);\n    }\n#else\ndone:\n    EVP_PKEY_CTX_free(evp_ctx);\n\n    if (rc != SSH_OK) {\n        EVP_PKEY_free(ctx->keypair[0]);\n        EVP_PKEY_free(ctx->keypair[1]);\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n    if (rc != SSH_OK) {\n        ctx->keypair[0] = NULL;\n        ctx->keypair[1] = NULL;\n    }\n\n    return rc;\n}\n",
      "line_start": 283,
      "line_end": 399,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 65,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Takes external bignum parameters and installs them into DH/EVP structures (cryptography), performing allocations, duplication and freeing; interacts heavily with OpenSSL APIs so malformed/edge bignums can trigger memory/crypto bugs. Has error-handling branches and multiple code paths (version-dependent), making it a high-value fuzz target."
    },
    {
      "name": "ssh_dh_compute_shared_secret",
      "clean_name": "ssh_dh_compute_shared_secret",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": " * @param[in] local peer identifier (DH_CLIENT_KEYPAIR or DH_SERVER_KEYPAIR)\n * @param[in] remote peer identifier (DH_CLIENT_KEYPAIR or DH_SERVER_KEYPAIR)\n * @param[out] dest a new bignum with the shared secret value is returned.\n * @return SSH_OK on success, SSH_ERROR on error\n */\nint ssh_dh_compute_shared_secret(struct dh_ctx *dh_ctx, int local, int remote,\n                                 bignum *dest)\n{\n    unsigned char *kstring = NULL;\n    int rc;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum pub_key = NULL;\n    int klen;\n#else\n    size_t klen;\n    EVP_PKEY_CTX *evp_ctx = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    if ((dh_ctx == NULL) ||\n        (dh_ctx->keypair[local] == NULL) ||\n        (dh_ctx->keypair[remote] == NULL)) {\n        return SSH_ERROR;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    kstring = malloc(DH_size(dh_ctx->keypair[local]));\n    if (kstring == NULL) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    rc = ssh_dh_keypair_get_keys(dh_ctx, remote, NULL, &pub_key);\n    if (rc != SSH_OK) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    klen = DH_compute_key(kstring, pub_key, dh_ctx->keypair[local]);\n    if (klen == -1) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n#else\n    evp_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, dh_ctx->keypair[local], NULL);\n\n    rc = EVP_PKEY_derive_init(evp_ctx);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    rc = EVP_PKEY_derive_set_peer(evp_ctx, dh_ctx->keypair[remote]);\n    if (rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to set peer key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    /* getting the size of the secret */\n    rc = EVP_PKEY_derive(evp_ctx, kstring, &klen);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    kstring = malloc(klen);\n    if (kstring == NULL) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    rc = EVP_PKEY_derive(evp_ctx, kstring, &klen);\n    if (rc != 1) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    *dest = BN_bin2bn(kstring, (int)klen, NULL);\n    if (*dest == NULL) {\n        rc = SSH_ERROR;\n        goto done;\n    }\n\n    rc = SSH_OK;\ndone:\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    EVP_PKEY_CTX_free(evp_ctx);\n#endif\n    free(kstring);\n    return rc;\n}\n",
      "line_start": 524,
      "line_end": 613,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Computes a Diffie-Hellman shared secret using external key material (security-critical crypto). It performs variable-sized memory allocations and binary-to-BIGNUM conversion on untrusted data, has multiple error/branch paths (OpenSSL API variants) and thus is a high-value fuzz target for discovering memory/crypto-related issues."
    },
    {
      "name": "ssh_message_auth_interactive_request",
      "clean_name": "ssh_message_auth_interactive_request",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  msg->session->auth.supported_methods = (uint32_t)methods;\n\n  return 0;\n}\n\nint ssh_message_auth_interactive_request(ssh_message msg, const char *name,\n                            const char *instruction, unsigned int num_prompts,\n                            const char **prompts, char *echo) {\n  int rc;\n  unsigned int i = 0;\n\n  if(name == NULL || instruction == NULL) {\n    return SSH_ERROR;\n  }\n  if(num_prompts > 0 && (prompts == NULL || echo == NULL)) {\n    return SSH_ERROR;\n  }\n\n  rc = ssh_buffer_pack(msg->session->out_buffer,\n                       \"bsssd\",\n                       SSH2_MSG_USERAUTH_INFO_REQUEST,\n                       name,\n                       instruction,\n                       \"\",           /* language tag */\n                       num_prompts);\n  if (rc != SSH_OK){\n    ssh_set_error_oom(msg->session);\n    return SSH_ERROR;\n  }\n\n  for(i = 0; i < num_prompts; i++) {\n    rc = ssh_buffer_pack(msg->session->out_buffer,\n                         \"sb\",\n                         prompts[i],\n                         echo[i] ? 1 : 0);\n    if (rc != SSH_OK){\n        ssh_set_error_oom(msg->session);\n        return SSH_ERROR;\n    }\n  }\n\n  rc = ssh_packet_send(msg->session);\n\n  /* fill in the kbdint structure */\n  if (msg->session->kbdint == NULL) {\n    SSH_LOG(SSH_LOG_DEBUG, \"Warning: Got a keyboard-interactive response \"\n                           \"but it seems we didn't send the request.\");\n\n    msg->session->kbdint = ssh_kbdint_new();\n    if (msg->session->kbdint == NULL) {\n      ssh_set_error_oom(msg->session);\n\n      return SSH_ERROR;\n    }\n  } else {\n    ssh_kbdint_clean(msg->session->kbdint);\n  }\n\n  msg->session->kbdint->name = strdup(name);\n  if(msg->session->kbdint->name == NULL) {\n      ssh_set_error_oom(msg->session);\n      ssh_kbdint_free(msg->session->kbdint);\n      msg->session->kbdint = NULL;\n      return SSH_PACKET_USED;\n  }\n  msg->session->kbdint->instruction = strdup(instruction);\n  if(msg->session->kbdint->instruction == NULL) {\n      ssh_set_error_oom(msg->session);\n      ssh_kbdint_free(msg->session->kbdint);\n      msg->session->kbdint = NULL;\n      return SSH_PACKET_USED;\n  }\n\n  msg->session->kbdint->nprompts = num_prompts;\n  if(num_prompts > 0) {\n    msg->session->kbdint->prompts = calloc(num_prompts, sizeof(char *));\n    if (msg->session->kbdint->prompts == NULL) {\n      msg->session->kbdint->nprompts = 0;\n      ssh_set_error_oom(msg->session);\n      ssh_kbdint_free(msg->session->kbdint);\n      msg->session->kbdint = NULL;\n      return SSH_ERROR;\n    }\n    msg->session->kbdint->echo = calloc(num_prompts, sizeof(unsigned char));\n    if (msg->session->kbdint->echo == NULL) {\n      ssh_set_error_oom(msg->session);\n      ssh_kbdint_free(msg->session->kbdint);\n      msg->session->kbdint = NULL;\n      return SSH_ERROR;\n    }\n    for (i = 0; i < num_prompts; i++) {\n      msg->session->kbdint->echo[i] = echo[i];\n      msg->session->kbdint->prompts[i] = strdup(prompts[i]);\n      if (msg->session->kbdint->prompts[i] == NULL) {\n        ssh_set_error_oom(msg->session);\n        msg->session->kbdint->nprompts = i;\n        ssh_kbdint_free(msg->session->kbdint);\n        msg->session->kbdint = NULL;\n        return SSH_PACKET_USED;\n      }\n    }\n  } else {\n    msg->session->kbdint->prompts = NULL;\n    msg->session->kbdint->echo = NULL;\n  }\n  msg->session->auth.state = SSH_AUTH_STATE_INFO;\n\n  return rc;\n}\n",
      "line_start": 932,
      "line_end": 1036,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 177,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Handles authentication (keyboard-interactive), performs many memory/string operations (strdup, calloc, buffer packing), loops over external num_prompts and copies untrusted prompt/echo data, sends network packets and has multiple error paths \u2014 high risk and valuable as a fuzz target."
    },
    {
      "name": "dh-gex.c:ssh_packet_server_dhgex_request",
      "clean_name": "ssh_packet_server_dhgex_request",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "    ssh_packet_set_callbacks(session, &ssh_dhgex_server_callbacks);\n    ssh_dh_init_common(session->next_crypto);\n    session->dh_handshake_state = DH_STATE_INIT;\n}\n\nstatic SSH_PACKET_CALLBACK(ssh_packet_server_dhgex_request)\n{\n    bignum modulus = NULL, generator = NULL;\n    uint32_t pmin, pn, pmax;\n    size_t size = 0;\n    int rc;\n\n    (void) type;\n    (void) user;\n\n    if (session->dh_handshake_state != DH_STATE_INIT) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Received DH_GEX_REQUEST in invalid state\");\n        goto error;\n    }\n\n    /* Minimum group size, preferred group size, maximum group size */\n    rc = ssh_buffer_unpack(packet, \"ddd\", &pmin, &pn, &pmax);\n    if (rc != SSH_OK){\n        ssh_set_error_invalid(session);\n        goto error;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"dh-gex: DHGEX_REQUEST[%\" PRIu32 \":%\" PRIu32 \":%\" PRIu32 \"]\", pmin, pn, pmax);\n\n    if (pmin > pn || pn > pmax || pn > DH_PMAX || pmax < DH_PMIN) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid dh-gex arguments [%\" PRIu32 \":%\" PRIu32 \":%\" PRIu32 \"]\",\n                      pmin,\n                      pn,\n                      pmax);\n        goto error;\n    }\n    session->next_crypto->dh_pmin = pmin;\n    session->next_crypto->dh_pn = pn;\n    session->next_crypto->dh_pmax = pmax;\n\n    /* ensure safe parameters */\n    if (pmin < DH_PMIN) {\n        pmin = DH_PMIN;\n        if (pn < pmin) {\n            pn = pmin;\n        }\n    }\n    rc = ssh_retrieve_dhgroup(session->server_opts.moduli_file,\n                              pmin,\n                              pn,\n                              pmax,\n                              &size,\n                              &modulus,\n                              &generator);\n    if (rc == SSH_ERROR) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Couldn't find DH group for [%\" PRIu32 \":%\" PRIu32 \":%\" PRIu32 \"]\",\n                      pmin,\n                      pn,\n                      pmax);\n        goto error;\n    }\n    rc = ssh_dh_set_parameters(session->next_crypto->dh_ctx,\n                               modulus, generator);\n    if (rc != SSH_OK) {\n        bignum_safe_free(generator);\n        bignum_safe_free(modulus);\n        goto error;\n    }\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bBB\",\n                         SSH2_MSG_KEX_DH_GEX_GROUP,\n                         modulus,\n                         generator);\n\n#ifdef HAVE_LIBCRYPTO\n    bignum_safe_free(generator);\n    bignum_safe_free(modulus);\n#endif\n\n    if (rc != SSH_OK) {\n        ssh_set_error_invalid(session);\n        goto error;\n    }\n\n    session->dh_handshake_state = DH_STATE_GROUP_SENT;\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\nerror:\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 605,
      "line_end": 699,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 153,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses untrusted network input for DH group exchange, performs bignum and buffer memory operations, touches moduli file selection, and sets crypto parameters for key exchange. Multiple validation branches and security-critical behavior make this a high-value fuzz target."
    },
    {
      "name": "dh-gex.c:ssh_retrieve_dhgroup",
      "clean_name": "ssh_retrieve_dhgroup",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": " * @param[out] size size of the chosen modulus\n * @param[out] p modulus\n * @param[out] g generator\n * @return SSH_OK on success, SSH_ERROR otherwise.\n */\nstatic int ssh_retrieve_dhgroup(char *moduli_file,\n                                uint32_t pmin,\n                                uint32_t pn,\n                                uint32_t pmax,\n                                size_t *size,\n                                bignum *p,\n                                bignum *g)\n{\n    FILE *moduli = NULL;\n    char *generator = NULL;\n    char *modulus = NULL;\n    int rc;\n\n    /* In FIPS mode, we can not negotiate arbitrary primes,\n     * but just the approved ones */\n    if (ssh_fips_mode()) {\n        SSH_LOG(SSH_LOG_TRACE, \"In FIPS mode, using built-in primes\");\n        return ssh_fallback_group(pmax, p, g);\n    }\n\n    if (moduli_file != NULL)\n        moduli = fopen(moduli_file, \"r\");\n    else\n        moduli = fopen(MODULI_FILE, \"r\");\n\n    if (moduli == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Unable to open moduli file: %s\",\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                return ssh_fallback_group(pmax, p, g);\n    }\n\n    *size = 0;\n    *p = NULL;\n    *g = NULL;\n\n    rc = ssh_retrieve_dhgroup_file(moduli,\n                                   pmin,\n                                   pn,\n                                   pmax,\n                                   size,\n                                   &generator,\n                                   &modulus);\n    fclose(moduli);\n    if (rc == SSH_ERROR || *size == 0) {\n        goto error;\n    }\n    rc = bignum_hex2bn(generator, g);\n    if (rc == 0) {\n        goto error;\n    }\n    rc = bignum_hex2bn(modulus, p);\n    if (rc == 0) {\n        goto error;\n    }\n    SAFE_FREE(generator);\n    SAFE_FREE(modulus);\n\n    return SSH_OK;\n\nerror:\n    bignum_safe_free(*g);\n    bignum_safe_free(*p);\n    SAFE_FREE(generator);\n    SAFE_FREE(modulus);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 506,
      "line_end": 575,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 117,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Opens and parses an external moduli file and converts hex strings into bignums (memory allocations and buffer processing) and is directly involved in selecting DH parameters (cryptographic, security-critical). While the function itself is mostly orchestration, it touches untrusted input parsing and bignum operations (high risk) \u2014 high-value fuzz target."
    },
    {
      "name": "dh-gex.c:ssh_retrieve_dhgroup_file",
      "clean_name": "ssh_retrieve_dhgroup_file",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "}\n\n/** @internal\n * @brief retrieves a DH group from an open moduli file.\n */\nstatic int ssh_retrieve_dhgroup_file(FILE *moduli,\n                                     uint32_t pmin,\n                                     uint32_t pn,\n                                     uint32_t pmax,\n                                     size_t *best_size,\n                                     char **best_generator,\n                                     char **best_modulus)\n{\n    char timestamp[32] = {0};\n    char generator[32] = {0};\n    char modulus[4096] = {0};\n    size_t type, tests, tries, size, proposed_size;\n    int firstbyte;\n    int rc;\n    size_t line = 0;\n    size_t best_nlines = 0;\n\n    for(;;) {\n        line++;\n        firstbyte = getc(moduli);\n        if (firstbyte == '#'){\n            do {\n                firstbyte = getc(moduli);\n            } while(firstbyte != '\\n' && firstbyte != EOF);\n            if (firstbyte == EOF) {\n                break;\n            }\n            continue;\n        }\n        if (firstbyte == EOF) {\n            break;\n        }\n        ungetc(firstbyte, moduli);\n        rc = fscanf(moduli,\n                    \"%31s %zu %zu %zu %zu %31s %4095s\\n\",\n                    timestamp,\n                    &type,\n                    &tests,\n                    &tries,\n                    &size,\n                    generator,\n                    modulus);\n        if (rc != 7){\n            if (rc == EOF) {\n                break;\n            }\n            SSH_LOG(SSH_LOG_DEBUG, \"Invalid moduli entry line %zu\", line);\n            do {\n                firstbyte = getc(moduli);\n            } while(firstbyte != '\\n' && firstbyte != EOF);\n            if (firstbyte == EOF) {\n                break;\n            }\n            continue;\n        }\n\n        /* we only want safe primes that were tested */\n        if (type != SAFE_PRIME || !(tests & PRIM_TEST_REQUIRED)) {\n            continue;\n        }\n\n        proposed_size = size + 1;\n        if (proposed_size != *best_size &&\n            dhgroup_better_size(pmin, pn, pmax, *best_size, proposed_size)) {\n            best_nlines = 1;\n            *best_size = proposed_size;\n        } else if (proposed_size == *best_size) {\n            best_nlines++;\n        }\n\n        /* Use reservoir sampling algorithm */\n        if (proposed_size == *best_size && invn_chance(best_nlines)) {\n            SAFE_FREE(*best_generator);\n            SAFE_FREE(*best_modulus);\n            *best_generator = strdup(generator);\n            if (*best_generator == NULL) {\n                return SSH_ERROR;\n            }\n            *best_modulus = strdup(modulus);\n            if (*best_modulus == NULL) {\n                SAFE_FREE(*best_generator);\n                return SSH_ERROR;\n            }\n        }\n    }\n    if (*best_size != 0) {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Selected %zu bits modulus out of %zu candidates in %zu lines\",\n                *best_size,\n                best_nlines - 1,\n                line);\n    } else {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"No moduli found for [%\" PRIu32 \":%\" PRIu32 \":%\" PRIu32 \"]\",\n                pmin,\n                pn,\n                pmax);\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 394,
      "line_end": 495,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 135,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Parses a complex external 'moduli' file and performs memory/string operations on untrusted data (fscanf into 4095-byte modulus buffer, strdup), has looped input-dependent bounds, nontrivial branching (type/tests filtering, size selection, reservoir sampling) and influences crypto parameter selection \u2014 high-value fuzz target."
    },
    {
      "name": "ssh_agent_get_next_ident",
      "clean_name": "ssh_agent_get_next_ident",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "\n    return NULL;\n}\n\n/* caller has to free comment */\nssh_key ssh_agent_get_next_ident(struct ssh_session_struct *session,\n                                 char **comment)\n{\n    struct ssh_key_struct *key = NULL;\n    struct ssh_string_struct *blob = NULL;\n    struct ssh_string_struct *tmp = NULL;\n    int rc;\n\n    if (session->agent->count == 0) {\n        return NULL;\n    }\n\n    /* get the blob */\n    blob = ssh_buffer_get_ssh_string(session->agent->ident);\n    if (blob == NULL) {\n        return NULL;\n    }\n\n    /* get the comment */\n    tmp = ssh_buffer_get_ssh_string(session->agent->ident);\n    if (tmp == NULL) {\n        SSH_STRING_FREE(blob);\n\n        return NULL;\n    }\n\n    if (comment) {\n        *comment = ssh_string_to_char(tmp);\n    } else {\n        SSH_STRING_FREE(blob);\n        SSH_STRING_FREE(tmp);\n\n        return NULL;\n    }\n    SSH_STRING_FREE(tmp);\n\n    /* get key from blob */\n    rc = ssh_pki_import_pubkey_blob(blob, &key);\n    if (rc == SSH_ERROR) {\n        /* Try again as a cert. */\n        rc = ssh_pki_import_cert_blob(blob, &key);\n    }\n    SSH_STRING_FREE(blob);\n    if (rc == SSH_ERROR) {\n        return NULL;\n    }\n\n    return key;\n}\n",
      "line_start": 446,
      "line_end": 495,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 94,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Security-critical wrapper that consumes and parses agent-provided key blobs and comments and calls complex crypto parsing functions (pubkey/cert import). It processes external/untrusted data and feeds it into memory- and parsing-intensive routines, making it a high-value fuzz target even though the function itself is thin."
    },
    {
      "name": "ssh_agent_sign_data",
      "clean_name": "ssh_agent_sign_data",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "    }\n\n    return 0;\n}\n\nssh_string ssh_agent_sign_data(ssh_session session,\n                               const ssh_key pubkey,\n                               struct ssh_buffer_struct *data)\n{\n    ssh_buffer request = NULL;\n    ssh_buffer reply = NULL;\n    ssh_string key_blob = NULL;\n    ssh_string sig_blob = NULL;\n    unsigned int type = 0;\n    unsigned int flags = 0;\n    uint32_t dlen;\n    size_t request_len;\n    int rc;\n\n    request = ssh_buffer_new();\n    if (request == NULL) {\n        return NULL;\n    }\n\n    /* create request */\n    if (ssh_buffer_add_u8(request, SSH2_AGENTC_SIGN_REQUEST) < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    rc = ssh_pki_export_pubkey_blob(pubkey, &key_blob);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    /*\n     * make sure it already can contain all the expected content:\n     * - 1 x uint8_t\n     * - 2 x uint32_t\n     * - 1 x ssh_string (uint8_t + data)\n     */\n    request_len = sizeof(uint8_t) * 2 +\n                  sizeof(uint32_t) * 2 +\n                  ssh_string_len(key_blob);\n    /* this can't overflow the uint32_t as the\n     * STRING_SIZE_MAX is (UINT32_MAX >> 8) + 1 */\n    rc = ssh_buffer_allocate_size(request, (uint32_t)request_len);\n    if (rc < 0) {\n        SSH_STRING_FREE(key_blob);\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    /* adds len + blob */\n    rc = ssh_buffer_add_ssh_string(request, key_blob);\n    SSH_STRING_FREE(key_blob);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    /* Add data */\n    dlen = ssh_buffer_get_len(data);\n    if (ssh_buffer_add_u32(request, htonl(dlen)) < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n    if (ssh_buffer_add_data(request, ssh_buffer_get(data), dlen) < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    /* Add Flags: SHA2 extension (RFC 8332) if negotiated */\n    if (ssh_key_type_plain(pubkey->type) == SSH_KEYTYPE_RSA) {\n        if (session->extensions & SSH_EXT_SIG_RSA_SHA512) {\n            flags |= SSH_AGENT_RSA_SHA2_512;\n        } else if (session->extensions & SSH_EXT_SIG_RSA_SHA256) {\n            flags |= SSH_AGENT_RSA_SHA2_256;\n        }\n    }\n    if (ssh_buffer_add_u32(request, htonl(flags)) < 0) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    reply = ssh_buffer_new();\n    if (reply == NULL) {\n        SSH_BUFFER_FREE(request);\n        return NULL;\n    }\n\n    /* send the request */\n    if (agent_talk(session, request, reply) < 0) {\n        SSH_BUFFER_FREE(request);\n        SSH_BUFFER_FREE(reply);\n        return NULL;\n    }\n    SSH_BUFFER_FREE(request);\n\n    /* check if reply is valid */\n    if (ssh_buffer_get_u8(reply, (uint8_t *) &type) != sizeof(uint8_t)) {\n        SSH_BUFFER_FREE(reply);\n        return NULL;\n    }\n#ifdef WORDS_BIGENDIAN\n    type = bswap_32(type);\n#endif\n\n    if (agent_failed(type)) {\n        SSH_LOG(SSH_LOG_DEBUG, \"Agent reports failure in signing the key\");\n        SSH_BUFFER_FREE(reply);\n        return NULL;\n    } else if (type != SSH2_AGENT_SIGN_RESPONSE) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Bad authentication response: %u\",\n                      type);\n        SSH_BUFFER_FREE(reply);\n        return NULL;\n    }\n\n    sig_blob = ssh_buffer_get_ssh_string(reply);\n    SSH_BUFFER_FREE(reply);\n\n    return sig_blob;\n}\n",
      "line_start": 515,
      "line_end": 637,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 275,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Constructs and parses SSH agent protocol messages: serializes untrusted data into buffers and copies it (memcpy-like ops), exports/parses length-prefixed key and signature blobs, and parses replies from an external agent via agent_talk. This is protocol parsing of external input with branching and security-critical (signing/crypto) context \u2014 high-value fuzz target."
    },
    {
      "name": "agent.c:agent_talk",
      "clean_name": "agent_talk",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "\n  return -1;\n}\n#endif\n\nstatic int agent_talk(struct ssh_session_struct *session,\n                      struct ssh_buffer_struct *request,\n                      struct ssh_buffer_struct *reply)\n{\n    uint32_t len = 0;\n    uint8_t tmpbuf[4];\n    uint8_t *payload = tmpbuf;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n    len = ssh_buffer_get_len(request);\n    SSH_LOG(SSH_LOG_TRACE, \"Request length: %\" PRIu32, len);\n    PUSH_BE_U32(payload, 0, len);\n\n    /* send length and then the request packet */\n    if (atomicio(session->agent, payload, 4, 0) == 4) {\n        if (atomicio(session->agent, ssh_buffer_get(request), len, 0) != len) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"atomicio sending request failed: %s\",\n                    ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n            return -1;\n        }\n    } else {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"atomicio sending request length failed: %s\",\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return -1;\n    }\n\n    /* wait for response, read the length of the response packet */\n    if (atomicio(session->agent, payload, 4, 1) != 4) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"atomicio read response length failed: %s\",\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return -1;\n    }\n\n    len = PULL_BE_U32(payload, 0);\n    if (len > 256 * 1024) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Authentication response too long: %\" PRIu32,\n                      len);\n        return -1;\n    }\n    SSH_LOG(SSH_LOG_TRACE, \"Response length: %\" PRIu32, len);\n\n    payload = ssh_buffer_allocate(reply, len);\n    if (payload == NULL) {\n        SSH_LOG(SSH_LOG_DEBUG, \"Not enough space\");\n        return -1;\n    }\n\n    if (atomicio(session->agent, payload, len, 1) != len) {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Error reading response from authentication socket.\");\n        /* Rollback the unused space */\n        ssh_buffer_pass_bytes_end(reply, len);\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 287,
      "line_end": 349,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 100,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 9.0,
      "reason": "Talks to an external agent over a socket (network protocol), performs memory operations on untrusted data (reads length, allocates buffer, reads payload), and is part of authentication/agent handling \u2014 security-critical. Input validation exists but is limited, making this a high-impact fuzz target."
    },
    {
      "name": "ssh_make_string_bn",
      "clean_name": "ssh_make_string_bn",
      "source_file": "/src/libssh/src/bignum.c",
      "source_code": "ssh_string ssh_make_padded_bignum_string(bignum num, size_t pad_len)\n{\n    return make_bignum_string(num, pad_len);\n}\n\nbignum ssh_make_string_bn(ssh_string string)\n{\n    bignum bn = NULL;\n    size_t len = ssh_string_len(string);\n\n#ifdef DEBUG_CRYPTO\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Importing a %zu bits, %zu bytes object ...\",\n            len * 8,\n            len);\n#endif /* DEBUG_CRYPTO */\n\n    bignum_bin2bn(string->data, (int)len, &bn);\n\n    return bn;\n}\n",
      "line_start": 77,
      "line_end": 93,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Takes untrusted input and imports it as a bignum (cryptographic primitive) by calling bignum_bin2bn on external data \u2014 security-critical and memory-facing. The function itself is simple, but it exercises integer/binary parsing in crypto code (also has a size_t\u2192int cast that could truncate), making it a high-value fuzz target."
    },
    {
      "name": "secure_memcmp",
      "clean_name": "secure_memcmp",
      "source_file": "/src/libssh/src/crypto_common.c",
      "source_code": " */\n\n#include \"config.h\"\n#include \"libssh/crypto.h\"\n\nint secure_memcmp(const void *s1, const void *s2, size_t n)\n{\n    size_t i;\n    uint8_t status = 0;\n    const uint8_t *p1 = s1;\n    const uint8_t *p2 = s2;\n\n    for (i = 0; i < n; i++) {\n        status |= (p1[i] ^ p2[i]);\n    }\n\n    return (status != 0);\n}\n",
      "line_start": 23,
      "line_end": 36,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This is a security-critical constant-time memory comparison used in crypto/auth contexts. It performs untrusted memory reads across an externally provided length and is used to compare secrets (high-value target for fuzzing and memory-safety checks). Its logic is simple (so not a 10), but because it operates on sensitive data and can expose memory- and timing-related issues it deserves critical priority."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_client_config_fuzzer.c",
      "source_code": "\n#define LIBSSH_STATIC 1\n#include \"libssh/libssh.h\"\n#include \"libssh/options.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_session session = NULL;\n    char *input = NULL;\n\n    input = (char *)malloc(size+1);\n    if (!input) {\n        return 1;\n    }\n    strncpy(input, (const char *)data, size);\n    input[size] = '\\0';\n\n    ssh_init();\n\n    session = ssh_new();\n    assert(session != NULL);\n\n    /* Make sure we have default options set */\n    ssh_options_set(session, SSH_OPTIONS_SSH_DIR, NULL);\n    ssh_options_set(session, SSH_OPTIONS_HOST, \"example.com\");\n\n    ssh_config_parse_string(session, input);\n\n    ssh_free(session);\n    ssh_finalize();\n\n    free(input);\n\n    return 0;\n}\n",
      "line_start": 25,
      "line_end": 55,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Feeds arbitrary bytes as an SSH config string into libssh's ssh_config_parse_string \u2014 a complex, structured parser with many code paths. The harness performs memory ops on untrusted data (malloc/strncpy) and exercises security-relevant library parsing (configuration that can affect SSH behavior). High-value fuzz target for finding memory- and logic-bugs."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_known_hosts_fuzzer.c",
      "source_code": "\n#define LIBSSH_STATIC 1\n#include \"libssh/libssh.h\"\n#include \"knownhosts.c\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    char *hostname = NULL;\n    const uint8_t *hostname_end = NULL;\n    size_t hostname_len = 0;\n    char filename[256];\n    struct ssh_list *entries = NULL;\n    struct ssh_iterator *it = NULL;\n    FILE *fp = NULL;\n\n    /* Interpret the first part of the string (until the first NULL byte)\n     * as a hostname we are searching for in the file */\n    hostname_end = memchr(data, '\\0', size);\n    if (hostname_end == NULL) {\n        return 1;\n    }\n    hostname_len = hostname_end - data + 1;\n    if (hostname_len > 253) {\n        /* This is the maximum valid length of a hostname */\n        return 1;\n    }\n    hostname = malloc(hostname_len);\n    if (hostname == NULL) {\n        return 1;\n    }\n    memcpy(hostname, data, hostname_len);\n\n    snprintf(filename, sizeof(filename), \"/tmp/libfuzzer.%d\", getpid());\n    fp = fopen(filename, \"wb\");\n    if (!fp) {\n        free(hostname);\n        return 1;\n    }\n    fwrite(data + hostname_len, size - hostname_len, 1, fp);\n    fclose(fp);\n\n    ssh_init();\n\n    ssh_known_hosts_read_entries(hostname, filename, &entries);\n    for (it = ssh_list_get_iterator(entries);\n         it != NULL;\n         it = ssh_list_get_iterator(entries)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entries, it);\n    }\n    ssh_list_free(entries);\n\n    ssh_finalize();\n\n    free(hostname);\n    unlink(filename);\n\n    return 0;\n}\n",
      "line_start": 25,
      "line_end": 82,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 45,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "This target feeds untrusted data into a real parser (libssh known_hosts file) via a temp file and performs memcpy/allocations on input. It exercises complex, structured-input parsing code (potentially security-critical), has input-dependent loops/paths via the parser results, and performs buffer/memory operations \u2014 making it a high-value (critical) fuzz target."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_privkey_fuzzer.c",
      "source_code": "\n#define LIBSSH_STATIC 1\n#include \"libssh/libssh.h\"\n#include \"libssh/priv.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_key pkey = NULL;\n    uint8_t *input = NULL;\n    int rc;\n\n    input = bin_to_base64(data, size);\n    if (input == NULL) {\n        return 1;\n    }\n\n    ssh_init();\n\n    rc = ssh_pki_import_privkey_base64((char *)input, NULL, NULL, NULL, &pkey);\n    free(input);\n    if (rc != SSH_OK) {\n        return 1;\n    }\n    ssh_key_free(pkey);\n\n    ssh_finalize();\n\n    return 0;\n}\n",
      "line_start": 27,
      "line_end": 51,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Takes untrusted input, converts to base64 and feeds into ssh_pki_import_privkey_base64 \u2014 a complex private-key parser that performs memory operations, ASN.1/PEM/format parsing and cryptographic handling with many code paths. High-value fuzz target for memory safety and logic bugs."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_pubkey_fuzzer.c",
      "source_code": "\n#define LIBSSH_STATIC 1\n#include \"libssh/libssh.h\"\n#include \"libssh/misc.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_key pkey = NULL;\n    char *filename = NULL;\n    int fd;\n    int rc;\n    ssize_t sz;\n\n    ssh_init();\n\n    filename = strdup(\"/tmp/libssh_pubkey_XXXXXX\");\n    if (filename == NULL) {\n        return -1;\n    }\n    fd = mkstemp(filename);\n    if (fd  == -1) {\n        free(filename);\n        close(fd);\n        return -1;\n    }\n    sz = ssh_writen(fd, data, size);\n    close(fd);\n    if (sz == SSH_ERROR) {\n        unlink(filename);\n        free(filename);\n        return -1;\n    }\n\n    rc = ssh_pki_import_pubkey_file(filename, &pkey);\n    if (rc != SSH_OK) {\n        unlink(filename);\n        free(filename);\n        return 1;\n    }\n    ssh_key_free(pkey);\n    unlink(filename);\n    free(filename);\n\n    ssh_finalize();\n\n    return 0;\n}\n",
      "line_start": 25,
      "line_end": 67,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Feeds arbitrary bytes into libssh's public-key parser (ssh_pki_import_pubkey_file). This exercises parsing of complex serialized/crypto key formats and likely memory operations/allocations on untrusted input (security-critical). The harness is simple but exercises high-impact code, making it a high/critical priority fuzz target."
    },
    {
      "name": "LLVMFuzzerTestOneInput",
      "clean_name": "LLVMFuzzerTestOneInput",
      "source_file": "/src/libssh/tests/fuzz/ssh_sshsig_fuzzer.c",
      "source_code": "    atexit(_fuzz_finalize);\n\n    return 0;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)\n{\n    ssh_key pkey = NULL;\n    const char input[] = \"badc0de\";\n    const char namespace[] = \"namespace\";\n    char *signature = NULL;\n    int rc;\n\n    signature = (char *)malloc(size + 1);\n    if (signature == NULL) {\n        return 1;\n    }\n    strncpy(signature, (const char *)data, size);\n    signature[size] = '\\0';\n\n    rc = sshsig_verify(input, sizeof(input), signature, namespace, &pkey);\n    free(signature);\n    if (rc != SSH_OK) {\n        return 1;\n    }\n    ssh_key_free(pkey);\n\n    return 0;\n}\n",
      "line_start": 40,
      "line_end": 64,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 9.0,
      "reason": "Although the function is a small wrapper, it feeds fuzzer-controlled data into sshsig_verify which performs cryptographic signature parsing/verification (complex parsing, security-critical logic and memory operations on untrusted data). This makes it a high/critical-value fuzz target."
    },
    {
      "name": "ssh_socket_pollcallback",
      "clean_name": "ssh_socket_pollcallback",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": " *                      in this case the socket object.\n *\n * @return              0 on success, < 0 when the poll object has been removed\n *                      from its poll context.\n */\nint ssh_socket_pollcallback(struct ssh_poll_handle_struct *p,\n                            socket_t fd,\n                            int revents,\n                            void *v_s)\n{\n    ssh_socket s = (ssh_socket)v_s;\n    void *buffer = NULL;\n    ssize_t nread = 0;\n    int rc;\n    int err = 0;\n    socklen_t errlen = sizeof(err);\n\n    /* Do not do anything if this socket was already closed */\n    if (!ssh_socket_is_open(s)) {\n        return -1;\n    }\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Poll callback on socket %d (%s%s%s), out buffer %\" PRIu32, fd,\n            (revents & POLLIN) ? \"POLLIN \":\"\",\n            (revents & POLLOUT) ? \"POLLOUT \":\"\",\n            (revents & POLLERR) ? \"POLLERR\":\"\",\n            ssh_buffer_get_len(s->out_buffer));\n    if ((revents & POLLERR) || (revents & POLLHUP)) {\n        /* Check if we are in a connecting state */\n        if (s->state == SSH_SOCKET_CONNECTING) {\n            s->state = SSH_SOCKET_ERROR;\n            rc = getsockopt(fd, SOL_SOCKET, SO_ERROR, (char *)&err, &errlen);\n            if (rc < 0) {\n                err = errno;\n            }\n            ssh_socket_close(s);\n            /* Overwrite ssh_socket_close() error with the real socket error */\n            s->last_errno = err;\n            errno = err;\n\n            if (s->callbacks != NULL && s->callbacks->connected != NULL) {\n                s->callbacks->connected(SSH_SOCKET_CONNECTED_ERROR,\n                                        err,\n                                        s->callbacks->userdata);\n            }\n\n            return -1;\n        }\n        /* Then we are in a more standard kind of error */\n        /* force a read to get an explanation */\n        revents |= POLLIN;\n    }\n    if ((revents & POLLIN) && s->state == SSH_SOCKET_CONNECTED) {\n        s->read_wontblock = 1;\n        buffer = ssh_buffer_allocate(s->in_buffer, MAX_BUF_SIZE);\n        if (buffer) {\n            nread = ssh_socket_unbuffered_read(s, buffer, MAX_BUF_SIZE);\n        }\n        if (nread < 0) {\n            ssh_buffer_pass_bytes_end(s->in_buffer, MAX_BUF_SIZE);\n            if (p != NULL) {\n                ssh_poll_remove_events(p, POLLIN);\n            }\n\n            if (s->callbacks != NULL && s->callbacks->exception != NULL) {\n                s->callbacks->exception(SSH_SOCKET_EXCEPTION_ERROR,\n                                        s->last_errno,\n                                        s->callbacks->userdata);\n            }\n            return -2;\n        }\n\n        /* Rollback the unused space */\n        ssh_buffer_pass_bytes_end(s->in_buffer,\n                                  (uint32_t)(MAX_BUF_SIZE - nread));\n\n        if (nread == 0) {\n            if (p != NULL) {\n                ssh_poll_remove_events(p, POLLIN);\n            }\n            if (s->callbacks != NULL && s->callbacks->exception != NULL) {\n                s->callbacks->exception(SSH_SOCKET_EXCEPTION_EOF,\n                                        0,\n                                        s->callbacks->userdata);\n            }\n            return -2;\n        }\n\n        if (s->session->socket_counter != NULL) {\n            s->session->socket_counter->in_bytes += nread;\n        }\n\n        /* Call the callback */\n        if (s->callbacks != NULL && s->callbacks->data != NULL) {\n            size_t processed;\n            do {\n                processed = s->callbacks->data(ssh_buffer_get(s->in_buffer),\n                                               ssh_buffer_get_len(s->in_buffer),\n                                               s->callbacks->userdata);\n                ssh_buffer_pass_bytes(s->in_buffer, (uint32_t)processed);\n            } while ((processed > 0) && (s->state == SSH_SOCKET_CONNECTED));\n\n            /* p may have been freed, so don't use it\n             * anymore in this function */\n            p = NULL;\n        }\n    }\n#ifdef _WIN32\n    if (revents & POLLOUT || revents & POLLWRNORM) {\n#else\n    if (revents & POLLOUT) {\n#endif\n        uint32_t len;\n\n        /* First, POLLOUT is a sign we may be connected */\n        if (s->state == SSH_SOCKET_CONNECTING) {\n            SSH_LOG(SSH_LOG_PACKET, \"Received POLLOUT in connecting state\");\n            ssh_socket_set_connected(s, p);\n\n            rc = ssh_socket_set_blocking(ssh_socket_get_fd(s));\n            if (rc < 0) {\n                return -1;\n            }\n\n            if (s->callbacks != NULL && s->callbacks->connected != NULL) {\n                s->callbacks->connected(SSH_SOCKET_CONNECTED_OK,\n                                        0,\n                                        s->callbacks->userdata);\n            }\n\n            return 0;\n        }\n\n        /* So, we can write data */\n        s->write_wontblock = 1;\n        if (p != NULL) {\n            ssh_poll_remove_events(p, POLLOUT);\n        }\n\n        /* If buffered data is pending, write it */\n        len = ssh_buffer_get_len(s->out_buffer);\n        if (len > 0) {\n            ssh_socket_nonblocking_flush(s);\n        } else if (s->callbacks != NULL && s->callbacks->controlflow != NULL) {\n            /* Otherwise advertise the upper level that write can be done */\n            SSH_LOG(SSH_LOG_TRACE, \"sending control flow event\");\n            s->callbacks->controlflow(SSH_SOCKET_FLOW_WRITEWONTBLOCK,\n                                      s->callbacks->userdata);\n        }\n        /* TODO: Find a way to put back POLLOUT when buffering occurs */\n    }\n\n    /* Return -1 if the poll handler disappeared */\n    if (s->poll_handle == NULL) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 249,
      "line_end": 403,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 214,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Handles untrusted network input and performs buffer/memory operations (buffer allocate/read/rollback), contains multiple branches and input-dependent control flow (POLLIN/POLLOUT/POLLERR, connecting vs connected, EOF/error paths), and a loop that repeatedly hands data to callbacks. High value as a fuzz target for exercising socket/state-machine and buffer handling, though it does not itself parse a complex serialized format or perform crypto."
    },
    {
      "name": "libcrypto.c:evp_cipher_encrypt",
      "clean_name": "evp_cipher_encrypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n    return SSH_OK;\n}\n\n/* EVP wrapper function for encrypt/decrypt */\nstatic void evp_cipher_encrypt(struct ssh_cipher_struct *cipher,\n                               void *in,\n                               void *out,\n                               size_t len)\n{\n    int outlen = 0;\n    int rc = 0;\n\n    rc = EVP_EncryptUpdate(cipher->ctx,\n                           (unsigned char *)out,\n                           &outlen,\n                           (unsigned char *)in,\n                           (int)len);\n    if (rc != 1){\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_EncryptUpdate failed\");\n        return;\n    }\n    if (outlen != (int)len){\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"EVP_EncryptUpdate: output size %d for %zu in\",\n                outlen,\n                len);\n        return;\n    }\n}\n",
      "line_start": 516,
      "line_end": 541,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes external buffers and invokes crypto (EVP_EncryptUpdate), performing memory operations on untrusted data and has input-dependent control flow (error/output-size branches). Also has risky casts (size_t -> int) and checks that could reveal truncation/length bugs or trigger library-side issues, making it a high-priority target."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_set_key",
      "clean_name": "chacha20_poly1305_set_key",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n    SAFE_FREE(cipher->chacha20_schedule);\n}\n\nstatic int\nchacha20_poly1305_set_key(struct ssh_cipher_struct *cipher,\n                          void *key,\n                          UNUSED_PARAM(void *IV))\n{\n    struct chacha20_poly1305_keysched *ctx = NULL;\n    uint8_t *u8key = key;\n    int ret = SSH_ERROR, rv;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    EVP_MAC *mac = NULL;\n#endif\n\n    if (cipher->chacha20_schedule == NULL) {\n        ctx = calloc(1, sizeof(*ctx));\n        if (ctx == NULL) {\n            return -1;\n        }\n        cipher->chacha20_schedule = ctx;\n    } else {\n        ctx = cipher->chacha20_schedule;\n    }\n\n    /* ChaCha20 initialization */\n    /* K2 uses the first half of the key */\n    ctx->main_evp = EVP_CIPHER_CTX_new();\n    if (ctx->main_evp == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CIPHER_CTX_new failed\");\n        goto out;\n    }\n    rv = EVP_EncryptInit_ex(ctx->main_evp, EVP_chacha20(), NULL, u8key, NULL);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherInit failed\");\n        goto out;\n    }\n    /* K1 uses the second half of the key */\n    ctx->header_evp = EVP_CIPHER_CTX_new();\n    if (ctx->header_evp == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CIPHER_CTX_new failed\");\n        goto out;\n    }\n    rv = EVP_EncryptInit_ex(ctx->header_evp, EVP_chacha20(), NULL,\n                             u8key + CHACHA20_KEYLEN, NULL);\n    if (rv != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherInit failed\");\n        goto out;\n    }\n\n    /* The Poly1305 key initialization is delayed to the time we know\n     * the actual key for packet so we do not need to create a bogus keys\n     */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    ctx->mctx = EVP_MD_CTX_new();\n    if (ctx->mctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MD_CTX_new failed\");\n        return SSH_ERROR;\n    }\n#else\n    mac = EVP_MAC_fetch(NULL, \"poly1305\", NULL);\n    if (mac == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_fetch failed\");\n        goto out;\n    }\n    ctx->mctx = EVP_MAC_CTX_new(mac);\n    if (ctx->mctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_MAC_CTX_new failed\");\n        goto out;\n    }\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    ret = SSH_OK;\nout:\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    EVP_MAC_free(mac);\n#endif\n    if (ret != SSH_OK) {\n        chacha20_poly1305_cleanup(cipher);\n    }\n    return ret;\n}\n",
      "line_start": 794,
      "line_end": 872,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 78,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Initializes ChaCha20-Poly1305 (cryptographic) contexts from an external key and interacts with OpenSSL APIs. Security-critical and operates on untrusted key material (resource allocation, pointer arithmetic u8key + CHACHA20_KEYLEN, error branches), but contains no complex parsing or input-driven control flow, so high rather than critical priority for fuzzing."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_set_iv",
      "clean_name": "chacha20_poly1305_set_iv",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "}\n\nstatic const uint8_t zero_block[CHACHA20_BLOCKSIZE] = {0};\n\nstatic int\nchacha20_poly1305_set_iv(struct ssh_cipher_struct *cipher,\n                         uint64_t seq,\n                         int do_encrypt)\n{\n    struct chacha20_poly1305_keysched *ctx = cipher->chacha20_schedule;\n    uint8_t seqbuf[16] = {0};\n    int ret;\n\n    /* Prepare the IV for OpenSSL -- it needs to be 128 b long. First 32 b is\n     * counter the rest is nonce. The memory is initialized to zeros\n     * (counter starts from 0) and we set the sequence number in the second half\n     */\n    PUSH_BE_U64(seqbuf, 8, seq);\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"seqbuf (chacha20 IV)\", seqbuf, sizeof(seqbuf));\n#endif /* DEBUG_CRYPTO */\n\n    ret = EVP_CipherInit_ex(ctx->header_evp, NULL, NULL, NULL, seqbuf, do_encrypt);\n    if (ret != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherInit_ex(header_evp) failed\");\n        return SSH_ERROR;\n    }\n\n    ret = EVP_CipherInit_ex(ctx->main_evp, NULL, NULL, NULL, seqbuf, do_encrypt);\n    if (ret != 1) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherInit_ex(main_evp) failed\");\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 876,
      "line_end": 907,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Crypto-related function that sets the AEAD IV from an external sequence number and calls OpenSSL EVP_CipherInit_ex \u2014 security-critical and a good fuzz target. However, it has very simple logic, no complex parsing, no loops or extensive memory operations, and only a single 64-bit input, so the attack surface is limited."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_aead_decrypt_length",
      "clean_name": "chacha20_poly1305_aead_decrypt_length",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    explicit_bzero(poly_key, sizeof(poly_key));\n    return ret;\n}\n\nstatic int\nchacha20_poly1305_aead_decrypt_length(struct ssh_cipher_struct *cipher,\n                                      void *in,\n                                      uint8_t *out,\n                                      size_t len,\n                                      uint64_t seq)\n{\n    struct chacha20_poly1305_keysched *ctx = cipher->chacha20_schedule;\n    int rv, outlen;\n\n    if (len < sizeof(uint32_t)) {\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"encrypted length\", (uint8_t *)in, sizeof(uint32_t));\n#endif /* DEBUG_CRYPTO */\n\n    /* Set IV for the header EVP */\n    rv = chacha20_poly1305_set_iv(cipher, seq, 0);\n    if (rv != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    rv = EVP_CipherUpdate(ctx->header_evp, out, &outlen, in, (int)len);\n    if (rv != 1 || outlen != sizeof(uint32_t)) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherUpdate failed\");\n        return SSH_ERROR;\n    }\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"deciphered length\", out, sizeof(uint32_t));\n#endif /* DEBUG_CRYPTO */\n\n    rv = EVP_CipherFinal_ex(ctx->header_evp, out + outlen, &outlen);\n    if (rv != 1 || outlen != 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"EVP_CipherFinal_ex failed\");\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 977,
      "line_end": 1018,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 50,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Processes external (encrypted) input and performs cryptographic operations using EVP APIs and an IV derived from sequence numbers \u2014 security-critical and a good fuzz target. The function itself is small with simple control flow (no loops) so not top-tier critical, but its interaction with crypto primitives and external buffers makes it high priority."
    },
    {
      "name": "ssh_bind_config_parse_string",
      "clean_name": "ssh_bind_config_parse_string",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": " * @params[in] input     Null terminated string containing the configuration\n *\n * @returns    SSH_OK on successful parsing the configuration string,\n *             SSH_ERROR on error\n */\nint ssh_bind_config_parse_string(ssh_bind bind, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0;\n    size_t line_len;\n    uint32_t parser_flags;\n    int rv;\n\n    /* This local table is used during the parsing of the current file (and\n     * files included recursively in this file) to prevent an option to be\n     * redefined, i.e. the first value set is kept. But this DO NOT prevent the\n     * option to be redefined later by another file. */\n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading bind configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parser_flags = PARSING;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            /* if there is no newline at the end of the string */\n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            /* should not happen, would mean a string without trailing '\\0' */\n            SSH_LOG(SSH_LOG_WARN, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_WARN,\n                    \"Line %u too long: %zu characters\",\n                    line_num,\n                    line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_bind_config_parse_line(bind, line, line_num, &parser_flags, seen, 0);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 667,
      "line_end": 722,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 59,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses external configuration data line-by-line and calls a complex line parser; contains an input-dependent loop and performs memory operations (memcpy) with bounds checks. It influences SSH bind behavior (security-relevant). Not super high internal cyclomatic complexity itself, but worth high-priority fuzzing."
    },
    {
      "name": "ssh_packet_userauth_info_request",
      "clean_name": "ssh_packet_userauth_info_request",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @internal\n * @brief handles a SSH_USERAUTH_INFO_REQUEST packet, as used in\n *        keyboard-interactive authentication, and changes the\n *        authentication state.\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_info_request) {\n    ssh_string tmp = NULL;\n    uint32_t nprompts;\n    uint32_t i;\n    int rc;\n    (void)user;\n    (void)type;\n\n\n    if (session->kbdint == NULL) {\n        session->kbdint = ssh_kbdint_new();\n        if (session->kbdint == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_PACKET_USED;\n        }\n    } else {\n        ssh_kbdint_clean(session->kbdint);\n    }\n\n    rc = ssh_buffer_unpack(packet, \"ssSd\",\n            &session->kbdint->name, /* name of the \"asking\" window shown to client */\n            &session->kbdint->instruction,\n            &tmp, /* to ignore */\n            &nprompts\n            );\n\n    /* We don't care about tmp */\n    SSH_STRING_FREE(tmp);\n\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid USERAUTH_INFO_REQUEST msg\");\n        ssh_kbdint_free(session->kbdint);\n        session->kbdint = NULL;\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"%\" PRIu32 \" keyboard-interactive prompts\", nprompts);\n    if (nprompts > KBDINT_MAX_PROMPT) {\n        ssh_set_error(session, SSH_FATAL,\n                \"Too much prompts requested by the server: %\" PRIu32 \" (0x%.4\" PRIx32 \")\",\n                nprompts, nprompts);\n        ssh_kbdint_free(session->kbdint);\n        session->kbdint = NULL;\n\n        return SSH_PACKET_USED;\n    }\n\n    session->kbdint->nprompts = nprompts;\n    session->kbdint->nanswers = nprompts;\n    session->kbdint->prompts = calloc(nprompts, sizeof(char *));\n    if (session->kbdint->prompts == NULL) {\n        session->kbdint->nprompts = 0;\n        ssh_set_error_oom(session);\n        ssh_kbdint_free(session->kbdint);\n        session->kbdint = NULL;\n\n        return SSH_PACKET_USED;\n    }\n\n    session->kbdint->echo = calloc(nprompts, sizeof(unsigned char));\n    if (session->kbdint->echo == NULL) {\n        session->kbdint->nprompts = 0;\n        ssh_set_error_oom(session);\n        ssh_kbdint_free(session->kbdint);\n        session->kbdint = NULL;\n\n        return SSH_PACKET_USED;\n    }\n\n    for (i = 0; i < nprompts; i++) {\n        rc = ssh_buffer_unpack(packet, \"sb\",\n                &session->kbdint->prompts[i],\n                &session->kbdint->echo[i]);\n        if (rc == SSH_ERROR) {\n            ssh_set_error(session, SSH_FATAL, \"Short INFO_REQUEST packet\");\n            ssh_kbdint_free(session->kbdint);\n            session->kbdint = NULL;\n\n            return SSH_PACKET_USED;\n        }\n    }\n    session->auth.state=SSH_AUTH_STATE_INFO;\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 2032,
      "line_end": 2118,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 131,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured external input (SSH packet) via ssh_buffer_unpack, uses an input-controlled nprompts to allocate arrays and drive a loop, and performs heap/string operations on untrusted data. Has validation (prompt cap) and error paths but still offers multiple code paths and memory-allocation/parse attack surface \u2014 high-priority fuzz target."
    },
    {
      "name": "auth.c:ssh_userauth_kbdint_send",
      "clean_name": "ssh_userauth_kbdint_send",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @returns SSH_AUTH_INFO if more info is needed\n * @returns SSH_AUTH_SUCCESS\n * @returns SSH_AUTH_FAILURE\n * @returns SSH_AUTH_PARTIAL\n */\nstatic int ssh_userauth_kbdint_send(ssh_session session)\n{\n    uint32_t i;\n    int rc;\n    if (session->pending_call_state == SSH_PENDING_CALL_AUTH_KBDINT_SEND)\n        goto pending;\n    if (session->pending_call_state != SSH_PENDING_CALL_NONE) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n    rc = ssh_buffer_pack(session->out_buffer, \"bd\",\n            SSH2_MSG_USERAUTH_INFO_RESPONSE,\n            session->kbdint->nprompts);\n    if (rc < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < session->kbdint->nprompts; i++) {\n        rc = ssh_buffer_pack(session->out_buffer, \"s\",\n                session->kbdint->answers && session->kbdint->answers[i] ?\n                        session->kbdint->answers[i]:\"\");\n        if (rc < 0) {\n            goto fail;\n        }\n    }\n\n    session->auth.current_method = SSH_AUTH_METHOD_INTERACTIVE;\n    session->auth.state = SSH_AUTH_STATE_KBDINT_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_KBDINT_SEND;\n    ssh_kbdint_free(session->kbdint);\n    session->kbdint = NULL;\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Sending keyboard-interactive response packet\");\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN)\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    return rc;\nfail:\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 1975,
      "line_end": 2025,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 84,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Takes user-supplied keyboard-interactive answers and packs them into an outgoing buffer with a loop bounded by nprompts (external input), performs memory/buffer operations, and touches session state and packet send logic \u2014 multiple code paths and potential for memory-related bugs. Not a complex parser/crypto routine, but high-value fuzz target for memory/serialization issues."
    },
    {
      "name": "ssh_buffer_add_data",
      "clean_name": "ssh_buffer_add_data",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The length of the data to add.\n *\n * @return              0 on success, < 0 on error.\n */\nint ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    if (buffer == NULL) {\n        return -1;\n    }\n\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}\n",
      "line_start": 300,
      "line_end": 330,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Copies untrusted data into an internal buffer (memcpy) and performs allocation/resizing and shift logic based on external length, with integer-overflow checks and multiple branches. This makes it a high-value fuzz target for memory safety issues (overflows, realloc/shift bugs), though it does not parse a complex protocol or perform crypto/auth operations."
    },
    {
      "name": "ssh_buffer_prepend_data",
      "clean_name": "ssh_buffer_prepend_data",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The length of data to prepend.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_prepend_data(struct ssh_buffer_struct *buffer, const void *data,\n    uint32_t len) {\n  buffer_verify(buffer);\n\n  if(len <= buffer->pos){\n    /* It's possible to insert data between begin and pos */\n    memcpy(buffer->data + (buffer->pos - len), data, len);\n    buffer->pos -= len;\n    buffer_verify(buffer);\n    return 0;\n  }\n  /* pos isn't high enough */\n  if (buffer->used - buffer->pos + len < len) {\n    return -1;\n  }\n\n  if (buffer->allocated < (buffer->used - buffer->pos + len)) {\n    if (realloc_buffer(buffer, buffer->used - buffer->pos + len) < 0) {\n      return -1;\n    }\n  }\n  memmove(buffer->data + len, buffer->data + buffer->pos, buffer->used - buffer->pos);\n  memcpy(buffer->data, data, len);\n  buffer->used += len - buffer->pos;\n  buffer->pos = 0;\n  buffer_verify(buffer);\n  return 0;\n}\n",
      "line_start": 536,
      "line_end": 564,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it performs direct memory operations (memcpy/memmove) on untrusted data and user-controlled length, has multiple branches (len <= pos vs realloc path) and allocation logic, and uses arithmetic (buffer->used - buffer->pos + len) that is subtle and could lead to integer/underflow or allocation size mistakes. These characteristics make it likely to reveal OOB/overlay/integer overflow bugs under fuzzing."
    },
    {
      "name": "ssh_buffer_get_ssh_string",
      "clean_name": "ssh_buffer_get_ssh_string",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @param[in]  buffer   The buffer to read.\n *\n * @returns             The SSH String, NULL on error.\n */\nstruct ssh_string_struct *\nssh_buffer_get_ssh_string(struct ssh_buffer_struct *buffer)\n{\n    uint32_t stringlen;\n    uint32_t hostlen;\n    struct ssh_string_struct *str = NULL;\n    int rc;\n\n    rc = ssh_buffer_get_u32(buffer, &stringlen);\n    if (rc == 0) {\n        return NULL;\n    }\n    hostlen = ntohl(stringlen);\n    /* verify if there is enough space in buffer to get it */\n    rc = ssh_buffer_validate_length(buffer, hostlen);\n    if (rc != SSH_OK) {\n      return NULL; /* it is indeed */\n    }\n    str = ssh_string_new(hostlen);\n    if (str == NULL) {\n        return NULL;\n    }\n\n    stringlen = ssh_buffer_get_data(buffer, ssh_string_data(str), hostlen);\n    if (stringlen != hostlen) {\n        /* should never happen */\n        SAFE_FREE(str);\n        return NULL;\n    }\n\n    return str;\n}\n",
      "line_start": 775,
      "line_end": 806,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses an SSH serialized string from untrusted input: reads a length (ntohl), validates buffer bounds, allocates and copies data. Contains memory operations on attacker-controlled data (allocation, buffer copy) and type conversion; relatively simple control flow but a high-value parser target (OOM/size/length checks, copying) for fuzzing."
    },
    {
      "name": "buffer.c:realloc_buffer",
      "clean_name": "realloc_buffer",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": "void ssh_buffer_set_secure(ssh_buffer buffer)\n{\n    buffer->secure = true;\n}\n\nstatic int realloc_buffer(struct ssh_buffer_struct *buffer, uint32_t needed)\n{\n    uint32_t smallest = 1;\n    uint8_t *new = NULL;\n\n    buffer_verify(buffer);\n\n    /* Find the smallest power of two which is greater or equal to needed */\n    while(smallest <= needed) {\n        if (smallest == 0) {\n            return -1;\n        }\n        smallest <<= 1;\n    }\n    needed = smallest;\n\n    if (needed > BUFFER_SIZE_MAX) {\n        return -1;\n    }\n\n    if (buffer->secure) {\n        new = malloc(needed);\n        if (new == NULL) {\n            return -1;\n        }\n        memcpy(new, buffer->data, buffer->used);\n        explicit_bzero(buffer->data, buffer->used);\n        SAFE_FREE(buffer->data);\n    } else {\n        new = realloc(buffer->data, needed);\n        if (new == NULL) {\n            return -1;\n        }\n    }\n    buffer->data = new;\n    buffer->allocated = needed;\n\n    buffer_verify(buffer);\n    return 0;\n}\n",
      "line_start": 181,
      "line_end": 221,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 49,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Touches untrusted allocation sizes and performs memory operations (malloc/realloc/memcpy/explicit_bzero) with branching (secure vs non-secure) and a loop that grows allocation based on the external `needed` value (risk of integer overflow/edge cases). Moderate complexity and multiple code paths make it a high-value fuzz target for finding allocation/overflow/realloc-related bugs."
    },
    {
      "name": "buffer.c:ssh_buffer_pack_allocate_va",
      "clean_name": "ssh_buffer_pack_allocate_va",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  ap        The va_list of arguments.\n *\n * @return SSH_OK on success, SSH_ERROR on error.\n */\nstatic int ssh_buffer_pack_allocate_va(struct ssh_buffer_struct *buffer,\n                                       const char *format,\n                                       size_t argc,\n                                       va_list ap)\n{\n    const char *p = NULL;\n    ssh_string string = NULL;\n    char *cstring = NULL;\n    bignum b = NULL;\n    size_t needed_size = 0;\n    size_t len;\n    size_t count;\n    int rc = SSH_OK;\n\n    for (p = format, count = 0; *p != '\\0'; p++, count++) {\n        /* Invalid number of arguments passed */\n        if (count > argc) {\n            return SSH_ERROR;\n        }\n\n        switch(*p) {\n        case 'b':\n            va_arg(ap, unsigned int);\n            needed_size += sizeof(uint8_t);\n            break;\n        case 'w':\n            va_arg(ap, unsigned int);\n            needed_size += sizeof(uint16_t);\n            break;\n        case 'd':\n            va_arg(ap, uint32_t);\n            needed_size += sizeof(uint32_t);\n            break;\n        case 'q':\n            va_arg(ap, uint64_t);\n            needed_size += sizeof(uint64_t);\n            break;\n        case 'S':\n            string = va_arg(ap, ssh_string);\n            needed_size += sizeof(uint32_t) + ssh_string_len(string);\n            string = NULL;\n            break;\n        case 's':\n            cstring = va_arg(ap, char *);\n            needed_size += sizeof(uint32_t) + strlen(cstring);\n            cstring = NULL;\n            break;\n        case 'P':\n            len = va_arg(ap, size_t);\n            needed_size += len;\n            va_arg(ap, void *);\n            count++; /* increase argument count */\n            break;\n        case 'F':\n        case 'B':\n            b = va_arg(ap, bignum);\n            if (*p == 'F') {\n                /* For padded bignum, we know the exact length */\n                len = va_arg(ap, size_t);\n                count++; /* increase argument count */\n                needed_size += sizeof(uint32_t) + len;\n            } else {\n                /* The bignum bytes + 1 for possible padding */\n                needed_size += sizeof(uint32_t) + bignum_num_bytes(b) + 1;\n            }\n            break;\n        case 't':\n            cstring = va_arg(ap, char *);\n            needed_size += strlen(cstring);\n            cstring = NULL;\n            break;\n        default:\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid buffer format %c\", *p);\n            rc = SSH_ERROR;\n        }\n        if (rc != SSH_OK){\n            break;\n        }\n    }\n\n    if (argc != count) {\n        return SSH_ERROR;\n    }\n\n    if (rc != SSH_ERROR){\n        /*\n         * Check if our canary is intact, if not, something really bad happened.\n         */\n        uint32_t canary = va_arg(ap, uint32_t);\n        if (canary != SSH_BUFFER_PACK_END) {\n            abort();\n        }\n    }\n\n    rc = ssh_buffer_allocate_size(buffer, (uint32_t)needed_size);\n    if (rc != 0) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 823,
      "line_end": 924,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 111,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Parses a format string and consumes varargs to compute allocation sizes: it processes structured input, has many branches and input-dependent loop bounds, and calls strlen/ssh_string_len/bignum_num_bytes on untrusted pointers (potential NULL derefs) and arithmetic on external lengths (risk of integer overflow). These characteristics make it a high-value fuzz target (multiple code paths, external-data-dependent behavior), though it does not itself perform the final buffer writes or cryptographic ops here."
    },
    {
      "name": "buffer.c:ssh_buffer_pack_va",
      "clean_name": "ssh_buffer_pack_va",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @returns             SSH_OK on success\n *                      SSH_ERROR on error\n * @see ssh_buffer_add_format() for format list values.\n */\nstatic int\nssh_buffer_pack_va(struct ssh_buffer_struct *buffer,\n                   const char *format,\n                   size_t argc,\n                   va_list ap)\n{\n    int rc = SSH_ERROR;\n    const char *p = NULL;\n    union {\n        uint8_t byte;\n        uint16_t word;\n        uint32_t dword;\n        uint64_t qword;\n        ssh_string string;\n        void *data;\n    } o;\n    char *cstring = NULL;\n    bignum b;\n    size_t len;\n    size_t count;\n\n    if (argc > 256) {\n        return SSH_ERROR;\n    }\n\n    for (p = format, count = 0; *p != '\\0'; p++, count++) {\n        /* Invalid number of arguments passed */\n        if (count > argc) {\n            return SSH_ERROR;\n        }\n\n        switch(*p) {\n        case 'b':\n            o.byte = (uint8_t)va_arg(ap, unsigned int);\n            rc = ssh_buffer_add_u8(buffer, o.byte);\n            break;\n        case 'w':\n            o.word = (uint16_t)va_arg(ap, unsigned int);\n            o.word = htons(o.word);\n            rc = ssh_buffer_add_u16(buffer, o.word);\n            break;\n        case 'd':\n            o.dword = va_arg(ap, uint32_t);\n            o.dword = htonl(o.dword);\n            rc = ssh_buffer_add_u32(buffer, o.dword);\n            break;\n        case 'q':\n            o.qword = va_arg(ap, uint64_t);\n            o.qword = htonll(o.qword);\n            rc = ssh_buffer_add_u64(buffer, o.qword);\n            break;\n        case 'S':\n            o.string = va_arg(ap, ssh_string);\n            rc = ssh_buffer_add_ssh_string(buffer, o.string);\n            o.string = NULL;\n            break;\n        case 's':\n            cstring = va_arg(ap, char *);\n            len = strlen(cstring);\n            if (len > UINT32_MAX) {\n                rc = SSH_ERROR;\n                break;\n            }\n            o.dword = (uint32_t)len;\n            rc = ssh_buffer_add_u32(buffer, htonl(o.dword));\n            if (rc == SSH_OK){\n                rc = ssh_buffer_add_data(buffer, cstring, o.dword);\n            }\n            cstring = NULL;\n            break;\n        case 'P':\n            len = va_arg(ap, size_t);\n            if (len > UINT32_MAX) {\n                rc = SSH_ERROR;\n                break;\n            }\n\n            o.data = va_arg(ap, void *);\n            count++; /* increase argument count */\n\n            rc = ssh_buffer_add_data(buffer, o.data, (uint32_t)len);\n            o.data = NULL;\n            break;\n        case 'F':\n        case 'B':\n            b = va_arg(ap, bignum);\n            if (*p == 'F') {\n                len = va_arg(ap, size_t);\n                count++; /* increase argument count */\n                o.string = ssh_make_padded_bignum_string(b, len);\n            } else {\n                o.string = ssh_make_bignum_string(b);\n            }\n            if(o.string == NULL){\n                rc = SSH_ERROR;\n                break;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, o.string);\n            SAFE_FREE(o.string);\n            break;\n        case 't':\n            cstring = va_arg(ap, char *);\n            len = strlen(cstring);\n            if (len > UINT32_MAX) {\n                rc = SSH_ERROR;\n                break;\n            }\n            rc = ssh_buffer_add_data(buffer, cstring, (uint32_t)len);\n            cstring = NULL;\n            break;\n        default:\n            SSH_LOG(SSH_LOG_TRACE, \"Invalid buffer format %c\", *p);\n            rc = SSH_ERROR;\n        }\n        if (rc != SSH_OK){\n            break;\n        }\n    }\n\n    if (argc != count) {\n        return SSH_ERROR;\n    }\n\n    if (rc != SSH_ERROR){\n        /* Check if our canary is intact, if not something really bad happened */\n        uint32_t canary = va_arg(ap, uint32_t);\n        if (canary != SSH_BUFFER_PACK_END) {\n            abort();\n        }\n    }\n    return rc;\n}\n",
      "line_start": 935,
      "line_end": 1066,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 154,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Good fuzz target: it interprets a format string and consumes va_args to serialize many types (integers, C-strings, raw pointers, bignums), performs memory operations (adding data/strings), has multiple branches and input-dependent loops/counts, and does length/argument validation. These characteristics make it high-value for fuzzing (likely to reveal crashes or logic bugs via malformed format/argument combinations)."
    },
    {
      "name": "ssh_packet_channel_open_fail",
      "clean_name": "ssh_packet_channel_open_fail",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "/**\n * @internal\n *\n * @brief Handle a SSH_CHANNEL_OPEN_FAILURE and set the state of the channel.\n */\nSSH_PACKET_CALLBACK(ssh_packet_channel_open_fail)\n{\n    ssh_channel channel = NULL;\n    char *error = NULL;\n    uint32_t code;\n    int rc;\n    (void)user;\n    (void)type;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_RARE, \"Invalid channel in packet\");\n        return SSH_PACKET_USED;\n    }\n\n    rc = ssh_buffer_unpack(packet, \"ds\", &code, &error);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid packet\");\n        return SSH_PACKET_USED;\n    }\n\n    if (channel->state != SSH_CHANNEL_STATE_OPENING) {\n        SSH_LOG(SSH_LOG_RARE,\n                \"SSH2_MSG_CHANNEL_OPEN_FAILURE received in incorrect channel \"\n                \"state %d\",\n                channel->state);\n        SAFE_FREE(error);\n        goto error;\n    }\n\n    ssh_set_error(session,\n                  SSH_REQUEST_DENIED,\n                  \"Channel opening failure: channel %\" PRIu32 \" error (%\" PRIu32\n                  \") %s\",\n                  channel->local_channel,\n                  code,\n                  error);\n    SAFE_FREE(error);\n    channel->state = SSH_CHANNEL_STATE_OPEN_DENIED;\n\n    ssh_callbacks_execute_list(channel->callbacks,\n                               ssh_channel_callbacks,\n                               channel_open_response_function,\n                               channel->session,\n                               channel,\n                               false /* is_success */);\n\n    return SSH_PACKET_USED;\n\nerror:\n  ssh_set_error(session, SSH_FATAL, \"Invalid packet\");\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 241,
      "line_end": 294,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 95,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Handles SSH protocol input: looks up channel from packet and unpacks untrusted data (uint32 + string), performs memory allocations/frees, updates channel state and invokes callbacks. This is structured network input with branching and state transitions\u2014high-value fuzz target but logic is relatively small (no heavy crypto), so not maximum criticality."
    },
    {
      "name": "channel_read_buffer",
      "clean_name": "channel_read_buffer",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      timeout and SSH_ERROR on error.\n * @deprecated          Please use ssh_channel_read instead\n * @warning             This function doesn't work in nonblocking/timeout mode\n * @see ssh_channel_read\n */\nint channel_read_buffer(ssh_channel channel, ssh_buffer buffer, uint32_t count,\n    int is_stderr)\n{\n    ssh_session session = NULL;\n    char *buffer_tmp = NULL;\n    int r;\n    uint32_t total = 0;\n\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n    session = channel->session;\n\n    if (buffer == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return SSH_ERROR;\n    }\n\n    ssh_buffer_reinit(buffer);\n    if (count == 0) {\n        do {\n            r = ssh_channel_poll(channel, is_stderr);\n            if (r < 0) {\n                return r;\n            }\n            if (r > 0) {\n                count = r;\n                buffer_tmp = ssh_buffer_allocate(buffer, count);\n                if (buffer_tmp == NULL) {\n                    ssh_set_error_oom(session);\n                    return SSH_ERROR;\n                }\n                r = ssh_channel_read(channel, buffer_tmp, r, is_stderr);\n                if (r < 0) {\n                    ssh_buffer_pass_bytes_end(buffer, count);\n                    return r;\n                }\n                /* Rollback the unused space */\n                ssh_buffer_pass_bytes_end(buffer, count - r);\n\n                return r;\n            }\n            if (ssh_channel_is_eof(channel)) {\n                return 0;\n            }\n            ssh_handle_packets(channel->session, SSH_TIMEOUT_INFINITE);\n        } while (r == 0);\n    }\n\n    buffer_tmp = ssh_buffer_allocate(buffer, count);\n    if (buffer_tmp == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    while (total < count) {\n        r = ssh_channel_read(channel, buffer_tmp, count - total, is_stderr);\n        if (r < 0) {\n            ssh_buffer_pass_bytes_end(buffer, count);\n            return r;\n        }\n        if (r == 0) {\n            /* Rollback the unused space */\n            ssh_buffer_pass_bytes_end(buffer, count - total);\n            return total;\n        }\n        total += r;\n    }\n\n    return total;\n}\n",
      "line_start": 2988,
      "line_end": 3058,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 93,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Reads untrusted data from a channel into allocated buffers with looping and multiple error/branching paths. Contains input-dependent loop bounds, buffer allocation/rollback logic and calls into low-level read/poll/packet handling \u2014 good potential to expose memory-management and control-flow bugs. Not directly handling crypto or complex parsing, so not top-critical but high-priority for fuzzing."
    },
    {
      "name": "ssh_channel_select",
      "clean_name": "ssh_channel_select",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @return             SSH_OK on a successful operation, SSH_EINTR if the\n *                     select(2) syscall was interrupted, then relaunch the\n *                     function, or SSH_ERROR on error.\n */\nint ssh_channel_select(ssh_channel *readchans, ssh_channel *writechans,\n                       ssh_channel *exceptchans, struct timeval * timeout)\n{\n    ssh_channel *rchans = NULL, *wchans = NULL, *echans = NULL;\n    ssh_channel dummy = NULL;\n    ssh_event event = NULL;\n    int rc;\n    int i;\n    int tm, tm_base;\n    int firstround = 1;\n    struct ssh_timestamp ts;\n\n    if (timeout != NULL)\n        tm_base = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;\n    else\n        tm_base = SSH_TIMEOUT_INFINITE;\n    ssh_timestamp_init(&ts);\n    tm = tm_base;\n    /* don't allow NULL pointers */\n    if (readchans == NULL) {\n        readchans = &dummy;\n    }\n\n    if (writechans == NULL) {\n        writechans = &dummy;\n    }\n\n    if (exceptchans == NULL) {\n        exceptchans = &dummy;\n    }\n\n    if (readchans[0] == NULL && writechans[0] == NULL &&\n        exceptchans[0] == NULL) {\n        /* No channel to poll?? Go away! */\n        return 0;\n    }\n\n    /* Prepare the outgoing temporary arrays */\n    rchans = calloc(count_ptrs(readchans) + 1, sizeof(ssh_channel));\n    if (rchans == NULL) {\n        return SSH_ERROR;\n    }\n\n    wchans = calloc(count_ptrs(writechans) + 1, sizeof(ssh_channel));\n    if (wchans == NULL) {\n        SAFE_FREE(rchans);\n        return SSH_ERROR;\n    }\n\n    echans = calloc(count_ptrs(exceptchans) + 1, sizeof(ssh_channel));\n    if (echans == NULL) {\n        SAFE_FREE(rchans);\n        SAFE_FREE(wchans);\n        return SSH_ERROR;\n    }\n\n    /*\n     * First, try without doing network stuff then, use the ssh_poll\n     * infrastructure to poll on all sessions.\n     */\n    do {\n        channel_protocol_select(readchans,\n                                writechans,\n                                exceptchans,\n                                rchans,\n                                wchans,\n                                echans);\n        if (rchans[0] != NULL || wchans[0] != NULL || echans[0] != NULL) {\n            /* At least one channel has an event */\n            break;\n        }\n        /* Add all channels' sessions right into an event object */\n        if (event == NULL) {\n            event = ssh_event_new();\n            if (event == NULL) {\n                SAFE_FREE(rchans);\n                SAFE_FREE(wchans);\n                SAFE_FREE(echans);\n\n                return SSH_ERROR;\n            }\n            for (i = 0; readchans[i] != NULL; i++) {\n                ssh_poll_get_default_ctx(readchans[i]->session);\n                ssh_event_add_session(event, readchans[i]->session);\n            }\n            for (i = 0; writechans[i] != NULL; i++) {\n                ssh_poll_get_default_ctx(writechans[i]->session);\n                ssh_event_add_session(event, writechans[i]->session);\n            }\n            for (i = 0; exceptchans[i] != NULL; i++) {\n                ssh_poll_get_default_ctx(exceptchans[i]->session);\n                ssh_event_add_session(event, exceptchans[i]->session);\n            }\n        }\n        /* Get out if the timeout has elapsed */\n        if (!firstround && ssh_timeout_elapsed(&ts, tm_base)) {\n            break;\n        }\n        /* Here we go */\n        rc = ssh_event_dopoll(event, tm);\n        if (rc != SSH_OK) {\n            SAFE_FREE(rchans);\n            SAFE_FREE(wchans);\n            SAFE_FREE(echans);\n            ssh_event_free(event);\n            return rc;\n        }\n        tm = ssh_timeout_update(&ts, tm_base);\n        firstround = 0;\n    } while (1);\n\n    if (readchans != &dummy) {\n        memcpy(readchans,\n               rchans,\n               (count_ptrs(rchans) + 1) * sizeof(ssh_channel));\n    }\n    if (writechans != &dummy) {\n        memcpy(writechans,\n               wchans,\n               (count_ptrs(wchans) + 1) * sizeof(ssh_channel));\n    }\n    if (exceptchans != &dummy) {\n        memcpy(exceptchans,\n               echans,\n               (count_ptrs(echans) + 1) * sizeof(ssh_channel));\n    }\n    SAFE_FREE(rchans);\n    SAFE_FREE(wchans);\n    SAFE_FREE(echans);\n    if (event)\n        ssh_event_free(event);\n    return 0;\n}\n",
      "line_start": 3633,
      "line_end": 3766,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 254,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes external channel arrays and a timeout, uses count_ptrs-dependent bounds, allocates and memcpy's based on those counts, and contains loops, event/polling and branching logic \u2014 making it prone to memory-safety and logic bugs in an SSH channel handling path."
    },
    {
      "name": "channels.c:channel_open",
      "clean_name": "channel_open",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @param[in]  payload   The buffer containing additional payload for the query.\n *\n * @return             SSH_OK if successful; SSH_ERROR otherwise.\n */\nstatic int\nchannel_open(ssh_channel channel,\n             const char *type,\n             uint32_t window,\n             uint32_t maxpacket,\n             ssh_buffer payload)\n{\n    ssh_session session = channel->session;\n    int err = SSH_ERROR;\n    int rc;\n\n    switch (channel->state) {\n    case SSH_CHANNEL_STATE_NOT_OPEN:\n        break;\n    case SSH_CHANNEL_STATE_OPENING:\n        goto pending;\n    case SSH_CHANNEL_STATE_OPEN:\n    case SSH_CHANNEL_STATE_CLOSED:\n    case SSH_CHANNEL_STATE_OPEN_DENIED:\n        goto end;\n    default:\n        ssh_set_error(session, SSH_FATAL, \"Bad state in channel_open: %d\",\n                      channel->state);\n    }\n\n    channel->local_channel = ssh_channel_new_id(session);\n    channel->local_maxpacket = maxpacket;\n    channel->local_window = window;\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Creating a channel %\" PRIu32 \" with %\" PRIu32 \" window and %\" PRIu32 \" max packet\",\n            channel->local_channel, window, maxpacket);\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bsddd\",\n                         SSH2_MSG_CHANNEL_OPEN,\n                         type,\n                         channel->local_channel,\n                         channel->local_window,\n                         channel->local_maxpacket);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return err;\n    }\n\n    if (payload != NULL) {\n        if (ssh_buffer_add_buffer(session->out_buffer, payload) < 0) {\n            ssh_set_error_oom(session);\n\n            return err;\n        }\n    }\n    channel->state = SSH_CHANNEL_STATE_OPENING;\n    if (ssh_packet_send(session) == SSH_ERROR) {\n        return err;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Sent a SSH_MSG_CHANNEL_OPEN type %s for channel %\" PRIu32,\n            type, channel->local_channel);\n\npending:\n    /* wait until channel is opened by server */\n    err = ssh_handle_packets_termination(session,\n                                         SSH_TIMEOUT_DEFAULT,\n                                         ssh_channel_open_termination,\n                                         channel);\n\n    if (session->session_state == SSH_SESSION_STATE_ERROR) {\n        err = SSH_ERROR;\n    }\n\nend:\n    /* This needs to pass the SSH_AGAIN from the above,\n     * but needs to catch failed channel states */\n    if (channel->state == SSH_CHANNEL_STATE_OPEN) {\n        err = SSH_OK;\n    } else if (err != SSH_AGAIN) {\n        /* Messages were handled correctly, but the channel state is invalid */\n        err = SSH_ERROR;\n    }\n\n    return err;\n}\n",
      "line_start": 326,
      "line_end": 409,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 98,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: it accepts untrusted inputs (type string and payload buffer) and performs buffer/serialization operations (ssh_buffer_pack, ssh_buffer_add_buffer), sends packets and waits on a stateful SSH session. Has multiple code paths depending on channel state and session responses and is security/network-critical, so fuzzing can reach memory/buffer handling and state-machine behaviours."
    },
    {
      "name": "channels.c:channel_write_common",
      "clean_name": "channel_write_common",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "int ssh_channel_flush(ssh_channel channel)\n{\n    return ssh_blocking_flush(channel->session, SSH_TIMEOUT_DEFAULT);\n}\n\nstatic int channel_write_common(ssh_channel channel,\n                                const void *data,\n                                uint32_t len, int is_stderr)\n{\n    ssh_session session = NULL;\n    uint32_t origlen = len;\n    uint32_t effectivelen;\n    int rc;\n\n    if (channel == NULL) {\n        return -1;\n    }\n    session = channel->session;\n    if (data == NULL) {\n        ssh_set_error_invalid(session);\n        return -1;\n    }\n\n    if (len > INT_MAX) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Length (%\" PRIu32 \") is bigger than INT_MAX\",\n                len);\n        return SSH_ERROR;\n    }\n\n    if (channel->local_eof) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Can't write to channel %\" PRIu32 \":%\" PRIu32\n                      \" after EOF was sent\",\n                      channel->local_channel,\n                      channel->remote_channel);\n        return -1;\n    }\n\n    if (channel->state != SSH_CHANNEL_STATE_OPEN ||\n        channel->delayed_close != 0) {\n        ssh_set_error(session, SSH_REQUEST_DENIED, \"Remote channel is closed\");\n\n        return -1;\n    }\n\n    if (session->session_state == SSH_SESSION_STATE_ERROR) {\n        return SSH_ERROR;\n    }\n\n    if (ssh_waitsession_unblocked(session) == 0) {\n        rc = ssh_handle_packets_termination(session,\n                                            SSH_TIMEOUT_DEFAULT,\n                                            ssh_waitsession_unblocked,\n                                            session);\n        if (rc == SSH_ERROR || !ssh_waitsession_unblocked(session))\n            goto out;\n    }\n    while (len > 0) {\n        if (channel->remote_window < len) {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"Remote window is %\" PRIu32\n                    \" bytes. going to write %\" PRIu32 \" bytes\",\n                    channel->remote_window,\n                    len);\n            /* When the window is zero, wait for it to grow */\n            if (channel->remote_window == 0) {\n                /* nothing can be written */\n                SSH_LOG(SSH_LOG_DEBUG, \"Wait for a growing window message...\");\n                rc = ssh_handle_packets_termination(\n                    session,\n                    SSH_TIMEOUT_DEFAULT,\n                    ssh_channel_waitwindow_termination,\n                    channel);\n                if (rc == SSH_ERROR ||\n                    !ssh_channel_waitwindow_termination(channel) ||\n                    session->session_state == SSH_SESSION_STATE_ERROR ||\n                    channel->state == SSH_CHANNEL_STATE_CLOSED)\n                    goto out;\n                continue;\n            }\n            /* When the window is non-zero, accept data up to the window size */\n            effectivelen = MIN(len, channel->remote_window);\n        } else {\n            effectivelen = len;\n        }\n\n        /*\n         * Like OpenSSH, don't subtract bytes for the header fields\n         * and allow to send a payload of remote_maxpacket length.\n         */\n        effectivelen = MIN(effectivelen, channel->remote_maxpacket);\n\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bd\",\n                             is_stderr ? SSH2_MSG_CHANNEL_EXTENDED_DATA\n                                       : SSH2_MSG_CHANNEL_DATA,\n                             channel->remote_channel);\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n\n        /* stderr message has an extra field */\n        if (is_stderr) {\n            rc = ssh_buffer_pack(session->out_buffer,\n                                 \"d\",\n                                 SSH2_EXTENDED_DATA_STDERR);\n            if (rc != SSH_OK) {\n                ssh_set_error_oom(session);\n                goto error;\n            }\n        }\n\n        /* append payload data */\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"dP\",\n                             effectivelen,\n                             (size_t)effectivelen,\n                             data);\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n\n        rc = ssh_packet_send(session);\n        if (rc == SSH_ERROR) {\n            return SSH_ERROR;\n        }\n\n        SSH_LOG(SSH_LOG_PACKET,\n                \"ssh_channel_write wrote %\" PRIu32 \" bytes\",\n                effectivelen);\n\n        channel->remote_window -= effectivelen;\n        len -= effectivelen;\n        data = ((uint8_t *)data + effectivelen);\n        if (channel->counter != NULL) {\n            channel->counter->out_bytes += effectivelen;\n        }\n    }\n\n    /* it's a good idea to flush the socket now */\n    rc = ssh_channel_flush(channel);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n\nout:\n    return (int)(origlen - len);\n\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 1533,
      "line_end": 1685,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 235,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: it operates on untrusted data and performs memory/buffer packing (likely memcpy), chunks input in a loop with bounds controlled by external state (len, remote_window, remote_maxpacket), and has multiple input-dependent code paths (session/channel state, wait/termination branches). Not a parser of a complex file format or doing crypto, so not top-critical, but strong candidate for fuzzing."
    },
    {
      "name": "channels.c:channel_request",
      "clean_name": "channel_request",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    return 1;\n  else\n    return 0;\n}\n\nstatic int channel_request(ssh_channel channel, const char *request,\n    ssh_buffer buffer, int reply)\n{\n  ssh_session session = channel->session;\n  int rc = SSH_ERROR;\n  int ret;\n\n  switch(channel->request_state){\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n\n  ret = ssh_buffer_pack(session->out_buffer,\n                        \"bdsb\",\n                        SSH2_MSG_CHANNEL_REQUEST,\n                        channel->remote_channel,\n                        request,\n                        reply == 0 ? 0 : 1);\n  if (ret != SSH_OK) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  if (buffer != NULL) {\n    if (ssh_buffer_add_data(session->out_buffer, ssh_buffer_get(buffer),\n        ssh_buffer_get_len(buffer)) < 0) {\n      ssh_set_error_oom(session);\n      goto error;\n    }\n  }\n  channel->request_state = SSH_CHANNEL_REQ_STATE_PENDING;\n  if (ssh_packet_send(session) == SSH_ERROR) {\n    return rc;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Sent a SSH_MSG_CHANNEL_REQUEST %s\", request);\n  if (reply == 0) {\n    channel->request_state = SSH_CHANNEL_REQ_STATE_NONE;\n    return SSH_OK;\n  }\npending:\n  rc = ssh_handle_packets_termination(session,\n                                      SSH_TIMEOUT_DEFAULT,\n                                      ssh_channel_request_termination,\n                                      channel);\n\n  if(session->session_state == SSH_SESSION_STATE_ERROR || rc == SSH_ERROR) {\n      channel->request_state = SSH_CHANNEL_REQ_STATE_ERROR;\n  }\n  /* we received something */\n  switch (channel->request_state){\n    case SSH_CHANNEL_REQ_STATE_ERROR:\n      rc=SSH_ERROR;\n      break;\n    case SSH_CHANNEL_REQ_STATE_DENIED:\n      ssh_set_error(session, SSH_REQUEST_DENIED,\n          \"Channel request %s failed\", request);\n      rc=SSH_ERROR;\n      break;\n    case SSH_CHANNEL_REQ_STATE_ACCEPTED:\n      SSH_LOG(SSH_LOG_DEBUG,\n          \"Channel request %s success\",request);\n      rc=SSH_OK;\n      break;\n    case SSH_CHANNEL_REQ_STATE_PENDING:\n      rc = SSH_AGAIN;\n      return rc;\n    case SSH_CHANNEL_REQ_STATE_NONE:\n      /* Never reached */\n      ssh_set_error(session, SSH_FATAL, \"Invalid state in channel_request()\");\n      rc=SSH_ERROR;\n      break;\n  }\n  channel->request_state=SSH_CHANNEL_REQ_STATE_NONE;\n\n  return rc;\nerror:\n  ssh_buffer_reinit(session->out_buffer);\n\n  return rc;\n}\n",
      "line_start": 1885,
      "line_end": 1969,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 110,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Part of an SSH protocol implementation: composes/sends channel request messages, copies external buffer data into outgoing buffers, and drives a stateful request/response flow. It contains multiple branches/state handling and relies on network/packet processing (external input-dependent code paths and memory operations), making it a high-value fuzz target."
    },
    {
      "name": "ssh_connect",
      "clean_name": "ssh_connect",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " *                      and call must be done again.\n *\n * @see ssh_new()\n * @see ssh_disconnect()\n */\nint ssh_connect(ssh_session session)\n{\n    int ret;\n\n    if (!is_ssh_initialized()) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Library not initialized.\");\n\n        return SSH_ERROR;\n    }\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    switch(session->pending_call_state) {\n    case SSH_PENDING_CALL_NONE:\n        break;\n    case SSH_PENDING_CALL_CONNECT:\n        goto pending;\n    default:\n        ssh_set_error(session, SSH_FATAL,\n                      \"Bad call during pending SSH call in ssh_connect\");\n\n        return SSH_ERROR;\n    }\n    session->alive = 0;\n    session->client = 1;\n\n    if (session->opts.fd == SSH_INVALID_SOCKET &&\n        session->opts.host == NULL &&\n        session->opts.ProxyCommand == NULL)\n    {\n        ssh_set_error(session, SSH_FATAL, \"Hostname required\");\n        return SSH_ERROR;\n    }\n\n    /* If the system configuration files were not yet processed, do it now */\n    if (!session->opts.config_processed) {\n        ret = ssh_options_parse_config(session, NULL);\n        if (ret != 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Failed to process system configuration files\");\n            return SSH_ERROR;\n        }\n    }\n\n    ret = ssh_options_apply(session);\n    if (ret < 0) {\n        ssh_set_error(session, SSH_FATAL, \"Couldn't apply options\");\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"libssh %s, using threading %s\",\n            ssh_copyright(),\n            ssh_threads_get_type());\n\n    session->ssh_connection_callback = ssh_client_connection_callback;\n    session->session_state = SSH_SESSION_STATE_CONNECTING;\n    ssh_socket_set_callbacks(session->socket, &session->socket_callbacks);\n    session->socket_callbacks.connected = socket_callback_connected;\n    session->socket_callbacks.data = callback_receive_banner;\n    session->socket_callbacks.exception = ssh_socket_exception_callback;\n    session->socket_callbacks.userdata = session;\n\n    if (session->opts.fd != SSH_INVALID_SOCKET) {\n        session->session_state = SSH_SESSION_STATE_SOCKET_CONNECTED;\n        ret = ssh_socket_set_fd(session->socket, session->opts.fd);\n#ifndef _WIN32\n#ifdef HAVE_PTHREAD\n    } else if (ssh_libssh_proxy_jumps() &&\n               ssh_list_count(session->opts.proxy_jumps) != 0) {\n        ret = ssh_socket_connect_proxyjump(session->socket);\n#endif /* HAVE_PTHREAD */\n#endif /* _WIN32 */\n    } else if (session->opts.ProxyCommand != NULL) {\n#ifdef WITH_EXEC\n        ret = ssh_socket_connect_proxycommand(session->socket,\n                session->opts.ProxyCommand);\n#else\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"The libssh is built without support for proxy commands.\");\n        ret = SSH_ERROR;\n#endif /* WITH_EXEC */\n    } else {\n        ret = ssh_socket_connect(session->socket,\n                                 session->opts.host,\n                                 session->opts.port > 0 ? session->opts.port : 22,\n                                 session->opts.bindaddr);\n    }\n    if (ret == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n\n    set_status(session, 0.2f);\n\n    session->alive = 1;\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Socket connecting, now waiting for the callbacks to work\");\n\npending:\n    session->pending_call_state = SSH_PENDING_CALL_CONNECT;\n    if(ssh_is_blocking(session)) {\n        int timeout = (session->opts.timeout * 1000) +\n            (session->opts.timeout_usec / 1000);\n        if (timeout == 0) {\n            timeout = 10 * 1000;\n        }\n        SSH_LOG(SSH_LOG_PACKET, \"Actual timeout : %d\", timeout);\n        ret = ssh_handle_packets_termination(session, timeout,\n                                             ssh_connect_termination, session);\n        if (session->session_state != SSH_SESSION_STATE_ERROR &&\n            (ret == SSH_ERROR || !ssh_connect_termination(session)))\n        {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Timeout connecting to %s\", session->opts.host);\n            session->session_state = SSH_SESSION_STATE_ERROR;\n        }\n    } else {\n        ret = ssh_handle_packets_termination(session,\n                                             SSH_TIMEOUT_NONBLOCKING,\n                                             ssh_connect_termination,\n                                             session);\n        if (ret == SSH_ERROR) {\n            session->session_state = SSH_SESSION_STATE_ERROR;\n        }\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"current state : %d\", session->session_state);\n    if (!ssh_is_blocking(session) && !ssh_connect_termination(session)) {\n        return SSH_AGAIN;\n    }\n\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    if (session->session_state == SSH_SESSION_STATE_ERROR ||\n        session->session_state == SSH_SESSION_STATE_DISCONNECTED)\n    {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 536,
      "line_end": 680,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 197,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Handles complex external configuration and connection logic (host, fd, ProxyCommand, proxy jumps), calls config parsing and socket/connect code, and drives multiple distinct code paths and timeouts. Not a trivial accessor \u2014 exercising it can reach parsing, network I/O and state-machine code \u2014 making it a high-value fuzz target though much of the heavy parsing/IO happens in callee functions."
    },
    {
      "name": "client.c:ssh_client_connection_callback",
      "clean_name": "ssh_client_connection_callback",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * @internal\n *\n * @brief A function to be called each time a step has been done in the\n * connection.\n */\nstatic void ssh_client_connection_callback(ssh_session session)\n{\n    int rc;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"session_state=%d\", session->session_state);\n\n    switch (session->session_state) {\n    case SSH_SESSION_STATE_NONE:\n    case SSH_SESSION_STATE_CONNECTING:\n        break;\n    case SSH_SESSION_STATE_SOCKET_CONNECTED:\n        ssh_set_fd_towrite(session);\n        ssh_send_banner(session, 0);\n\n        break;\n    case SSH_SESSION_STATE_BANNER_RECEIVED:\n        if (session->serverbanner == NULL) {\n            goto error;\n        }\n        set_status(session, 0.4f);\n        SSH_LOG(SSH_LOG_DEBUG, \"SSH server banner: %s\", session->serverbanner);\n\n        /* Here we analyze the different protocols the server allows. */\n        rc = ssh_analyze_banner(session, 0);\n        if (rc < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"No version of SSH protocol usable (banner: %s)\",\n                          session->serverbanner);\n            goto error;\n        }\n\n        ssh_packet_register_socket_callback(session, session->socket);\n\n        ssh_packet_set_default_callbacks(session);\n        session->session_state = SSH_SESSION_STATE_INITIAL_KEX;\n        rc = ssh_set_client_kex(session);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        rc = ssh_send_kex(session);\n        if (rc < 0) {\n            goto error;\n        }\n        set_status(session, 0.5f);\n\n        break;\n    case SSH_SESSION_STATE_INITIAL_KEX:\n        /* TODO: This state should disappear in favor of get_key handle */\n        break;\n    case SSH_SESSION_STATE_KEXINIT_RECEIVED:\n        set_status(session, 0.6f);\n        ssh_list_kex(&session->next_crypto->server_kex);\n        if ((session->flags & SSH_SESSION_FLAG_KEXINIT_SENT) == 0) {\n            /* in rekeying state if next_crypto client_kex might be empty */\n            rc = ssh_set_client_kex(session);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n            rc = ssh_send_kex(session);\n            if (rc < 0) {\n                goto error;\n            }\n        }\n        if (ssh_kex_select_methods(session) == SSH_ERROR)\n            goto error;\n        set_status(session, 0.8f);\n        session->session_state = SSH_SESSION_STATE_DH;\n\n        /* If the init packet was already sent in previous step, this will be no\n         * operation */\n        if (dh_handshake(session) == SSH_ERROR) {\n            goto error;\n        }\n        FALL_THROUGH;\n    case SSH_SESSION_STATE_DH:\n        if (session->dh_handshake_state == DH_STATE_FINISHED) {\n            set_status(session, 1.0f);\n            session->connected = 1;\n            if (session->flags & SSH_SESSION_FLAG_AUTHENTICATED) {\n                session->session_state = SSH_SESSION_STATE_AUTHENTICATED;\n            } else {\n                session->session_state = SSH_SESSION_STATE_AUTHENTICATING;\n            }\n        }\n        break;\n    case SSH_SESSION_STATE_AUTHENTICATING:\n        break;\n    case SSH_SESSION_STATE_ERROR:\n        goto error;\n    default:\n        ssh_set_error(session, SSH_FATAL, \"Invalid state %d\",\n                      session->session_state);\n    }\n\n    return;\nerror:\n    ssh_session_socket_close(session);\n    SSH_LOG(SSH_LOG_WARN, \"%s\", ssh_get_error(session));\n}\n",
      "line_start": 407,
      "line_end": 506,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 150,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "This function is a high-value fuzz target because it drives the SSH state machine and branches into many security-critical code paths (banner analysis, KEX selection/sending, DH handshake, authentication). It dispatches to parsers and crypto routines and its behavior depends on many attacker-controllable session fields (serverbanner, flags, next_crypto, dh state), so fuzzing it can reach complex parsing and memory-manipulating code. It does not itself perform heavy parsing/data copies, so it fits High Priority rather than Critical."
    },
    {
      "name": "client.c:callback_receive_banner",
      "clean_name": "callback_receive_banner",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * @param  data pointer to the beginning of header\n * @param  len size of the banner\n * @param  user is a pointer to session\n * @returns Number of bytes processed, or zero if the banner is not complete.\n */\nstatic size_t callback_receive_banner(const void *data, size_t len, void *user)\n{\n    char *buffer = (char *)data;\n    ssh_session session = (ssh_session) user;\n    char *str = NULL;\n    uint32_t i;\n    int ret=0;\n\n    if (session->session_state != SSH_SESSION_STATE_SOCKET_CONNECTED) {\n        ssh_set_error(session,SSH_FATAL,\n                      \"Wrong state in callback_receive_banner : %d\",\n                      session->session_state);\n\n        return 0;\n    }\n    for (i = 0; i < len; ++i) {\n#ifdef WITH_PCAP\n        if (session->pcap_ctx && buffer[i] == '\\n') {\n            ssh_pcap_context_write(session->pcap_ctx,\n                                   SSH_PCAP_DIR_IN,\n                                   buffer,i+1,\n                                   i+1);\n        }\n#endif\n        if (buffer[i] == '\\r') {\n            buffer[i] = '\\0';\n        }\n        if (buffer[i] == '\\n') {\n            int cmp;\n\n            buffer[i] = '\\0';\n\n            /* The server MAY send other lines of data... */\n            cmp = strncmp(buffer, \"SSH-\", 4);\n            if (cmp == 0) {\n                str = strdup(buffer);\n                if (str == NULL) {\n                    return SSH_ERROR;\n                }\n                /* number of bytes read */\n                ret = i + 1;\n                session->serverbanner = str;\n                session->session_state = SSH_SESSION_STATE_BANNER_RECEIVED;\n                SSH_LOG(SSH_LOG_PACKET, \"Received banner: %s\", str);\n                session->ssh_connection_callback(session);\n\n                return ret;\n            } else {\n                SSH_LOG(SSH_LOG_DEBUG,\n                        \"ssh_protocol_version_exchange: %s\",\n                        buffer);\n                ret = i + 1;\n                break;\n            }\n        }\n        /* According to RFC 4253 the max banner length is 255 */\n        if (i > 255) {\n            /* Too big banner */\n            session->session_state=SSH_SESSION_STATE_ERROR;\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Receiving banner: too large banner\");\n\n            return 0;\n        }\n    }\n\n    return ret;\n}\n",
      "line_start": 104,
      "line_end": 173,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Parses a network protocol banner (SSH) and performs memory/string operations on untrusted input (writes CR/LF to '\\0', strncmp, strdup). It contains input-dependent looping, branching (PCAP path, banner vs non-banner), length checks and state transitions including a callback invocation (potential reentrancy). Not extremely complex but has multiple code paths and manipulates external data \u2014 a high-value fuzz target."
    },
    {
      "name": "ssh_connect_host_nonblocking",
      "clean_name": "ssh_connect_host_nonblocking",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": " * specified by its IP address or hostname.\n *\n * @returns A file descriptor, < 0 on error.\n * @warning very ugly !!!\n */\nsocket_t ssh_connect_host_nonblocking(ssh_session session, const char *host,\n                                      const char *bind_addr, int port)\n{\n    socket_t s = -1, first = -1;\n    int rc;\n    struct addrinfo *ai = NULL;\n    struct addrinfo *itr = NULL;\n\n    rc = getai(host, port, &ai);\n    if (rc != 0) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Failed to resolve hostname %s (%s)\",\n                      host, gai_strerror(rc));\n\n        return -1;\n    }\n\n    for (itr = ai; itr != NULL; itr = itr->ai_next) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        /* create socket */\n        s = socket(itr->ai_family, itr->ai_socktype, itr->ai_protocol);\n        if (s < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Socket create failed: %s\",\n                          ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n            continue;\n        }\n\n        if (bind_addr) {\n            struct addrinfo *bind_ai = NULL;\n            struct addrinfo *bind_itr = NULL;\n\n            SSH_LOG(SSH_LOG_PACKET, \"Resolving %s\", bind_addr);\n\n            rc = getai(bind_addr, 0, &bind_ai);\n            if (rc != 0) {\n                ssh_set_error(session, SSH_FATAL,\n                              \"Failed to resolve bind address %s (%s)\",\n                              bind_addr,\n                              gai_strerror(rc));\n                ssh_connect_socket_close(s);\n                s = -1;\n                break;\n            }\n\n            for (bind_itr = bind_ai;\n                 bind_itr != NULL;\n                 bind_itr = bind_itr->ai_next)\n            {\n                rc = bind(s, bind_itr->ai_addr, bind_itr->ai_addrlen);\n                if (rc < 0) {\n                    ssh_set_error(session, SSH_FATAL,\n                                  \"Binding local address: %s\",\n                                  ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            freeaddrinfo(bind_ai);\n\n            /* Cannot bind to any local addresses */\n            if (bind_itr == NULL) {\n                ssh_connect_socket_close(s);\n                s = -1;\n                continue;\n            }\n        }\n\n        rc = ssh_socket_set_nonblocking(s);\n        if (rc < 0) {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Failed to set socket non-blocking for %s:%d\",\n                          host, port);\n            ssh_connect_socket_close(s);\n            s = -1;\n            continue;\n        }\n\n        if (session->opts.nodelay) {\n            /* For winsock, socket options are only effective before connect */\n            rc = set_tcp_nodelay(s);\n            if (rc < 0) {\n                ssh_set_error(session, SSH_FATAL,\n                              \"Failed to set TCP_NODELAY on socket: %s\",\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                ssh_connect_socket_close(s);\n                s = -1;\n                continue;\n            }\n        }\n\n        errno = 0;\n        rc = connect(s, itr->ai_addr, itr->ai_addrlen);\n        if (rc == -1) {\n            if ((errno != 0) && (errno != EINPROGRESS)) {\n                ssh_set_error(session, SSH_FATAL,\n                              \"Failed to connect: %s\",\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                ssh_connect_socket_close(s);\n                s = -1;\n            } else {\n                if (first == -1) {\n                    first = s;\n                } else { /* errno == EINPROGRESS */\n                    /* save only the first \"working\" socket */\n                    ssh_connect_socket_close(s);\n                    s = -1;\n                }\n            }\n            continue;\n        }\n\n        break;\n    }\n\n    freeaddrinfo(ai);\n\n    /* first let's go through all the addresses looking for immediate\n     * connection, otherwise return the first address without error or error */\n    if (s == -1) {\n        s = first;\n    }\n\n    return s;\n}\n",
      "line_start": 162,
      "line_end": 288,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 116,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it resolves and processes external host/bind strings, iterates over addrinfo lists (input-dependent loop bounds), creates/binds/connects sockets and sets socket options with many error/branching paths. Not cryptographic but has complex system-call interaction and multiple code paths that could expose resource or API misuse bugs."
    },
    {
      "name": "ssh_known_hosts_get_algorithms_names",
      "clean_name": "ssh_known_hosts_get_algorithms_names",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *\n * @return A newly allocated cstring containing a list of signature algorithms\n * that can be generated by the host using the keys listed in the known_hosts\n * files, NULL on error.\n */\nchar *ssh_known_hosts_get_algorithms_names(ssh_session session)\n{\n    char methods_buffer[256 + 1] = {0};\n    struct ssh_list *entry_list = NULL;\n    struct ssh_iterator *it = NULL;\n    char *host_port = NULL;\n    size_t count;\n    bool needcomma = false;\n    char *names = NULL;\n\n    int rc;\n\n    if (session->opts.knownhosts == NULL ||\n        session->opts.global_knownhosts == NULL) {\n        if (ssh_options_apply(session) < 0) {\n            ssh_set_error(session,\n                          SSH_REQUEST_DENIED,\n                          \"Can't find a known_hosts file\");\n\n            return NULL;\n        }\n    }\n\n    host_port = ssh_session_get_host_port(session);\n    if (host_port == NULL) {\n        return NULL;\n    }\n\n    rc = ssh_known_hosts_read_entries(host_port,\n                                      session->opts.knownhosts,\n                                      &entry_list);\n    if (rc != 0) {\n        SAFE_FREE(host_port);\n        ssh_list_free(entry_list);\n        return NULL;\n    }\n\n    rc = ssh_known_hosts_read_entries(host_port,\n                                      session->opts.global_knownhosts,\n                                      &entry_list);\n    SAFE_FREE(host_port);\n    if (rc != 0) {\n        ssh_list_free(entry_list);\n        return NULL;\n    }\n\n    if (entry_list == NULL) {\n        return NULL;\n    }\n\n    count = ssh_list_count(entry_list);\n    if (count == 0) {\n        ssh_list_free(entry_list);\n        return NULL;\n    }\n\n    for (it = ssh_list_get_iterator(entry_list);\n         it != NULL;\n         it = ssh_list_get_iterator(entry_list))\n    {\n        struct ssh_knownhosts_entry *entry = NULL;\n        const char *algo = NULL;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        algo = ssh_known_host_sigs_from_hostkey_type(entry->publickey->type);\n        if (algo == NULL) {\n            ssh_knownhosts_entry_free(entry);\n            ssh_list_remove(entry_list, it);\n            continue;\n        }\n\n        if (needcomma) {\n            strncat(methods_buffer,\n                    \",\",\n                    sizeof(methods_buffer) - strlen(methods_buffer) - 1);\n        }\n\n        strncat(methods_buffer,\n                algo,\n                sizeof(methods_buffer) - strlen(methods_buffer) - 1);\n        needcomma = true;\n\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entry_list, it);\n    }\n\n    ssh_list_free(entry_list);\n\n    names = ssh_remove_duplicates(methods_buffer);\n\n    return names;\n}\n",
      "line_start": 524,
      "line_end": 616,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 107,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Processes structured external input (known_hosts files) and iterates over an input-dependent list, performing memory/string operations (strncat) and multiple input-dependent code paths. It has moderate branching and loop logic, so is a good/high-priority fuzz target\u2014though the heavy parsing work appears delegated to helper functions and it doesn't perform crypto or large unsafe memcpy operations itself."
    },
    {
      "name": "ssh_session_has_known_hosts_entry",
      "clean_name": "ssh_session_has_known_hosts_entry",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *\n * @param[in]  session  The session with the values set to check.\n *\n * @return A ssh_known_hosts_e return value.\n */\nenum ssh_known_hosts_e ssh_session_has_known_hosts_entry(ssh_session session)\n{\n    struct ssh_list *entry_list = NULL;\n    struct ssh_iterator *it = NULL;\n    char *host_port = NULL;\n    bool global_known_hosts_found = false;\n    bool known_hosts_found = false;\n    int rc;\n\n    if (session->opts.knownhosts == NULL) {\n        if (ssh_options_apply(session) < 0) {\n            ssh_set_error(session,\n                          SSH_REQUEST_DENIED,\n                          \"Cannot find a known_hosts file\");\n\n            return SSH_KNOWN_HOSTS_NOT_FOUND;\n        }\n    }\n\n    if (session->opts.knownhosts == NULL &&\n        session->opts.global_knownhosts == NULL) {\n            ssh_set_error(session,\n                          SSH_REQUEST_DENIED,\n                          \"No path set for a known_hosts file\");\n\n            return SSH_KNOWN_HOSTS_NOT_FOUND;\n    }\n\n    if (session->opts.knownhosts != NULL) {\n        known_hosts_found = ssh_file_readaccess_ok(session->opts.knownhosts);\n        if (!known_hosts_found) {\n            SSH_LOG(SSH_LOG_TRACE, \"Cannot access file %s\",\n                    session->opts.knownhosts);\n        }\n    }\n\n    if (session->opts.global_knownhosts != NULL) {\n        global_known_hosts_found =\n                ssh_file_readaccess_ok(session->opts.global_knownhosts);\n        if (!global_known_hosts_found) {\n            SSH_LOG(SSH_LOG_TRACE, \"Cannot access file %s\",\n                    session->opts.global_knownhosts);\n        }\n    }\n\n    if ((!known_hosts_found) && (!global_known_hosts_found)) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Cannot find a known_hosts file\");\n\n        return SSH_KNOWN_HOSTS_NOT_FOUND;\n    }\n\n    host_port = ssh_session_get_host_port(session);\n    if (host_port == NULL) {\n        return SSH_KNOWN_HOSTS_ERROR;\n    }\n\n    if (known_hosts_found) {\n        rc = ssh_known_hosts_read_entries(host_port,\n                                          session->opts.knownhosts,\n                                          &entry_list);\n        if (rc != 0) {\n            SAFE_FREE(host_port);\n            ssh_list_free(entry_list);\n            return SSH_KNOWN_HOSTS_ERROR;\n        }\n    }\n\n    if (global_known_hosts_found) {\n        rc = ssh_known_hosts_read_entries(host_port,\n                                          session->opts.global_knownhosts,\n                                          &entry_list);\n        if (rc != 0) {\n            SAFE_FREE(host_port);\n            ssh_list_free(entry_list);\n            return SSH_KNOWN_HOSTS_ERROR;\n        }\n    }\n\n    SAFE_FREE(host_port);\n\n    if (ssh_list_count(entry_list) == 0) {\n        ssh_list_free(entry_list);\n        return SSH_KNOWN_HOSTS_UNKNOWN;\n    }\n\n    for (it = ssh_list_get_iterator(entry_list);\n         it != NULL;\n         it = ssh_list_get_iterator(entry_list)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entry_list, it);\n    }\n    ssh_list_free(entry_list);\n\n    return SSH_KNOWN_HOSTS_OK;\n}\n",
      "line_start": 804,
      "line_end": 904,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 135,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it drives parsing of external known_hosts files (via ssh_known_hosts_read_entries), exercises file I/O and memory/list manipulation, has multiple branches and input-dependent loops/error paths. It does not itself implement heavy crypto or very high cyclomatic complexity, so not top-critical, but still high priority."
    },
    {
      "name": "knownhosts.c:ssh_known_hosts_read_entries",
      "clean_name": "ssh_known_hosts_read_entries",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * in  filename  argument, and entries matching the  match  argument\n * will be added to the list in  entries  argument.\n * If the  entries  list is NULL, it will allocate a new list. Caller\n * is responsible to free it even if an error occurs.\n */\nstatic int ssh_known_hosts_read_entries(const char *match,\n                                        const char *filename,\n                                        struct ssh_list **entries)\n{\n    char line[MAX_LINE_SIZE];\n    size_t lineno = 0;\n    size_t len = 0;\n    FILE *fp = NULL;\n    int rc;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to open the known_hosts file '%s': %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        /* The missing file is not an error here */\n        return SSH_OK;\n    }\n\n    if (*entries == NULL) {\n        *entries = ssh_list_new();\n        if (*entries == NULL) {\n            fclose(fp);\n            return SSH_ERROR;\n        }\n    }\n\n    for (rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno);\n         rc == 0;\n         rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        struct ssh_iterator *it = NULL;\n        char *p = NULL;\n\n        if (line[len] != '\\n') {\n            len = strcspn(line, \"\\n\");\n        }\n        line[len] = '\\0';\n\n        /* Skip leading spaces */\n        for (p = line; isspace((int)p[0]); p++);\n\n        /* Skip comments and empty lines */\n        if (p[0] == '\\0' || p[0] == '#') {\n            continue;\n        }\n\n        /* Skip lines starting with markers (@cert-authority, @revoked):\n         * we do not completely support them anyway */\n        if (p[0] == '@') {\n            continue;\n        }\n\n        rc = ssh_known_hosts_parse_line(match,\n                                        line,\n                                        &entry);\n        if (rc == SSH_AGAIN) {\n            continue;\n        } else if (rc != SSH_OK) {\n            goto error;\n        }\n\n        /* Check for duplicates */\n        for (it = ssh_list_get_iterator(*entries);\n             it != NULL;\n             it = it->next) {\n            struct ssh_knownhosts_entry *entry2 = NULL;\n            int cmp;\n            entry2 = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n            cmp = ssh_known_hosts_entries_compare(entry, entry2);\n            if (cmp == 0) {\n                ssh_knownhosts_entry_free(entry);\n                entry = NULL;\n                break;\n            }\n        }\n        if (entry != NULL) {\n            ssh_list_append(*entries, entry);\n        }\n    }\n\n    fclose(fp);\n    return SSH_OK;\nerror:\n    fclose(fp);\n    return SSH_ERROR;\n}\n",
      "line_start": 224,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 99,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High priority: reads untrusted file input line-by-line and performs string operations (strcspn, isspace, NUL termination), loop bounds and control flow depend on external data, and it exercises parsing (ssh_known_hosts_parse_line), allocation, list manipulation and duplicate-checking. The real heavy parsing is delegated but this function still exposes multiple code paths and memory/logic handling of attacker-controlled data, making it a good fuzz target."
    },
    {
      "name": "match_pattern_list",
      "clean_name": "match_pattern_list",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " * Tries to match the string against the comma-separated sequence of subpatterns\n * (each possibly preceded by ! to indicate negation).\n * Returns -1 if negation matches, 1 if there is a positive match, 0 if there is\n * no match at all.\n */\nint match_pattern_list(const char *string, const char *pattern,\n    size_t len, int dolower) {\n  char sub[1024];\n  int negated;\n  int got_positive;\n  size_t i, subi;\n\n  got_positive = 0;\n  for (i = 0; i < len;) {\n    /* Check if the subpattern is negated. */\n    if (pattern[i] == '!') {\n      negated = 1;\n      i++;\n    } else {\n      negated = 0;\n    }\n\n    /*\n     * Extract the subpattern up to a comma or end.  Convert the\n     * subpattern to lowercase.\n     */\n    for (subi = 0;\n        i < len && subi < sizeof(sub) - 1 && pattern[i] != ',';\n        subi++, i++) {\n      sub[subi] = dolower && isupper(pattern[i]) ?\n        (char)tolower(pattern[i]) : pattern[i];\n    }\n\n    /* If subpattern too long, return failure (no match). */\n    if (subi >= sizeof(sub) - 1) {\n      return 0;\n    }\n\n    /* If the subpattern was terminated by a comma, skip the comma. */\n    if (i < len && pattern[i] == ',') {\n      i++;\n    }\n\n    /* Null-terminate the subpattern. */\n    sub[subi] = '\\0';\n\n    /* Try to match the subpattern against the string. */\n    if (match_pattern(string, sub, MAX_MATCH_RECURSION)) {\n      if (negated) {\n        return -1;        /* Negative */\n      } else {\n        got_positive = 1; /* Positive */\n      }\n    }\n  }\n\n  /*\n   * Return success if got a positive match.  If there was a negative\n   * match, we have already returned -1 and never get here.\n   */\n  return got_positive;\n}\n",
      "line_start": 142,
      "line_end": 199,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured external input (comma-separated subpatterns), performs buffer/string operations and case conversion, and has input-dependent loops and branching (negation, early returns). It also calls match_pattern (likely complex/recursive), so it\u2019s a high-value fuzz target though the local buffer is bounds-checked."
    },
    {
      "name": "match.c:match_pattern",
      "clean_name": "match_pattern",
      "source_file": "/src/libssh/src/match.c",
      "source_code": "\n/*\n * Returns true if the given string matches the pattern (which may contain ?\n * and * as wildcards), and zero if it does not match.\n */\nstatic int match_pattern(const char *s, const char *pattern, size_t limit)\n{\n    bool had_asterisk = false;\n\n    if (s == NULL || pattern == NULL || limit <= 0) {\n        return 0;\n    }\n\n    for (;;) {\n        /* If at end of pattern, accept if also at end of string. */\n        if (*pattern == '\\0') {\n            return (*s == '\\0');\n        }\n\n        /* Skip all the asterisks and adjacent question marks */\n        while (*pattern == '*' || (had_asterisk && *pattern == '?')) {\n            if (*pattern == '*') {\n                had_asterisk = true;\n            }\n            pattern++;\n        }\n\n        if (had_asterisk) {\n            /* If at end of pattern, accept immediately. */\n            if (!*pattern)\n                return 1;\n\n            /* If next character in pattern is known, optimize. */\n            if (*pattern != '?') {\n                /*\n                 * Look instances of the next character in\n                 * pattern, and try to match starting from\n                 * those.\n                 */\n                for (; *s; s++)\n                    if (*s == *pattern && match_pattern(s + 1, pattern + 1, limit - 1)) {\n                        return 1;\n                    }\n                /* Failed. */\n                return 0;\n            }\n            /*\n             * Move ahead one character at a time and try to\n             * match at each position.\n             */\n            for (; *s; s++) {\n                if (match_pattern(s, pattern, limit - 1)) {\n                    return 1;\n                }\n            }\n            /* Failed. */\n            return 0;\n        }\n        /*\n         * There must be at least one more character in the string.\n         * If we are at the end, fail.\n         */\n        if (!*s) {\n            return 0;\n        }\n\n        /* Check if the next character of the string is acceptable. */\n        if (*pattern != '?' && *pattern != *s) {\n            return 0;\n        }\n\n        /* Move to the next character, both in string and in pattern. */\n        s++;\n        pattern++;\n    }\n\n    /* NOTREACHED */\n    return 0;\n}\n",
      "line_start": 61,
      "line_end": 135,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 104,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Parses two external strings using a wildcard grammar with extensive branching, recursion and input-dependent loops (potential exponential/backtracking behavior). Good fuzz target for logic/DoS/edge-case bugs. Not doing raw memory ops or crypto, so not highest criticality."
    },
    {
      "name": "ssh_packet_service_request",
      "clean_name": "ssh_packet_service_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "  SAFE_FREE(msg);\n}\n\n#ifdef WITH_SERVER\n\nSSH_PACKET_CALLBACK(ssh_packet_service_request)\n{\n    char *service_c = NULL;\n    ssh_message msg = NULL;\n    int rc;\n\n    (void)type;\n    (void)user;\n\n    rc = ssh_buffer_unpack(packet,\n                           \"s\",\n                           &service_c);\n    if (rc != SSH_OK) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid SSH_MSG_SERVICE_REQUEST packet\");\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received a SERVICE_REQUEST for service %s\",\n            service_c);\n\n    msg = ssh_message_new(session);\n    if (msg == NULL) {\n        SAFE_FREE(service_c);\n        goto error;\n    }\n\n    msg->type = SSH_REQUEST_SERVICE;\n    msg->service_request.service = service_c;\n\n    ssh_message_queue(session, msg);\nerror:\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 723,
      "line_end": 760,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses attacker-controlled network protocol data and unpacks a string from the packet (memory allocation/operations on untrusted data), making it a good fuzz target. The function is simple with limited branching and no crypto/auth logic, so it doesn't meet the highest (9\u201310) critical threshold, but is high priority for fuzzing."
    },
    {
      "name": "ssh_message_handle_channel_request",
      "clean_name": "ssh_message_handle_channel_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " * @param[in]  want_reply The want_reply field from the request.\n *\n * @returns             SSH_OK on success, SSH_ERROR if an error occurred.\n */\nint\nssh_message_handle_channel_request(ssh_session session,\n                                   ssh_channel channel,\n                                   ssh_buffer packet,\n                                   const char *request,\n                                   uint8_t want_reply)\n{\n    ssh_message msg = NULL;\n    int rc;\n\n    msg = ssh_message_new(session);\n    if (msg == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received a %s channel_request for channel (%\" PRIu32 \":%\" PRIu32\n            \") (want_reply=%hhu)\",\n            request,\n            channel->local_channel,\n            channel->remote_channel,\n            want_reply);\n\n    msg->type = SSH_REQUEST_CHANNEL;\n    msg->channel_request.channel = channel;\n    msg->channel_request.want_reply = want_reply;\n\n    if (strcmp(request, \"pty-req\") == 0) {\n        rc = ssh_buffer_unpack(packet,\n                               \"sddddS\",\n                               &msg->channel_request.TERM,\n                               &msg->channel_request.width,\n                               &msg->channel_request.height,\n                               &msg->channel_request.pxwidth,\n                               &msg->channel_request.pxheight,\n                               &msg->channel_request.modes);\n\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_PTY;\n\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(request, \"window-change\") == 0) {\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_WINDOW_CHANGE;\n        rc = ssh_buffer_unpack(packet,\n                               \"dddd\",\n                               &msg->channel_request.width,\n                               &msg->channel_request.height,\n                               &msg->channel_request.pxwidth,\n                               &msg->channel_request.pxheight);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(request, \"subsystem\") == 0) {\n        rc = ssh_buffer_unpack(packet, \"s\", &msg->channel_request.subsystem);\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_SUBSYSTEM;\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(request, \"shell\") == 0) {\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_SHELL;\n        goto end;\n    }\n\n    if (strcmp(request, \"exec\") == 0) {\n        rc = ssh_buffer_unpack(packet, \"s\", &msg->channel_request.command);\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_EXEC;\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(request, \"env\") == 0) {\n        rc = ssh_buffer_unpack(packet,\n                               \"ss\",\n                               &msg->channel_request.var_name,\n                               &msg->channel_request.var_value);\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_ENV;\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        goto end;\n    }\n\n    if (strcmp(request, \"x11-req\") == 0) {\n        rc = ssh_buffer_unpack(packet,\n                               \"bssd\",\n                               &msg->channel_request.x11_single_connection,\n                               &msg->channel_request.x11_auth_protocol,\n                               &msg->channel_request.x11_auth_cookie,\n                               &msg->channel_request.x11_screen_number);\n\n        msg->channel_request.type = SSH_CHANNEL_REQUEST_X11;\n        if (rc != SSH_OK) {\n            goto error;\n        }\n\n        goto end;\n    }\n\n    msg->channel_request.type = SSH_CHANNEL_REQUEST_UNKNOWN;\nend:\n    ssh_message_queue(session, msg);\n\n    return SSH_OK;\nerror:\n    SSH_MESSAGE_FREE(msg);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 1522,
      "line_end": 1642,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 199,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured network input (SSH channel request packets) and calls ssh_buffer_unpack on untrusted data (strings/binaries), with many request-specific branches \u2014 moderate-to-high cyclomatic complexity and potential memory/parse pitfalls, making it a high-priority fuzz target."
    },
    {
      "name": "ssh_get_hexa",
      "clean_name": "ssh_get_hexa",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @return                  The hex string or NULL on error. The memory needs\n *                          to be freed using ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_get_hexa(const unsigned char *what, size_t len)\n{\n    const char h[] = \"0123456789abcdef\";\n    char *hexa = NULL;\n    size_t i;\n    size_t hlen = len * 3;\n\n    if (len > (UINT_MAX - 1) / 3) {\n        return NULL;\n    }\n\n    hexa = malloc(hlen + 1);\n    if (hexa == NULL) {\n        return NULL;\n    }\n\n    for (i = 0; i < len; i++) {\n        hexa[i * 3] = h[(what[i] >> 4) & 0xF];\n        hexa[i * 3 + 1] = h[what[i] & 0xF];\n        hexa[i * 3 + 2] = ':';\n    }\n    hexa[hlen - 1] = '\\0';\n\n    return hexa;\n}\n",
      "line_start": 483,
      "line_end": 508,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Converts untrusted binary into a heap buffer with writes indexed by an input-dependent loop, so it performs memory operations on external data and has multiple code paths (allocation failure/path). There is a subtle size-check/overflow weakness (checks against UINT_MAX rather than SIZE_MAX) that can lead to integer overflow or buffer misallocation, making it a high-value fuzz target."
    },
    {
      "name": "ssh_log_hexdump",
      "clean_name": "ssh_log_hexdump",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in] len   The length of the buffer given in what\n *\n * @note If a too long description is provided (which would result in a first\n * line longer than 80 bytes), the function will fail.\n */\nvoid ssh_log_hexdump(const char *descr, const unsigned char *what, size_t len)\n{\n    size_t i;\n    char ascii[17];\n    const unsigned char *pc = NULL;\n    size_t count = 0;\n    ssize_t printed = 0;\n\n    /* The required buffer size is calculated from:\n     *\n     *  2 bytes for spaces at the beginning\n     *  8 bytes for the offset\n     *  2 bytes for spaces\n     * 24 bytes to print the first 8 bytes + spaces\n     *  1 byte for an extra space\n     * 24 bytes to print next 8 bytes + spaces\n     *  2 bytes for extra spaces\n     * 16 bytes for the content as ASCII characters at the end\n     *  1 byte for the ending '\\0'\n     *\n     * Resulting in 80 bytes.\n     *\n     * Except for the first line (description + size), all lines have fixed\n     * length. If a too long description is used, the function will fail.\n     * */\n    char buffer[80];\n\n    /* Print description */\n    if (descr != NULL) {\n        printed = snprintf(buffer, sizeof(buffer), \"%s \", descr);\n        if (printed < 0) {\n            goto error;\n        }\n        count += printed;\n    } else {\n        printed = snprintf(buffer, sizeof(buffer), \"(NULL description) \");\n        if (printed < 0) {\n            goto error;\n        }\n        count += printed;\n    }\n\n    if (len == 0) {\n        printed = snprintf(buffer + count, sizeof(buffer) - count,\n                           \"(zero length):\");\n        if (printed < 0) {\n            goto error;\n        }\n        SSH_LOG(SSH_LOG_DEBUG, \"%s\", buffer);\n        return;\n    } else {\n        printed = snprintf(buffer + count, sizeof(buffer) - count,\n                           \"(%zu bytes):\", len);\n        if (printed < 0) {\n            goto error;\n        }\n        count += printed;\n    }\n\n    if (what == NULL) {\n        printed = snprintf(buffer + count, sizeof(buffer) - count,\n                           \"(NULL)\");\n        if (printed < 0) {\n            goto error;\n        }\n        SSH_LOG(SSH_LOG_DEBUG, \"%s\", buffer);\n        return;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"%s\", buffer);\n\n    /* Reset state */\n    count = 0;\n    pc = what;\n\n    for (i = 0; i < len; i++) {\n        /* Add one space after printing 8 bytes */\n        if ((i % 8) == 0) {\n            if (i != 0) {\n                printed = snprintf(buffer + count, sizeof(buffer) - count, \" \");\n                if (printed < 0) {\n                    goto error;\n                }\n                count += printed;\n            }\n        }\n\n        /* Log previous line and reset state for new line */\n        if ((i % 16) == 0) {\n            if (i != 0) {\n                printed = snprintf(buffer + count, sizeof(buffer) - count,\n                                   \"  %s\", ascii);\n                if (printed < 0) {\n                    goto error;\n                }\n                SSH_LOG(SSH_LOG_DEBUG, \"%s\", buffer);\n                count = 0;\n            }\n\n            /* Start a new line with the offset */\n            printed = snprintf(buffer, sizeof(buffer),\n                               \"  %08zx \", i);\n            if (printed < 0) {\n                goto error;\n            }\n            count += printed;\n        }\n\n        /* Print the current byte hexadecimal representation */\n        printed = snprintf(buffer + count, sizeof(buffer) - count,\n                           \" %02x\", pc[i]);\n        if (printed < 0) {\n            goto error;\n        }\n        count += printed;\n\n        /* If printable, store the ASCII character */\n        if (isprint(pc[i])) {\n            ascii[i % 16] = pc[i];\n        } else {\n            ascii[i % 16] = '.';\n        }\n        ascii[(i % 16) + 1] = '\\0';\n    }\n\n    /* Add padding if not exactly 16 characters */\n    while ((i % 16) != 0) {\n        /* Add one space after printing 8 bytes */\n        if ((i % 8) == 0) {\n            if (i != 0) {\n                printed = snprintf(buffer + count, sizeof(buffer) - count, \" \");\n                if (printed < 0) {\n                    goto error;\n                }\n                count += printed;\n            }\n        }\n\n        printed = snprintf(buffer + count, sizeof(buffer) - count, \"   \");\n        if (printed < 0) {\n            goto error;\n        }\n        count += printed;\n        i++;\n    }\n\n    /* Print the last printable part */\n    printed = snprintf(buffer + count, sizeof(buffer) - count,\n                       \"   %s\", ascii);\n    if (printed < 0) {\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"%s\", buffer);\n\n    return;\n\nerror:\n    SSH_LOG(SSH_LOG_DEBUG, \"Could not print to buffer\");\n    return;\n}\n",
      "line_start": 549,
      "line_end": 710,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 159,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes untrusted inputs (descr and a byte buffer) with loops whose bounds depend on len, does many string/ buffer operations, and has multiple input-dependent code paths. It also contains an unchecked snprintf/size arithmetic pattern that can lead to writing past the local 80-byte buffer when descr is long (and thus a potential memory-corruption crash). Not a complex protocol parser, so not top-critical, but very likely to yield exploitable crashes \u2014 high priority for fuzzing."
    },
    {
      "name": "ssh_path_expand_escape",
      "clean_name": "ssh_path_expand_escape",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @returns Expanded string. The caller needs to free the memory using\n *          ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_path_expand_escape(ssh_session session, const char *s)\n{\n    char host[NI_MAXHOST] = {0};\n    char *buf = NULL;\n    char *r = NULL;\n    char *x = NULL;\n    const char *p = NULL;\n    size_t i, l;\n\n    r = ssh_path_expand_tilde(s);\n    if (r == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    if (strlen(r) > MAX_BUF_SIZE) {\n        ssh_set_error(session, SSH_FATAL, \"string to expand too long\");\n        free(r);\n        return NULL;\n    }\n\n    buf = malloc(MAX_BUF_SIZE);\n    if (buf == NULL) {\n        ssh_set_error_oom(session);\n        free(r);\n        return NULL;\n    }\n\n    p = r;\n    buf[0] = '\\0';\n\n    for (i = 0; *p != '\\0'; p++) {\n        if (*p != '%') {\n        escape:\n            buf[i] = *p;\n            i++;\n            if (i >= MAX_BUF_SIZE) {\n                free(buf);\n                free(r);\n                return NULL;\n            }\n            buf[i] = '\\0';\n            continue;\n        }\n\n        p++;\n        if (*p == '\\0') {\n            break;\n        }\n\n        switch (*p) {\n            case '%':\n                goto escape;\n            case 'd':\n                if (session->opts.sshdir) {\n                    x = strdup(session->opts.sshdir);\n                } else {\n                    ssh_set_error(session, SSH_FATAL,\n                            \"Cannot expand sshdir\");\n                    free(buf);\n                    free(r);\n                    return NULL;\n                }\n                break;\n            case 'u':\n                x = ssh_get_local_username();\n                break;\n            case 'l':\n                if (gethostname(host, sizeof(host) == 0)) {\n                    x = strdup(host);\n                }\n                break;\n            case 'h':\n                if (session->opts.host) {\n                    x = strdup(session->opts.host);\n                } else {\n                    ssh_set_error(session, SSH_FATAL,\n                            \"Cannot expand host\");\n                    free(buf);\n                    free(r);\n                    return NULL;\n                }\n                break;\n            case 'r':\n                if (session->opts.username) {\n                    x = strdup(session->opts.username);\n                } else {\n                    ssh_set_error(session, SSH_FATAL,\n                            \"Cannot expand username\");\n                    free(buf);\n                    free(r);\n                    return NULL;\n                }\n                break;\n            case 'p':\n                {\n                  char tmp[6];\n\n                  snprintf(tmp, sizeof(tmp), \"%hu\",\n                           (uint16_t)(session->opts.port > 0 ? session->opts.port\n                                                             : 22));\n                  x = strdup(tmp);\n                }\n                break;\n            default:\n                ssh_set_error(session, SSH_FATAL,\n                        \"Wrong escape sequence detected\");\n                free(buf);\n                free(r);\n                return NULL;\n        }\n\n        if (x == NULL) {\n            ssh_set_error_oom(session);\n            free(buf);\n            free(r);\n            return NULL;\n        }\n\n        i += strlen(x);\n        if (i >= MAX_BUF_SIZE) {\n            ssh_set_error(session, SSH_FATAL,\n                    \"String too long\");\n            free(buf);\n            free(x);\n            free(r);\n            return NULL;\n        }\n        l = strlen(buf);\n        strncpy(buf + l, x, MAX_BUF_SIZE - l - 1);\n        buf[i] = '\\0';\n        SAFE_FREE(x);\n    }\n\n    free(r);\n\n    /* strip the unused space by realloc */\n    x = realloc(buf, strlen(buf) + 1);\n    if (x == NULL) {\n        ssh_set_error_oom(session);\n        free(buf);\n    }\n    return x;\n}\n",
      "line_start": 1217,
      "line_end": 1361,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 165,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Good fuzz target: it parses external input escape sequences, performs many memory/string operations (malloc/realloc/strncpy/strdup/strn/ snprintf), has input-dependent loop bounds and multiple branches. Contains obvious risky code paths (uninitialized i, incorrect gethostname call, multiple length checks and realloc) making it likely to yield memory-corruption or logic bugs. Not handling crypto/auth, so High (7-8) rather than Critical."
    },
    {
      "name": "ssh_quote_file_name",
      "clean_name": "ssh_quote_file_name",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in]   buf_len   The size of the provided output buffer\n *\n * @returns SSH_ERROR on error; length of the resulting string not counting the\n * string terminator '\\0'\n * */\nint ssh_quote_file_name(const char *file_name, char *buf, size_t buf_len)\n{\n    const char *src = NULL;\n    char *dst = NULL;\n    size_t required_buf_len;\n\n    enum ssh_quote_state_e state = NO_QUOTE;\n\n    if (file_name == NULL || buf == NULL || buf_len == 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid parameter\");\n        return SSH_ERROR;\n    }\n\n    /* Only allow file names smaller than 32kb. */\n    if (strlen(file_name) > 32 * 1024) {\n        SSH_LOG(SSH_LOG_TRACE, \"File name too long\");\n        return SSH_ERROR;\n    }\n\n    /* Paranoia check */\n    required_buf_len = (size_t)3 * strlen(file_name) + 1;\n    if (required_buf_len > buf_len) {\n        SSH_LOG(SSH_LOG_TRACE, \"Buffer too small\");\n        return SSH_ERROR;\n    }\n\n    src = file_name;\n    dst = buf;\n\n    while ((*src != '\\0')) {\n        switch (*src) {\n\n        /* The '\\'' char is double quoted */\n\n        case '\\'':\n            switch (state) {\n            case NO_QUOTE:\n                /* Start a new double quoted string. The '\\'' char will be\n                 * copied to the beginning of it at the end of the loop. */\n                *dst++ = '\"';\n                break;\n            case SINGLE_QUOTE:\n                /* Close the current single quoted string and start a new double\n                 * quoted string. The '\\'' char will be copied to the beginning\n                 * of it at the end of the loop. */\n                *dst++ = '\\'';\n                *dst++ = '\"';\n                break;\n            case DOUBLE_QUOTE:\n                /* If already in the double quoted string, keep copying the\n                 * sequence of chars. */\n                break;\n            default:\n                /* Should never be reached */\n                goto error;\n            }\n\n            /* When the '\\'' char is found, the resulting state will be\n             * DOUBLE_QUOTE in any case*/\n            state = DOUBLE_QUOTE;\n            break;\n\n        /* The '!' char is replaced by unquoted \"\\!\" */\n\n        case '!':\n            switch (state) {\n            case NO_QUOTE:\n                /* The '!' char is interpreted in some shells (e.g. CSH) even\n                 * when is quoted with single quotes.  Replace it with unquoted\n                 * \"\\!\" which is correctly interpreted as the '!' character. */\n                *dst++ = '\\\\';\n                break;\n            case SINGLE_QUOTE:\n                /* Close the currently quoted string and replace '!' for unquoted\n                 * \"\\!\" */\n                *dst++ = '\\'';\n                *dst++ = '\\\\';\n                break;\n            case DOUBLE_QUOTE:\n                /* Close currently quoted string and replace  \"!\" for unquoted\n                 * \"\\!\" */\n                *dst++ = '\"';\n                *dst++ = '\\\\';\n                break;\n            default:\n                /* Should never be reached */\n                goto error;\n            }\n\n            /* When the '!' char is found, the resulting state will be NO_QUOTE\n             * in any case*/\n            state = NO_QUOTE;\n            break;\n\n        /* Ordinary chars are single quoted */\n\n        default:\n            switch (state) {\n            case NO_QUOTE:\n                /* Start a new single quoted string */\n                *dst++ = '\\'';\n                break;\n            case SINGLE_QUOTE:\n                /* If already in the single quoted string, keep copying the\n                 * sequence of chars. */\n                break;\n            case DOUBLE_QUOTE:\n                /* Close current double quoted string and start a new single\n                 * quoted string. */\n                *dst++ = '\"';\n                *dst++ = '\\'';\n                break;\n            default:\n                /* Should never be reached */\n                goto error;\n            }\n\n            /* When an ordinary char is found, the resulting state will be\n             * SINGLE_QUOTE in any case*/\n            state = SINGLE_QUOTE;\n            break;\n        }\n\n        /* Copy the current char to output */\n        *dst++ = *src++;\n    }\n\n    /* Close the quoted string when necessary */\n\n    switch (state) {\n    case NO_QUOTE:\n        /* No open string */\n        break;\n    case SINGLE_QUOTE:\n        /* Close current single quoted string */\n        *dst++ = '\\'';\n        break;\n    case DOUBLE_QUOTE:\n        /* Close current double quoted string */\n        *dst++ = '\"';\n        break;\n    default:\n        /* Should never be reached */\n        goto error;\n    }\n\n    /* Put the string terminator */\n    *dst = '\\0';\n\n    return (int)(dst - buf);\n\nerror:\n    return SSH_ERROR;\n}\n",
      "line_start": 1705,
      "line_end": 1859,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 130,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High priority: consumes untrusted input and performs buffer writes with a non-trivial state machine and many branches (quoting rules). Loop bounds depend on input length and there are multiple code paths per character. Bounds checks reduce trivial overflow risk, but the complex quoting logic and state transitions make this a valuable fuzz target."
    },
    {
      "name": "ssh_check_hostname_syntax",
      "clean_name": "ssh_check_hostname_syntax",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param hostname The domain name to be checked, has to be null terminated\n *\n * @return SSH_OK if the hostname passes syntax check\n *         SSH_ERROR otherwise or if hostname is NULL or empty string\n */\nint ssh_check_hostname_syntax(const char *hostname)\n{\n    char *it = NULL, *s = NULL, *buf = NULL;\n    size_t it_len;\n    char c;\n\n    if (hostname == NULL || strlen(hostname) == 0) {\n        return SSH_ERROR;\n    }\n\n    /* strtok_r writes into the string, keep the input clean */\n    s = strdup(hostname);\n    if (s == NULL) {\n        return SSH_ERROR;\n    }\n\n    it = strtok_r(s, \".\", &buf);\n    /* if the token has 0 length */\n    if (it == NULL) {\n        free(s);\n        return SSH_ERROR;\n    }\n    do {\n        it_len = strlen(it);\n        if (it_len > ARPA_DOMAIN_MAX_LEN ||\n            /* the first char must be a letter, but some virtual urls start\n             * with a number */\n            isalnum(it[0]) == 0 ||\n            isalnum(it[it_len - 1]) == 0) {\n            free(s);\n            return SSH_ERROR;\n        }\n        while (*it != '\\0') {\n            c = *it;\n            /* the \".\" is allowed too, but tokenization removes it from the\n             * string */\n            if (isalnum(c) == 0 && c != '-') {\n                free(s);\n                return SSH_ERROR;\n            }\n            it++;\n        }\n    } while ((it = strtok_r(NULL, \".\", &buf)) != NULL);\n\n    free(s);\n\n    return SSH_OK;\n}\n",
      "line_start": 2174,
      "line_end": 2222,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "This function parses and validates external input (hostnames), tokenizes the string (strdup + strtok_r), and contains loops and multiple branching checks that depend on input (length checks, per-character validation). Those qualities make it a good fuzz target. It also has subtle pitfalls (use of isalnum on plain char can trigger undefined behavior for negative/UTF-8 bytes), so fuzzing can reveal real issues. Not as complex as full protocol parsers or crypto code, so not top-tier critical."
    },
    {
      "name": "ssh_options_set_algo",
      "clean_name": "ssh_options_set_algo",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "    *dest = new;\n\n    return 0;\n}\n\nint ssh_options_set_algo(ssh_session session,\n                         enum ssh_kex_types_e algo,\n                         const char *list,\n                         char **place)\n{\n    /* When the list start with +,-,^ the filtration of unknown algorithms\n     * gets handled inside the helper functions, otherwise the list is taken\n     * as it is. */\n    char *p = (char *)list;\n\n    if (algo < SSH_COMP_C_S) {\n        if (list[0] == '+') {\n            p = ssh_add_to_default_algos(algo, list+1);\n        } else if (list[0] == '-') {\n            p = ssh_remove_from_default_algos(algo, list+1);\n        } else if (list[0] == '^') {\n            p = ssh_prefix_default_algos(algo, list+1);\n        }\n    }\n\n    if (p == list) {\n        if (ssh_fips_mode()) {\n            p = ssh_keep_fips_algos(algo, list);\n        } else {\n            p = ssh_keep_known_algos(algo, list);\n        }\n    }\n\n    if (p == NULL) {\n        ssh_set_error(session, SSH_REQUEST_DENIED,\n                \"Setting method: no allowed algorithm for method \\\"%s\\\" (%s)\",\n                ssh_kex_get_description(algo), list);\n        return -1;\n    }\n\n    SAFE_FREE(*place);\n    *place = p;\n\n    return 0;\n}\n",
      "line_start": 264,
      "line_end": 304,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-priority target: accepts untrusted 'list' string that controls parsing branches (+/-/^ or direct), delegates to helper parsers that likely perform memory operations/allocations, and frees/assigns pointers. Multiple code paths (including FIPS vs non-FIPS) and lack of defensive checks make it valuable for fuzzing."
    },
    {
      "name": "ssh_options_getopt",
      "clean_name": "ssh_options_getopt",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *\n * @returns 0 on success, < 0 on error.\n *\n * @see ssh_session_new()\n */\nint ssh_options_getopt(ssh_session session, int *argcptr, char **argv)\n{\n#ifdef _MSC_VER\n    (void)session;\n    (void)argcptr;\n    (void)argv;\n    /* Not supported with a Microsoft compiler */\n    return -1;\n#else\n    char *user = NULL;\n    char *cipher = NULL;\n    char *identity = NULL;\n    char *port = NULL;\n    char **save = NULL;\n    char **tmp = NULL;\n    size_t i = 0;\n    int argc = *argcptr;\n    int debuglevel = 0;\n    int compress = 0;\n    int cont = 1;\n    size_t current = 0;\n    int saveoptind = optind; /* need to save 'em */\n    int saveopterr = opterr;\n    int opt;\n\n    /* Nothing to do here */\n    if (argc <= 1) {\n        return SSH_OK;\n    }\n\n    opterr = 0; /* shut up getopt */\n    while((opt = getopt(argc, argv, \"c:i:Cl:p:vb:r12\")) != -1) {\n        switch(opt) {\n        case 'l':\n            user = optarg;\n            break;\n        case 'p':\n            port = optarg;\n            break;\n        case 'v':\n            debuglevel++;\n            break;\n        case 'r':\n            break;\n        case 'c':\n            cipher = optarg;\n            break;\n        case 'i':\n            identity = optarg;\n            break;\n        case 'C':\n            compress++;\n            break;\n        case '2':\n            break;\n        case '1':\n            break;\n        default:\n            {\n                tmp = realloc(save, (current + 1) * sizeof(char*));\n                if (tmp == NULL) {\n                    SAFE_FREE(save);\n                    ssh_set_error_oom(session);\n                    return -1;\n                }\n                save = tmp;\n                save[current] = argv[optind-1];\n                current++;\n                /* We can not use optarg here as getopt does not set it for\n                 * unknown options. We need to manually extract following\n                 * option and skip it manually from further processing */\n                if (optind < argc && argv[optind][0] != '-') {\n                    tmp = realloc(save, (current + 1) * sizeof(char*));\n                    if (tmp == NULL) {\n                        SAFE_FREE(save);\n                        ssh_set_error_oom(session);\n                        return -1;\n                    }\n                    save = tmp;\n                    save[current++] = argv[optind];\n                    optind++;\n                }\n            }\n        } /* switch */\n    } /* while */\n    opterr = saveopterr;\n    tmp = realloc(save, (current + (argc - optind)) * sizeof(char*));\n    if (tmp == NULL) {\n        SAFE_FREE(save);\n        ssh_set_error_oom(session);\n        return -1;\n    }\n    save = tmp;\n    while (optind < argc) {\n        tmp = realloc(save, (current + 1) * sizeof(char*));\n        if (tmp == NULL) {\n            SAFE_FREE(save);\n            ssh_set_error_oom(session);\n            return -1;\n        }\n        save = tmp;\n        save[current] = argv[optind];\n        current++;\n        optind++;\n    }\n\n    ssh_set_log_level(debuglevel);\n\n    optind = saveoptind;\n\n    if(!cont) {\n        SAFE_FREE(save);\n        return -1;\n    }\n\n    /* first recopy the save vector into the original's */\n    for (i = 0; i < current; i++) {\n        /* don't erase argv[0] */\n        argv[ i + 1] = save[i];\n    }\n    argv[current + 1] = NULL;\n    *argcptr = current + 1;\n    SAFE_FREE(save);\n\n    /* set a new option struct */\n    if (compress) {\n        if (ssh_options_set(session, SSH_OPTIONS_COMPRESSION, \"yes\") < 0) {\n            cont = 0;\n        }\n    }\n\n    if (cont && cipher) {\n        if (ssh_options_set(session, SSH_OPTIONS_CIPHERS_C_S, cipher) < 0) {\n            cont = 0;\n        }\n        if (cont && ssh_options_set(session, SSH_OPTIONS_CIPHERS_S_C, cipher) < 0) {\n            cont = 0;\n        }\n    }\n\n    if (cont && user) {\n        if (ssh_options_set(session, SSH_OPTIONS_USER, user) < 0) {\n            cont = 0;\n        }\n    }\n\n    if (cont && identity) {\n        if (ssh_options_set(session, SSH_OPTIONS_IDENTITY, identity) < 0) {\n            cont = 0;\n        }\n    }\n\n    if (port != NULL) {\n        ssh_options_set(session, SSH_OPTIONS_PORT_STR, port);\n    }\n\n    if (!cont) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n#endif\n}\n",
      "line_start": 1644,
      "line_end": 1807,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 208,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses untrusted command-line input, contains substantial parsing/branching logic and loops with input-dependent bounds, and performs multiple dynamic memory operations (realloc, pointer copying) that are high-risk for heap/logic bugs. It does not itself perform crypto/auth operations, so not top-critical but is a high-priority fuzz target."
    },
    {
      "name": "ssh_options_apply",
      "clean_name": "ssh_options_apply",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "out:\n    free(expanded_filename);\n    return r;\n}\n\nint ssh_options_apply(ssh_session session)\n{\n    char *tmp = NULL;\n    int rc;\n\n    if (session->opts.sshdir == NULL) {\n        rc = ssh_options_set(session, SSH_OPTIONS_SSH_DIR, NULL);\n        if (rc < 0) {\n            return -1;\n        }\n    }\n\n    if (session->opts.username == NULL) {\n        rc = ssh_options_set(session, SSH_OPTIONS_USER, NULL);\n        if (rc < 0) {\n            return -1;\n        }\n    }\n\n    if ((session->opts.exp_flags & SSH_OPT_EXP_FLAG_KNOWNHOSTS) == 0) {\n        if (session->opts.knownhosts == NULL) {\n            tmp = ssh_path_expand_escape(session, \"%d/known_hosts\");\n        } else {\n            tmp = ssh_path_expand_escape(session, session->opts.knownhosts);\n        }\n        if (tmp == NULL) {\n            return -1;\n        }\n        free(session->opts.knownhosts);\n        session->opts.knownhosts = tmp;\n        session->opts.exp_flags |= SSH_OPT_EXP_FLAG_KNOWNHOSTS;\n    }\n\n    if ((session->opts.exp_flags & SSH_OPT_EXP_FLAG_GLOBAL_KNOWNHOSTS) == 0) {\n        if (session->opts.global_knownhosts == NULL) {\n            tmp = strdup(\"/etc/ssh/ssh_known_hosts\");\n        } else {\n            tmp = ssh_path_expand_escape(session,\n                                         session->opts.global_knownhosts);\n        }\n        if (tmp == NULL) {\n            return -1;\n        }\n        free(session->opts.global_knownhosts);\n        session->opts.global_knownhosts = tmp;\n        session->opts.exp_flags |= SSH_OPT_EXP_FLAG_GLOBAL_KNOWNHOSTS;\n    }\n\n\n    if ((session->opts.exp_flags & SSH_OPT_EXP_FLAG_PROXYCOMMAND) == 0) {\n        if (session->opts.ProxyCommand != NULL) {\n            char *p = NULL;\n            size_t plen = strlen(session->opts.ProxyCommand) +\n                          5 /* strlen(\"exec \") */;\n\n            if (strncmp(session->opts.ProxyCommand, \"exec \", 5) != 0) {\n                p = malloc(plen + 1 /* \\0 */);\n                if (p == NULL) {\n                    return -1;\n                }\n\n                rc = snprintf(p, plen + 1, \"exec %s\", session->opts.ProxyCommand);\n                if ((size_t)rc != plen) {\n                    free(p);\n                    return -1;\n                }\n                tmp = ssh_path_expand_escape(session, p);\n                free(p);\n            } else {\n                tmp = ssh_path_expand_escape(session,\n                                             session->opts.ProxyCommand);\n            }\n\n            if (tmp == NULL) {\n                return -1;\n            }\n            free(session->opts.ProxyCommand);\n            session->opts.ProxyCommand = tmp;\n            session->opts.exp_flags |= SSH_OPT_EXP_FLAG_PROXYCOMMAND;\n        }\n    }\n\n    if ((session->opts.exp_flags & SSH_OPT_EXP_FLAG_CONTROL_PATH) == 0) {\n        if (session->opts.control_path != NULL) {\n            tmp = ssh_path_expand_escape(session, session->opts.control_path);\n            if (tmp == NULL) {\n                return -1;\n            }\n            free(session->opts.control_path);\n            session->opts.control_path = tmp;\n            session->opts.exp_flags |= SSH_OPT_EXP_FLAG_CONTROL_PATH;\n        }\n    }\n\n    for (tmp = ssh_list_pop_head(char *, session->opts.identity_non_exp);\n         tmp != NULL;\n         tmp = ssh_list_pop_head(char *, session->opts.identity_non_exp)) {\n        char *id = tmp;\n        if (strncmp(id, \"pkcs11:\", 6) != 0) {\n            /* PKCS#11 URIs are using percent-encoding so we can not mix\n             * it with ssh expansion of ssh escape characters.\n             */\n            tmp = ssh_path_expand_escape(session, id);\n            free(id);\n            if (tmp == NULL) {\n                return -1;\n            }\n        }\n\n        /* use append to keep the order at first call and use prepend\n         * to put anything that comes on the nth calls to the beginning */\n        if (session->opts.exp_flags & SSH_OPT_EXP_FLAG_IDENTITY) {\n            rc = ssh_list_prepend(session->opts.identity, tmp);\n        } else {\n            rc = ssh_list_append(session->opts.identity, tmp);\n        }\n        if (rc != SSH_OK) {\n            free(tmp);\n            return -1;\n        }\n    }\n    session->opts.exp_flags |= SSH_OPT_EXP_FLAG_IDENTITY;\n\n    for (tmp = ssh_list_pop_head(char *, session->opts.certificate_non_exp);\n         tmp != NULL;\n         tmp = ssh_list_pop_head(char *, session->opts.certificate_non_exp)) {\n        char *id = tmp;\n\n        tmp = ssh_path_expand_escape(session, id);\n        free(id);\n        if (tmp == NULL) {\n            return -1;\n        }\n\n        rc = ssh_list_append(session->opts.certificate, tmp);\n        if (rc != SSH_OK) {\n            free(tmp);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 1887,
      "line_end": 2030,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 193,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Processes multiple untrusted option strings (paths, ProxyCommand, identities), performs many memory operations (malloc/strdup/free/strncpy/snprintf), and has multiple branches and loops that depend on input/list contents. Calls into path-expansion/parsing routines and list manipulation, so it's a good high-priority fuzz target for memory and parsing bugs (though not directly crypto/authentication logic)."
    },
    {
      "name": "packet.c:ssh_packet_incoming_filter",
      "clean_name": "ssh_packet_incoming_filter",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": " * @param session current ssh_session\n * @returns SSH_PACKET_ALLOWED if the packet is allowed; SSH_PACKET_DENIED\n * if the packet arrived in wrong state; SSH_PACKET_UNKNOWN if the packet type\n * is unknown\n */\nstatic enum ssh_packet_filter_result_e ssh_packet_incoming_filter(ssh_session session)\n{\n    enum ssh_packet_filter_result_e rc;\n\n#ifdef DEBUG_PACKET\n    SSH_LOG(SSH_LOG_PACKET, \"Filtering packet type %d\",\n            session->in_packet.type);\n#endif\n\n    switch(session->in_packet.type) {\n    case SSH2_MSG_DISCONNECT:                         // 1\n        /*\n         * States required:\n         * - None\n         *\n         * Transitions:\n         * - session->socket->state = SSH_SOCKET_CLOSED\n         * - session->session_state = SSH_SESSION_STATE_ERROR\n         * */\n\n        /* Always allowed */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_IGNORE:                             // 2\n        /*\n         * States required:\n         * - None\n         *\n         * Transitions:\n         * - None\n         * */\n\n        /* Always allowed */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_UNIMPLEMENTED:                      // 3\n        /*\n         * States required:\n         * - None\n         *\n         * Transitions:\n         * - None\n         * */\n\n        /* Always allowed */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_DEBUG:                              // 4\n        /*\n         * States required:\n         * - None\n         *\n         * Transitions:\n         * - None\n         * */\n\n        /* Always allowed */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_SERVICE_REQUEST:                    // 5\n        /* Server only */\n\n        /*\n         * States required:\n         * - session->session_state == SSH_SESSION_STATE_AUTHENTICATING\n         *   or session->session_state == SSH_SESSION_STATE_AUTHENTICATED\n         * - session->dh_handshake_state == DH_STATE_FINISHED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        /* If this is a client, reject the message */\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if ((session->session_state != SSH_SESSION_STATE_AUTHENTICATING) &&\n            (session->session_state != SSH_SESSION_STATE_AUTHENTICATED))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_SERVICE_ACCEPT:                     // 6\n        /*\n         * States required:\n         * - session->session_state == SSH_SESSION_STATE_AUTHENTICATING\n         *   or session->session_state == SSH_SESSION_STATE_AUTHENTICATED\n         * - session->dh_handshake_state == DH_STATE_FINISHED\n         * - session->auth.service_state == SSH_AUTH_SERVICE_SENT\n         *\n         * Transitions:\n         * - auth.service_state = SSH_AUTH_SERVICE_ACCEPTED\n         * */\n\n        if ((session->session_state != SSH_SESSION_STATE_AUTHENTICATING) &&\n            (session->session_state != SSH_SESSION_STATE_AUTHENTICATED))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        /* TODO check if only auth service can be requested */\n        if (session->auth.service_state != SSH_AUTH_SERVICE_SENT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_EXT_INFO:                           // 7\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         *   or session->session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *   (re-exchange)\n         * - dh_handshake_state == DH_STATE_FINISHED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if ((session->session_state != SSH_SESSION_STATE_AUTHENTICATING) &&\n            (session->session_state != SSH_SESSION_STATE_AUTHENTICATED))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEXINIT:                            // 20\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *   or session_state == SSH_SESSION_STATE_INITIAL_KEX\n         * - dh_handshake_state == DH_STATE_INIT\n         *   or dh_handshake_state == DH_STATE_INIT_SENT (re-exchange)\n         *   or dh_handshake_state == DH_STATE_REQUEST_SENT (dh-gex)\n         *   or dh_handshake_state == DH_STATE_FINISHED (re-exchange)\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_INIT\n         * - session->session_state = SSH_SESSION_STATE_KEXINIT_RECEIVED\n         *\n         * On server:\n         * - session->session_state = SSH_SESSION_STATE_DH\n         * */\n\n        if ((session->session_state != SSH_SESSION_STATE_AUTHENTICATED) &&\n            (session->session_state != SSH_SESSION_STATE_INITIAL_KEX))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if ((session->dh_handshake_state != DH_STATE_INIT) &&\n            (session->dh_handshake_state != DH_STATE_INIT_SENT) &&\n            (session->dh_handshake_state != DH_STATE_REQUEST_SENT) &&\n            (session->dh_handshake_state != DH_STATE_FINISHED))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_NEWKEYS:                            // 21\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_NEWKEYS_SENT\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_FINISHED\n         * - session->session_state = SSH_SESSION_STATE_AUTHENTICATING\n         * if session->flags & SSH_SESSION_FLAG_AUTHENTICATED\n         * - session->session_state = SSH_SESSION_STATE_AUTHENTICATED\n         * */\n\n        /* If DH has not been started, reject message */\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        /* Only allowed if dh_handshake_state is in NEWKEYS_SENT state */\n        if (session->dh_handshake_state != DH_STATE_NEWKEYS_SENT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEXDH_INIT:                         // 30\n      // SSH2_MSG_KEX_ECDH_INIT:                      // 30\n      // SSH2_MSG_ECMQV_INIT:                         // 30\n      // SSH2_MSG_KEX_DH_GEX_REQUEST_OLD:             // 30\n\n        /* Server only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_INIT\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_INIT_SENT\n         * then calls dh_handshake_server which triggers:\n         * - session->dh_handshake_state = DH_STATE_NEWKEYS_SENT\n         * */\n\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        /* Only allowed if dh_handshake_state is in initial state */\n        if (session->dh_handshake_state != DH_STATE_INIT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEXDH_REPLY:                        // 31\n      // SSH2_MSG_KEX_ECDH_REPLY:                     // 31\n      // SSH2_MSG_ECMQV_REPLY:                        // 31\n      // SSH2_MSG_KEX_DH_GEX_GROUP:                   // 31\n\n        /* Client only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_INIT_SENT\n         *   or dh_handshake_state == DH_STATE_REQUEST_SENT (dh-gex)\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_NEWKEYS_SENT\n         * */\n\n        if (session->server) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_INIT_SENT &&\n            session->dh_handshake_state != DH_STATE_REQUEST_SENT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEX_DH_GEX_INIT:                    // 32\n        /* Server only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_GROUP_SENT\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_GROUP_SENT\n         * then calls ssh_packet_server_dhgex_init which triggers:\n         * - session->dh_handshake_state = DH_STATE_NEWKEYS_SENT\n         * */\n\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        /* Only allowed if dh_handshake_state is in initial state */\n        if (session->dh_handshake_state != DH_STATE_GROUP_SENT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEX_DH_GEX_REPLY:                   // 33\n\n        /* Client only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_INIT_SENT\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_NEWKEYS_SENT\n         * */\n\n        if (session->server) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_INIT_SENT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_KEX_DH_GEX_REQUEST:                 // 34\n\n        /* Server only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_DH\n         * - dh_handshake_state == DH_STATE_INIT\n         *\n         * Transitions:\n         * - session->dh_handshake_state = DH_STATE_INIT_SENT\n         * then calls ssh_packet_server_dhgex_request which triggers:\n         * - session->dh_handshake_state = DH_STATE_GROUP_SENT\n         * */\n\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_DH) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        /* Only allowed if dh_handshake_state is in initial state */\n        if (session->dh_handshake_state != DH_STATE_INIT) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_REQUEST:                   // 50\n        /* Server only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - dh_handshake_state == DH_STATE_FINISHED\n         *\n         * Transitions:\n         * - if authentication was successful:\n         *   - session_state = SSH_SESSION_STATE_AUTHENTICATED\n         * */\n\n        /* If this is a client, reject the message */\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_FAILURE:                   // 51\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - dh_handshake_state == DH_STATE_FINISHED\n         * - session->auth.state == SSH_AUTH_STATE_KBDINT_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_PUBKEY_OFFER_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_PUBKEY_AUTH_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_PASSWORD_AUTH_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_GSSAPI_MIC_SENT\n         *\n         * Transitions:\n         * - if unpacking failed:\n         *   - session->auth.state = SSH_AUTH_ERROR\n         * - if failure was partial:\n         *   - session->auth.state = SSH_AUTH_PARTIAL\n         * - else:\n         *   - session->auth.state = SSH_AUTH_STATE_FAILED\n         * */\n\n        /* If this is a server, reject the message */\n        if (session->server) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_SUCCESS:                   // 52\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - dh_handshake_state == DH_STATE_FINISHED\n         * - session->auth.state == SSH_AUTH_STATE_KBDINT_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_PUBKEY_AUTH_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_PASSWORD_AUTH_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_GSSAPI_MIC_SENT\n         *   or session->auth.state == SSH_AUTH_STATE_AUTH_NONE_SENT\n         *\n         * Transitions:\n         * - session->auth.state = SSH_AUTH_STATE_SUCCESS\n         * - session->session_state = SSH_SESSION_STATE_AUTHENTICATED\n         * - session->flags |= SSH_SESSION_FLAG_AUTHENTICATED\n         * - sessions->auth.current_method = SSH_AUTH_METHOD_UNKNOWN\n         * */\n\n        /* If this is a server, reject the message */\n        if (session->server) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if ((session->auth.state != SSH_AUTH_STATE_KBDINT_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_PUBKEY_AUTH_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_PASSWORD_AUTH_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_GSSAPI_MIC_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_AUTH_NONE_SENT))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_BANNER:                    // 53\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_PK_OK:                     // 60\n      // SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ:          // 60\n      // SSH2_MSG_USERAUTH_INFO_REQUEST:              // 60\n      // SSH2_MSG_USERAUTH_GSSAPI_RESPONSE:           // 60\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - session->auth.state == SSH_AUTH_STATE_KBDINT_SENT\n         *   or\n         *   session->auth.state == SSH_AUTH_STATE_GSSAPI_REQUEST_SENT\n         *   or\n         *   session->auth.state == SSH_AUTH_STATE_PUBKEY_OFFER_SENT\n         *\n         * Transitions:\n         * Depending on the current state, the message is treated\n         * differently:\n         * - session->auth.state == SSH_AUTH_STATE_KBDINT_SENT\n         *   - session->auth.state = SSH_AUTH_STATE_INFO\n         * - session->auth.state == SSH_AUTH_STATE_GSSAPI_REQUEST_SENT\n         *   - session->auth.state = SSH_AUTH_STATE_GSSAPI_TOKEN\n         * - session->auth.state == SSH_AUTH_STATE_PUBKEY_OFFER_SENT\n         *   - session->auth.state = SSH_AUTH_STATE_PK_OK\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if ((session->auth.state != SSH_AUTH_STATE_KBDINT_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_PUBKEY_OFFER_SENT) &&\n            (session->auth.state != SSH_AUTH_STATE_GSSAPI_REQUEST_SENT))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_INFO_RESPONSE:             // 61\n      // SSH2_MSG_USERAUTH_GSSAPI_TOKEN:              // 61\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - session_state->auth.state == SSH_SESSION_STATE_GSSAPI_TOKEN\n         *   or\n         *   session_state->auth.state == SSH_SESSION_STATE_INFO\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if ((session->auth.state != SSH_AUTH_STATE_INFO) &&\n            (session->auth.state != SSH_AUTH_STATE_GSSAPI_TOKEN))\n        {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE:  // 63\n        /* TODO Not filtered */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_GSSAPI_ERROR:              // 64\n        /* TODO Not filtered */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_GSSAPI_ERRTOK:             // 65\n        /* TODO Not filtered */\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_USERAUTH_GSSAPI_MIC:                // 66\n        /* Server only */\n\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATING\n         * - session->gssapi->state == SSH_GSSAPI_STATE_RCV_MIC\n         *\n         * Transitions:\n         * Depending on the result of the verification, the states are\n         * changed:\n         * - SSH_AUTH_SUCCESS:\n         *   - session->session_state = SSH_SESSION_STATE_AUTHENTICATED\n         *   - session->flags != SSH_SESSION_FLAG_AUTHENTICATED\n         * - SSH_AUTH_PARTIAL:\n         *   - None\n         * - any other case:\n         *   - None\n         * */\n\n        /* If this is a client, reject the message */\n        if (session->client) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->dh_handshake_state != DH_STATE_FINISHED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATING) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_GLOBAL_REQUEST:                     // 80\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_REQUEST_SUCCESS:                    // 81\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - From channel->request_state == SSH_CHANNEL_REQ_STATE_PENDING\n         * - To   channel->request_state = SSH_CHANNEL_REQ_STATE_ACCEPTED\n         *\n         * If not in a pending state, message is ignored in the callback handler.\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_REQUEST_FAILURE:                    // 82\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - From channel->request_state == SSH_CHANNEL_REQ_STATE_PENDING\n         * - To   channel->request_state = SSH_CHANNEL_REQ_STATE_ACCEPTED\n         *\n         * If not in a pending state, message is ignored in the callback handler.\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_OPEN:                       // 90\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_OPEN_CONFIRMATION:          // 91\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - channel->state = SSH_CHANNEL_STATE_OPEN\n         * - channel->flags &= ~SSH_CHANNEL_FLAG_NOT_BOUND\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_OPEN_FAILURE:               // 92\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - channel->state = SSH_CHANNEL_STATE_OPEN_DENIED\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_WINDOW_ADJUST:              // 93\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_DATA:                       // 94\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_EXTENDED_DATA:              // 95\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_EOF:                        // 96\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - None\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_CLOSE:                      // 97\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - channel->state = SSH_CHANNEL_STATE_CLOSED\n         * - channel->flags |= SSH_CHANNEL_FLAG_CLOSED_REMOTE\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_REQUEST:                    // 98\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - Depends on the request\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_SUCCESS:                    // 99\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - From channel->request_state == SSH_CHANNEL_REQ_STATE_PENDING\n         * - To   channel->request_state = SSH_CHANNEL_REQ_STATE_ACCEPTED\n         *\n         * If not in a pending state, message is ignored in the callback handler.\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    case SSH2_MSG_CHANNEL_FAILURE:                    // 100\n        /*\n         * States required:\n         * - session_state == SSH_SESSION_STATE_AUTHENTICATED\n         *\n         * Transitions:\n         * - From channel->request_state == SSH_CHANNEL_REQ_STATE_PENDING\n         * - To   channel->request_state = SSH_CHANNEL_REQ_STATE_ACCEPTED\n         *\n         * If not in a pending state, message is ignored in the callback handler.\n         * */\n\n        if (session->session_state != SSH_SESSION_STATE_AUTHENTICATED) {\n            rc = SSH_PACKET_DENIED;\n            break;\n        }\n\n        rc = SSH_PACKET_ALLOWED;\n        break;\n    default:\n        /* Unknown message, do not filter */\n        rc = SSH_PACKET_UNKNOWN;\n        goto end;\n    }\n\nend:\n#ifdef DEBUG_PACKET\n    if (rc == SSH_PACKET_DENIED) {\n        SSH_LOG(SSH_LOG_PACKET, \"REJECTED packet type %d: \",\n                session->in_packet.type);\n    }\n\n    if (rc == SSH_PACKET_UNKNOWN) {\n        SSH_LOG(SSH_LOG_PACKET, \"UNKNOWN packet type %d\",\n                session->in_packet.type);\n    }\n#endif\n\n    return rc;\n}\n",
      "line_start": 139,
      "line_end": 1026,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 600,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "High-value fuzz target: large switch with many input-dependent branches and state checks (session_state, dh_handshake_state, auth state) covering SSH authentication/handshake paths. Security-critical logic with many code paths, but it does not parse complex raw payloads or perform memory operations, so not the absolute highest priority without a stateful harness."
    },
    {
      "name": "ssh_packet_ext_info",
      "clean_name": "ssh_packet_ext_info",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "/**\n * @internal\n * @brief handles a SSH2_MSG_EXT_INFO packet defined in RFC 8308\n *\n */\nSSH_PACKET_CALLBACK(ssh_packet_ext_info)\n{\n    int rc;\n    uint32_t nr_extensions = 0;\n    uint32_t i;\n\n    (void)type;\n    (void)user;\n\n    SSH_LOG(SSH_LOG_PACKET, \"Received SSH_MSG_EXT_INFO\");\n\n    rc = ssh_buffer_get_u32(packet, &nr_extensions);\n    if (rc == 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"Failed to read number of extensions\");\n        return SSH_PACKET_USED;\n    }\n\n    nr_extensions = ntohl(nr_extensions);\n    if (nr_extensions > 128) {\n        SSH_LOG(SSH_LOG_PACKET, \"Invalid number of extensions\");\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"Follows %\" PRIu32 \" extensions\", nr_extensions);\n\n    for (i = 0; i < nr_extensions; i++) {\n        char *name = NULL;\n        char *value = NULL;\n\n        rc = ssh_buffer_unpack(packet, \"ss\", &name, &value);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_PACKET, \"Error reading extension name-value pair\");\n            return SSH_PACKET_USED;\n        }\n\n        if (strcmp(name, \"server-sig-algs\") == 0) {\n            /* TODO check for NULL bytes */\n            SSH_LOG(SSH_LOG_PACKET, \"Extension: %s=<%s>\", name, value);\n\n            rc = match_group(value, \"rsa-sha2-512\");\n            if (rc == 1) {\n                session->extensions |= SSH_EXT_SIG_RSA_SHA512;\n            }\n\n            rc = match_group(value, \"rsa-sha2-256\");\n            if (rc == 1) {\n                session->extensions |= SSH_EXT_SIG_RSA_SHA256;\n            }\n        } else if (strcmp(name, \"publickey-hostbound@openssh.com\") == 0) {\n            SSH_LOG(SSH_LOG_PACKET, \"Extension: %s=<%s>\", name, value);\n            session->extensions |= SSH_EXT_PUBLICKEY_HOSTBOUND;\n        } else {\n            SSH_LOG(SSH_LOG_PACKET, \"Unknown extension: %s\", name);\n        }\n        free(name);\n        free(value);\n    }\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 265,
      "line_end": 325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 98,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured external input (SSH packet) and unpacks name/value strings, performs memory/string operations and allocations, and has input-dependent loop bounds and multiple branches. The code handles complex, attacker-controlled data and has TODOs around NULL-byte handling, making it a high-value fuzz target (bounded nr_extensions reduces severity slightly)."
    },
    {
      "name": "ssh_pcap_context_write",
      "clean_name": "ssh_pcap_context_write",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": " * @param len data to write in the pcap file. May be smaller than origlen.\n * @param origlen number of bytes of complete data.\n * @returns SSH_OK write is successful\n * @returns SSH_ERROR an error happened.\n */\nint ssh_pcap_context_write(ssh_pcap_context ctx,\n                           enum ssh_pcap_direction direction,\n                           void *data,\n                           uint32_t len,\n                           uint32_t origlen)\n{\n    ssh_buffer ip;\n    int rc;\n\n    if (ctx == NULL || ctx->file == NULL) {\n        return SSH_ERROR;\n    }\n    if (ctx->connected == 0) {\n        if (ssh_pcap_context_connect(ctx) == SSH_ERROR) {\n            return SSH_ERROR;\n        }\n    }\n    ip = ssh_buffer_new();\n    if (ip == NULL) {\n        ssh_set_error_oom(ctx->session);\n        return SSH_ERROR;\n    }\n\n    /* build an IP packet */\n    rc = ssh_buffer_pack(ip,\n                         \"bbwwwbbw\",\n                         4 << 4 | 5, /* V4, 20 bytes */\n                         0,          /* tos */\n                         origlen + TCPIPHDR_LEN, /* total len */\n                         ctx->file->ipsequence,  /* IP id number */\n                         0,          /* fragment offset */\n                         64,         /* TTL */\n                         6,          /* protocol TCP=6 */\n                         0);         /* checksum */\n\n    ctx->file->ipsequence++;\n    if (rc != SSH_OK) {\n        goto error;\n    }\n    if (direction == SSH_PCAP_DIR_OUT) {\n        rc = ssh_buffer_add_u32(ip, ctx->ipsource);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = ssh_buffer_add_u32(ip, ctx->ipdest);\n        if (rc < 0) {\n            goto error;\n        }\n    } else {\n        rc = ssh_buffer_add_u32(ip, ctx->ipdest);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = ssh_buffer_add_u32(ip, ctx->ipsource);\n        if (rc < 0) {\n            goto error;\n        }\n    }\n    /* TCP */\n    if (direction == SSH_PCAP_DIR_OUT) {\n        rc = ssh_buffer_add_u16(ip, ctx->portsource);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = ssh_buffer_add_u16(ip, ctx->portdest);\n        if (rc < 0) {\n            goto error;\n        }\n    } else {\n        rc = ssh_buffer_add_u16(ip, ctx->portdest);\n        if (rc < 0) {\n            goto error;\n        }\n        rc = ssh_buffer_add_u16(ip, ctx->portsource);\n        if (rc < 0) {\n            goto error;\n        }\n    }\n    /* sequence number */\n    if (direction == SSH_PCAP_DIR_OUT) {\n        rc = ssh_buffer_pack(ip, \"d\", ctx->outsequence);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        ctx->outsequence += origlen;\n    } else {\n        rc = ssh_buffer_pack(ip, \"d\", ctx->insequence);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        ctx->insequence += origlen;\n    }\n    /* ack number */\n    if (direction == SSH_PCAP_DIR_OUT) {\n        rc = ssh_buffer_pack(ip, \"d\", ctx->insequence);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n    } else {\n        rc = ssh_buffer_pack(ip, \"d\", ctx->outsequence);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n    }\n\n    rc = ssh_buffer_pack(ip,\n                         \"bbwwwP\",\n                         5 << 4,             /* header len = 20 = 5 * 32 bits, at offset 4*/\n                         TH_PUSH | TH_ACK,   /* flags */\n                         65535,              /* window */\n                         0,                  /* checksum */\n                         0,                  /* urgent data ptr */\n                         (size_t)len, data); /* actual data */\n    if (rc != SSH_OK) {\n        goto error;\n    }\n    rc = ssh_pcap_file_write_packet(ctx->file, ip, origlen + TCPIPHDR_LEN);\n\nerror:\n    SSH_BUFFER_FREE(ip);\n    return rc;\n}\n",
      "line_start": 400,
      "line_end": 522,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 235,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Accepts external data pointer and length and copies it into internal buffers (memory operations), builds structured IP/TCP packets using input-dependent sizes (origlen/len), updates sequence state, and has multiple branching code paths based on direction. Moderate-high complexity and several potential memory/length-related issues (integer overflow, buffer handling) make it a high-value fuzz target."
    },
    {
      "name": "ssh_pki_export_privkey_base64_format",
      "clean_name": "ssh_pki_export_privkey_base64_format",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @return     SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_string_free_char()\n */\nint\nssh_pki_export_privkey_base64_format(const ssh_key privkey,\n                                     const char *passphrase,\n                                     ssh_auth_callback auth_fn,\n                                     void *auth_data,\n                                     char **b64_key,\n                                     enum ssh_file_format_e format)\n{\n    ssh_string blob = NULL;\n    char *b64 = NULL;\n\n    if (privkey == NULL || !ssh_key_is_private(privkey)) {\n        return SSH_ERROR;\n    }\n\n    /*\n     * For historic reasons, the Ed25519 keys are exported in OpenSSH file\n     * format by default also when built with OpenSSL.\n     *\n     * The FIDO2/U2F security keys are an extension to the SSH protocol\n     * proposed by OpenSSH, and do not have any representation in PEM format.\n     * So, they are always exported in the OpenSSH file format.\n     */\n#ifdef HAVE_LIBCRYPTO\n    if (format == SSH_FILE_FORMAT_DEFAULT &&\n        privkey->type != SSH_KEYTYPE_ED25519 &&\n        !is_sk_key_type(privkey->type)) {\n        format = SSH_FILE_FORMAT_PEM;\n    }\n#endif /* HAVE_LIBCRYPTO */\n\n    switch (format) {\n    case SSH_FILE_FORMAT_PEM:\n        blob = pki_private_key_to_pem(privkey,\n                                      passphrase,\n                                      auth_fn,\n                                      auth_data);\n        break;\n    case SSH_FILE_FORMAT_DEFAULT:\n        /* default except (OpenSSL && !ED25519) handled above */\n    case SSH_FILE_FORMAT_OPENSSH:\n        blob = ssh_pki_openssh_privkey_export(privkey,\n                                              passphrase,\n                                              auth_fn,\n                                              auth_data);\n        break;\n    }\n    if (blob == NULL) {\n        return SSH_ERROR;\n    }\n\n    b64 = strndup(ssh_string_data(blob), ssh_string_len(blob));\n    SSH_STRING_FREE(blob);\n    if (b64 == NULL) {\n        return SSH_ERROR;\n    }\n\n    *b64_key = b64;\n\n    return SSH_OK;\n}\n",
      "line_start": 981,
      "line_end": 1041,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Wrapper around complex private-key export logic (PEM/OpenSSH) that invokes cryptographic/serialization routines and an auth callback. It performs memory operations on exporter-produced data and contains branching based on key type/format \u2014 security-critical and valuable to fuzz (though most heavy parsing is delegated to called functions)."
    },
    {
      "name": "ssh_pki_import_privkey_file",
      "clean_name": "ssh_pki_import_privkey_file",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @returns SSH_OK on success, SSH_EOF if the file doesn't exist or permission\n *          denied, SSH_ERROR otherwise.\n *\n * @see ssh_key_free()\n **/\nint ssh_pki_import_privkey_file(const char *filename,\n                                const char *passphrase,\n                                ssh_auth_callback auth_fn,\n                                void *auth_data,\n                                ssh_key *pkey) {\n    struct stat sb;\n    char *key_buf = NULL;\n    FILE *file = NULL;\n    off_t size;\n    int rc;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n    if (pkey == NULL || filename == NULL || *filename == '\\0') {\n        return SSH_ERROR;\n    }\n\n#ifdef WITH_PKCS11_URI\n    if (ssh_pki_is_uri(filename)) {\n        rc = pki_uri_import(filename, pkey, SSH_KEY_PRIVATE);\n        return rc;\n    }\n#endif /* WITH_PKCS11_URI */\n\n    file = fopen(filename, \"rb\");\n    if (file == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Error opening %s: %s\",\n                filename,\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_EOF;\n    }\n\n    rc = fstat(fileno(file), &sb);\n    if (rc < 0) {\n        fclose(file);\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Error getting stat of %s: %s\",\n                filename,\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        switch (errno) {\n            case ENOENT:\n            case EACCES:\n                return SSH_EOF;\n        }\n\n        return SSH_ERROR;\n    }\n\n    if (sb.st_size > MAX_PRIVKEY_SIZE) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Private key is bigger than 4M.\");\n        fclose(file);\n        return SSH_ERROR;\n    }\n\n    key_buf = malloc(sb.st_size + 1);\n    if (key_buf == NULL) {\n        fclose(file);\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory!\");\n        return SSH_ERROR;\n    }\n\n    size = fread(key_buf, 1, sb.st_size, file);\n    fclose(file);\n\n    if (size != sb.st_size) {\n        SAFE_FREE(key_buf);\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Error reading %s: %s\",\n                filename,\n                ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_ERROR;\n    }\n    key_buf[size] = 0;\n\n    rc = ssh_pki_import_privkey_base64(key_buf,\n                                       passphrase,\n                                       auth_fn,\n                                       auth_data,\n                                       pkey);\n\n    SAFE_FREE(key_buf);\n    return rc;\n}\n",
      "line_start": 1099,
      "line_end": 1183,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 106,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Reads untrusted file data into a malloc'd buffer, performs bounds checks and string operations, and is the entry point for importing private keys (security-critical). While the function itself is low-complexity wrapper logic, it hands untrusted input to a complex key-parsing routine, making it a high-priority fuzz target."
    },
    {
      "name": "ssh_pki_import_pubkey_blob",
      "clean_name": "ssh_pki_import_pubkey_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_pubkey_blob(const ssh_string key_blob,\n                               ssh_key *pkey)\n{\n    ssh_buffer buffer = NULL;\n    ssh_string type_s = NULL;\n    enum ssh_keytypes_e type;\n    int rc;\n\n    if (key_blob == NULL || pkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory!\");\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_data(buffer,\n                             ssh_string_data(key_blob),\n                             (uint32_t)ssh_string_len(key_blob));\n    if (rc < 0) {\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory!\");\n        goto fail;\n    }\n\n    type_s = ssh_buffer_get_ssh_string(buffer);\n    if (type_s == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Out of memory!\");\n        goto fail;\n    }\n\n    type = ssh_key_type_from_name(ssh_string_get_char(type_s));\n    if (type == SSH_KEYTYPE_UNKNOWN) {\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown key type found!\");\n        goto fail;\n    }\n    SSH_STRING_FREE(type_s);\n\n    if (is_cert_type(type)) {\n        rc = pki_import_cert_buffer(buffer, type, pkey);\n    } else {\n        rc = pki_import_pubkey_buffer(buffer, type, pkey);\n    }\n\n    SSH_BUFFER_FREE(buffer);\n\n    return rc;\nfail:\n    SSH_BUFFER_FREE(buffer);\n    SSH_STRING_FREE(type_s);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 1860,
      "line_end": 1914,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 107,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Accepts untrusted key blobs and copies them into a buffer, extracts a type field and dispatches to certificate/public-key parsers. This touches structured, security-critical input (crypto key formats) and performs memory operations on external data; multiple code paths exist. The function itself is a thin dispatcher so fuzzing will be most valuable at the pki_import_* parsers it calls, but the target is high-priority."
    },
    {
      "name": "ssh_pki_do_sign_agent",
      "clean_name": "ssh_pki_do_sign_agent",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    SSH_STRING_FREE(session_id);\n\n    return sig_blob;\n}\n\nssh_string ssh_pki_do_sign_agent(ssh_session session,\n                                 struct ssh_buffer_struct *buf,\n                                 const ssh_key pubkey)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    ssh_string session_id = NULL;\n    ssh_string sig_blob = NULL;\n    ssh_buffer sig_buf = NULL;\n    int rc;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_BOTH);\n    if (crypto == NULL) {\n        return NULL;\n    }\n\n    /* prepend session identifier */\n    session_id = ssh_string_new(crypto->session_id_len);\n    if (session_id == NULL) {\n        return NULL;\n    }\n    rc = ssh_string_fill(session_id, crypto->session_id, crypto->session_id_len);\n    if (rc < 0) {\n        SSH_STRING_FREE(session_id);\n        return NULL;\n    }\n\n    sig_buf = ssh_buffer_new();\n    if (sig_buf == NULL) {\n        SSH_STRING_FREE(session_id);\n        return NULL;\n    }\n\n    rc = ssh_buffer_add_ssh_string(sig_buf, session_id);\n    if (rc < 0) {\n        SSH_STRING_FREE(session_id);\n        SSH_BUFFER_FREE(sig_buf);\n        return NULL;\n    }\n    SSH_STRING_FREE(session_id);\n\n    /* append out buffer */\n    if (ssh_buffer_add_buffer(sig_buf, buf) < 0) {\n        SSH_BUFFER_FREE(sig_buf);\n        return NULL;\n    }\n\n    /* create signature */\n    sig_blob = ssh_agent_sign_data(session, pubkey, sig_buf);\n\n    SSH_BUFFER_FREE(sig_buf);\n\n    return sig_blob;\n}\n",
      "line_start": 3528,
      "line_end": 3581,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 108,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Constructs data to be signed and calls the SSH agent (security-critical crypto operation) while manipulating buffers/strings derived from external inputs (buf, pubkey). It presents memory operations on untrusted data and multiple failure paths, but the function itself is a relatively simple orchestrator (low branching/complexity) so it is high priority for fuzzing rather than critical."
    },
    {
      "name": "pki.c:sshsig_prepare_data",
      "clean_name": "sshsig_prepare_data",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param sig_namespace  The signature namespace\n * @param tosign_buf     Pointer to store the allocated to-sign buffer\n *\n * @return SSH_OK on success, SSH_ERROR on error\n */\nstatic int sshsig_prepare_data(const void *data,\n                               size_t data_length,\n                               const char *hash_alg,\n                               const char *sig_namespace,\n                               ssh_buffer *tosign_buf)\n{\n    ssh_buffer tosign = NULL;\n    ssh_string hash_string = NULL;\n    char hash[SHA512_DIGEST_LEN];\n    size_t hash_len;\n    int rc = SSH_ERROR;\n\n    if (data == NULL || hash_alg == NULL || sig_namespace == NULL ||\n        tosign_buf == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid input parameters\");\n        return SSH_ERROR;\n    }\n\n    *tosign_buf = NULL;\n\n    if (strcmp(hash_alg, \"sha256\") == 0) {\n        hash_len = SHA256_DIGEST_LEN;\n        rc = sha256(data, data_length, (unsigned char *)hash);\n    } else if (strcmp(hash_alg, \"sha512\") == 0) {\n        hash_len = SHA512_DIGEST_LEN;\n        rc = sha512(data, data_length, (unsigned char *)hash);\n    } else {\n        SSH_LOG(SSH_LOG_TRACE, \"Unsupported hash algorithm: %s\", hash_alg);\n        goto cleanup;\n    }\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to compute %s hash of data\", hash_alg);\n        goto cleanup;\n    }\n\n    hash_string = ssh_string_new(hash_len);\n    if (hash_string == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to allocate ssh_string for hash\");\n        goto cleanup;\n    }\n\n    rc = ssh_string_fill(hash_string, hash, hash_len);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to fill ssh_string with hash data\");\n        goto cleanup;\n    }\n\n    tosign = ssh_buffer_new();\n    if (tosign == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to allocate buffer for signing data\");\n        goto cleanup;\n    }\n\n    rc = ssh_buffer_pack(tosign,\n                         \"tsssS\",\n                         SSHSIG_MAGIC_PREAMBLE,\n                         sig_namespace,\n                         \"\",\n                         hash_alg,\n                         hash_string);\n\n    if (rc == SSH_OK) {\n        *tosign_buf = tosign;\n        tosign = NULL;\n    } else {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to pack signing data into buffer\");\n    }\n\ncleanup:\n    SSH_BUFFER_FREE(tosign);\n    SSH_STRING_FREE(hash_string);\n\n    return rc;\n}\n",
      "line_start": 3089,
      "line_end": 3163,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 135,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Accepts untrusted data and strings, computes cryptographic hashes, and packs them into a dynamically allocated signing buffer \u2014 involving allocations and buffer/string operations. It has multiple input-dependent code paths (hash algorithm selection) and handles security-critical data, making it a high-value fuzz target. It lacks very complex parsing or heavy branching, so not scored as critical."
    },
    {
      "name": "ttyopts.c:encode_termios_opts",
      "clean_name": "encode_termios_opts",
      "source_file": "/src/libssh/src/ttyopts.c",
      "source_code": " * @param[in]  buflen   The length of the buffer.\n *\n * @return              number of bytes in the buffer on success, -1 on error.\n */\nstatic int\nencode_termios_opts(struct termios *attr, unsigned char *buf, size_t buflen)\n{\n    unsigned int offset = 0;\n    int rc;\n\n#define SSH_ENCODE_OPT(code, value)                                      \\\n    rc = encode_termios_opt(code, value, buf + offset, buflen - offset); \\\n    if (rc < 0) {                                                        \\\n        return rc;                                                       \\\n    } else {                                                             \\\n        offset += rc;                                                    \\\n    }\n\n#define SSH_ENCODE_INPUT_OPT(opt) \\\n    SSH_ENCODE_OPT(TTY_OP_##opt, (attr->c_iflag & opt) ? 1 : 0)\n    SSH_ENCODE_INPUT_OPT(IGNPAR)\n    SSH_ENCODE_INPUT_OPT(PARMRK)\n    SSH_ENCODE_INPUT_OPT(INPCK)\n    SSH_ENCODE_INPUT_OPT(ISTRIP)\n    SSH_ENCODE_INPUT_OPT(INLCR)\n    SSH_ENCODE_INPUT_OPT(IGNCR)\n    SSH_ENCODE_INPUT_OPT(ICRNL)\n#ifdef IUCLC\n    SSH_ENCODE_INPUT_OPT(IUCLC)\n#endif\n    SSH_ENCODE_INPUT_OPT(IXON)\n    SSH_ENCODE_INPUT_OPT(IXANY)\n    SSH_ENCODE_INPUT_OPT(IXOFF)\n    SSH_ENCODE_INPUT_OPT(IMAXBEL)\n#ifdef IUTF8\n    SSH_ENCODE_INPUT_OPT(IUTF8)\n#endif\n#undef SSH_ENCODE_INPUT_OPT\n\n#define SSH_ENCODE_OUTPUT_OPT(opt) \\\n    SSH_ENCODE_OPT(TTY_OP_##opt, (attr->c_oflag & opt) ? 1 : 0)\n    SSH_ENCODE_OUTPUT_OPT(OPOST)\n#ifdef OLCUC\n    SSH_ENCODE_OUTPUT_OPT(OLCUC)\n#endif\n    SSH_ENCODE_OUTPUT_OPT(ONLCR)\n    SSH_ENCODE_OUTPUT_OPT(OCRNL)\n    SSH_ENCODE_OUTPUT_OPT(ONOCR)\n    SSH_ENCODE_OUTPUT_OPT(ONLRET)\n#undef SSH_ENCODE_OUTPUT_OPT\n\n#define SSH_ENCODE_CONTROL_OPT(opt) \\\n    SSH_ENCODE_OPT(TTY_OP_##opt, (attr->c_cflag & opt) ? 1 : 0)\n    SSH_ENCODE_CONTROL_OPT(CS7)\n    SSH_ENCODE_CONTROL_OPT(CS8)\n    SSH_ENCODE_CONTROL_OPT(PARENB)\n    SSH_ENCODE_CONTROL_OPT(PARODD)\n#undef SSH_ENCODE_CONTROL_OPT\n\n#define SSH_ENCODE_LOCAL_OPT(opt) \\\n    SSH_ENCODE_OPT(TTY_OP_##opt, (attr->c_lflag & opt) ? 1 : 0)\n    SSH_ENCODE_LOCAL_OPT(ISIG)\n    SSH_ENCODE_LOCAL_OPT(ICANON)\n#ifdef XCASE\n    SSH_ENCODE_LOCAL_OPT(XCASE)\n#endif\n    SSH_ENCODE_LOCAL_OPT(ECHO)\n    SSH_ENCODE_LOCAL_OPT(ECHOE)\n    SSH_ENCODE_LOCAL_OPT(ECHOK)\n    SSH_ENCODE_LOCAL_OPT(ECHONL)\n    SSH_ENCODE_LOCAL_OPT(NOFLSH)\n    SSH_ENCODE_LOCAL_OPT(TOSTOP)\n    SSH_ENCODE_LOCAL_OPT(IEXTEN)\n    SSH_ENCODE_LOCAL_OPT(ECHOCTL)\n    SSH_ENCODE_LOCAL_OPT(ECHOKE)\n#ifdef PENDIN\n    SSH_ENCODE_LOCAL_OPT(PENDIN)\n#endif\n#undef SSH_ENCODE_LOCAL_OPT\n\n#define SSH_ENCODE_CC_OPT(opt) SSH_ENCODE_OPT(TTY_OP_##opt, attr->c_cc[opt])\n    SSH_ENCODE_CC_OPT(VINTR)\n    SSH_ENCODE_CC_OPT(VQUIT)\n    SSH_ENCODE_CC_OPT(VERASE)\n    SSH_ENCODE_CC_OPT(VKILL)\n    SSH_ENCODE_CC_OPT(VEOF)\n    SSH_ENCODE_CC_OPT(VEOL)\n    SSH_ENCODE_CC_OPT(VEOL2)\n    SSH_ENCODE_CC_OPT(VSTART)\n    SSH_ENCODE_CC_OPT(VSTOP)\n    SSH_ENCODE_CC_OPT(VSUSP)\n#ifdef VDSUSP\n    SSH_ENCODE_CC_OPT(VDSUSP)\n#endif\n    SSH_ENCODE_CC_OPT(VREPRINT)\n    SSH_ENCODE_CC_OPT(VWERASE)\n    SSH_ENCODE_CC_OPT(VLNEXT)\n#ifdef VFLUSH\n    SSH_ENCODE_CC_OPT(VFLUSH)\n#endif\n#ifdef VSWTC\n    SSH_ENCODE_CC_OPT(VSWTC)\n#endif\n#ifdef VSTATUS\n    SSH_ENCODE_CC_OPT(VSTATUS)\n#endif\n    SSH_ENCODE_CC_OPT(VDISCARD)\n#undef SSH_ENCODE_CC_OPT\n\n    SSH_ENCODE_OPT(TTY_OP_ISPEED, baud2speed(cfgetispeed(attr)))\n    SSH_ENCODE_OPT(TTY_OP_OSPEED, baud2speed(cfgetospeed(attr)))\n#undef SSH_ENCODE_OPT\n\n    /* end of options */\n    if (buflen > offset) {\n        buf[offset++] = TTY_OP_END;\n    } else {\n        return -1;\n    }\n\n    return (int)offset;\n}\n",
      "line_start": 196,
      "line_end": 313,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 601,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Serializes a complex, structured termios object into a caller-supplied buffer and calls encode_termios_opt repeatedly (memory writes with explicit buflen checks). Many input-dependent branches (many flag/cc fields and speed conversions) and potential buffer-boundary/serialization edge cases make it a high-value fuzz target for uncovering memory/logic errors."
    },
    {
      "name": "pki_key_dup",
      "clean_name": "pki_key_dup",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    key->key = pkey;\n\n    return SSH_OK;\n}\n\nssh_key pki_key_dup(const ssh_key key, int demote)\n{\n    ssh_key new = NULL;\n    int rc;\n\n    new = pki_key_dup_common_init(key, demote);\n    if (new == NULL) {\n        return NULL;\n    }\n\n    switch (key->type) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA1: {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        const BIGNUM *n = NULL, *e = NULL, *d = NULL;\n        BIGNUM *nn, *ne, *nd;\n        RSA *new_rsa = NULL;\n        const RSA *key_rsa = EVP_PKEY_get0_RSA(key->key);\n#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */\n#ifdef WITH_PKCS11_URI\n        /* Take the PKCS#11 keys as they are */\n        if (key->flags & SSH_KEY_FLAG_PKCS11_URI && !demote) {\n            rc = EVP_PKEY_up_ref(key->key);\n            if (rc != 1) {\n                goto fail;\n            }\n            new->key = key->key;\n            return new;\n        }\n#endif /* WITH_PKCS11_URI */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        new_rsa = RSA_new();\n        if (new_rsa == NULL) {\n            goto fail;\n        }\n\n        /*\n         * n    = public modulus\n         * e    = public exponent\n         * d    = private exponent\n         * p    = secret prime factor\n         * q    = secret prime factor\n         * dmp1 = d mod (p-1)\n         * dmq1 = d mod (q-1)\n         * iqmp = q^-1 mod p\n         */\n        RSA_get0_key(key_rsa, &n, &e, &d);\n        nn = BN_dup(n);\n        ne = BN_dup(e);\n        if (nn == NULL || ne == NULL) {\n            RSA_free(new_rsa);\n            BN_free(nn);\n            BN_free(ne);\n            goto fail;\n        }\n\n        /* Memory management of nn and ne is transferred to RSA object */\n        rc = RSA_set0_key(new_rsa, nn, ne, NULL);\n        if (rc == 0) {\n            RSA_free(new_rsa);\n            BN_free(nn);\n            BN_free(ne);\n            goto fail;\n        }\n\n        if (!demote && (key->flags & SSH_KEY_FLAG_PRIVATE)) {\n            const BIGNUM *p = NULL, *q = NULL, *dmp1 = NULL,\n              *dmq1 = NULL, *iqmp = NULL;\n            BIGNUM *np, *nq, *ndmp1, *ndmq1, *niqmp;\n\n            nd = BN_dup(d);\n            if (nd == NULL) {\n                RSA_free(new_rsa);\n                goto fail;\n            }\n\n            /* Memory management of nd is transferred to RSA object */\n            rc = RSA_set0_key(new_rsa, NULL, NULL, nd);\n            if (rc == 0) {\n                RSA_free(new_rsa);\n                goto fail;\n            }\n\n            /* p, q, dmp1, dmq1 and iqmp may be NULL in private keys, but the\n             * RSA operations are much faster when these values are available.\n             */\n            RSA_get0_factors(key_rsa, &p, &q);\n            if (p != NULL && q != NULL) { /* need to set both of them */\n                np = BN_dup(p);\n                nq = BN_dup(q);\n                if (np == NULL || nq == NULL) {\n                    RSA_free(new_rsa);\n                    BN_free(np);\n                    BN_free(nq);\n                    goto fail;\n                }\n\n                /* Memory management of np and nq is transferred to RSA object */\n                rc = RSA_set0_factors(new_rsa, np, nq);\n                if (rc == 0) {\n                    RSA_free(new_rsa);\n                    BN_free(np);\n                    BN_free(nq);\n                    goto fail;\n                }\n            }\n\n            RSA_get0_crt_params(key_rsa, &dmp1, &dmq1, &iqmp);\n            if (dmp1 != NULL || dmq1 != NULL || iqmp != NULL) {\n                ndmp1 = BN_dup(dmp1);\n                ndmq1 = BN_dup(dmq1);\n                niqmp = BN_dup(iqmp);\n                if (ndmp1 == NULL || ndmq1 == NULL || niqmp == NULL) {\n                    RSA_free(new_rsa);\n                    BN_free(ndmp1);\n                    BN_free(ndmq1);\n                    BN_free(niqmp);\n                    goto fail;\n                }\n\n                /* Memory management of ndmp1, ndmq1 and niqmp is transferred\n                 * to RSA object */\n                rc = RSA_set0_crt_params(new_rsa, ndmp1, ndmq1, niqmp);\n                if (rc == 0) {\n                    RSA_free(new_rsa);\n                    BN_free(ndmp1);\n                    BN_free(ndmq1);\n                    BN_free(niqmp);\n                    goto fail;\n                }\n            }\n        }\n\n        new->key = EVP_PKEY_new();\n        if (new->key == NULL) {\n            RSA_free(new_rsa);\n            goto fail;\n        }\n\n        rc = EVP_PKEY_assign_RSA(new->key, new_rsa);\n        if (rc != 1) {\n            EVP_PKEY_free(new->key);\n            RSA_free(new_rsa);\n            goto fail;\n        }\n\n        new_rsa = NULL;\n#else\n        rc = evp_dup_rsa_pkey(key, new, demote);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n    }\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_SK_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n        new->ecdsa_nid = key->ecdsa_nid;\n#ifdef WITH_PKCS11_URI\n        /* Take the PKCS#11 keys as they are */\n        if (key->flags & SSH_KEY_FLAG_PKCS11_URI && !demote) {\n            rc = EVP_PKEY_up_ref(key->key);\n            if (rc != 1) {\n                goto fail;\n            }\n            new->key = key->key;\n            return new;\n        }\n#endif /* WITH_PKCS11_URI */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        /* privkey -> pubkey */\n        if (demote && ssh_key_is_private(key)) {\n            const EC_POINT *p = NULL;\n            EC_KEY *new_ecdsa = NULL, *old_ecdsa = NULL;\n            int ok;\n\n            new_ecdsa = EC_KEY_new_by_curve_name(key->ecdsa_nid);\n            if (new_ecdsa == NULL) {\n                goto fail;\n            }\n\n            old_ecdsa = EVP_PKEY_get0_EC_KEY(key->key);\n            if (old_ecdsa == NULL) {\n                EC_KEY_free(new_ecdsa);\n                goto fail;\n            }\n\n            p = EC_KEY_get0_public_key(old_ecdsa);\n            if (p == NULL) {\n                EC_KEY_free(new_ecdsa);\n                goto fail;\n            }\n\n            ok = EC_KEY_set_public_key(new_ecdsa, p);\n            if (ok != 1) {\n                EC_KEY_free(new_ecdsa);\n                goto fail;\n            }\n\n            new->key = EVP_PKEY_new();\n            if (new->key == NULL) {\n                EC_KEY_free(new_ecdsa);\n                goto fail;\n            }\n\n            ok = EVP_PKEY_assign_EC_KEY(new->key, new_ecdsa);\n            if (ok != 1) {\n                EC_KEY_free(new_ecdsa);\n                goto fail;\n            }\n        } else {\n            rc = EVP_PKEY_up_ref(key->key);\n            if (rc != 1) {\n                goto fail;\n            }\n            new->key = key->key;\n        }\n#else\n        rc = evp_dup_ecdsa_pkey(key, new, demote);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n#endif /* HAVE_OPENSSL_ECC */\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_SK_ED25519: {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        /* Take the PKCS#11 keys as they are */\n        if (key->flags & SSH_KEY_FLAG_PKCS11_URI && !demote) {\n            rc = EVP_PKEY_up_ref(key->key);\n            if (rc != 1) {\n                goto fail;\n            }\n            new->key = key->key;\n            return new;\n        }\n\n        if (!demote && (key->flags & SSH_KEY_FLAG_PRIVATE) &&\n            key->type == SSH_KEYTYPE_ED25519) {\n            rc = EVP_PKEY_up_ref(key->key);\n            if (rc != 1) {\n                goto fail;\n            }\n            new->key = key->key;\n        } else {\n            unsigned char *ed25519_pubkey = NULL;\n            size_t key_len = 0;\n\n            rc = EVP_PKEY_get_raw_public_key(key->key, NULL, &key_len);\n            if (rc != 1) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Failed to get ed25519 raw public key length: %s\",\n                        ERR_error_string(ERR_get_error(), NULL));\n                goto fail;\n            }\n\n            if (key_len != ED25519_KEY_LEN) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Unexpected length of public key %zu. Expected %d.\",\n                        key_len,\n                        ED25519_KEY_LEN);\n                goto fail;\n            }\n\n            ed25519_pubkey = malloc(key_len);\n            if (ed25519_pubkey == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n                goto fail;\n            }\n\n            rc = EVP_PKEY_get_raw_public_key(key->key,\n                                             ed25519_pubkey,\n                                             &key_len);\n            if (rc != 1) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Failed to get ed25519 raw public key: %s\",\n                        ERR_error_string(ERR_get_error(), NULL));\n                free(ed25519_pubkey);\n                goto fail;\n            }\n\n            new->key = EVP_PKEY_new_raw_public_key(EVP_PKEY_ED25519,\n                                                   NULL,\n                                                   ed25519_pubkey,\n                                                   key_len);\n            free(ed25519_pubkey);\n        }\n\n#else\n        rc = evp_dup_ed25519_pkey(key, new, demote);\n        if (rc != SSH_OK) {\n            goto fail;\n        }\n#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */\n        break;\n    }\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        ssh_key_free(new);\n        return NULL;\n    }\n\n    return new;\nfail:\n    ssh_key_free(new);\n    return NULL;\n}\n",
      "line_start": 482,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 317,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High priority: duplicates and manipulates cryptographic key material (RSA/EC/Ed25519), performs many memory operations and allocations (BN_dup, RSA/EC/EVP_PKEY APIs, raw public key copy), and has significant branching per key type and flag (demote, PKCS#11, private/public). This presents many code paths and potential memory-management bugs. It is not a raw input parser (requires crafted ssh_key/EVP_PKEY structures), so not quite \"critical\" parsing of external file/protocol data, but still a strong fuzz target."
    },
    {
      "name": "pki_key_to_blob",
      "clean_name": "pki_key_to_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "\n    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n\nssh_string pki_key_to_blob(const ssh_key key, enum ssh_key_e type)\n{\n    ssh_buffer buffer = NULL;\n    ssh_string type_s = NULL;\n    ssh_string str = NULL;\n    ssh_string e = NULL;\n    ssh_string n = NULL;\n    ssh_string p = NULL;\n    ssh_string g = NULL;\n    ssh_string q = NULL;\n    ssh_string d = NULL;\n    ssh_string iqmp = NULL;\n    int rc;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    BIGNUM *bp = NULL, *bq = NULL, *bg = NULL, *bpub_key = NULL,\n           *bn = NULL, *be = NULL,\n           *bd = NULL, *biqmp = NULL;\n    OSSL_PARAM *params = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n    uint8_t *ed25519_pubkey = NULL;\n    uint8_t *ed25519_privkey = NULL;\n    size_t key_len = 0;\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        return NULL;\n    }\n    /* The buffer will contain sensitive information. Make sure it is erased */\n    ssh_buffer_set_secure(buffer);\n\n    if (key->cert != NULL) {\n        rc = ssh_buffer_add_buffer(buffer, key->cert);\n        if (rc < 0) {\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n        goto makestring;\n    }\n\n    type_s = ssh_string_from_char(key->type_c);\n    if (type_s == NULL) {\n        SSH_BUFFER_FREE(buffer);\n        return NULL;\n    }\n\n    rc = ssh_buffer_add_ssh_string(buffer, type_s);\n    SSH_STRING_FREE(type_s);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(buffer);\n        return NULL;\n    }\n\n    switch (key->type) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA1: {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        const BIGNUM *be = NULL, *bn = NULL;\n        const RSA *key_rsa = EVP_PKEY_get0_RSA(key->key);\n        RSA_get0_key(key_rsa, &bn, &be, NULL);\n#else\n        const OSSL_PARAM *out_param = NULL;\n        rc = EVP_PKEY_todata(key->key, EVP_PKEY_PUBLIC_KEY, &params);\n        if (rc != 1) {\n            goto fail;\n        }\n        out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_E);\n        if (out_param == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"RSA: No param E has been found\");\n            goto fail;\n        }\n        rc = OSSL_PARAM_get_BN(out_param, &be);\n        if (rc != 1) {\n            goto fail;\n        }\n        out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_N);\n        if (out_param == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"RSA: No param N has been found\");\n            goto fail;\n        }\n        rc = OSSL_PARAM_get_BN(out_param, &bn);\n        if (rc != 1) {\n            goto fail;\n        }\n#endif /* OPENSSL_VERSION_NUMBER */\n        e = ssh_make_bignum_string((BIGNUM *)be);\n        if (e == NULL) {\n            goto fail;\n        }\n\n        n = ssh_make_bignum_string((BIGNUM *)bn);\n        if (n == NULL) {\n            goto fail;\n        }\n\n        if (type == SSH_KEY_PUBLIC) {\n            /* The N and E parts are swapped in the public key export ! */\n            rc = ssh_buffer_add_ssh_string(buffer, e);\n            if (rc < 0) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, n);\n            if (rc < 0) {\n                goto fail;\n            }\n        } else if (type == SSH_KEY_PRIVATE) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n            const BIGNUM *bd, *biqmp, *bp, *bq;\n            RSA_get0_key(key_rsa, NULL, NULL, &bd);\n            RSA_get0_factors(key_rsa, &bp, &bq);\n            RSA_get0_crt_params(key_rsa, NULL, NULL, &biqmp);\n#else\n            OSSL_PARAM_free(params);\n            rc = EVP_PKEY_todata(key->key, EVP_PKEY_KEYPAIR, &params);\n            if (rc != 1) {\n                goto fail;\n            }\n\n            out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_D);\n            if (out_param == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"RSA: No param D has been found\");\n                goto fail;\n            }\n            rc = OSSL_PARAM_get_BN(out_param, &bd);\n            if (rc != 1) {\n                goto fail;\n            }\n\n            out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_FACTOR1);\n            if (out_param == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"RSA: No param P has been found\");\n                goto fail;\n            }\n            rc = OSSL_PARAM_get_BN(out_param, &bp);\n            if (rc != 1) {\n                goto fail;\n            }\n\n            out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_FACTOR2);\n            if (out_param == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"RSA: No param Q has been found\");\n                goto fail;\n            }\n            rc = OSSL_PARAM_get_BN(out_param, &bq);\n            if (rc != 1) {\n                goto fail;\n            }\n\n            out_param = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_COEFFICIENT1);\n            if (out_param == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"RSA: No param IQMP has been found\");\n                goto fail;\n            }\n            rc = OSSL_PARAM_get_BN(out_param, &biqmp);\n            if (rc != 1) {\n                goto fail;\n            }\n#endif /* OPENSSL_VERSION_NUMBER */\n            rc = ssh_buffer_add_ssh_string(buffer, n);\n            if (rc < 0) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, e);\n            if (rc < 0) {\n                goto fail;\n            }\n\n            d = ssh_make_bignum_string((BIGNUM *)bd);\n            if (d == NULL) {\n                goto fail;\n            }\n\n            iqmp = ssh_make_bignum_string((BIGNUM *)biqmp);\n            if (iqmp == NULL) {\n                goto fail;\n            }\n\n            p = ssh_make_bignum_string((BIGNUM *)bp);\n            if (p == NULL) {\n                goto fail;\n            }\n\n            q = ssh_make_bignum_string((BIGNUM *)bq);\n            if (q == NULL) {\n                goto fail;\n            }\n\n            rc = ssh_buffer_add_ssh_string(buffer, d);\n            if (rc < 0) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, iqmp);\n            if (rc < 0) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, p);\n            if (rc < 0) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, q);\n            if (rc < 0) {\n                goto fail;\n            }\n\n            ssh_string_burn(d);\n            SSH_STRING_FREE(d);\n            ssh_string_burn(iqmp);\n            SSH_STRING_FREE(iqmp);\n            ssh_string_burn(p);\n            SSH_STRING_FREE(p);\n            ssh_string_burn(q);\n            SSH_STRING_FREE(q);\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n            bignum_safe_free(bd);\n            bignum_safe_free(biqmp);\n            bignum_safe_free(bp);\n            bignum_safe_free(bq);\n#endif /* OPENSSL_VERSION_NUMBER */\n        }\n        ssh_string_burn(e);\n        SSH_STRING_FREE(e);\n        ssh_string_burn(n);\n        SSH_STRING_FREE(n);\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n        bignum_safe_free(bn);\n        bignum_safe_free(be);\n        OSSL_PARAM_free(params);\n        params = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n    }\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_SK_ED25519:\n        rc = EVP_PKEY_get_raw_public_key(key->key, NULL, &key_len);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to get ed25519 raw public key length: %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n\n        if (key_len != ED25519_KEY_LEN) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Unexpected length of private key %zu. Expected %d.\",\n                    key_len,\n                    ED25519_KEY_LEN);\n            goto fail;\n        }\n\n        ed25519_pubkey = malloc(key_len);\n        if (ed25519_pubkey == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n            goto fail;\n        }\n\n        rc = EVP_PKEY_get_raw_public_key(key->key,\n                                         (uint8_t *)ed25519_pubkey,\n                                         &key_len);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to get ed25519 raw public key:  %s\",\n                    ERR_error_string(ERR_get_error(), NULL));\n            goto fail;\n        }\n\n        rc = ssh_buffer_pack(buffer,\n                             \"dP\",\n                             (uint32_t)ED25519_KEY_LEN,\n                             (size_t)ED25519_KEY_LEN,\n                             ed25519_pubkey);\n        if (rc == SSH_ERROR) {\n            goto fail;\n        }\n\n        if (type == SSH_KEY_PRIVATE && key->type == SSH_KEYTYPE_ED25519) {\n            key_len = 0;\n            rc = EVP_PKEY_get_raw_private_key(key->key, NULL, &key_len);\n            if (rc != 1) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Failed to get ed25519 raw private key length: %s\",\n                        ERR_error_string(ERR_get_error(), NULL));\n                goto fail;\n            }\n\n            if (key_len != ED25519_KEY_LEN) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Unexpected length of private key %zu. Expected %d.\",\n                        key_len,\n                        ED25519_KEY_LEN);\n                goto fail;\n            }\n\n            ed25519_privkey = malloc(key_len);\n            if (ed25519_privkey == NULL) {\n                SSH_LOG(SSH_LOG_TRACE, \"Out of memory\");\n                goto fail;\n            }\n\n            rc = EVP_PKEY_get_raw_private_key(key->key,\n                                              ed25519_privkey,\n                                              &key_len);\n            if (rc != 1) {\n                SSH_LOG(SSH_LOG_TRACE,\n                        \"Failed to get ed25519 raw private key: %s\",\n                        ERR_error_string(ERR_get_error(), NULL));\n                goto fail;\n            }\n\n            rc = ssh_buffer_pack(buffer,\n                                 \"dPP\",\n                                 (uint32_t)(2 * ED25519_KEY_LEN),\n                                 (size_t)ED25519_KEY_LEN,\n                                 ed25519_privkey,\n                                 (size_t)ED25519_KEY_LEN,\n                                 ed25519_pubkey);\n            if (rc == SSH_ERROR) {\n                goto fail;\n            }\n            explicit_bzero(ed25519_privkey, ED25519_KEY_LEN);\n            SAFE_FREE(ed25519_privkey);\n        } else if (type == SSH_KEY_PRIVATE &&\n                   key->type == SSH_KEYTYPE_SK_ED25519) {\n\n            rc = pki_buffer_pack_sk_priv_data(buffer, key);\n            if (rc == SSH_ERROR) {\n                goto fail;\n            }\n        } else if (type == SSH_KEY_PUBLIC &&\n                   key->type == SSH_KEYTYPE_SK_ED25519) {\n            /* public key can contain certificate sk information */\n            rc = ssh_buffer_add_ssh_string(buffer, key->sk_application);\n            if (rc != SSH_OK) {\n                goto fail;\n            }\n        }\n\n        SAFE_FREE(ed25519_pubkey);\n        break;\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_SK_ECDSA:\n#ifdef HAVE_OPENSSL_ECC\n    {\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n        EC_GROUP *group = NULL;\n        EC_POINT *point = NULL;\n        const void *pubkey = NULL;\n        size_t pubkey_len;\n        OSSL_PARAM *locate_param = NULL;\n#else\n        const EC_GROUP *group = NULL;\n        const EC_POINT *point = NULL;\n        const BIGNUM *exp = NULL;\n        EC_KEY *ec = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n        type_s = ssh_string_from_char(pki_key_ecdsa_nid_to_char(key->ecdsa_nid));\n        if (type_s == NULL) {\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n\n        rc = ssh_buffer_add_ssh_string(buffer, type_s);\n        SSH_STRING_FREE(type_s);\n        if (rc < 0) {\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        ec = EVP_PKEY_get0_EC_KEY(key->key);\n        if (ec == NULL) {\n            goto fail;\n        }\n#ifdef WITH_PKCS11_URI\n        if (ssh_key_is_private(key) && !EC_KEY_get0_public_key(ec)) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"It is mandatory to have separate\"\n                    \" public ECDSA key objects in the PKCS #11 device.\"\n                    \" Unlike RSA, ECDSA public keys cannot be derived\"\n                    \" from their private keys.\");\n            goto fail;\n        }\n#endif /* WITH_PKCS11_URI */\n        group = EC_KEY_get0_group(ec);\n        point = EC_KEY_get0_public_key(ec);\n        if (group == NULL || point == NULL) {\n            goto fail;\n        }\n        e = pki_key_make_ecpoint_string(group, point);\n#else\n        rc = EVP_PKEY_todata(key->key, EVP_PKEY_PUBLIC_KEY, &params);\n        if (rc < 0) {\n            goto fail;\n        }\n\n        locate_param = OSSL_PARAM_locate(params, OSSL_PKEY_PARAM_PUB_KEY);\n#ifdef WITH_PKCS11_URI\n        if (ssh_key_is_private(key) && !locate_param) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"It is mandatory to have separate\"\n                    \" public ECDSA key objects in the PKCS #11 device.\"\n                    \" Unlike RSA, ECDSA public keys cannot be derived\"\n                    \" from their private keys.\");\n            goto fail;\n        }\n#endif /* WITH_PKCS11_URI */\n\n        rc = OSSL_PARAM_get_octet_string_ptr(locate_param, &pubkey, &pubkey_len);\n        if (rc != 1) {\n            goto fail;\n        }\n        /* Convert the data to low-level representation */\n        group = EC_GROUP_new_by_curve_name_ex(NULL, NULL, key->ecdsa_nid);\n        point = EC_POINT_new(group);\n        rc = EC_POINT_oct2point(group, point, pubkey, pubkey_len, NULL);\n        if (group == NULL || point == NULL || rc != 1) {\n            EC_GROUP_free(group);\n            EC_POINT_free(point);\n            goto fail;\n        }\n\n        e = pki_key_make_ecpoint_string(group, point);\n        EC_GROUP_free(group);\n        EC_POINT_free(point);\n#endif /* OPENSSL_VERSION_NUMBER */\n        if (e == NULL) {\n            SSH_BUFFER_FREE(buffer);\n            return NULL;\n        }\n\n        rc = ssh_buffer_add_ssh_string(buffer, e);\n        if (rc < 0) {\n            goto fail;\n        }\n\n        ssh_string_burn(e);\n        SSH_STRING_FREE(e);\n        e = NULL;\n\n        if (type == SSH_KEY_PRIVATE && key->type != SSH_KEYTYPE_SK_ECDSA) {\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n            OSSL_PARAM_free(params);\n            rc = EVP_PKEY_todata(key->key, EVP_PKEY_KEYPAIR, &params);\n            if (rc < 0) {\n                goto fail;\n            }\n\n            locate_param = OSSL_PARAM_locate(params, OSSL_PKEY_PARAM_PRIV_KEY);\n            rc = OSSL_PARAM_get_BN(locate_param, &bd);\n            if (rc != 1) {\n                goto fail;\n            }\n            d = ssh_make_bignum_string((BIGNUM *)bd);\n            if (d == NULL) {\n                goto fail;\n            }\n            if (ssh_buffer_add_ssh_string(buffer, d) < 0) {\n                goto fail;\n            }\n#else\n            exp = EC_KEY_get0_private_key(ec);\n            if (exp == NULL) {\n                goto fail;\n            }\n            d = ssh_make_bignum_string((BIGNUM *)exp);\n            if (d == NULL) {\n                goto fail;\n            }\n            rc = ssh_buffer_add_ssh_string(buffer, d);\n            if (rc < 0) {\n                goto fail;\n            }\n#endif /* OPENSSL_VERSION_NUMBER */\n            ssh_string_burn(d);\n            SSH_STRING_FREE(d);\n            d = NULL;\n        } else if (type == SSH_KEY_PRIVATE &&\n                   key->type == SSH_KEYTYPE_SK_ECDSA) {\n\n            rc = pki_buffer_pack_sk_priv_data(buffer, key);\n            if (rc == SSH_ERROR) {\n                goto fail;\n            }\n        } else if (type == SSH_KEY_PUBLIC &&\n                   key->type == SSH_KEYTYPE_SK_ECDSA) {\n            /* public key can contain certificate sk information */\n            rc = ssh_buffer_add_ssh_string(buffer, key->sk_application);\n            if (rc != SSH_OK) {\n                goto fail;\n            }\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n        bignum_safe_free(bd);\n        OSSL_PARAM_free(params);\n        params = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n        break;\n    }\n#endif /* HAVE_OPENSSL_ECC */\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        goto fail;\n    }\n\nmakestring:\n    str = ssh_string_new(ssh_buffer_get_len(buffer));\n    if (str == NULL) {\n        goto fail;\n    }\n\n    rc = ssh_string_fill(str, ssh_buffer_get(buffer), ssh_buffer_get_len(buffer));\n    if (rc < 0) {\n        goto fail;\n    }\n    SSH_BUFFER_FREE(buffer);\n\n    return str;\nfail:\n    SSH_BUFFER_FREE(buffer);\n    ssh_string_burn(str);\n    SSH_STRING_FREE(str);\n    ssh_string_burn(e);\n    SSH_STRING_FREE(e);\n    ssh_string_burn(p);\n    SSH_STRING_FREE(p);\n    ssh_string_burn(g);\n    SSH_STRING_FREE(g);\n    ssh_string_burn(q);\n    SSH_STRING_FREE(q);\n    ssh_string_burn(n);\n    SSH_STRING_FREE(n);\n    ssh_string_burn(d);\n    SSH_STRING_FREE(d);\n    ssh_string_burn(iqmp);\n    SSH_STRING_FREE(iqmp);\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(bp);\n    bignum_safe_free(bq);\n    bignum_safe_free(bg);\n    bignum_safe_free(bpub_key);\n    bignum_safe_free(bn);\n    bignum_safe_free(be);\n    bignum_safe_free(bd);\n    bignum_safe_free(biqmp);\n    OSSL_PARAM_free(params);\n#endif /* OPENSSL_VERSION_NUMBER */\n    free(ed25519_pubkey);\n    if (ed25519_privkey) {\n        explicit_bzero(ed25519_privkey, ED25519_KEY_LEN);\n        free(ed25519_privkey);\n    }\n\n    return NULL;\n}\n",
      "line_start": 1478,
      "line_end": 2033,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 688,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High fuzzing value: complex branching over multiple key types (RSA, Ed25519, ECDSA), many memory operations/allocations/packing and bignum handling, and it deals with cryptographic/private key material. It doesn\u2019t directly parse external file formats itself (it serializes internal key structures), so it\u2019s high-priority but not top-critical as a standalone parser target."
    },
    {
      "name": "sha384_update",
      "clean_name": "sha384_update",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "{\n    EVP_MD_CTX_free(c);\n}\n\nint\nsha384_update(SHA384CTX c, const void *data, size_t len)\n{\n    int rc = EVP_DigestUpdate(c, data, len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 179,
      "line_end": 187,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Wrapper around a cryptographic update (EVP_DigestUpdate) that processes untrusted data: security-critical but contains almost no internal logic or branching. Good to exercise with fuzzing (to stress the crypto implementation), but the function itself is trivial so vulnerability surface is mainly in the underlying EVP code rather than in this wrapper."
    },
    {
      "name": "server_set_kex",
      "clean_name": "server_set_kex",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * The selection of algorithms and keys used are determined by the\n * options that are currently set in the given ssh_session structure.\n */\n\nint server_set_kex(ssh_session session)\n{\n    struct ssh_kex_struct *server = &session->next_crypto->server_kex;\n    int i, j, rc;\n    const char *wanted = NULL, *allowed = NULL;\n    char *kept = NULL;\n    char hostkeys[128] = {0};\n    enum ssh_keytypes_e keytype;\n    size_t len;\n    int ok;\n\n    /* Skip if already set, for example for the rekey or when we do the guessing\n     * it could have been already used to make some protocol decisions. */\n    if (server->methods[0] != NULL) {\n        return SSH_OK;\n    }\n\n    ok = ssh_get_random(server->cookie, 16, 0);\n    if (!ok) {\n        ssh_set_error(session, SSH_FATAL, \"PRNG error\");\n        return -1;\n    }\n\n    if (session->srv.ed25519_key != NULL) {\n        snprintf(hostkeys,\n                 sizeof(hostkeys),\n                 \"%s\",\n                 ssh_key_type_to_char(ssh_key_type(session->srv.ed25519_key)));\n    }\n#ifdef HAVE_ECC\n    if (session->srv.ecdsa_key != NULL) {\n        len = strlen(hostkeys);\n        snprintf(hostkeys + len, sizeof(hostkeys) - len,\n                 \",%s\", session->srv.ecdsa_key->type_c);\n    }\n#endif\n    if (session->srv.rsa_key != NULL) {\n        /* We support also the SHA2 variants */\n        len = strlen(hostkeys);\n        snprintf(hostkeys + len, sizeof(hostkeys) - len,\n                 \",rsa-sha2-512,rsa-sha2-256\");\n\n        len = strlen(hostkeys);\n        keytype = ssh_key_type(session->srv.rsa_key);\n\n        snprintf(hostkeys + len, sizeof(hostkeys) - len,\n                 \",%s\", ssh_key_type_to_char(keytype));\n    }\n\n    if (strlen(hostkeys) == 0) {\n        return -1;\n    }\n\n    if (session->opts.wanted_methods[SSH_HOSTKEYS]) {\n        allowed = session->opts.wanted_methods[SSH_HOSTKEYS];\n    } else {\n        if (ssh_fips_mode()) {\n            allowed = ssh_kex_get_fips_methods(SSH_HOSTKEYS);\n        } else {\n            allowed = ssh_kex_get_default_methods(SSH_HOSTKEYS);\n        }\n    }\n\n    /* It is expected for the list of allowed hostkeys to be ordered by\n     * preference */\n    kept = ssh_find_all_matching(hostkeys[0] == ',' ? hostkeys + 1 : hostkeys,\n                                 allowed);\n    if (kept == NULL) {\n        /* Nothing was allowed */\n        return -1;\n    }\n\n    rc = ssh_options_set_algo(session,\n                              SSH_HOSTKEYS,\n                              kept,\n                              &session->opts.wanted_methods[SSH_HOSTKEYS]);\n    SAFE_FREE(kept);\n    if (rc < 0) {\n        return -1;\n    }\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        wanted = session->opts.wanted_methods[i];\n        if (wanted == NULL) {\n            if (ssh_fips_mode()) {\n                wanted = ssh_kex_get_fips_methods(i);\n            } else {\n                wanted = ssh_kex_get_default_methods(i);\n            }\n        }\n        if (wanted == NULL) {\n            for (j = 0; j < i; j++) {\n                SAFE_FREE(server->methods[j]);\n            }\n            return -1;\n        }\n\n        server->methods[i] = strdup(wanted);\n        if (server->methods[i] == NULL) {\n            for (j = 0; j < i; j++) {\n                SAFE_FREE(server->methods[j]);\n            }\n            return -1;\n        }\n    }\n\n    /* Do not append the extensions during rekey */\n    if (session->flags & SSH_SESSION_FLAG_AUTHENTICATED) {\n        return SSH_OK;\n    }\n\n    rc = ssh_kex_append_extensions(session, server);\n    return rc;\n}\n",
      "line_start": 83,
      "line_end": 197,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 146,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "High-value fuzz target: it processes structured, session-controlled algorithm strings and options, performs string/buffer operations (snprintf, strlen, strdup, SAFE_FREE), memory allocations and selections, and is security-critical (hostkey/kex selection, FIPS handling). Contains branching and multiple error paths. It is not parsing a raw complex file/protocol payload itself, so not maximum criticality, but still high priority for fuzzing."
    },
    {
      "name": "server.c:callback_receive_banner",
      "clean_name": "callback_receive_banner",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " * @param  data pointer to the beginning of header\n * @param  len size of the banner\n * @param  user is a pointer to session\n * @returns Number of bytes processed, or zero if the banner is not complete.\n */\nstatic size_t callback_receive_banner(const void *data, size_t len, void *user)\n{\n    char *buffer = (char *)data;\n    ssh_session session = (ssh_session)user;\n    char *str = NULL;\n    size_t i;\n    size_t processed = 0;\n\n    for (i = 0; i < len; i++) {\n#ifdef WITH_PCAP\n        if (session->pcap_ctx && buffer[i] == '\\n') {\n            ssh_pcap_context_write(session->pcap_ctx,\n                                   SSH_PCAP_DIR_IN,\n                                   buffer,\n                                   (uint32_t)(i + 1),\n                                   (uint32_t)(i + 1));\n        }\n#endif\n        if (buffer[i] == '\\r') {\n            buffer[i] = '\\0';\n        }\n\n        if (buffer[i] == '\\n') {\n            buffer[i] = '\\0';\n\n            str = strdup(buffer);\n            /* number of bytes read */\n            processed = i + 1;\n            session->clientbanner = str;\n            session->session_state = SSH_SESSION_STATE_BANNER_RECEIVED;\n            SSH_LOG(SSH_LOG_PACKET, \"Received banner: %s\", str);\n            session->ssh_connection_callback(session);\n\n            return processed;\n        }\n\n        if (i > 127) {\n            /* Too big banner */\n            session->session_state = SSH_SESSION_STATE_ERROR;\n            ssh_set_error(session, SSH_FATAL,\n                          \"Receiving banner: too large banner\");\n\n            return 0;\n        }\n    }\n\n    return processed;\n}\n",
      "line_start": 473,
      "line_end": 521,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Parses external input line-by-line, writes into the input buffer and calls strdup, has an input-dependent loop with a size limit and multiple code paths (CR, LF, size error) and invokes a session callback \u2014 high-value fuzz target."
    },
    {
      "name": "base64_to_bin",
      "clean_name": "base64_to_bin",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": " * @brief Translates a base64 string into a binary one.\n *\n * @returns A buffer containing the decoded string, NULL if something went\n *          wrong (e.g. incorrect char).\n */\nssh_buffer base64_to_bin(const char *source)\n{\n    ssh_buffer buffer = NULL;\n    unsigned char block[3];\n    char *base64 = NULL;\n    char *ptr = NULL;\n    size_t len;\n    int equals;\n\n    base64 = strdup(source);\n    if (base64 == NULL) {\n        return NULL;\n    }\n    ptr = base64;\n\n    /* Get the number of equals signs, which mirrors the padding */\n    equals = get_equals(ptr);\n    if (equals > 2) {\n        SAFE_FREE(base64);\n        return NULL;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        SAFE_FREE(base64);\n        return NULL;\n    }\n    /*\n     * The base64 buffer often contains sensitive data. Make sure we don't leak\n     * sensitive data\n     */\n    ssh_buffer_set_secure(buffer);\n\n    len = strlen(ptr);\n    while (len > 4) {\n        if (_base64_to_bin(block, ptr, 3) < 0) {\n            goto error;\n        }\n        if (ssh_buffer_add_data(buffer, block, 3) < 0) {\n            goto error;\n        }\n        len -= 4;\n        ptr += 4;\n    }\n\n    /*\n     * Depending on the number of bytes resting, there are 3 possibilities\n     * from the RFC.\n     */\n    switch (len) {\n    /*\n     * (1) The final quantum of encoding input is an integral multiple of\n     *     24 bits. Here, the final unit of encoded output will be an integral\n     *     multiple of 4 characters with no \"=\" padding\n     */\n    case 4:\n        if (equals != 0) {\n            goto error;\n        }\n        if (_base64_to_bin(block, ptr, 3) < 0) {\n            goto error;\n        }\n        if (ssh_buffer_add_data(buffer, block, 3) < 0) {\n            goto error;\n        }\n        SAFE_FREE(base64);\n\n        return buffer;\n    /*\n     * (2) The final quantum of encoding input is exactly 8 bits; here, the\n     *     final unit of encoded output will be two characters followed by\n     *     two \"=\" padding characters.\n     */\n    case 2:\n        if (equals != 2) {\n            goto error;\n        }\n\n        if (_base64_to_bin(block, ptr, 1) < 0) {\n            goto error;\n        }\n        if (ssh_buffer_add_data(buffer, block, 1) < 0) {\n            goto error;\n        }\n        SAFE_FREE(base64);\n\n        return buffer;\n    /*\n     * The final quantum of encoding input is exactly 16 bits. Here, the final\n     * unit of encoded output will be three characters followed by one \"=\"\n     * padding character.\n     */\n    case 3:\n        if (equals != 1) {\n            goto error;\n        }\n        if (_base64_to_bin(block, ptr, 2) < 0) {\n            goto error;\n        }\n        if (ssh_buffer_add_data(buffer, block, 2) < 0) {\n            goto error;\n        }\n        SAFE_FREE(base64);\n\n        return buffer;\n    default:\n        /* 4,3,2 are the only padding size allowed */\n        goto error;\n    }\n\nerror:\n    SAFE_FREE(base64);\n    SSH_BUFFER_FREE(buffer);\n    return NULL;\n}\n",
      "line_start": 62,
      "line_end": 177,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 166,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses external structured input (base64), performs memory/buffer operations and allocations, has input-dependent loop and multiple branches for padding \u2014 good high-priority fuzz target. Not critical (simple format, no crypto)."
    },
    {
      "name": "ssh_config_parse_proxy_jump",
      "clean_name": "ssh_config_parse_proxy_jump",
      "source_file": "/src/libssh/src/config.c",
      "source_code": " *\n * @returns     SSH_OK if the provided string is formatted and parsed correctly\n *              SSH_ERROR on failure\n */\nint\nssh_config_parse_proxy_jump(ssh_session session, const char *s, bool do_parsing)\n{\n    char *c = NULL, *cp = NULL, *endp = NULL;\n    char *username = NULL;\n    char *hostname = NULL;\n    char *port = NULL;\n    char *next = NULL;\n    int cmp, rv = SSH_ERROR;\n    struct ssh_jump_info_struct *jump_host = NULL;\n    bool parse_entry = do_parsing;\n    bool libssh_proxy_jump = ssh_libssh_proxy_jumps();\n\n    /* Special value none disables the proxy */\n    cmp = strcasecmp(s, \"none\");\n    if (cmp == 0) {\n        if (!libssh_proxy_jump && do_parsing) {\n            ssh_options_set(session, SSH_OPTIONS_PROXYCOMMAND, s);\n        }\n        return SSH_OK;\n    }\n\n    /* This is comma-separated list of [user@]host[:port] entries */\n    c = strdup(s);\n    if (c == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    cp = c;\n    do {\n        endp = strchr(cp, ',');\n        if (endp != NULL) {\n            /* Split out the token */\n            *endp = '\\0';\n        }\n        if (parse_entry && libssh_proxy_jump) {\n            jump_host = calloc(1, sizeof(struct ssh_jump_info_struct));\n            if (jump_host == NULL) {\n                ssh_set_error_oom(session);\n                rv = SSH_ERROR;\n                goto out;\n            }\n\n            rv = ssh_config_parse_uri(cp,\n                                      &jump_host->username,\n                                      &jump_host->hostname,\n                                      &port,\n                                      false);\n            if (rv != SSH_OK) {\n                ssh_set_error_invalid(session);\n                SAFE_FREE(jump_host);\n                goto out;\n            }\n            if (port == NULL) {\n                jump_host->port = 22;\n            } else {\n                jump_host->port = strtol(port, NULL, 10);\n                SAFE_FREE(port);\n            }\n\n            /* Prepend because we will recursively proxy jump */\n            rv = ssh_list_prepend(session->opts.proxy_jumps, jump_host);\n            if (rv != SSH_OK) {\n                ssh_set_error_oom(session);\n                SAFE_FREE(jump_host);\n                goto out;\n            }\n        } else if (parse_entry) {\n            /* We actually care only about the first item */\n            rv = ssh_config_parse_uri(cp, &username, &hostname, &port, false);\n            if (rv != SSH_OK) {\n                ssh_set_error_invalid(session);\n                goto out;\n            }\n            /* The rest of the list needs to be passed on */\n            if (endp != NULL) {\n                next = strdup(endp + 1);\n                if (next == NULL) {\n                    ssh_set_error_oom(session);\n                    rv = SSH_ERROR;\n                    goto out;\n                }\n            }\n        } else {\n            /* The rest is just sanity-checked to avoid failures later */\n            rv = ssh_config_parse_uri(cp, NULL, NULL, NULL, false);\n            if (rv != SSH_OK) {\n                ssh_set_error_invalid(session);\n                goto out;\n            }\n        }\n        if (!libssh_proxy_jump) {\n            parse_entry = 0;\n        }\n        if (endp != NULL) {\n            cp = endp + 1;\n        } else {\n            cp = NULL; /* end */\n        }\n    } while (cp != NULL);\n\n    if (!libssh_proxy_jump && hostname != NULL && do_parsing) {\n        char com[512] = {0};\n\n        rv = snprintf(com, sizeof(com), \"ssh%s%s%s%s%s%s -W '[%%h]:%%p' %s\",\n                      username ? \" -l \" : \"\",\n                      username ? username : \"\",\n                      port ? \" -p \" : \"\",\n                      port ? port : \"\",\n                      next ? \" -J \" : \"\",\n                      next ? next : \"\",\n                      hostname);\n        if (rv < 0 || rv >= (int)sizeof(com)) {\n            SSH_LOG(SSH_LOG_TRACE, \"Too long ProxyJump configuration line\");\n            rv = SSH_ERROR;\n            goto out;\n        }\n        rv = ssh_options_set(session, SSH_OPTIONS_PROXYCOMMAND, com);\n        if (rv != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto out;\n        }\n    }\n\n    rv = SSH_OK;\n\nout:\n    if (rv != SSH_OK) {\n        ssh_proxyjumps_free(session->opts.proxy_jumps);\n    }\n    SAFE_FREE(username);\n    SAFE_FREE(hostname);\n    SAFE_FREE(port);\n    SAFE_FREE(next);\n    SAFE_FREE(c);\n    return rv;\n}\n",
      "line_start": 450,
      "line_end": 587,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 278,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Parses structured external input (ProxyJump comma-separated [user@]host[:port] list), performs many memory operations (strdup, strchr, calloc, strtol, snprintf), has loops with input-dependent bounds and multiple branches/paths. Good high-priority fuzz target for parsing and memory-handling bugs; not rated critical because it does not perform crypto/auth logic."
    },
    {
      "name": "ssh_config_parse_string",
      "clean_name": "ssh_config_parse_string",
      "source_file": "/src/libssh/src/config.c",
      "source_code": " * @params[in] input     Null terminated string containing the configuration\n *\n * @returns    SSH_OK on successful parsing the configuration string,\n *             SSH_ERROR on error\n */\nint ssh_config_parse_string(ssh_session session, const char *input)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    const char *c = input, *line_start = input;\n    unsigned int line_num = 0;\n    size_t line_len;\n    int parsing, rv;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Reading configuration data from string:\");\n    SSH_LOG(SSH_LOG_DEBUG, \"START\\n%s\\nEND\", input);\n\n    parsing = 1;\n    while (1) {\n        line_num++;\n        line_start = c;\n        c = strchr(line_start, '\\n');\n        if (c == NULL) {\n            /* if there is no newline at the end of the string */\n            c = strchr(line_start, '\\0');\n        }\n        if (c == NULL) {\n            /* should not happen, would mean a string without trailing '\\0' */\n            SSH_LOG(SSH_LOG_TRACE, \"No trailing '\\\\0' in config string\");\n            return SSH_ERROR;\n        }\n        line_len = c - line_start;\n        if (line_len > MAX_LINE_SIZE - 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Line %u too long: %zu characters\",\n                    line_num,\n                    line_len);\n            return SSH_ERROR;\n        }\n        memcpy(line, line_start, line_len);\n        line[line_len] = '\\0';\n        SSH_LOG(SSH_LOG_DEBUG, \"Line %u: %s\", line_num, line);\n        rv = ssh_config_parse_line(session, line, line_num, &parsing, 0, false);\n        if (rv < 0) {\n            return SSH_ERROR;\n        }\n        if (*c == '\\0') {\n            break;\n        }\n        c++;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 1524,
      "line_end": 1572,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 8.0,
      "reason": "Accepts untrusted input and parses it into lines, performing memcpy/buffer operations (with bounds checks) and driving an input-dependent loop. It delegates to ssh_config_parse_line (likely complex parsing/validation), so fuzzing this entrypoint will exercise many parsing codepaths and potential edge cases. Not extremely complex itself, but high-value as a fuzz target."
    },
    {
      "name": "config.c:local_parse_file",
      "clean_name": "local_parse_file",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "  return SOC_UNKNOWN;\n}\n\n#define LIBSSH_CONF_MAX_DEPTH 16\nstatic void\nlocal_parse_file(ssh_session session,\n                 const char *filename,\n                 int *parsing,\n                 unsigned int depth,\n                 bool global)\n{\n    FILE *f = NULL;\n    char line[MAX_LINE_SIZE] = {0};\n    unsigned int count = 0;\n    int rv;\n\n    if (depth > LIBSSH_CONF_MAX_DEPTH) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"ERROR - Too many levels of configuration includes \"\n                      \"when processing file '%s'\", filename);\n        return;\n    }\n\n    f = fopen(filename, \"r\");\n    if (f == NULL) {\n        SSH_LOG(SSH_LOG_RARE, \"Cannot find file %s to load\",\n                filename);\n        return;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"Reading additional configuration data from %s\", filename);\n    while (fgets(line, sizeof(line), f)) {\n        count++;\n        rv = ssh_config_parse_line(session, line, count, parsing, depth, global);\n        if (rv < 0) {\n            fclose(f);\n            return;\n        }\n    }\n\n    fclose(f);\n    return;\n}\n",
      "line_start": 207,
      "line_end": 245,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Reads and processes external file input line-by-line and delegates to a parser (ssh_config_parse_line). Contains an input-dependent loop, include-depth validation, and multiple code paths on parse errors. While the heavy parsing/memory handling likely happens in the called parser, this function is a high-value fuzz entrypoint for exercising configuration parsing and include recursion handling."
    },
    {
      "name": "gzip.c:gzip_compress",
      "clean_name": "gzip_compress",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "\n    return stream;\n}\n\nstatic ssh_buffer\ngzip_compress(ssh_session session, ssh_buffer source, int level)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    z_stream *zout = NULL;\n    void *in_ptr = ssh_buffer_get(source);\n    uint32_t in_size = ssh_buffer_get_len(source);\n    ssh_buffer dest = NULL;\n    unsigned char out_buf[BLOCKSIZE] = {0};\n    uint32_t len;\n    int status;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n    if (crypto == NULL) {\n        return NULL;\n    }\n    zout = crypto->compress_out_ctx;\n    if (zout == NULL) {\n        zout = crypto->compress_out_ctx = initcompress(session, level);\n        if (zout == NULL) {\n            return NULL;\n        }\n    }\n\n    dest = ssh_buffer_new();\n    if (dest == NULL) {\n        return NULL;\n    }\n\n    zout->next_out = out_buf;\n    zout->next_in = in_ptr;\n    zout->avail_in = in_size;\n    do {\n        zout->avail_out = BLOCKSIZE;\n        status = deflate(zout, Z_PARTIAL_FLUSH);\n        if (status != Z_OK) {\n            SSH_BUFFER_FREE(dest);\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"status %d deflating zlib packet\",\n                          status);\n            return NULL;\n        }\n        len = BLOCKSIZE - zout->avail_out;\n        if (ssh_buffer_add_data(dest, out_buf, len) < 0) {\n            SSH_BUFFER_FREE(dest);\n            return NULL;\n        }\n        zout->next_out = out_buf;\n    } while (zout->avail_out == 0);\n\n    return dest;\n}\n",
      "line_start": 67,
      "line_end": 119,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Consumes untrusted buffer and performs memory operations (zlib deflate, buffer writes) with an input-dependent loop and multiple error paths. It's part of the SSH crypto/IO path so defects can be security-relevant; good fuzz target (high priority) though it doesn't parse a complex file format or perform crypto itself."
    },
    {
      "name": "gzip.c:gzip_decompress",
      "clean_name": "gzip_decompress",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "\n    return stream;\n}\n\nstatic ssh_buffer\ngzip_decompress(ssh_session session, ssh_buffer source, size_t maxlen)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    z_stream *zin = NULL;\n    void *in_ptr = ssh_buffer_get(source);\n    uint32_t in_size = ssh_buffer_get_len(source);\n    unsigned char out_buf[BLOCKSIZE] = {0};\n    ssh_buffer dest = NULL;\n    uint32_t len;\n    int status;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto == NULL) {\n        return NULL;\n    }\n\n    zin = crypto->compress_in_ctx;\n    if (zin == NULL) {\n        zin = crypto->compress_in_ctx = initdecompress(session);\n        if (zin == NULL) {\n            return NULL;\n        }\n    }\n\n    dest = ssh_buffer_new();\n    if (dest == NULL) {\n        return NULL;\n    }\n\n    zin->next_out = out_buf;\n    zin->next_in = in_ptr;\n    zin->avail_in = in_size;\n\n    do {\n        zin->avail_out = BLOCKSIZE;\n        status = inflate(zin, Z_PARTIAL_FLUSH);\n        if (status != Z_OK && status != Z_BUF_ERROR) {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"status %d inflating zlib packet\",\n                          status);\n            SSH_BUFFER_FREE(dest);\n            return NULL;\n        }\n\n        len = BLOCKSIZE - zin->avail_out;\n        if (ssh_buffer_add_data(dest, out_buf, len) < 0) {\n            SSH_BUFFER_FREE(dest);\n            return NULL;\n        }\n        if (ssh_buffer_get_len(dest) > maxlen) {\n            /* Size of packet exceeded, avoid a denial of service attack */\n            SSH_BUFFER_FREE(dest);\n            return NULL;\n        }\n        zin->next_out = out_buf;\n    } while (zin->avail_out == 0);\n\n    return dest;\n}\n",
      "line_start": 176,
      "line_end": 236,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 96,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Decompresses untrusted/zlib-compressed data (complex external input) and performs memory/buffer operations with input-dependent looping and multiple code paths (inflate status handling). It has good potential for finding memory-corruption or logic bugs; rated high priority for fuzzing."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:hash_hostname",
      "clean_name": "hash_hostname",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * @addtogroup libssh_session\n *\n * @{\n */\n\nstatic int hash_hostname(const char *name,\n                         unsigned char *salt,\n                         unsigned int salt_size,\n                         unsigned char **hash,\n                         size_t *hash_size)\n{\n    int rc;\n    HMACCTX mac_ctx = NULL;\n\n    mac_ctx = hmac_init(salt, salt_size, SSH_HMAC_SHA1);\n    if (mac_ctx == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = hmac_update(mac_ctx, name, strlen(name));\n    if (rc != 1)\n        return SSH_ERROR;\n\n    rc = hmac_final(mac_ctx, *hash, hash_size);\n    if (rc != 1)\n        return SSH_ERROR;\n\n    return SSH_OK;\n}\n",
      "line_start": 56,
      "line_end": 80,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Calls cryptographic HMAC on external inputs (name and salt), uses strlen(name) (input-dependent loop) and writes to a caller-provided hash buffer\u2014so it can expose memory-handling issues and logic bugs. Cyclomatic complexity is low and it doesn\u2019t parse complex structured formats, so it\u2019s high priority rather than critical."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:ssh_known_hosts_check_server_key",
      "clean_name": "ssh_known_hosts_check_server_key",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "    fclose(fp);\n    return SSH_OK;\n}\n\nstatic enum ssh_known_hosts_e\nssh_known_hosts_check_server_key(const char *hosts_entry,\n                                 const char *filename,\n                                 ssh_key server_key,\n                                 struct ssh_knownhosts_entry **pentry)\n{\n    struct ssh_list *entry_list = NULL;\n    struct ssh_iterator *it = NULL;\n    enum ssh_known_hosts_e found = SSH_KNOWN_HOSTS_UNKNOWN;\n    int rc;\n\n    rc = ssh_known_hosts_read_entries(hosts_entry,\n                                      filename,\n                                      &entry_list);\n    if (rc != 0) {\n        ssh_list_free(entry_list);\n        return SSH_KNOWN_HOSTS_UNKNOWN;\n    }\n\n    it = ssh_list_get_iterator(entry_list);\n    if (it == NULL) {\n        ssh_list_free(entry_list);\n        return SSH_KNOWN_HOSTS_UNKNOWN;\n    }\n\n    for (;it != NULL; it = it->next) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        int cmp;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n\n        cmp = ssh_key_cmp(server_key, entry->publickey, SSH_KEY_CMP_PUBLIC);\n        if (cmp == 0) {\n            found = SSH_KNOWN_HOSTS_OK;\n            if (pentry != NULL) {\n                *pentry = entry;\n                ssh_list_remove(entry_list, it);\n            }\n            break;\n        }\n\n        if (ssh_key_type(server_key) == ssh_key_type(entry->publickey)) {\n            found = SSH_KNOWN_HOSTS_CHANGED;\n            continue;\n        }\n\n        if (found != SSH_KNOWN_HOSTS_CHANGED) {\n            found = SSH_KNOWN_HOSTS_OTHER;\n        }\n    }\n\n    for (it = ssh_list_get_iterator(entry_list);\n         it != NULL;\n         it = ssh_list_get_iterator(entry_list)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entry_list, it);\n    }\n    ssh_list_free(entry_list);\n\n    return found;\n}\n",
      "line_start": 1073,
      "line_end": 1136,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 8.0,
      "reason": "Checks server keys against known_hosts data read from external inputs (hosts_entry/filename), performs key comparisons and list/memory manipulation, has multiple input-dependent code paths and loops, and is security-critical (authentication). Parsing is delegated but this function still exercises structured, untrusted data \u2014 high-value fuzz target."
    },
    {
      "name": "ssh_packet_userauth_failure",
      "clean_name": "ssh_packet_userauth_failure",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @brief Handles a SSH_USERAUTH_FAILURE packet.\n *\n * This handles the complete or partial authentication failure.\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_failure) {\n    const char *current_method = ssh_auth_get_current_method(session);\n    char *auth_methods = NULL;\n    uint8_t partial = 0;\n    int rc;\n    (void) type;\n    (void) user;\n\n    rc = ssh_buffer_unpack(packet, \"sb\", &auth_methods, &partial);\n    if (rc != SSH_OK) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid SSH_MSG_USERAUTH_FAILURE message\");\n        session->auth.state = SSH_AUTH_STATE_ERROR;\n        goto end;\n    }\n\n    if (partial) {\n        session->auth.state = SSH_AUTH_STATE_PARTIAL;\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Partial success for '%s'. Authentication that can continue: %s\",\n                current_method,\n                auth_methods);\n    } else {\n        session->auth.state = SSH_AUTH_STATE_FAILED;\n        ssh_set_error(session, SSH_REQUEST_DENIED,\n                      \"Access denied for '%s'. Authentication that can continue: %s\",\n                      current_method,\n                      auth_methods);\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"%s\",\n                ssh_get_error(session));\n\n    }\n    session->auth.supported_methods = 0;\n    if (strstr(auth_methods, \"password\") != NULL) {\n        session->auth.supported_methods |= SSH_AUTH_METHOD_PASSWORD;\n    }\n    if (strstr(auth_methods, \"keyboard-interactive\") != NULL) {\n        session->auth.supported_methods |= SSH_AUTH_METHOD_INTERACTIVE;\n    }\n    if (strstr(auth_methods, \"publickey\") != NULL) {\n        session->auth.supported_methods |= SSH_AUTH_METHOD_PUBLICKEY;\n    }\n    if (strstr(auth_methods, \"hostbased\") != NULL) {\n        session->auth.supported_methods |= SSH_AUTH_METHOD_HOSTBASED;\n    }\n    if (strstr(auth_methods, \"gssapi-with-mic\") != NULL) {\n        session->auth.supported_methods |= SSH_AUTH_METHOD_GSSAPI_MIC;\n    }\n\nend:\n    session->auth.current_method = SSH_AUTH_METHOD_UNKNOWN;\n    SAFE_FREE(auth_methods);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 225,
      "line_end": 281,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses structured network input (SSH packet) and unpacks an untrusted string, then branches and performs multiple strstr checks to set auth flags. Good fuzz target because it exercises protocol parsing and multiple code paths, but it lacks direct unsafe memory manipulation, loops with input-dependent bounds, or heavy cryptographic/auth logic that would push it into critical (9-10) territory."
    },
    {
      "name": "ssh_packet_channel_open_conf",
      "clean_name": "ssh_packet_channel_open_conf",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @brief Handle a SSH_PACKET_CHANNEL_OPEN_CONFIRMATION packet.\n *\n * Constructs the channel object.\n */\nSSH_PACKET_CALLBACK(ssh_packet_channel_open_conf)\n{\n    uint32_t channelid = 0;\n    ssh_channel channel = NULL;\n    int rc;\n    (void)type;\n    (void)user;\n\n    SSH_LOG(SSH_LOG_PACKET, \"Received SSH2_MSG_CHANNEL_OPEN_CONFIRMATION\");\n\n    rc = ssh_buffer_unpack(packet, \"d\", &channelid);\n    if (rc != SSH_OK)\n        goto error;\n    channel = ssh_channel_from_local(session, channelid);\n    if (channel == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Unknown channel id %\" PRIu32,\n                      (uint32_t)channelid);\n        /* TODO: Set error marking in channel object */\n\n        return SSH_PACKET_USED;\n    }\n\n    rc = ssh_buffer_unpack(packet,\n                           \"ddd\",\n                           &channel->remote_channel,\n                           &channel->remote_window,\n                           &channel->remote_maxpacket);\n    if (rc != SSH_OK)\n        goto error;\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Received a CHANNEL_OPEN_CONFIRMATION for channel %\" PRIu32\n            \":%\" PRIu32,\n            channel->local_channel,\n            channel->remote_channel);\n\n    if (channel->state != SSH_CHANNEL_STATE_OPENING) {\n        SSH_LOG(SSH_LOG_RARE,\n                \"SSH2_MSG_CHANNEL_OPEN_CONFIRMATION received in incorrect \"\n                \"channel state %d\",\n                channel->state);\n        goto error;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Remote window : %\" PRIu32 \", maxpacket : %\" PRIu32,\n            channel->remote_window,\n            channel->remote_maxpacket);\n\n    channel->state = SSH_CHANNEL_STATE_OPEN;\n    channel->flags &= ~SSH_CHANNEL_FLAG_NOT_BOUND;\n\n    ssh_callbacks_execute_list(channel->callbacks,\n                               ssh_channel_callbacks,\n                               channel_open_response_function,\n                               channel->session,\n                               channel,\n                               true /* is_success */);\n\n    return SSH_PACKET_USED;\n\nerror:\n    ssh_set_error(session, SSH_FATAL, \"Invalid packet\");\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 168,
      "line_end": 235,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 104,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses structured external input (SSH packet) and unpacks multiple integer fields into channel state, performs validation (unknown channel id, state checks) and triggers callbacks. Security-relevant state transitions and multiple code paths make it a worthwhile fuzz target, though it lacks heavy memory manipulation or very high complexity."
    },
    {
      "name": "ssh_global_request",
      "clean_name": "ssh_global_request",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n */\nint ssh_global_request(ssh_session session,\n                       const char *request,\n                       ssh_buffer buffer,\n                       int reply)\n{\n  int rc;\n\n  switch (session->global_req_state) {\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n\n  rc = ssh_buffer_pack(session->out_buffer,\n                       \"bsb\",\n                       SSH2_MSG_GLOBAL_REQUEST,\n                       request,\n                       reply == 0 ? 0 : 1);\n  if (rc != SSH_OK){\n      ssh_set_error_oom(session);\n      rc = SSH_ERROR;\n      goto error;\n  }\n\n  if (buffer != NULL) {\n      rc = ssh_buffer_add_data(session->out_buffer,\n                           ssh_buffer_get(buffer),\n                           ssh_buffer_get_len(buffer));\n      if (rc < 0) {\n          ssh_set_error_oom(session);\n          rc = SSH_ERROR;\n          goto error;\n      }\n  }\n\n  session->global_req_state = SSH_CHANNEL_REQ_STATE_PENDING;\n  rc = ssh_packet_send(session);\n  if (rc == SSH_ERROR) {\n      return rc;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Sent a SSH_MSG_GLOBAL_REQUEST %s\", request);\n\n  if (reply == 0) {\n      session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n      return SSH_OK;\n  }\npending:\n  rc = ssh_handle_packets_termination(session,\n                                      SSH_TIMEOUT_DEFAULT,\n                                      ssh_global_request_termination,\n                                      session);\n\n  if(rc==SSH_ERROR || session->session_state == SSH_SESSION_STATE_ERROR){\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_ERROR;\n  }\n  switch(session->global_req_state){\n    case SSH_CHANNEL_REQ_STATE_ACCEPTED:\n      SSH_LOG(SSH_LOG_DEBUG, \"Global request %s success\",request);\n      rc=SSH_OK;\n      break;\n    case SSH_CHANNEL_REQ_STATE_DENIED:\n      SSH_LOG(SSH_LOG_PACKET,\n          \"Global request %s failed\", request);\n      ssh_set_error(session, SSH_REQUEST_DENIED,\n          \"Global request %s failed\", request);\n      rc=SSH_ERROR;\n      break;\n    case SSH_CHANNEL_REQ_STATE_ERROR:\n    case SSH_CHANNEL_REQ_STATE_NONE:\n      rc = SSH_ERROR;\n      break;\n    case SSH_CHANNEL_REQ_STATE_PENDING:\n      return SSH_AGAIN;\n  }\n  session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n  return rc;\nerror:\n  ssh_buffer_reinit(session->out_buffer);\n\n  return rc;\n}\n",
      "line_start": 2483,
      "line_end": 2569,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 109,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "High-value fuzz target: it serializes and copies caller-supplied data into session->out_buffer (buffer_add_data/pack), sends network packets, and contains a state-machine with multiple branches and blocking/pending logic. It manipulates untrusted buffers and has several code paths dependent on input/state, but it does not perform heavy parsing of complex formats or crypto operations, so it is high (not critical) priority for fuzzing."
    },
    {
      "name": "ssh_channel_read_timeout",
      "clean_name": "ssh_channel_read_timeout",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      timeout, SSH_ERROR on error.\n *\n * @warning This function may return less than count bytes of data, and won't\n *          block until count bytes have been read.\n */\nint ssh_channel_read_timeout(ssh_channel channel,\n                             void *dest,\n                             uint32_t count,\n                             int is_stderr,\n                             int timeout_ms)\n{\n    ssh_session session = NULL;\n    ssh_buffer stdbuf = NULL;\n    uint32_t len;\n    struct ssh_channel_read_termination_struct ctx;\n    int rc;\n\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n    if (dest == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return SSH_ERROR;\n    }\n\n    session = channel->session;\n    stdbuf = channel->stdout_buffer;\n\n    if (count == 0) {\n        return 0;\n    }\n\n    if (is_stderr) {\n        stdbuf = channel->stderr_buffer;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Read (%\" PRIu32 \") buffered : %\" PRIu32 \" bytes. Window: %\" PRIu32,\n            count,\n            ssh_buffer_get_len(stdbuf),\n            channel->local_window);\n\n    /* block reading until at least one byte has been read\n     * and ignore the trivial case count=0\n     */\n    ctx.channel = channel;\n    ctx.buffer = stdbuf;\n\n    if (timeout_ms < SSH_TIMEOUT_DEFAULT) {\n        timeout_ms = SSH_TIMEOUT_INFINITE;\n    }\n\n    rc = ssh_handle_packets_termination(session,\n                                        timeout_ms,\n                                        ssh_channel_read_termination,\n                                        &ctx);\n    if (rc == SSH_ERROR || rc == SSH_AGAIN) {\n        return rc;\n    }\n\n    /*\n     * If the channel is closed or in an error state, reading from it is an\n     * error\n     */\n    if (session->session_state == SSH_SESSION_STATE_ERROR) {\n        return SSH_ERROR;\n    }\n    /* If the server closed the channel properly, there is nothing to do */\n    if (channel->remote_eof && ssh_buffer_get_len(stdbuf) == 0) {\n        return 0;\n    }\n    if (channel->state == SSH_CHANNEL_STATE_CLOSED) {\n        ssh_set_error(session, SSH_FATAL, \"Remote channel is closed.\");\n        return SSH_ERROR;\n    }\n    len = ssh_buffer_get_len(stdbuf);\n    /* Read count bytes if len is greater, everything otherwise */\n    len = (len > count ? count : len);\n    memcpy(dest, ssh_buffer_get(stdbuf), len);\n    ssh_buffer_pass_bytes(stdbuf, len);\n    if (channel->counter != NULL) {\n        channel->counter->in_bytes += len;\n    }\n    /* Try completing the delayed_close */\n    if (channel->delayed_close && !ssh_channel_has_unread_data(channel)) {\n        channel->state = SSH_CHANNEL_STATE_CLOSED;\n    }\n\n    rc = grow_window(session, channel);\n    if (rc == SSH_ERROR) {\n        return -1;\n    }\n\n    return len;\n}\n",
      "line_start": 3121,
      "line_end": 3211,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 110,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "This function is a good fuzz target: it interacts with network/session state, calls packet handling, and copies externally-originated data (memcpy) into a caller-provided buffer while making several state/timeout branches. It has multiple code paths and can surface memory/logic bugs, but it does not itself parse complex file formats or perform cryptographic operations, so it is high priority rather than critical."
    },
    {
      "name": "ssh_select",
      "clean_name": "ssh_select",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": " *          during the processing of this function, you cannot call libssh\n *          functions on sessions that are busy with ssh_select().\n *\n * @see select(2)\n */\nint ssh_select(ssh_channel *channels, ssh_channel *outchannels, socket_t maxfd,\n               fd_set *readfds, struct timeval *timeout)\n{\n    fd_set origfds;\n    socket_t fd;\n    size_t i, j;\n    int rc;\n    int base_tm, tm;\n    struct ssh_timestamp ts;\n    ssh_event event = ssh_event_new();\n    int firstround = 1;\n\n    base_tm = tm = (timeout->tv_sec * 1000) + (timeout->tv_usec / 1000);\n    for (i = 0 ; channels[i] != NULL; ++i) {\n        ssh_event_add_session(event, channels[i]->session);\n    }\n\n    ZERO_STRUCT(origfds);\n    FD_ZERO(&origfds);\n    for (fd = 0; fd < maxfd ; fd++) {\n        if (FD_ISSET(fd, readfds)) {\n            ssh_event_add_fd(event, fd, POLLIN, ssh_select_cb, readfds);\n            FD_SET(fd, &origfds);\n        }\n    }\n    outchannels[0] = NULL;\n    FD_ZERO(readfds);\n    ssh_timestamp_init(&ts);\n    do {\n        /* Poll every channel */\n        j = 0;\n        for (i = 0; channels[i]; i++) {\n            rc = ssh_channel_poll(channels[i], 0);\n            if (rc != 0) {\n                outchannels[j] = channels[i];\n                j++;\n            } else {\n                rc = ssh_channel_poll(channels[i], 1);\n                if (rc != 0) {\n                    outchannels[j] = channels[i];\n                    j++;\n                }\n            }\n        }\n\n        outchannels[j] = NULL;\n        if (j != 0) {\n            break;\n        }\n\n        /* watch if a user socket was triggered */\n        for (fd = 0; fd < maxfd; fd++) {\n            if (FD_ISSET(fd, readfds)) {\n                goto out;\n            }\n        }\n\n        /* If the timeout is elapsed, we should go out */\n        if (!firstround && ssh_timeout_elapsed(&ts, base_tm)) {\n            goto out;\n        }\n\n        /* since there's nothing, let's fire the polling */\n        rc = ssh_event_dopoll(event,tm);\n        if (rc == SSH_ERROR) {\n            goto out;\n        }\n\n        tm = ssh_timeout_update(&ts, base_tm);\n        firstround = 0;\n    } while (1);\nout:\n    for (fd = 0; fd < maxfd; fd++) {\n        if (FD_ISSET(fd, &origfds)) {\n            ssh_event_remove_fd(event, fd);\n        }\n    }\n    ssh_event_free(event);\n    return SSH_OK;\n}\n",
      "line_start": 334,
      "line_end": 414,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 115,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Orchestrates event/FD handling with loops bounded by external inputs (channels[] terminated by NULL, maxfd and readfds) and timeout logic; calls ssh_channel_poll and ssh_event_dopoll (downstream code that processes untrusted network data). Multiple code paths and input-dependent looping make it a good high-priority fuzz target for exercising event and session handling, but it does not itself parse complex file/protocol formats or perform direct memory operations on raw untrusted buffers, so it is not top-tier critical."
    },
    {
      "name": "connector.c:ssh_connector_channel_data_cb",
      "clean_name": "ssh_connector_channel_data_cb",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " *\n * @param[in] userdata The ssh connector\n *\n * @returns Amount of data bytes consumed\n */\nstatic int ssh_connector_channel_data_cb(ssh_session session,\n                                         ssh_channel channel,\n                                         void *data,\n                                         uint32_t len,\n                                         int is_stderr,\n                                         void *userdata)\n{\n    ssh_connector connector = userdata;\n    int w;\n    uint32_t window;\n\n    (void) session;\n    (void) channel;\n    (void) is_stderr;\n\n    SSH_LOG(SSH_LOG_TRACE,\"connector data on channel\");\n\n    if (is_stderr && !(connector->in_flags & SSH_CONNECTOR_STDERR)) {\n        /* ignore stderr */\n        return 0;\n    } else if (!is_stderr && !(connector->in_flags & SSH_CONNECTOR_STDOUT)) {\n        /* ignore stdout */\n        return 0;\n    } else if (len == 0) {\n        /* ignore empty data */\n        return 0;\n    }\n\n    if (connector->out_wontblock) {\n        if (connector->out_channel != NULL) {\n            uint32_t window_len;\n\n            window = ssh_channel_window_size(connector->out_channel);\n            window_len = MIN(window, len);\n\n            /* Route the data to the right exception channel */\n            if (is_stderr && (connector->out_flags & SSH_CONNECTOR_STDERR)) {\n                w = ssh_channel_write_stderr(connector->out_channel,\n                                             data,\n                                             window_len);\n            } else if (!is_stderr &&\n                       (connector->out_flags & SSH_CONNECTOR_STDOUT)) {\n                w = ssh_channel_write(connector->out_channel,\n                                      data,\n                                      window_len);\n            } else if (connector->out_flags & SSH_CONNECTOR_STDOUT) {\n                w = ssh_channel_write(connector->out_channel,\n                                      data,\n                                      window_len);\n            } else {\n                w = ssh_channel_write_stderr(connector->out_channel,\n                                             data,\n                                             window_len);\n            }\n            if (w == SSH_ERROR) {\n                ssh_connector_except_channel(connector, connector->out_channel);\n            }\n        } else if (connector->out_fd != SSH_INVALID_SOCKET) {\n            ssize_t ws = ssh_connector_fd_write(connector, data, len);\n            if (ws < 0) {\n                ssh_connector_except(connector, connector->out_fd);\n            }\n            w = (int)ws;\n        } else {\n            ssh_set_error(session, SSH_FATAL, \"output socket or channel closed\");\n            return SSH_ERROR;\n        }\n\n        connector->out_wontblock = 0;\n        connector->in_available = 0;\n        if ((unsigned int)w < len) {\n            connector->in_available = 1;\n        }\n        ssh_connector_reset_pollevents(connector);\n\n        return w;\n    } else {\n        connector->in_available = 1;\n\n        return 0;\n    }\n}\n",
      "line_start": 421,
      "line_end": 503,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 97,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Callback receives untrusted channel data and routes it to channels or file descriptors, uses input-dependent length/window calculations and multiple branches (out_channel vs out_fd, stderr/stdout), and performs type conversions and error handling. It lacks complex parsing/crypto but has enough input-dependent logic and memory/IO interaction to be a high-value fuzz target."
    },
    {
      "name": "ssh_get_fingerprint_hash",
      "clean_name": "ssh_get_fingerprint_hash",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": " * @return Returns the allocated fingerprint hash or NULL on error. The caller\n *         needs to free the memory using ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_get_fingerprint_hash(enum ssh_publickey_hash_type type,\n                               unsigned char *hash,\n                               size_t len)\n{\n    const char *prefix = \"UNKNOWN\";\n    char *fingerprint = NULL;\n    char *str = NULL;\n    size_t str_len;\n    int rc;\n\n    switch (type) {\n    case SSH_PUBLICKEY_HASH_SHA1:\n    case SSH_PUBLICKEY_HASH_SHA256:\n        fingerprint = ssh_get_b64_unpadded(hash, len);\n        break;\n    case SSH_PUBLICKEY_HASH_MD5:\n        fingerprint = ssh_get_hexa(hash, len);\n        break;\n    }\n    if (fingerprint == NULL) {\n        return NULL;\n    }\n\n    switch (type) {\n    case SSH_PUBLICKEY_HASH_MD5:\n        prefix = \"MD5\";\n        break;\n    case SSH_PUBLICKEY_HASH_SHA1:\n        prefix = \"SHA1\";\n        break;\n    case SSH_PUBLICKEY_HASH_SHA256:\n        prefix = \"SHA256\";\n        break;\n    }\n\n    str_len = strlen(prefix);\n    if (str_len + 1 + strlen(fingerprint) + 1 < str_len) {\n        SAFE_FREE(fingerprint);\n        return NULL;\n    }\n    str_len += 1 + strlen(fingerprint) + 1;\n\n    str = malloc(str_len);\n    if (str == NULL) {\n        SAFE_FREE(fingerprint);\n        return NULL;\n    }\n    rc = snprintf(str, str_len, \"%s:%s\", prefix, fingerprint);\n    SAFE_FREE(fingerprint);\n    if (rc < 0 || rc < (int)(str_len - 1)) {\n        SAFE_FREE(str);\n    }\n\n    return str;\n}\n",
      "line_start": 736,
      "line_end": 791,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 81,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Accepts untrusted hash bytes and length, calls encoding helpers (base64/hexa) that perform memory/string operations, and builds/allocates a combined fingerprint string. Multiple code paths based on hash type and non-trivial allocation/size checks make it a good fuzz target (potential boundary/formatting bugs \u2014 e.g. snprintf/length handling). Not a full parser of a complex format, so high (not critical) priority."
    },
    {
      "name": "ssh_client_select_hostkeys",
      "clean_name": "ssh_client_select_hostkeys",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * as some hostkey mechanisms may be present in known_hosts files.\n *\n * @returns a cstring containing a comma-separated list of hostkey methods.\n *          NULL if no method matches\n */\nchar *ssh_client_select_hostkeys(ssh_session session)\n{\n    const char *wanted = NULL;\n    char *wanted_without_certs = NULL;\n    char *known_hosts_algorithms = NULL;\n    char *known_hosts_ordered = NULL;\n    char *new_hostkeys = NULL;\n    char *fips_hostkeys = NULL;\n\n    wanted = session->opts.wanted_methods[SSH_HOSTKEYS];\n    if (wanted == NULL) {\n        if (ssh_fips_mode()) {\n            wanted = ssh_kex_get_fips_methods(SSH_HOSTKEYS);\n        } else {\n            wanted = ssh_kex_get_default_methods(SSH_HOSTKEYS);\n        }\n    }\n\n    /* This removes the certificate types, unsupported for now */\n    wanted_without_certs = ssh_find_all_matching(HOSTKEYS, wanted);\n    if (wanted_without_certs == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"List of allowed host key algorithms is empty or contains only \"\n                \"unsupported algorithms\");\n        return NULL;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Order of wanted host keys: \\\"%s\\\"\",\n            wanted_without_certs);\n\n    known_hosts_algorithms = ssh_known_hosts_get_algorithms_names(session);\n    if (known_hosts_algorithms == NULL) {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"No key found in known_hosts; \"\n                \"changing host key method to \\\"%s\\\"\",\n                wanted_without_certs);\n\n        return wanted_without_certs;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Algorithms found in known_hosts files: \\\"%s\\\"\",\n            known_hosts_algorithms);\n\n    /* Filter and order the keys from known_hosts according to wanted list */\n    known_hosts_ordered = ssh_find_all_matching(known_hosts_algorithms,\n                                                wanted_without_certs);\n    SAFE_FREE(known_hosts_algorithms);\n    if (known_hosts_ordered == NULL) {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"No key found in known_hosts is allowed; \"\n                \"changing host key method to \\\"%s\\\"\",\n                wanted_without_certs);\n\n        return wanted_without_certs;\n    }\n\n    /* Append the other supported keys after the preferred ones\n     * This function tolerates NULL pointers in parameters */\n    new_hostkeys = ssh_append_without_duplicates(known_hosts_ordered,\n                                                 wanted_without_certs);\n    SAFE_FREE(known_hosts_ordered);\n    SAFE_FREE(wanted_without_certs);\n    if (new_hostkeys == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    if (ssh_fips_mode()) {\n        /* Filter out algorithms not allowed in FIPS mode */\n        fips_hostkeys = ssh_keep_fips_algos(SSH_HOSTKEYS, new_hostkeys);\n        SAFE_FREE(new_hostkeys);\n        if (fips_hostkeys == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"None of the wanted host keys or keys in known_hosts files \"\n                    \"is allowed in FIPS mode.\");\n            return NULL;\n        }\n        new_hostkeys = fips_hostkeys;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Changing host key method to \\\"%s\\\"\",\n            new_hostkeys);\n\n    return new_hostkeys;\n}\n",
      "line_start": 685,
      "line_end": 773,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 119,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Orchestrates selection/filtering of hostkey algorithms using external inputs (session options and known_hosts contents), with multiple code paths (FIPS mode, missing known_hosts, filtering/ordering) and string operations. The heavy parsing and memory work is delegated to helper functions, so it is a useful but not top-tier fuzz target (moderate complexity and multiple branches)."
    },
    {
      "name": "ssh_kex_append_extensions",
      "clean_name": "ssh_kex_append_extensions",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n\n    return SSH_OK;\n}\n\nint ssh_kex_append_extensions(ssh_session session, struct ssh_kex_struct *pkex)\n{\n    char *kex = NULL;\n    char *kex_tmp = NULL;\n    size_t kex_len, len;\n\n    /* Here we append ext-info-c and kex-strict-c-v00@openssh.com for client\n     * and kex-strict-s-v00@openssh.com for server to the list of kex algorithms\n     */\n    kex = pkex->methods[SSH_KEX];\n    len = strlen(kex);\n    if (session->server) {\n        /* Comma, nul byte */\n        kex_len = len + 1 + strlen(KEX_STRICT_SERVER) + 1;\n    } else {\n        /* Comma, comma, nul byte */\n        kex_len = len + 1 + strlen(KEX_EXTENSION_CLIENT) + 1 +\n                  strlen(KEX_STRICT_CLIENT) + 1;\n    }\n    if (kex_len >= MAX_PACKET_LEN) {\n        /* Overflow */\n        return SSH_ERROR;\n    }\n    kex_tmp = realloc(kex, kex_len);\n    if (kex_tmp == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    if (session->server){\n        snprintf(kex_tmp + len, kex_len - len, \",%s\", KEX_STRICT_SERVER);\n    } else {\n        snprintf(kex_tmp + len,\n                 kex_len - len,\n                 \",%s,%s\",\n                 KEX_EXTENSION_CLIENT,\n                 KEX_STRICT_CLIENT);\n    }\n    pkex->methods[SSH_KEX] = kex_tmp;\n    return SSH_OK;\n}\n",
      "line_start": 840,
      "line_end": 880,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 49,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Performs memory operations (realloc/snprintf) on what is likely untrusted kex algorithm strings and has branching by role \u2014 this makes it a good fuzz target because missing/null-checks or integer wrap in length math can cause crashes or corruption. Complexity is low (no heavy parsing or loops, not cryptographic), so it is high priority but not critical."
    },
    {
      "name": "ssh_known_hosts_get_algorithms",
      "clean_name": "ssh_known_hosts_get_algorithms",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *\n * @param[in]  session  The ssh session to use.\n *\n * @return A list of supported key types, NULL on error.\n */\nstruct ssh_list *ssh_known_hosts_get_algorithms(ssh_session session)\n{\n    struct ssh_list *entry_list = NULL;\n    struct ssh_iterator *it = NULL;\n    char *host_port = NULL;\n    size_t count;\n    struct ssh_list *list = NULL;\n    int list_error = 0;\n    int rc;\n\n    if (session->opts.knownhosts == NULL ||\n        session->opts.global_knownhosts == NULL) {\n        if (ssh_options_apply(session) < 0) {\n            ssh_set_error(session,\n                          SSH_REQUEST_DENIED,\n                          \"Can't find a known_hosts file\");\n\n            return NULL;\n        }\n    }\n\n    host_port = ssh_session_get_host_port(session);\n    if (host_port == NULL) {\n        return NULL;\n    }\n\n    list = ssh_list_new();\n    if (list == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(host_port);\n        return NULL;\n    }\n\n    rc = ssh_known_hosts_read_entries(host_port,\n                                      session->opts.knownhosts,\n                                      &entry_list);\n    if (rc != 0) {\n        ssh_list_free(entry_list);\n        ssh_list_free(list);\n        return NULL;\n    }\n\n    rc = ssh_known_hosts_read_entries(host_port,\n                                      session->opts.global_knownhosts,\n                                      &entry_list);\n    SAFE_FREE(host_port);\n    if (rc != 0) {\n        ssh_list_free(entry_list);\n        ssh_list_free(list);\n        return NULL;\n    }\n\n    if (entry_list == NULL) {\n        ssh_list_free(list);\n        return NULL;\n    }\n\n    count = ssh_list_count(entry_list);\n    if (count == 0) {\n        ssh_list_free(list);\n        ssh_list_free(entry_list);\n        return NULL;\n    }\n\n    for (it = ssh_list_get_iterator(entry_list);\n         it != NULL;\n         it = ssh_list_get_iterator(entry_list)) {\n        struct ssh_iterator *it2 = NULL;\n        struct ssh_knownhosts_entry *entry = NULL;\n        const char *algo = NULL;\n        bool present = false;\n\n        entry = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n        algo = entry->publickey->type_c;\n\n        /* Check for duplicates */\n        for (it2 = ssh_list_get_iterator(list);\n             it2 != NULL;\n             it2 = it2->next) {\n            char *alg2 = ssh_iterator_value(char *, it2);\n            int cmp = strcmp(alg2, algo);\n            if (cmp == 0) {\n                present = true;\n                break;\n            }\n        }\n\n        /* Add to the new list only if it is unique */\n        if (!present) {\n            rc = ssh_list_append(list, algo);\n            if (rc != SSH_OK) {\n               list_error = 1;\n            }\n        }\n\n        ssh_knownhosts_entry_free(entry);\n        ssh_list_remove(entry_list, it);\n    }\n    ssh_list_free(entry_list);\n    if (list_error) {\n        goto error;\n    }\n\n    return list;\nerror:\n    ssh_list_free(list);\n    return NULL;\n}\n",
      "line_start": 357,
      "line_end": 465,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 132,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "High-value fuzz target: it depends on external known_hosts files (via ssh_known_hosts_read_entries), iterates input-dependent lists, performs parsing/validation indirectly, and has multiple branches (duplicate checks, error paths). Not critical (no direct crypto or unsafe raw memory ops in this function), but exercises structured input handling and loop logic so warrants high priority fuzzing."
    },
    {
      "name": "ssh_message_channel_request_open_reply_accept_channel",
      "clean_name": "ssh_message_channel_request_open_reply_accept_channel",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param[in]  chan     The channel the request is made on.\n *\n * @returns             SSH_OK on success, SSH_ERROR if an error occurred.\n */\nint ssh_message_channel_request_open_reply_accept_channel(ssh_message msg,\n                                                          ssh_channel chan)\n{\n    ssh_session session = NULL;\n    int rc;\n\n    if (msg == NULL) {\n        return SSH_ERROR;\n    }\n\n    session = msg->session;\n\n    chan->local_channel = ssh_channel_new_id(session);\n    chan->local_maxpacket = 35000;\n    chan->local_window = 32000;\n    chan->remote_channel = msg->channel_request_open.sender;\n    chan->remote_maxpacket = msg->channel_request_open.packet_size;\n    chan->remote_window = msg->channel_request_open.window;\n    chan->state = SSH_CHANNEL_STATE_OPEN;\n    chan->flags &= ~SSH_CHANNEL_FLAG_NOT_BOUND;\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bdddd\",\n                         SSH2_MSG_CHANNEL_OPEN_CONFIRMATION,\n                         chan->remote_channel,\n                         chan->local_channel,\n                         chan->local_window,\n                         chan->local_maxpacket);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Accepting a channel request_open for chan %\" PRIu32,\n            chan->remote_channel);\n\n    rc = ssh_packet_send(session);\n\n    return rc;\n}\n",
      "line_start": 1428,
      "line_end": 1469,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 45,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Handles structured network input (ssh_message) and copies untrusted fields (remote channel id, packet_size, window) into channel state and an outgoing packet. It is protocol-handling code (security-relevant) and processes external data, but has low internal branching and no complex parsing or heavy memory-manipulation itself, so it is high priority but not top-critical."
    },
    {
      "name": "ssh_is_ipaddr",
      "clean_name": "ssh_is_ipaddr",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n\n    return 0;\n}\n\nint ssh_is_ipaddr(const char *str)\n{\n    int rc = -1;\n    char *s = strdup(str);\n\n    if (s == NULL) {\n        return -1;\n    }\n    if (strchr(s, ':')) {\n        struct in6_addr dest6;\n        char *network_interface = strchr(s, '%');\n\n        /* link-local (IP:v6:addr%ifname). */\n        if (network_interface != NULL) {\n            rc = if_nametoindex(network_interface + 1);\n            if (rc == 0) {\n                free(s);\n                return 0;\n            }\n            *network_interface = '\\0';\n        }\n        rc = inet_pton(AF_INET6, s, &dest6);\n        if (rc > 0) {\n            free(s);\n            return 1;\n        }\n    }\n\n    free(s);\n    return ssh_is_ipaddr_v4(str);\n}\n",
      "line_start": 396,
      "line_end": 427,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses external input as IP addresses (IPv6 including %zone handling), performs memory operations on untrusted data (strdup/strchr/modify), and calls inet_pton/if_nametoindex. Multiple code paths depend on input, so it is a valuable high-priority fuzz target, but it has relatively low cyclomatic complexity and no input-dependent loops so it is not top-critical."
    },
    {
      "name": "ssh_path_expand_tilde",
      "clean_name": "ssh_path_expand_tilde",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @return              The expanded directory, NULL on error. The caller\n *                      needs to free the memory using ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_path_expand_tilde(const char *d)\n{\n    char *h = NULL, *r = NULL;\n    const char *p = NULL;\n    size_t ld;\n    size_t lh = 0;\n\n    if (d[0] != '~') {\n        return strdup(d);\n    }\n    d++;\n\n    /* handle ~user/path */\n    p = strchr(d, '/');\n    if (p != NULL && p > d) {\n#ifdef _WIN32\n        return strdup(d);\n#else\n        struct passwd *pw = NULL;\n        size_t s = p - d;\n        char u[128];\n\n        if (s >= sizeof(u)) {\n            return NULL;\n        }\n        memcpy(u, d, s);\n        u[s] = '\\0';\n        pw = getpwnam(u);\n        if (pw == NULL) {\n            return NULL;\n        }\n        ld = strlen(p);\n        h = strdup(pw->pw_dir);\n#endif\n    } else {\n        ld = strlen(d);\n        p = (char *) d;\n        h = ssh_get_user_home_dir();\n    }\n    if (h == NULL) {\n        return NULL;\n    }\n    lh = strlen(h);\n\n    r = malloc(ld + lh + 1);\n    if (r == NULL) {\n        SAFE_FREE(h);\n        return NULL;\n    }\n\n    if (lh > 0) {\n        memcpy(r, h, lh);\n    }\n    SAFE_FREE(h);\n    memcpy(r + lh, p, ld + 1);\n\n    return r;\n}\n",
      "line_start": 1144,
      "line_end": 1202,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Input-controlled path expansion with branching (~user/path vs ~), multiple code paths, and several memory operations on untrusted data (strdup, memcpy, malloc). Bounds checks exist for the small username buffer, but the function still performs buffer allocation and raw memcopies and calls getpwnam/ssh_get_user_home_dir, making it a good high-priority fuzz target (not critical because it\u2019s relatively simple and lacks complex parsing or crypto)."
    },
    {
      "name": "ssh_analyze_banner",
      "clean_name": "ssh_analyze_banner",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @return 0 on success, < 0 on error.\n *\n * @see ssh_get_issue_banner()\n */\nint ssh_analyze_banner(ssh_session session, int server)\n{\n    const char *banner = NULL;\n    const char *openssh = NULL;\n\n    if (server) {\n        banner = session->clientbanner;\n    } else {\n        banner = session->serverbanner;\n    }\n\n    if (banner == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"Invalid banner\");\n        return -1;\n    }\n\n    /*\n     * Typical banners e.g. are:\n     *\n     * SSH-1.5-openSSH_5.4\n     * SSH-1.99-openSSH_3.0\n     *\n     * SSH-2.0-something\n     * 012345678901234567890\n     */\n    if (strlen(banner) < 6 ||\n        strncmp(banner, \"SSH-\", 4) != 0) {\n          ssh_set_error(session, SSH_FATAL, \"Protocol mismatch: %s\", banner);\n          return -1;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Analyzing banner: %s\", banner);\n\n    switch (banner[4]) {\n        case '2':\n            break;\n        case '1':\n            if (strlen(banner) > 6) {\n                if (banner[6] == '9') {\n                    break;\n                }\n            }\n            FALL_THROUGH;\n        default:\n            ssh_set_error(session, SSH_FATAL, \"Protocol mismatch: %s\", banner);\n            return -1;\n    }\n\n    /* Make a best-effort to extract OpenSSH version numbers. */\n    openssh = strstr(banner, \"OpenSSH\");\n    if (openssh != NULL) {\n        char *tmp = NULL;\n        unsigned long int major = 0UL;\n        unsigned long int minor = 0UL;\n        int off = 0;\n\n        /*\n         * The banner is typical:\n         * OpenSSH_5.4\n         * 012345678901234567890\n         */\n        if (strlen(openssh) > 9) {\n            errno = 0;\n            major = strtoul(openssh + 8, &tmp, 10);\n            if ((tmp == (openssh + 8)) ||\n                ((errno == ERANGE) && (major == ULONG_MAX)) ||\n                ((errno != 0) && (major == 0)) ||\n                ((major < 1) || (major > 100))) {\n                /* invalid major */\n                errno = 0;\n                goto done;\n            }\n\n            errno = 0;\n            off = major >= 10 ? 11 : 10;\n            minor = strtoul(openssh + off, &tmp, 10);\n            if ((tmp == (openssh + off)) ||\n                ((errno == ERANGE) && (major == ULONG_MAX)) ||\n                ((errno != 0) && (major == 0)) ||\n                (minor > 100)) {\n                /* invalid minor */\n                errno = 0;\n                goto done;\n            }\n\n            session->openssh = SSH_VERSION_INT(((int) major), ((int) minor), 0);\n\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"We are talking to an OpenSSH %s version: %lu.%lu (%x)\",\n                    server ? \"client\" : \"server\",\n                    major, minor, session->openssh);\n        }\n    }\n\ndone:\n    return 0;\n}\n",
      "line_start": 1374,
      "line_end": 1471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 136,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses untrusted SSH banners and branches on protocol/version, uses strstr/strtoul (type conversion) and has multiple code paths dependent on input. Limited memory-write/risk (no raw memcpy/buffer writes), moderate complexity \u2014 good high-priority fuzz target but not critical."
    },
    {
      "name": "options.c:ssh_bind_options_expand_escape",
      "clean_name": "ssh_bind_options_expand_escape",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "    }\n\n    return 0;\n}\n\nstatic char *ssh_bind_options_expand_escape(ssh_bind sshbind, const char *s)\n{\n    char *buf = NULL;\n    char *r = NULL;\n    char *x = NULL;\n    const char *p = NULL;\n    size_t i, l;\n\n    r = ssh_path_expand_tilde(s);\n    if (r == NULL) {\n        ssh_set_error_oom(sshbind);\n        return NULL;\n    }\n\n    if (strlen(r) > MAX_BUF_SIZE) {\n        ssh_set_error(sshbind, SSH_FATAL, \"string to expand too long\");\n        free(r);\n        return NULL;\n    }\n\n    buf = malloc(MAX_BUF_SIZE);\n    if (buf == NULL) {\n        ssh_set_error_oom(sshbind);\n        free(r);\n        return NULL;\n    }\n\n    p = r;\n    buf[0] = '\\0';\n\n    for (i = 0; *p != '\\0'; p++) {\n        if (*p != '%') {\n            buf[i] = *p;\n            i++;\n            if (i >= MAX_BUF_SIZE) {\n                free(buf);\n                free(r);\n                return NULL;\n            }\n            buf[i] = '\\0';\n            continue;\n        }\n\n        p++;\n        if (*p == '\\0') {\n            break;\n        }\n\n        switch (*p) {\n            case 'd':\n                x = strdup(sshbind->config_dir);\n                break;\n            default:\n                ssh_set_error(sshbind, SSH_FATAL,\n                        \"Wrong escape sequence detected\");\n                free(buf);\n                free(r);\n                return NULL;\n        }\n\n        if (x == NULL) {\n            ssh_set_error_oom(sshbind);\n            free(buf);\n            free(r);\n            return NULL;\n        }\n\n        i += strlen(x);\n        if (i >= MAX_BUF_SIZE) {\n            ssh_set_error(sshbind, SSH_FATAL,\n                    \"String too long\");\n            free(buf);\n            free(x);\n            free(r);\n            return NULL;\n        }\n        l = strlen(buf);\n        strncpy(buf + l, x, MAX_BUF_SIZE - l - 1);\n        buf[i] = '\\0';\n        SAFE_FREE(x);\n    }\n\n    free(r);\n\n    /* strip the unused space by realloc */\n    x = realloc(buf, strlen(buf) + 1);\n    if (x == NULL) {\n        ssh_set_error_oom(sshbind);\n        free(buf);\n    }\n    return x;\n}\n",
      "line_start": 2619,
      "line_end": 2711,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 114,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Consumes external input and performs multiple string/buffer operations (allocation, memcpy/strncpy, realloc) with input-dependent loop bounds and branching (escape handling). Not a complex parser or crypto code but has enough input-dependent memory manipulation and multiple paths to be a high-priority fuzz target."
    },
    {
      "name": "ssh_packet_process",
      "clean_name": "ssh_packet_process",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "\n/** @internal\n * @brief dispatch the call of packet handlers callbacks for a received packet\n * @param type type of packet\n */\nvoid ssh_packet_process(ssh_session session, uint8_t type)\n{\n    struct ssh_iterator *i = NULL;\n    int rc = SSH_PACKET_NOT_USED;\n    ssh_packet_callbacks cb;\n\n    SSH_LOG(SSH_LOG_PACKET, \"Dispatching handler for packet type %d\", type);\n    if (session->packet_callbacks == NULL) {\n        SSH_LOG(SSH_LOG_RARE, \"Packet callback is not initialized !\");\n        return;\n    }\n\n    i = ssh_list_get_iterator(session->packet_callbacks);\n    while (i != NULL) {\n        cb = ssh_iterator_value(ssh_packet_callbacks, i);\n        i = i->next;\n\n        if (!cb) {\n            continue;\n        }\n\n        if (cb->start > type) {\n            continue;\n        }\n\n        if (cb->start + cb->n_callbacks <= type) {\n            continue;\n        }\n\n        if (cb->callbacks[type - cb->start] == NULL) {\n            continue;\n        }\n\n        rc = cb->callbacks[type - cb->start](session, type, session->in_buffer,\n                                             cb->user);\n        if (rc == SSH_PACKET_USED) {\n            break;\n        }\n    }\n\n    if (rc == SSH_PACKET_NOT_USED) {\n        SSH_LOG(SSH_LOG_RARE, \"Couldn't do anything with packet type %d\", type);\n        rc = ssh_packet_send_unimplemented(session, session->recv_seq - 1);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_RARE, \"Failed to send unimplemented: %s\",\n                    ssh_get_error(session));\n        }\n        if (session->current_crypto == NULL) {\n            session->flags |= SSH_SESSION_FLAG_KEX_TAINTED;\n        }\n    }\n}\n",
      "line_start": 1604,
      "line_end": 1656,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 74,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Dispatcher invokes user-controlled packet handlers on session->in_buffer (untrusted data) with multiple branches and a loop that selects callbacks based on the external packet type. It doesn't itself parse complex formats or perform memory ops, but it exercises many code paths and hands off untrusted data to potentially vulnerable callbacks, making it a high-value fuzzing entry point."
    },
    {
      "name": "ssh_packet_disconnect_callback",
      "clean_name": "ssh_packet_disconnect_callback",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "/**\n * @internal\n *\n * @brief Handle a SSH_DISCONNECT packet.\n */\nSSH_PACKET_CALLBACK(ssh_packet_disconnect_callback)\n{\n    int rc;\n    uint32_t code = 0;\n    char *error = NULL;\n    ssh_string error_s = NULL;\n\n    (void)user;\n    (void)type;\n\n    rc = ssh_buffer_get_u32(packet, &code);\n    if (rc != 0) {\n        code = ntohl(code);\n    }\n\n    error_s = ssh_buffer_get_ssh_string(packet);\n    if (error_s != NULL) {\n        error = ssh_string_to_char(error_s);\n        SSH_STRING_FREE(error_s);\n    }\n\n    if (error != NULL) {\n        session->peer_discon_msg = strdup(error);\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received SSH_MSG_DISCONNECT %\" PRIu32 \":%s\",\n            code,\n            error != NULL ? error : \"no error\");\n    ssh_set_error(session,\n                  SSH_FATAL,\n                  \"Received SSH_MSG_DISCONNECT: %\" PRIu32 \":%s\",\n                  code,\n                  error != NULL ? error : \"no error\");\n    SAFE_FREE(error);\n\n    ssh_session_socket_close(session);\n    /* correctly handle disconnect during authorization */\n    session->auth.state = SSH_AUTH_STATE_FAILED;\n\n    /* TODO: handle a graceful disconnect */\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 47,
      "line_end": 90,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses structured network input (SSH packet) and extracts a uint32 and an SSH string from untrusted data, then performs memory operations (ssh_string_to_char, strdup, frees). While the function logic is simple with few branches, it exercises parsing and allocation paths that can trigger memory issues in downstream helpers (string parsing/conversion/alloc/free), so it is a high-priority fuzz target."
    },
    {
      "name": "ssh_packet_debug_callback",
      "clean_name": "ssh_packet_debug_callback",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "/**\n * @internal\n *\n * @brief Handle a SSH_DEBUG packet.\n */\nSSH_PACKET_CALLBACK(ssh_packet_debug_callback)\n{\n    uint8_t always_display = -1;\n    char *message = NULL;\n    int rc;\n\n    (void)session; /* unused */\n    (void)type;\n    (void)user;\n\n    rc = ssh_buffer_unpack(packet, \"bs\", &always_display, &message);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_PACKET, \"Error reading debug message\");\n        return SSH_PACKET_USED;\n    }\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Received SSH_MSG_DEBUG packet with message %s%s\",\n            message,\n            always_display != 0 ? \" (always display)\" : \"\");\n    SAFE_FREE(message);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 113,
      "line_end": 136,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 44,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses structured network input (SSH packet) and unpacks a byte and a string from untrusted data, allocating/freeing memory. Logic is simple with low branching, so it's a useful high-priority fuzz target (can exercise parser and allocator) but not complex enough for critical priority."
    },
    {
      "name": "ssh_key_cmp",
      "clean_name": "ssh_key_cmp",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] what      What part or type of the key do you want to compare.\n *\n * @return              0 if equal, 1 if not.\n */\nint ssh_key_cmp(const ssh_key k1,\n                const ssh_key k2,\n                enum ssh_keycmp_e what)\n{\n    if (k1 == NULL || k2 == NULL) {\n        return 1;\n    }\n\n    if (ssh_key_type_plain(k1->type) != ssh_key_type_plain(k2->type)) {\n        SSH_LOG(SSH_LOG_DEBUG, \"key types don't match!\");\n        return 1;\n    }\n\n    if (what == SSH_KEY_CMP_PRIVATE) {\n        if (!ssh_key_is_private(k1) ||\n            !ssh_key_is_private(k2)) {\n            return 1;\n        }\n    }\n\n    if (is_sk_key_type(k1->type)) {\n        if (ssh_string_cmp(k1->sk_application, k2->sk_application) != 0) {\n            return 1;\n        }\n\n        if (what == SSH_KEY_CMP_PRIVATE) {\n            if (k1->sk_flags != k2->sk_flags) {\n                return 1;\n            }\n\n            if (ssh_string_cmp(k1->sk_key_handle, k2->sk_key_handle) != 0) {\n                return 1;\n            }\n\n            if (ssh_string_cmp(k1->sk_reserved, k2->sk_reserved) != 0) {\n                return 1;\n            }\n        }\n    }\n\n    if (what == SSH_KEY_CMP_CERTIFICATE) {\n        if (!is_cert_type(k1->type) ||\n            !is_cert_type(k2->type)) {\n            return 1;\n        }\n        if (k1->cert == NULL || k2->cert == NULL) {\n            return 1;\n        }\n        if (ssh_buffer_get_len(k1->cert) != ssh_buffer_get_len(k2->cert)) {\n            return 1;\n        }\n        return memcmp(ssh_buffer_get(k1->cert),\n                      ssh_buffer_get(k2->cert),\n                      ssh_buffer_get_len(k1->cert));\n    }\n\n#ifndef HAVE_LIBCRYPTO\n    if (k1->type == SSH_KEYTYPE_ED25519) {\n        return pki_ed25519_key_cmp(k1, k2, what);\n    } else if (k1->type == SSH_KEYTYPE_SK_ED25519) {\n        return pki_ed25519_key_cmp(k1, k2, SSH_KEY_CMP_PUBLIC);\n    }\n#endif\n\n    return pki_key_compare(k1, k2, what);\n}\n",
      "line_start": 764,
      "line_end": 830,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 122,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Compares structured SSH key objects with multiple branches (private/public, cert, sk keys), performs buffer comparisons (memcmp) on key/cert data and delegates to PKI compare routines. It processes structured external data and has multiple input-dependent code paths, but it does not itself parse raw formats or perform unsafe memory writes, so it's high priority but not critical."
    },
    {
      "name": "pki.c:sshsig_armor",
      "clean_name": "sshsig_armor",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param out_str    Pointer to store the allocated base64 encoded string\n *                   Must be freed with ssh_string_free_char()\n *\n * @return SSH_OK on success, SSH_ERROR on error\n */\nstatic int sshsig_armor(ssh_buffer blob, char **out_str)\n{\n    char *b64_data = NULL;\n    char *armored = NULL;\n    const unsigned char *data = NULL;\n    size_t len, b64_len, armored_len, num_lines;\n    size_t i, j;\n\n    if (blob == NULL || out_str == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid input parameters\");\n        return SSH_ERROR;\n    }\n\n    *out_str = NULL;\n\n    data = ssh_buffer_get(blob);\n    len = ssh_buffer_get_len(blob);\n\n    b64_data = (char *)bin_to_base64(data, len);\n    if (b64_data == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to base64 encode signature blob\");\n        return SSH_ERROR;\n    }\n\n    b64_len = strlen(b64_data);\n\n    /* Calculate space needed: header + data with line breaks + footer */\n    num_lines = (b64_len + SSHSIG_LINE_LENGTH - 1) /\n                SSHSIG_LINE_LENGTH;                    /* Round up division */\n    armored_len = strlen(SSHSIG_BEGIN_SIGNATURE) + 1 + /* header + \\n */\n                  b64_len + num_lines +                /* data + line breaks */\n                  strlen(SSHSIG_END_SIGNATURE) + 1;    /* footer + \\0 */\n\n    armored = calloc(armored_len, 1);\n    if (armored == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to allocate %zu bytes for armored signature\",\n                armored_len);\n        SAFE_FREE(b64_data);\n        return SSH_ERROR;\n    }\n\n    j = snprintf(armored, armored_len, SSHSIG_BEGIN_SIGNATURE \"\\n\");\n    for (i = 0; i < b64_len; i++) {\n        if (i > 0 && i % SSHSIG_LINE_LENGTH == 0) {\n            armored[j++] = '\\n';\n        }\n        armored[j++] = b64_data[i];\n    }\n    armored[j++] = '\\n';\n    snprintf(armored + j, armored_len - j, SSHSIG_END_SIGNATURE);\n\n    SAFE_FREE(b64_data);\n\n    *out_str = armored;\n    return SSH_OK;\n}\n",
      "line_start": 2940,
      "line_end": 2997,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 92,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Takes external binary input, base64-encodes it and performs multiple memory/string operations and allocations with input-dependent loop bounds\u2014making it a worthwhile fuzz target for discovering buffer/length/formatting bugs (e.g. off-by-one or allocation miscalculation). Not a 9-10 because it does not parse a complex protocol or perform crypto/auth logic and has relatively simple control flow."
    },
    {
      "name": "ssh_event_free",
      "clean_name": "ssh_event_free",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  event        The ssh_event object to free.\n *                      Note: you have to manually remove sessions and socket\n *                      fds before freeing the event object.\n *\n */\nvoid ssh_event_free(ssh_event event)\n{\n    size_t used, i;\n    ssh_poll_handle p = NULL;\n\n    if (event == NULL) {\n        return;\n    }\n\n    if (event->ctx != NULL) {\n        used = event->ctx->polls_used;\n        for (i = 0; i < used; i++) {\n            p = event->ctx->pollptrs[i];\n            if (p->session != NULL) {\n                ssh_poll_ctx_remove(event->ctx, p);\n                ssh_poll_ctx_add(p->session->default_poll_ctx, p);\n                p->session = NULL;\n                used = 0;\n            }\n        }\n\n        ssh_poll_ctx_free(event->ctx);\n    }\n#ifdef WITH_SERVER\n    if (event->sessions != NULL) {\n        ssh_list_free(event->sessions);\n    }\n#endif\n    free(event);\n}\n",
      "line_start": 1184,
      "line_end": 1214,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Fuzzing this function can trigger memory-corruption bugs: it dereferences many pointers, frees structures, and iterates using event->ctx->polls_used (an input-dependent bound). That makes it a good high-priority target for finding UAF/double-free/out-of-bounds/loop-termination issues. It does not parse complex external formats or perform cryptographic/auth logic, so it is not critical (9-10)."
    },
    {
      "name": "ssh_find_matching",
      "clean_name": "ssh_find_matching",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * @param[in] preferred_list    The list of tokens to search, ordered by\n * preference\n *\n * @return  A newly allocated copy of the token if found; NULL otherwise\n */\nchar *ssh_find_matching(const char *available_list,\n                        const char *preferred_list)\n{\n    struct ssh_tokens_st *a_tok = NULL, *p_tok = NULL;\n\n    int i, j;\n    char *ret = NULL;\n\n    if ((available_list == NULL) || (preferred_list == NULL)) {\n        return NULL;\n    }\n\n    a_tok = ssh_tokenize(available_list, ',');\n    if (a_tok == NULL) {\n        return NULL;\n    }\n\n    p_tok = ssh_tokenize(preferred_list, ',');\n    if (p_tok == NULL) {\n        goto out;\n    }\n\n    for (i = 0; p_tok->tokens[i]; i++) {\n        for (j = 0; a_tok->tokens[j]; j++) {\n            if (strcmp(a_tok->tokens[j], p_tok->tokens[i]) == 0) {\n                ret = strdup(a_tok->tokens[j]);\n                goto out;\n            }\n        }\n    }\n\nout:\n    ssh_tokens_free(a_tok);\n    ssh_tokens_free(p_tok);\n    return ret;\n}\n",
      "line_start": 154,
      "line_end": 190,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses and tokenizes two external input strings and performs nested string comparisons and allocations (strcmp/strdup) with loop bounds dependent on input length. Moderate complexity with multiple code paths (matching vs no-match, NULL checks) and potential for edge-case bugs (very long tokens, memory allocation/handling). Good fuzz target but not a complex parser or crypto/auth routine, so high (not critical) priority."
    },
    {
      "name": "ssh_find_all_matching",
      "clean_name": "ssh_find_all_matching",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * preference\n *\n * @return  A newly allocated string containing the list of all matching tokens;\n * NULL otherwise\n */\nchar *ssh_find_all_matching(const char *available_list,\n                            const char *preferred_list)\n{\n    struct ssh_tokens_st *a_tok = NULL, *p_tok = NULL;\n    int i, j;\n    char *ret = NULL;\n    size_t max, len, pos = 0;\n    int match;\n\n    if ((available_list == NULL) || (preferred_list == NULL)) {\n        return NULL;\n    }\n\n    max = MAX(strlen(available_list), strlen(preferred_list));\n\n    ret = calloc(1, max + 1);\n    if (ret == NULL) {\n        return NULL;\n    }\n\n    a_tok = ssh_tokenize(available_list, ',');\n    if (a_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    p_tok = ssh_tokenize(preferred_list, ',');\n    if (p_tok == NULL) {\n        SAFE_FREE(ret);\n        goto out;\n    }\n\n    for (i = 0; p_tok->tokens[i] ; i++) {\n        for (j = 0; a_tok->tokens[j]; j++) {\n            match = !strcmp(a_tok->tokens[j], p_tok->tokens[i]);\n            if (match) {\n                if (pos != 0) {\n                    ret[pos] = ',';\n                    pos++;\n                }\n\n                len = strlen(a_tok->tokens[j]);\n                memcpy(&ret[pos], a_tok->tokens[j], len);\n                pos += len;\n                ret[pos] = '\\0';\n            }\n        }\n    }\n\n    if (ret[0] == '\\0') {\n        SAFE_FREE(ret);\n    }\n\nout:\n    ssh_tokens_free(a_tok);\n    ssh_tokens_free(p_tok);\n    return ret;\n}\n",
      "line_start": 205,
      "line_end": 263,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 90,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Processes externally-controlled comma-separated input, tokenizes and performs string/memcpy operations with nested loops and multiple code paths (good fuzz value). Not a complex file/protocol parser or crypto/auth code, so not top-critical but high-priority to fuzz for memory/logic bugs."
    },
    {
      "name": "ssh_remove_duplicates",
      "clean_name": "ssh_remove_duplicates",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * @param[in] list  The list to be freed of duplicates\n *\n * @return  A newly allocated copy of the string free of duplicates; NULL in\n * case of error.\n */\nchar *ssh_remove_duplicates(const char *list)\n{\n    struct ssh_tokens_st *tok = NULL;\n\n    size_t i, j, num_tokens, max_len;\n    char *ret = NULL;\n    bool *should_copy = NULL, need_comma = false;\n\n    if (list == NULL) {\n        return NULL;\n    }\n\n    /* The maximum number of tokens is the size of the list */\n    max_len = strlen(list);\n    if (max_len == 0) {\n        return NULL;\n    }\n\n    /* Add space for ending '\\0' */\n    max_len++;\n\n    tok = ssh_tokenize(list, ',');\n    if ((tok == NULL) || (tok->tokens == NULL) || (tok->tokens[0] == NULL)) {\n        goto out;\n    }\n\n    should_copy = calloc(1, max_len);\n    if (should_copy == NULL) {\n        goto out;\n    }\n\n    if (strlen(tok->tokens[0]) > 0) {\n        should_copy[0] = true;\n    }\n\n    for (i = 1; tok->tokens[i]; i++) {\n        for (j = 0; j < i; j++) {\n            if (strcmp(tok->tokens[i], tok->tokens[j]) == 0) {\n                /* Found a duplicate; do not copy */\n                should_copy[i] = false;\n                break;\n            }\n        }\n\n        /* No matching token before */\n        if (j == i) {\n            /* Only copy if it is not an empty string */\n            if (strlen(tok->tokens[i]) > 0) {\n                should_copy[i] = true;\n            } else {\n                should_copy[i] = false;\n            }\n        }\n    }\n\n    num_tokens = i;\n\n    ret = calloc(1, max_len);\n    if (ret == NULL) {\n        goto out;\n    }\n\n    for (i = 0; i < num_tokens; i++) {\n        if (should_copy[i]) {\n            if (need_comma) {\n                strncat(ret, \",\", (max_len - strlen(ret) - 1));\n            }\n            strncat(ret, tok->tokens[i], (max_len - strlen(ret) - 1));\n            need_comma = true;\n        }\n    }\n\n    /* If no comma is needed, nothing was copied */\n    if (!need_comma) {\n        SAFE_FREE(ret);\n    }\n\nout:\n    SAFE_FREE(should_copy);\n    ssh_tokens_free(tok);\n    return ret;\n}\n",
      "line_start": 275,
      "line_end": 357,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 118,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Parses external input (comma-separated list) and performs memory operations (calloc, strncat) with nested loops and input-dependent bounds. Moderate complexity and multiple code paths (duplicate handling) make it a useful fuzz target, but it is not a complex file/protocol parser or security-critical routine."
    },
    {
      "name": "ssh_remove_all_matching",
      "clean_name": "ssh_remove_all_matching",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * @param[in] remove_list      The list to be removed\n *\n * @return  A newly allocated copy list containing elements of the\n * list without the elements of remove_list; NULL in case of error.\n */\nchar *ssh_remove_all_matching(const char *list,\n                              const char *remove_list)\n{\n    struct ssh_tokens_st *l_tok = NULL, *r_tok = NULL;\n    int i, j, cmp;\n    char *ret = NULL;\n    size_t len, pos = 0;\n    bool exclude;\n\n    if (list == NULL) {\n        return NULL;\n    }\n    if (remove_list == NULL) {\n        return strdup (list);\n    }\n\n    l_tok = ssh_tokenize(list, ',');\n    if (l_tok == NULL) {\n        goto out;\n    }\n\n    r_tok = ssh_tokenize(remove_list, ',');\n    if (r_tok == NULL) {\n        goto out;\n    }\n\n    ret = calloc(1, strlen(list) + 1);\n    if (ret == NULL) {\n        goto out;\n    }\n\n    for (i = 0; l_tok->tokens[i]; i++) {\n        exclude = false;\n        for (j = 0; r_tok->tokens[j]; j++) {\n            cmp = strcmp(l_tok->tokens[i], r_tok->tokens[j]);\n            if (cmp == 0) {\n                exclude = true;\n                break;\n            }\n        }\n        if (exclude == false) {\n            if (pos != 0) {\n                ret[pos] = ',';\n                pos++;\n            }\n\n            len = strlen(l_tok->tokens[i]);\n            memcpy(&ret[pos], l_tok->tokens[i], len);\n            pos += len;\n        }\n    }\n\n    if (ret[0] == '\\0') {\n        SAFE_FREE(ret);\n    }\n\nout:\n    ssh_tokens_free(l_tok);\n    ssh_tokens_free(r_tok);\n    return ret;\n}\n",
      "line_start": 428,
      "line_end": 489,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Processes structured external input (comma-separated lists), tokenizes and performs string operations/memcpy with input-dependent loops and branching. Moderate complexity and multiple code paths make it a good high-priority fuzz target (but not critical: no crypto/auth and overall logic is simple)."
    },
    {
      "name": "pki_pubkey_build_ed25519",
      "clean_name": "pki_pubkey_build_ed25519",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    key->key = pkey;\n\n    return SSH_OK;\n}\n\nint pki_pubkey_build_ed25519(ssh_key key, ssh_string pubkey)\n{\n    EVP_PKEY *pkey = NULL;\n\n    if (ssh_string_len(pubkey) != ED25519_KEY_LEN) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid ed25519 key len\");\n        return SSH_ERROR;\n    }\n\n    if (ssh_fips_mode()) {\n        /* We do not want to fail here as we know the algorithm, but we can not\n         * use it. Just store the public key here. We won't be able to use it\n         * for anything though. */\n        key->ed25519_pubkey = malloc(ED25519_KEY_LEN);\n        if (key->ed25519_pubkey == NULL) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to allocate memory for the Ed25519 public key\");\n            return SSH_ERROR;\n        }\n\n        memcpy(key->ed25519_pubkey, ssh_string_data(pubkey), ED25519_KEY_LEN);\n        return SSH_OK;\n    }\n\n    pkey = EVP_PKEY_new_raw_public_key(EVP_PKEY_ED25519,\n                                       NULL,\n                                       (const uint8_t *)ssh_string_data(pubkey),\n                                       ED25519_KEY_LEN);\n    if (pkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create ed25519 EVP_PKEY: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    key->key = pkey;\n\n    return SSH_OK;\n}\n",
      "line_start": 442,
      "line_end": 481,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 59,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Accepts untrusted public-key bytes and either memcpy's them or hands them to OpenSSL (EVP_PKEY_new_raw_public_key). This is security-critical crypto handling and involves memory ops on external data, so it's a valuable fuzz target; however the function logic is simple (fixed-length check, small branch on FIPS mode) so it is not top-critical."
    },
    {
      "name": "sha1_update",
      "clean_name": "sha1_update",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "{\n    EVP_MD_CTX_free(c);\n}\n\nint\nsha1_update(SHACTX c, const void *data, size_t len)\n{\n    int rc = EVP_DigestUpdate(c, data, len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 55,
      "line_end": 63,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Thin wrapper that consumes untrusted input and invokes cryptographic code (EVP_DigestUpdate). It\u2019s security-relevant but contains minimal internal logic or parsing\u2014good fuzz target to exercise crypto implementation boundaries but not high-complexity on its own."
    },
    {
      "name": "sha256_update",
      "clean_name": "sha256_update",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "{\n    EVP_MD_CTX_free(c);\n}\n\nint\nsha256_update(SHA256CTX c, const void *data, size_t len)\n{\n    int rc = EVP_DigestUpdate(c, data, len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 117,
      "line_end": 125,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "High priority: this wrapper accepts untrusted data and length and forwards it to a cryptographic digest routine (security-critical). The function itself has minimal logic and no parsing/branching, so it\u2019s less complex than a full parser but still valuable to fuzz for crypto/memory-handling bugs in the digest path."
    },
    {
      "name": "dh-gex.c:invn_chance",
      "clean_name": "invn_chance",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "\n/** @internal\n * @brief returns 1 with 1/n probability\n * @returns 1 on with P(1/n), 0 with P(n-1/n).\n */\nstatic bool invn_chance(size_t n)\n{\n    size_t nounce = 0;\n    int ok;\n\n    ok = ssh_get_random(&nounce, sizeof(nounce), 0);\n    if (!ok) {\n        return false;\n    }\n    return (nounce % n) == 0;\n}\n",
      "line_start": 379,
      "line_end": 390,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Simple, low-complexity function but takes an external parameter n and does a modulo operation without checking for n==0 (potential UB/crash). Calls ssh_get_random and branches on its result \u2014 small logic but a good fuzz target because fuzzers can easily trigger the division-by-zero or random-path behaviors."
    },
    {
      "name": "ssh_agent_get_ident_count",
      "clean_name": "ssh_agent_get_ident_count",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "    }\n\n    return 0;\n}\n\nuint32_t ssh_agent_get_ident_count(struct ssh_session_struct *session)\n{\n    ssh_buffer request = NULL;\n    ssh_buffer reply = NULL;\n    unsigned int type = 0;\n    uint32_t count = 0;\n    uint32_t rc;\n\n    /* send message to the agent requesting the list of identities */\n    request = ssh_buffer_new();\n    if (request == NULL) {\n        ssh_set_error_oom(session);\n        return 0;\n    }\n    if (ssh_buffer_add_u8(request, SSH2_AGENTC_REQUEST_IDENTITIES) < 0) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(request);\n        return 0;\n    }\n\n    reply = ssh_buffer_new();\n    if (reply == NULL) {\n        SSH_BUFFER_FREE(request);\n        ssh_set_error(session, SSH_FATAL, \"Not enough space\");\n        return 0;\n    }\n\n    if (agent_talk(session, request, reply) < 0) {\n        SSH_BUFFER_FREE(request);\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    }\n    SSH_BUFFER_FREE(request);\n\n    /* get message type and verify the answer */\n    rc = ssh_buffer_get_u8(reply, (uint8_t *) &type);\n    if (rc != sizeof(uint8_t)) {\n        ssh_set_error(session, SSH_FATAL,\n                \"Bad authentication reply size: %\" PRIu32, rc);\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    }\n#ifdef WORDS_BIGENDIAN\n    type = bswap_32(type);\n#endif\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Answer type: %d, expected answer: %d\",\n            type, SSH2_AGENT_IDENTITIES_ANSWER);\n\n    if (agent_failed(type)) {\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    } else if (type != SSH2_AGENT_IDENTITIES_ANSWER) {\n        ssh_set_error(session, SSH_FATAL,\n                \"Bad authentication reply message type: %u\", type);\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    }\n\n    rc = ssh_buffer_get_u32(reply, &count);\n    if (rc != 4) {\n        ssh_set_error(session,\n                SSH_FATAL,\n                \"Failed to read count\");\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    }\n    session->agent->count = ntohl(count);\n    SSH_LOG(SSH_LOG_DEBUG, \"Agent count: %d\",\n            session->agent->count);\n    if (session->agent->count > 1024) {\n        ssh_set_error(session, SSH_FATAL,\n                \"Too many identities in authentication reply: %d\",\n                session->agent->count);\n        SSH_BUFFER_FREE(reply);\n        return 0;\n    }\n\n    ssh_buffer_free(session->agent->ident);\n    session->agent->ident = reply;\n\n    return session->agent->count;\n}\n",
      "line_start": 350,
      "line_end": 434,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 173,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 7.0,
      "reason": "Talks to an external agent and parses an untrusted reply (agent_talk + ssh_buffer_get_u8/ssh_buffer_get_u32), does type checking, endian conversion and bounds checking (ntohl, >1024), and updates session state \u2014 multiple input-dependent code paths. It lacks deep/complex parsing or loops over external data, so important but not top-critical."
    },
    {
      "name": "agent.c:atomicio",
      "clean_name": "atomicio",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "#define agent_failed(x) \\\n  (((x) == SSH_AGENT_FAILURE) || ((x) == SSH_COM_AGENT2_FAILURE) || \\\n   ((x) == SSH2_AGENT_FAILURE))\n\nstatic uint32_t\natomicio(struct ssh_agent_struct *agent, void *buf, uint32_t n, int do_read)\n{\n    char *b = buf;\n    uint32_t pos = 0;\n    ssize_t res;\n    ssh_pollfd_t pfd;\n    ssh_channel channel = agent->channel;\n    socket_t fd;\n\n    /* Using a socket ? */\n    if (channel == NULL) {\n        fd = ssh_socket_get_fd(agent->sock);\n        pfd.fd = fd;\n        pfd.events = do_read ? POLLIN : POLLOUT;\n\n        while (n > pos) {\n            if (do_read) {\n                res = recv(fd, b + pos, n - pos, 0);\n            } else {\n                res = send(fd, b + pos, n - pos, 0);\n            }\n            switch (res) {\n            case -1:\n                if (errno == EINTR) {\n                    continue;\n                }\n#ifdef EWOULDBLOCK\n                if (errno == EAGAIN || errno == EWOULDBLOCK) {\n#else\n                if (errno == EAGAIN) {\n#endif\n                    (void)ssh_poll(&pfd, 1, -1);\n                    continue;\n                }\n                return 0;\n            case 0:\n                /* read returns 0 on end-of-file */\n                errno = do_read ? 0 : EPIPE;\n                return pos;\n            default:\n                pos += (uint32_t)res;\n            }\n        }\n        return pos;\n    } else {\n        /* using an SSH channel */\n        while (n > pos) {\n            if (do_read) {\n                res = ssh_channel_read(channel, b + pos, n - pos, 0);\n            } else {\n                res = ssh_channel_write(channel, b + pos, n - pos);\n            }\n            if (res == SSH_AGAIN) {\n                continue;\n            }\n            if (res == SSH_ERROR) {\n                return 0;\n            }\n            pos += (uint32_t)res;\n        }\n        return pos;\n    }\n}\n",
      "line_start": 70,
      "line_end": 133,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 84,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "High-value fuzz target: it performs repeated I/O (recv/send and ssh_channel read/write) into a caller buffer with loops bounded by external 'n', handles EINTR/EAGAIN/SSH_AGAIN and has multiple error-handling paths. It does memory operations on untrusted data and includes type conversions (ssize_t to uint32_t), but it does not parse complex file/protocol formats or crypto, so rates as high (7)."
    },
    {
      "name": "base64.c:to_block4",
      "clean_name": "to_block4",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": "                             i = ptr - (const char *)alphabet; \\\n                             SET_##letter(*block, i); \\\n                         } while(0)\n\n/* Returns 0 if ok, -1 if not (ie invalid char into the stuff) */\nstatic int to_block4(unsigned long *block, const char *source, int num)\n{\n    const char *ptr = NULL;\n    size_t i;\n\n    *block = 0;\n    if (num < 1) {\n        return 0;\n    }\n\n    BLOCK(A, 0); /* 6 bit */\n    BLOCK(B, 1); /* 12 bit */\n\n    if (num < 2) {\n        return 0;\n    }\n\n    BLOCK(C, 2); /* 18 bit */\n\n    if (num < 3) {\n        return 0;\n    }\n\n    BLOCK(D, 3); /* 24 bit */\n\n    return 0;\n}\n",
      "line_start": 185,
      "line_end": 212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 80,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Parses untrusted input (source) into a packed bit block and uses per-character validation/mapping (macros) with multiple code paths depending on num and input values. It performs type conversions/bit manipulation and has branching logic, but the input size is small/fixed (up to 4 chars) and there are no obvious large memory operations or complex protocol parsing, so it is high priority but not critical."
    },
    {
      "name": "base64.c:get_equals",
      "clean_name": "get_equals",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": "\n    return 0;\n}\n\n/* Count the number of \"=\" signs and replace them by zeroes */\nstatic int get_equals(char *string)\n{\n    char *ptr = string;\n    int num = 0;\n\n    while ((ptr = strchr(ptr, '=')) != NULL) {\n        num++;\n        *ptr = '\\0';\n        ptr++;\n    }\n\n    return num;\n}\n",
      "line_start": 229,
      "line_end": 242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Accepts external string, scans with an input-dependent loop and performs in-place memory writes (replacing '=' with '\\0'), making it a useful fuzz target. Low cyclomatic complexity and simple logic keep it from being critical, but the input-dependent loop and direct buffer modification warrant high priority."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:ssh_known_hosts_read_entries",
      "clean_name": "ssh_known_hosts_read_entries",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * in  filename  argument, and entries matching the  match  argument\n * will be added to the list in  entries  argument.\n * If the  entries  list is NULL, it will allocate a new list. Caller\n * is responsible to free it even if an error occurs.\n */\nstatic int ssh_known_hosts_read_entries(const char *match,\n                                        const char *filename,\n                                        struct ssh_list **entries)\n{\n    char line[MAX_LINE_SIZE];\n    size_t lineno = 0;\n    size_t len = 0;\n    FILE *fp = NULL;\n    int rc;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_TRACE, \"Failed to open the known_hosts file '%s': %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        /* The missing file is not an error here */\n        return SSH_OK;\n    }\n\n    if (*entries == NULL) {\n        *entries = ssh_list_new();\n        if (*entries == NULL) {\n            fclose(fp);\n            return SSH_ERROR;\n        }\n    }\n\n    for (rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno);\n         rc == 0;\n         rc = known_hosts_read_line(fp, line, sizeof(line), &len, &lineno)) {\n        struct ssh_knownhosts_entry *entry = NULL;\n        struct ssh_iterator *it = NULL;\n        char *p = NULL;\n\n        if (line[len] != '\\n') {\n            len = strcspn(line, \"\\n\");\n        }\n        line[len] = '\\0';\n\n        /* Skip leading spaces */\n        for (p = line; isspace((int)p[0]); p++);\n\n        /* Skip comments and empty lines */\n        if (p[0] == '\\0' || p[0] == '#') {\n            continue;\n        }\n\n        /* Skip lines starting with markers (@cert-authority, @revoked):\n         * we do not completely support them anyway */\n        if (p[0] == '@') {\n            continue;\n        }\n\n        rc = ssh_known_hosts_parse_line(match,\n                                        line,\n                                        &entry);\n        if (rc == SSH_AGAIN) {\n            continue;\n        } else if (rc != SSH_OK) {\n            goto error;\n        }\n\n        /* Check for duplicates */\n        for (it = ssh_list_get_iterator(*entries);\n             it != NULL;\n             it = it->next) {\n            struct ssh_knownhosts_entry *entry2 = NULL;\n            int cmp;\n            entry2 = ssh_iterator_value(struct ssh_knownhosts_entry *, it);\n            cmp = ssh_known_hosts_entries_compare(entry, entry2);\n            if (cmp == 0) {\n                ssh_knownhosts_entry_free(entry);\n                entry = NULL;\n                break;\n            }\n        }\n        if (entry != NULL) {\n            ssh_list_append(*entries, entry);\n        }\n    }\n\n    fclose(fp);\n    return SSH_OK;\nerror:\n    fclose(fp);\n    return SSH_ERROR;\n}\n",
      "line_start": 224,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 99,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 7.0,
      "reason": "Reads and processes external input (known_hosts file), does string/buffer operations on untrusted data, contains loops and multiple branches (skips, markers, duplicate checking) and delegates to a complex parser. Not directly crypto/auth handling and overall control flow is moderate, so it's a high-priority (7) fuzz target; the inner parser/read_line functions would be even higher-value to fuzz."
    },
    {
      "name": "bind_config.c:local_parse_glob",
      "clean_name": "local_parse_glob",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "    fclose(f);\n    return;\n}\n\n#if defined(HAVE_GLOB) && defined(HAVE_GLOB_GL_FLAGS_MEMBER)\nstatic void local_parse_glob(ssh_bind bind,\n                             const char *fileglob,\n                             uint32_t *parser_flags,\n                             uint8_t *seen,\n                             unsigned int depth)\n{\n    glob_t globbuf = {\n        .gl_flags = 0,\n    };\n    int rt;\n    u_int i;\n\n    rt = glob(fileglob, GLOB_TILDE, NULL, &globbuf);\n    if (rt == GLOB_NOMATCH) {\n        globfree(&globbuf);\n        return;\n    } else if (rt != 0) {\n        SSH_LOG(SSH_LOG_RARE, \"Glob error: %s\",\n                fileglob);\n        globfree(&globbuf);\n        return;\n    }\n\n    for (i = 0; i < globbuf.gl_pathc; i++) {\n        local_parse_file(bind, globbuf.gl_pathv[i], parser_flags, seen, depth);\n    }\n\n    globfree(&globbuf);\n}\n",
      "line_start": 238,
      "line_end": 267,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Medium priority: the function takes external input (a file glob), calls glob() and iterates over an attacker-controlled number of results (external-input-dependent loop bounds) and dispatches to local_parse_file, but contains simple control flow and no direct complex parsing or unsafe memory ops itself\u2014the real risk is in the downstream parser it calls."
    },
    {
      "name": "ssh_userauth_password",
      "clean_name": "ssh_userauth_password",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * before you connect to the server.\n *\n * @see ssh_userauth_none()\n * @see ssh_userauth_kbdint()\n */\nint ssh_userauth_password(ssh_session session,\n                          const char *username,\n                          const char *password)\n{\n    int rc;\n\n    switch (session->pending_call_state) {\n        case SSH_PENDING_CALL_NONE:\n            break;\n        case SSH_PENDING_CALL_AUTH_PASSWORD:\n            goto pending;\n        default:\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Wrong state (%d) during pending SSH call\",\n                          session->pending_call_state);\n            return SSH_ERROR;\n    }\n\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* request */\n    rc = ssh_buffer_pack(session->out_buffer, \"bsssbs\",\n            SSH2_MSG_USERAUTH_REQUEST,\n            username ? username : session->opts.username,\n            \"ssh-connection\",\n            \"password\",\n            0, /* false */\n            password\n    );\n    if (rc < 0) {\n        goto fail;\n    }\n\n    /* Set the buffer as secure to be explicitly zeroed when freed */\n    ssh_buffer_set_secure(session->out_buffer);\n\n    session->auth.current_method = SSH_AUTH_METHOD_PASSWORD;\n    session->auth.state = SSH_AUTH_STATE_PASSWORD_AUTH_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_PASSWORD;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n\n    return rc;\nfail:\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 1716,
      "line_end": 1779,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it handles untrusted inputs (username/password) and performs buffer packing/memory operations and some state handling, but it is primarily a wrapper that constructs/sends a packet and delegates parsing/complex logic to other functions. Better targets are the actual protocol parsers or lower-level buffer/pack functions."
    },
    {
      "name": "channel_rcv_change_window",
      "clean_name": "channel_rcv_change_window",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    }\n\n    return channel;\n}\n\nSSH_PACKET_CALLBACK(channel_rcv_change_window)\n{\n    ssh_channel channel = NULL;\n    uint32_t bytes;\n    int rc;\n    bool was_empty;\n\n    (void)user;\n    (void)type;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n    }\n\n    rc = ssh_buffer_unpack(packet, \"d\", &bytes);\n    if (channel == NULL || rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_PACKET,\n                \"Error getting a window adjust message: invalid packet\");\n\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Adding %\" PRIu32 \" bytes to channel (%\" PRIu32 \":%\" PRIu32\n            \") (from %\" PRIu32 \" bytes)\",\n            bytes,\n            channel->local_channel,\n            channel->remote_channel,\n            channel->remote_window);\n\n    was_empty = channel->remote_window == 0;\n\n    channel->remote_window += bytes;\n\n    /* Writing to the channel is non-blocking until the receive window is empty.\n     * When the receive window becomes non-zero again, call\n     * channel_write_wontblock_function. */\n    if (was_empty && bytes > 0) {\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_write_wontblock_function,\n                                   session,\n                                   channel,\n                                   channel->remote_window);\n    }\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 534,
      "line_end": 583,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Parses external packet data (unpacks a uint32) and mutates channel state (remote_window) and triggers callbacks, so it is a useful fuzz target. However the function is small, has simple control flow and no direct memory operations or complex parsing/validation; risk is mostly state/overflow-related rather than rich parsing logic, so medium priority."
    },
    {
      "name": "channel_default_bufferize",
      "clean_name": "channel_default_bufferize",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * When data has been received from the ssh server, it can be applied to the\n * known user function, with help of the callback, or inserted here\n *\n * FIXME is the window changed?\n */\nint channel_default_bufferize(ssh_channel channel,\n                              void *data, uint32_t len,\n                              bool is_stderr)\n{\n    ssh_session session = NULL;\n\n    if (channel == NULL) {\n        return -1;\n    }\n\n    session = channel->session;\n\n    if (data == NULL) {\n        ssh_set_error_invalid(session);\n        return -1;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"placing %\" PRIu32 \" bytes into channel buffer (%s)\",\n            len,\n            is_stderr ? \"stderr\" : \"stdout\");\n    if (!is_stderr) {\n        /* stdout */\n        if (channel->stdout_buffer == NULL) {\n            channel->stdout_buffer = ssh_buffer_new();\n            if (channel->stdout_buffer == NULL) {\n                ssh_set_error_oom(session);\n                return -1;\n            }\n        }\n\n        if (ssh_buffer_add_data(channel->stdout_buffer, data, len) < 0) {\n            ssh_set_error_oom(session);\n            SSH_BUFFER_FREE(channel->stdout_buffer);\n            channel->stdout_buffer = NULL;\n            return -1;\n        }\n    } else {\n        /* stderr */\n        if (channel->stderr_buffer == NULL) {\n            channel->stderr_buffer = ssh_buffer_new();\n            if (channel->stderr_buffer == NULL) {\n                ssh_set_error_oom(session);\n                return -1;\n            }\n        }\n\n        if (ssh_buffer_add_data(channel->stderr_buffer, data, len) < 0) {\n            ssh_set_error_oom(session);\n            SSH_BUFFER_FREE(channel->stderr_buffer);\n            channel->stderr_buffer = NULL;\n            return -1;\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 994,
      "line_end": 1051,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 89,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Thin wrapper that accepts external data and appends it into stdout/stderr buffers (via ssh_buffer_add_data), so it performs memory operations on untrusted input and has branches for stderr/stdout and allocation/failure handling. However it has low cyclomatic complexity and no parsing, protocol handling, or security-critical logic, making it a medium-priority fuzz target."
    },
    {
      "name": "ssh_channel_request_pty_size_modes",
      "clean_name": "ssh_channel_request_pty_size_modes",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n */\nint ssh_channel_request_pty_size_modes(ssh_channel channel, const char *terminal,\n    int col, int row, const unsigned char* modes, size_t modes_len)\n{\n    ssh_session session = NULL;\n    ssh_buffer buffer = NULL;\n    int rc = SSH_ERROR;\n\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n    session = channel->session;\n\n    if (terminal == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return rc;\n    }\n\n    switch (channel->request_state) {\n    case SSH_CHANNEL_REQ_STATE_NONE:\n        break;\n    default:\n        goto pending;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(buffer,\n                         \"sdddddP\",\n                         terminal,\n                         col,\n                         row,\n                         0, /* pix */\n                         0, /* pix */\n                         (uint32_t)modes_len,\n                         (size_t)modes_len,\n                         modes);\n\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\npending:\n    rc = channel_request(channel, \"pty-req\", buffer, 1);\nerror:\n    SSH_BUFFER_FREE(buffer);\n\n    return rc;\n}\n",
      "line_start": 1990,
      "line_end": 2042,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Accepts untrusted inputs (terminal string and modes blob) and serializes them into an SSH message (calls ssh_buffer_pack), so it performs memory operations on external data and has some non-trivial behavior. However the function itself is fairly simple (low cyclomatic complexity, no loops or complex parsing/validation) and mainly a wrapper around buffer packing and channel_request, so it rates as medium priority for fuzzing."
    },
    {
      "name": "ssh_channel_poll",
      "clean_name": "ssh_channel_poll",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @warning When the channel is in EOF state, the function returns SSH_EOF.\n *\n * @see ssh_channel_is_eof()\n */\nint ssh_channel_poll(ssh_channel channel, int is_stderr)\n{\n  ssh_buffer stdbuf;\n\n  if ((channel == NULL) || (channel->flags & SSH_CHANNEL_FLAG_FREED_LOCAL)) {\n      return SSH_ERROR;\n  }\n\n  stdbuf = channel->stdout_buffer;\n\n  if (is_stderr) {\n    stdbuf = channel->stderr_buffer;\n  }\n\n  if (channel->remote_eof == 0) {\n    if (channel->session->session_state == SSH_SESSION_STATE_ERROR){\n      return SSH_ERROR;\n    }\n    if (ssh_handle_packets(channel->session, SSH_TIMEOUT_NONBLOCKING)==SSH_ERROR) {\n      return SSH_ERROR;\n    }\n  }\n\n  if (ssh_buffer_get_len(stdbuf) > 0){\n  \treturn ssh_buffer_get_len(stdbuf);\n  }\n\n  if (channel->remote_eof) {\n    return SSH_EOF;\n  }\n\n  return ssh_buffer_get_len(stdbuf);\n}\n",
      "line_start": 3292,
      "line_end": 3325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Low-complexity wrapper: ssh_channel_poll mainly polls buffers and conditionally calls ssh_handle_packets. It does not perform direct memory/string operations or complex parsing itself (low cyclomatic complexity), so as a standalone fuzz target it is medium value. However it can be a useful entry point to exercise the real parser in ssh_handle_packets (which handles complex external input), so consider fuzzing the packet parser directly or using this function as a harness trigger."
    },
    {
      "name": "channels.c:channel_protocol_select",
      "clean_name": "channel_protocol_select",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * select(2).\n * This is made in two parts: protocol select and network select. The protocol\n * select does not use the network functions at all\n */\nstatic int\nchannel_protocol_select(ssh_channel *rchans, ssh_channel *wchans,\n                        ssh_channel *echans, ssh_channel *rout,\n                        ssh_channel *wout, ssh_channel *eout)\n{\n    ssh_channel chan = NULL;\n    int i;\n    int j = 0;\n\n    for (i = 0; rchans[i] != NULL; i++) {\n        chan = rchans[i];\n\n        while (ssh_channel_is_open(chan) &&\n               ssh_socket_data_available(chan->session->socket)) {\n            ssh_handle_packets(chan->session, SSH_TIMEOUT_NONBLOCKING);\n        }\n\n        if ((chan->stdout_buffer &&\n             ssh_buffer_get_len(chan->stdout_buffer) > 0) ||\n            (chan->stderr_buffer &&\n             ssh_buffer_get_len(chan->stderr_buffer) > 0) ||\n            chan->remote_eof) {\n            rout[j] = chan;\n            j++;\n        }\n    }\n    rout[j] = NULL;\n\n    j = 0;\n    for (i = 0; wchans[i] != NULL; i++) {\n        chan = wchans[i];\n        /* It's not our business to seek if the file descriptor is writable */\n        if (ssh_socket_data_writable(chan->session->socket) &&\n            ssh_channel_is_open(chan) && (chan->remote_window > 0)) {\n            wout[j] = chan;\n            j++;\n        }\n    }\n    wout[j] = NULL;\n\n    j = 0;\n    for (i = 0; echans[i] != NULL; i++) {\n        chan = echans[i];\n\n        if (!ssh_socket_is_open(chan->session->socket) ||\n            ssh_channel_is_closed(chan)) {\n            eout[j] = chan;\n            j++;\n        }\n    }\n    eout[j] = NULL;\n\n    return 0;\n}\n",
      "line_start": 3547,
      "line_end": 3600,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 66,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: the function iterates over external channel arrays (loop bounds depend on input), has multiple conditional branches and builds output lists, and calls network/packet handling routines (ssh_handle_packets) which may exercise more complex code. However, it does not itself parse complex external formats or perform direct memory operations on untrusted data, so it is not top-tier critical for fuzzing on its own."
    },
    {
      "name": "ssh_service_request",
      "clean_name": "ssh_service_request",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * @return SSH_OK on success\n * @return SSH_ERROR on error\n * @return SSH_AGAIN No response received yet\n * @bug actually only works with ssh-userauth\n */\nint ssh_service_request(ssh_session session, const char *service)\n{\n  int rc = SSH_ERROR;\n\n  if(session->auth.service_state != SSH_AUTH_SERVICE_NONE)\n    goto pending;\n\n  rc = ssh_buffer_pack(session->out_buffer,\n                       \"bs\",\n                       SSH2_MSG_SERVICE_REQUEST,\n                       service);\n  if (rc != SSH_OK){\n      ssh_set_error_oom(session);\n      return SSH_ERROR;\n  }\n  session->auth.service_state = SSH_AUTH_SERVICE_SENT;\n  if (ssh_packet_send(session) == SSH_ERROR) {\n    ssh_set_error(session, SSH_FATAL,\n        \"Sending SSH2_MSG_SERVICE_REQUEST failed.\");\n      return SSH_ERROR;\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Sent SSH_MSG_SERVICE_REQUEST (service %s)\", service);\npending:\n  rc=ssh_handle_packets_termination(session,SSH_TIMEOUT_USER,\n      ssh_service_request_termination, session);\n  if (rc == SSH_ERROR) {\n      return SSH_ERROR;\n  }\n  switch(session->auth.service_state) {\n  case SSH_AUTH_SERVICE_DENIED:\n    ssh_set_error(session,SSH_FATAL,\"ssh_auth_service request denied\");\n    break;\n  case SSH_AUTH_SERVICE_ACCEPTED:\n    rc=SSH_OK;\n    break;\n  case SSH_AUTH_SERVICE_SENT:\n    rc=SSH_AGAIN;\n    break;\n  case SSH_AUTH_SERVICE_NONE:\n    rc=SSH_ERROR;\n    break;\n  }\n\n  return rc;\n}\n",
      "line_start": 353,
      "line_end": 400,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 78,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate fuzz target: it copies an external string into an SSH buffer (ssh_buffer_pack) and drives auth state transitions, so it performs memory/string operations on untrusted input and has multiple code paths. Cyclomatic complexity is modest, and the heavy parsing/crypto happens in called packet handlers rather than in this function itself, so it rates as medium priority."
    },
    {
      "name": "connector.c:ssh_connector_channel_write_wontblock_cb",
      "clean_name": "ssh_connector_channel_write_wontblock_cb",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " *\n * @param[in] userdata The ssh connector\n *\n * @returns Amount of data bytes consumed\n */\nstatic int ssh_connector_channel_write_wontblock_cb(ssh_session session,\n                                                    ssh_channel channel,\n                                                    uint32_t bytes,\n                                                    void *userdata)\n{\n    ssh_connector connector = userdata;\n    uint8_t buffer[CHUNKSIZE];\n    int r, w;\n\n    (void) channel;\n\n    SSH_LOG(SSH_LOG_TRACE, \"Channel write won't block\");\n    if (connector->in_available) {\n        if (connector->in_channel != NULL) {\n            uint32_t len = MIN(CHUNKSIZE, bytes);\n\n            r = ssh_channel_read_nonblocking(connector->in_channel,\n                                             buffer,\n                                             len,\n                                             0);\n            if (r == SSH_ERROR) {\n                ssh_connector_except_channel(connector, connector->in_channel);\n            } else if(r == 0 && ssh_channel_is_eof(connector->in_channel)){\n                ssh_channel_send_eof(connector->out_channel);\n            } else if (r > 0) {\n                w = ssh_channel_write(connector->out_channel, buffer, r);\n                if (w == SSH_ERROR) {\n                    ssh_connector_except_channel(connector,\n                                                 connector->out_channel);\n                }\n            }\n        } else if (connector->in_fd != SSH_INVALID_SOCKET) {\n            /* fallback on on the socket input callback */\n            connector->out_wontblock = 1;\n            ssh_connector_fd_in_cb(connector);\n            ssh_connector_reset_pollevents(connector);\n        } else {\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Output socket or channel closed\");\n\n            return 0;\n        }\n        connector->in_available = 0;\n        connector->out_wontblock = 0;\n    } else {\n        connector->out_wontblock = 1;\n    }\n\n    return 0;\n}\n",
      "line_start": 515,
      "line_end": 566,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Reads untrusted data into a fixed-size buffer and writes it out (memory operations on external input) and contains several branches (error, EOF, channel vs fd fallback), but it does not parse complex formats, has no input-dependent loops, and overall moderate cyclomatic complexity \u2014 medium-priority fuzz target."
    },
    {
      "name": "connector.c:ssh_connector_fd_in_cb",
      "clean_name": "ssh_connector_fd_in_cb",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "/**\n * @internal\n *\n * @brief Callback called when a poll event is received on an input fd.\n */\nstatic void ssh_connector_fd_in_cb(ssh_connector connector)\n{\n    unsigned char buffer[CHUNKSIZE];\n    uint32_t toread = CHUNKSIZE;\n    ssize_t r;\n    ssize_t w;\n    ssize_t total = 0;\n    int rc;\n\n    SSH_LOG(SSH_LOG_TRACE, \"connector POLLIN event for fd %d\", connector->in_fd);\n\n    if (connector->out_wontblock) {\n        if (connector->out_channel != NULL) {\n            uint32_t size = ssh_channel_window_size(connector->out_channel);\n\n            /* Don't attempt reading more than the window */\n            toread = MIN(size, CHUNKSIZE);\n        }\n\n        r = ssh_connector_fd_read(connector, buffer, toread);\n        if (r < 0) {\n            ssh_connector_except(connector, connector->in_fd);\n            return;\n        }\n\n        if (connector->out_channel != NULL) {\n            if (r == 0) {\n                SSH_LOG(SSH_LOG_TRACE, \"input fd %d is EOF\", connector->in_fd);\n                if (connector->out_channel->local_eof == 0) {\n                    rc = ssh_channel_send_eof(connector->out_channel);\n                    (void)rc; /* TODO Handle rc? */\n                }\n                connector->in_available = 1; /* Don't poll on it */\n                return;\n            } else if (r > 0) {\n                /* loop around ssh_channel_write in case our window reduced due to a race */\n                while (total != r){\n                    if (connector->out_flags & SSH_CONNECTOR_STDOUT) {\n                        w = ssh_channel_write(connector->out_channel,\n                                              buffer + total,\n                                              (uint32_t)(r - total));\n                    } else {\n                        w = ssh_channel_write_stderr(connector->out_channel,\n                                                     buffer + total,\n                                                     (uint32_t)(r - total));\n                    }\n                    if (w == SSH_ERROR) {\n                        return;\n                    }\n                    total += w;\n                }\n            }\n        } else if (connector->out_fd != SSH_INVALID_SOCKET) {\n            if (r == 0){\n                close(connector->out_fd);\n                connector->out_fd = SSH_INVALID_SOCKET;\n            } else {\n                /*\n                 * Loop around write in case the write blocks even for CHUNKSIZE\n                 * bytes\n                 */\n                while (total < r) {\n                    w = ssh_connector_fd_write(connector,\n                                               buffer + total,\n                                               (uint32_t)(r - total));\n                    if (w < 0) {\n                        ssh_connector_except(connector, connector->out_fd);\n                        return;\n                    }\n                    total += w;\n                }\n            }\n        } else {\n            ssh_set_error(connector->session, SSH_FATAL, \"output socket or channel closed\");\n            return;\n        }\n        connector->out_wontblock = 0;\n        connector->in_available = 0;\n    } else {\n        connector->in_available = 1;\n    }\n}\n",
      "line_start": 232,
      "line_end": 314,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 89,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Reads untrusted data into a fixed-size buffer and forwards it, with input-dependent loops and multiple branches (EOF handling, channel vs socket write paths). However it does not parse complex formats or perform crypto/auth operations and overall logic is fairly straightforward, so it is medium-priority as a fuzz target."
    },
    {
      "name": "ssh_options_copy",
      "clean_name": "ssh_options_copy",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " * @returns             0 on success, -1 on error with errno set.\n *\n * @see ssh_connect()\n * @see ssh_free()\n */\nint ssh_options_copy(ssh_session src, ssh_session *dest)\n{\n    ssh_session new = NULL;\n    struct ssh_iterator *it = NULL;\n    struct ssh_list *list = NULL;\n    char *id = NULL;\n    int i;\n\n    if (src == NULL || dest == NULL) {\n        return -1;\n    }\n\n    new = ssh_new();\n    if (new == NULL) {\n        return -1;\n    }\n\n    if (src->opts.username != NULL) {\n        new->opts.username = strdup(src->opts.username);\n        if (new->opts.username == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.host != NULL) {\n        new->opts.host = strdup(src->opts.host);\n        if (new->opts.host == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.bindaddr != NULL) {\n        new->opts.bindaddr = strdup(src->opts.bindaddr);\n        if (new->opts.bindaddr == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    /* Remove the default identities */\n    for (id = ssh_list_pop_head(char *, new->opts.identity_non_exp);\n         id != NULL;\n         id = ssh_list_pop_head(char *, new->opts.identity_non_exp)) {\n        SAFE_FREE(id);\n    }\n    /* Copy the new identities from the source list */\n    list = new->opts.identity_non_exp;\n    it = ssh_list_get_iterator(src->opts.identity_non_exp);\n    for (i = 0; i < 2; i++) {\n        while (it) {\n            int rc;\n\n            id = strdup((char *)it->data);\n            if (id == NULL) {\n                ssh_free(new);\n                return -1;\n            }\n\n            rc = ssh_list_append(list, id);\n            if (rc < 0) {\n                free(id);\n                ssh_free(new);\n                return -1;\n            }\n            it = it->next;\n        }\n\n        /* copy the identity list if there is any already */\n        list = new->opts.identity;\n        it = ssh_list_get_iterator(src->opts.identity);\n    }\n\n    list = new->opts.certificate_non_exp;\n    it = ssh_list_get_iterator(src->opts.certificate_non_exp);\n    for (i = 0; i < 2; i++) {\n        while (it) {\n            int rc;\n\n            id = strdup((char *)it->data);\n            if (id == NULL) {\n                ssh_free(new);\n                return -1;\n            }\n\n            rc = ssh_list_append(list, id);\n            if (rc < 0) {\n                free(id);\n                ssh_free(new);\n                return -1;\n            }\n            it = it->next;\n        }\n\n        /* copy the certificate list if there is any already */\n        list = new->opts.certificate;\n        it = ssh_list_get_iterator(src->opts.certificate);\n    }\n\n    if (src->opts.sshdir != NULL) {\n        new->opts.sshdir = strdup(src->opts.sshdir);\n        if (new->opts.sshdir == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.knownhosts != NULL) {\n        new->opts.knownhosts = strdup(src->opts.knownhosts);\n        if (new->opts.knownhosts == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.global_knownhosts != NULL) {\n        new->opts.global_knownhosts = strdup(src->opts.global_knownhosts);\n        if (new->opts.global_knownhosts == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        if (src->opts.wanted_methods[i] != NULL) {\n            new->opts.wanted_methods[i] = strdup(src->opts.wanted_methods[i]);\n            if (new->opts.wanted_methods[i] == NULL) {\n                ssh_free(new);\n                return -1;\n            }\n        }\n    }\n\n    if (src->opts.ProxyCommand != NULL) {\n        new->opts.ProxyCommand = strdup(src->opts.ProxyCommand);\n        if (new->opts.ProxyCommand == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.pubkey_accepted_types != NULL) {\n        new->opts.pubkey_accepted_types = strdup(src->opts.pubkey_accepted_types);\n        if (new->opts.pubkey_accepted_types == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.gss_server_identity != NULL) {\n        new->opts.gss_server_identity = strdup(src->opts.gss_server_identity);\n        if (new->opts.gss_server_identity == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.gss_client_identity != NULL) {\n        new->opts.gss_client_identity = strdup(src->opts.gss_client_identity);\n        if (new->opts.gss_client_identity == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    if (src->opts.control_path != NULL) {\n        new->opts.control_path = strdup(src->opts.control_path);\n        if (new->opts.control_path == NULL) {\n            ssh_free(new);\n            return -1;\n        }\n    }\n\n    memcpy(new->opts.options_seen, src->opts.options_seen,\n           sizeof(new->opts.options_seen));\n\n    new->opts.fd                    = src->opts.fd;\n    new->opts.port                  = src->opts.port;\n    new->opts.timeout               = src->opts.timeout;\n    new->opts.timeout_usec          = src->opts.timeout_usec;\n    new->opts.compressionlevel      = src->opts.compressionlevel;\n    new->opts.StrictHostKeyChecking = src->opts.StrictHostKeyChecking;\n    new->opts.gss_delegate_creds    = src->opts.gss_delegate_creds;\n    new->opts.flags                 = src->opts.flags;\n    new->opts.nodelay               = src->opts.nodelay;\n    new->opts.config_processed      = src->opts.config_processed;\n    new->opts.control_master        = src->opts.control_master;\n    new->common.log_verbosity       = src->common.log_verbosity;\n    new->common.callbacks           = src->common.callbacks;\n\n    *dest = new;\n\n    return 0;\n}\n",
      "line_start": 68,
      "line_end": 263,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 236,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it performs many memory operations (strdup, memcpy), iterates and copies lists (loops with input-dependent length) and has multiple branches and allocation error paths. However it is an internal copy helper (not parsing complex external formats or performing crypto/authentication) so it is medium priority for fuzzing."
    },
    {
      "name": "ssh_packet_send",
      "clean_name": "ssh_packet_send",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "    return (session->flags & SSH_SESSION_FLAG_AUTHENTICATED) &&\n           (session->dh_handshake_state != DH_STATE_FINISHED) &&\n           (session->dh_handshake_state != DH_STATE_NEWKEYS_SENT);\n}\n\nint ssh_packet_send(ssh_session session)\n{\n    uint32_t payloadsize;\n    uint8_t type, *payload;\n    bool need_rekey, in_rekey;\n    int rc;\n\n    payloadsize = ssh_buffer_get_len(session->out_buffer);\n    if (payloadsize < 1) {\n        return SSH_ERROR;\n    }\n\n    payload = (uint8_t *)ssh_buffer_get(session->out_buffer);\n    type = payload[0]; /* type is the first byte of the packet now */\n    need_rekey = ssh_packet_need_rekey(session, payloadsize);\n    in_rekey = ssh_packet_in_rekey(session);\n\n    /* The rekey is triggered here. After that, only the key exchange\n     * packets can be sent, until we send our NEWKEYS.\n     */\n    if (need_rekey || (in_rekey && !ssh_packet_is_kex(type))) {\n        if (need_rekey) {\n            SSH_LOG(SSH_LOG_PACKET, \"Outgoing packet triggered rekey\");\n        }\n        /* Queue the current packet -- we will send it after the rekey */\n        SSH_LOG(SSH_LOG_PACKET, \"Queuing packet type %d\", type);\n        rc = ssh_list_append(session->out_queue, session->out_buffer);\n        if (rc != SSH_OK) {\n            return SSH_ERROR;\n        }\n        session->out_buffer = ssh_buffer_new();\n        if (session->out_buffer == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n\n        if (need_rekey) {\n            /* Send the KEXINIT packet instead.\n             * This recursively calls the packet_send(), but it should\n             * not get into rekeying again.\n             * After that we need to handle the key exchange responses\n             * up to the point where we can send the rest of the queue.\n             */\n            return ssh_send_rekex(session);\n        }\n        return SSH_OK;\n    }\n\n    /* Send the packet normally */\n    rc = packet_send2(session);\n\n    /* We finished the key exchange so we can try to send our queue now */\n    if (rc == SSH_OK && type == SSH2_MSG_NEWKEYS) {\n        struct ssh_iterator *it = NULL;\n\n        if (session->flags & SSH_SESSION_FLAG_KEX_STRICT) {\n            /* reset packet sequence number when running in strict kex mode */\n            session->send_seq = 0;\n        }\n        for (it = ssh_list_get_iterator(session->out_queue);\n             it != NULL;\n             it = ssh_list_get_iterator(session->out_queue)) {\n            struct ssh_buffer_struct *next_buffer = NULL;\n\n            /* Peek only -- do not remove from queue yet */\n            next_buffer = (struct ssh_buffer_struct *)it->data;\n            payloadsize = ssh_buffer_get_len(next_buffer);\n            if (ssh_packet_need_rekey(session, payloadsize)) {\n                /* Sigh ... we still can not send this packet. Repeat. */\n                SSH_LOG(SSH_LOG_PACKET, \"Queued packet triggered rekey\");\n                return ssh_send_rekex(session);\n            }\n            SSH_BUFFER_FREE(session->out_buffer);\n            session->out_buffer = ssh_list_pop_head(struct ssh_buffer_struct *,\n                                                    session->out_queue);\n            payload = (uint8_t *)ssh_buffer_get(session->out_buffer);\n            type = payload[0];\n            SSH_LOG(SSH_LOG_PACKET, \"Dequeue packet type %d\", type);\n            rc = packet_send2(session);\n            if (rc != SSH_OK) {\n                return rc;\n            }\n        }\n    }\n\n    return rc;\n}\n",
      "line_start": 1933,
      "line_end": 2020,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 115,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it inspects external packet buffers (reads payload size and first byte), has branching and a queue-driven loop dependent on buffer contents, and triggers different code paths (rekey, enqueue/dequeue, send). However it does not itself perform complex parsing of external formats or low-level memory ops on untrusted data \u2014 much of the heavy work appears delegated to packet_send2/ssh_send_rekex \u2014 so it\u2019s medium priority for fuzzing."
    },
    {
      "name": "ssh_key_algorithm_allowed",
      "clean_name": "ssh_key_algorithm_allowed",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] session The SSH session\n * @param[in] type    The key algorithm to check\n * @returns           1 if the key algorithm is allowed, 0 otherwise\n */\nint ssh_key_algorithm_allowed(ssh_session session, const char *type)\n{\n    const char *allowed_list = NULL;\n\n    if (session->client) {\n        allowed_list = session->opts.pubkey_accepted_types;\n        if (allowed_list == NULL) {\n            if (ssh_fips_mode()) {\n                allowed_list = ssh_kex_get_fips_methods(SSH_HOSTKEYS);\n            } else {\n                allowed_list = ssh_kex_get_default_methods(SSH_HOSTKEYS);\n            }\n        }\n    }\n#ifdef WITH_SERVER\n    else if (session->server) {\n        allowed_list = session->opts.wanted_methods[SSH_HOSTKEYS];\n        if (allowed_list == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"Session invalid: no host key available\");\n            return 0;\n        }\n    }\n#endif /* WITH_SERVER */\n    else {\n        SSH_LOG(SSH_LOG_TRACE, \"Session invalid: not set as client nor server\");\n        return 0;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Checking %s with list <%s>\", type, allowed_list);\n    return match_group(allowed_list, type);\n}\n",
      "line_start": 413,
      "line_end": 444,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Simple policy-check wrapper: low cyclomatic complexity and no direct memory operations on untrusted data. It selects an allowed-list (from session or defaults) and delegates actual parsing/matching to match_group. It affects a security decision (algorithm allowance), so worth medium priority, but the function itself has limited surface for fuzzing."
    },
    {
      "name": "ssh_pki_generate",
      "clean_name": "ssh_pki_generate",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @warning             Generating a key pair may take some time.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_generate(enum ssh_keytypes_e type, int parameter,\n        ssh_key *pkey)\n{\n    int rc;\n    ssh_key key = ssh_key_new();\n\n    if (key == NULL) {\n        return SSH_ERROR;\n    }\n\n    key->type = type;\n    key->type_c = ssh_key_type_to_char(type);\n    key->flags = SSH_KEY_FLAG_PRIVATE | SSH_KEY_FLAG_PUBLIC;\n\n    switch(type){\n        case SSH_KEYTYPE_RSA:\n            rc = pki_key_generate_rsa(key, parameter);\n            if(rc == SSH_ERROR)\n                goto error;\n            break;\n#ifdef HAVE_ECC\n        case SSH_KEYTYPE_ECDSA: /* deprecated */\n            rc = pki_key_generate_ecdsa(key, parameter);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n\n            /* Update key type */\n            key->type_c = ssh_pki_key_ecdsa_name(key);\n            break;\n        case SSH_KEYTYPE_ECDSA_P256:\n            rc = pki_key_generate_ecdsa(key, 256);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n            break;\n        case SSH_KEYTYPE_ECDSA_P384:\n            rc = pki_key_generate_ecdsa(key, 384);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n            break;\n        case SSH_KEYTYPE_ECDSA_P521:\n            rc = pki_key_generate_ecdsa(key, 521);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n            break;\n#endif /* HAVE_ECC */\n        case SSH_KEYTYPE_ED25519:\n            rc = pki_key_generate_ed25519(key);\n            if (rc == SSH_ERROR) {\n                goto error;\n            }\n            break;\n        case SSH_KEYTYPE_RSA_CERT01:\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n        case SSH_KEYTYPE_ED25519_CERT01:\n        case SSH_KEYTYPE_SK_ECDSA:\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n        case SSH_KEYTYPE_SK_ED25519:\n        case SSH_KEYTYPE_SK_ED25519_CERT01:\n        case SSH_KEYTYPE_RSA1:\n        case SSH_KEYTYPE_UNKNOWN:\n        default:\n            goto error;\n    }\n\n    *pkey = key;\n    return SSH_OK;\nerror:\n    ssh_key_free(key);\n    return SSH_ERROR;\n}\n",
      "line_start": 2193,
      "line_end": 2269,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 93,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "This is a simple dispatcher that triggers cryptographic key generation (security-critical) but contains low cyclomatic complexity and does not parse complex external input itself. Its fuzz value depends mainly on the deeper pki_key_generate_* implementations (e.g., parameter may influence key sizes/loops), so it is medium priority as a fuzz target."
    },
    {
      "name": "ssh_poll_ctx_dopoll",
      "clean_name": "ssh_poll_ctx_dopoll",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @returns SSH_OK      No error.\n *          SSH_ERROR   Error happened during the poll.\n *          SSH_AGAIN   Timeout occurred\n */\n\nint ssh_poll_ctx_dopoll(ssh_poll_ctx ctx, int timeout)\n{\n    int rc;\n    size_t i, used;\n    ssh_poll_handle p = NULL;\n    socket_t fd;\n    int revents;\n    struct ssh_timestamp ts;\n\n    if (ctx->polls_used == 0) {\n        return SSH_ERROR;\n    }\n\n    /* Allow only POLLOUT events on locked sockets as that means we are called\n     * recursively and we only want process the POLLOUT events here to flush\n     * output buffer */\n    for (i = 0; i < ctx->polls_used; i++) {\n        /* The lock allows only POLLOUT events: drop the rest */\n        if (ssh_poll_is_locked(ctx->pollptrs[i])) {\n            ctx->pollfds[i].events &= POLLOUT;\n        }\n    }\n    ssh_timestamp_init(&ts);\n    do {\n        int tm = ssh_timeout_update(&ts, timeout);\n        rc = ssh_poll(ctx->pollfds, ctx->polls_used, tm);\n    } while (rc == -1 && errno == EINTR);\n\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\n    if (rc == 0) {\n        return SSH_AGAIN;\n    }\n\n    used = ctx->polls_used;\n    for (i = 0; i < used && rc > 0; ) {\n        revents = ctx->pollfds[i].revents;\n        /* Do not pass any other events except for POLLOUT to callback when\n         * called recursively more than 2 times. On s390x the poll will be\n         * spammed with POLLHUP events causing infinite recursion when the user\n         * callback issues some write/flush/poll calls. */\n        if (ctx->pollptrs[i]->lock_cnt > 2) {\n            revents &= POLLOUT;\n        }\n        if (revents == 0) {\n            i++;\n        } else {\n            int ret;\n\n            p = ctx->pollptrs[i];\n            fd = ctx->pollfds[i].fd;\n            /* avoid having any event caught during callback */\n            ctx->pollfds[i].events = 0;\n            p->lock_cnt++;\n            if (p->cb && (ret = p->cb(p, fd, revents, p->cb_data)) < 0) {\n                if (ret == -2) {\n                    return -1;\n                }\n                /* the poll was removed, reload the used counter and start again\n                 */\n                used = ctx->polls_used;\n                i = 0;\n            } else {\n                ctx->pollfds[i].revents = 0;\n                ctx->pollfds[i].events = p->events;\n                p->lock_cnt--;\n                i++;\n            }\n\n            rc--;\n        }\n    }\n\n    return rc;\n}\n",
      "line_start": 714,
      "line_end": 790,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 81,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate fuzz target: the function implements a non-trivial poll loop with multiple branches, input-dependent loop bounds (ctx->polls_used/used), and invokes user callbacks which can change state. However it does not parse complex external formats, perform explicit memory/string operations, or handle crypto/auth\u2014so it\u2019s useful to fuzz for logic/state bugs but is not a top-tier parsing target."
    },
    {
      "name": "poll.c:ssh_poll_ctx_resize",
      "clean_name": "ssh_poll_ctx_resize",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": "    }\n\n    SAFE_FREE(ctx);\n}\n\nstatic int ssh_poll_ctx_resize(ssh_poll_ctx ctx, size_t new_size)\n{\n    ssh_poll_handle *pollptrs = NULL;\n    ssh_pollfd_t *pollfds = NULL;\n\n    pollptrs = realloc(ctx->pollptrs, sizeof(ssh_poll_handle) * new_size);\n    if (pollptrs == NULL) {\n        /* Fail, but keep the old value to be freed later */\n        return SSH_ERROR;\n    }\n    ctx->pollptrs = pollptrs;\n\n    pollfds = realloc(ctx->pollfds, sizeof(ssh_pollfd_t) * new_size);\n    if (pollfds == NULL) {\n        if (ctx->polls_allocated == 0) {\n            /* This was initial allocation -- just free what we allocated above\n             * and fail */\n            SAFE_FREE(ctx->pollptrs);\n            return SSH_ERROR;\n        }\n        /* Try to realloc the pollptrs back to the original size */\n        pollptrs = realloc(ctx->pollptrs,\n                           sizeof(ssh_poll_handle) * ctx->polls_allocated);\n        if (pollptrs == NULL) {\n            return SSH_ERROR;\n        }\n        ctx->pollptrs = pollptrs;\n        return SSH_ERROR;\n    }\n\n    ctx->pollfds = pollfds;\n    ctx->polls_allocated = new_size;\n\n    return SSH_OK;\n}\n",
      "line_start": 567,
      "line_end": 602,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Helper that resizes internal arrays with realloc based on external new_size. It performs memory operations and has branching to handle realloc failures/rollback (moderate cyclomatic complexity). No parsing/protocol logic, but allocation-size handling could lead to integer/size-overflow or allocation-related issues, so it is a medium-priority fuzz target."
    },
    {
      "name": "ssh_handle_packets_termination",
      "clean_name": "ssh_handle_packets_termination",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *                      possible to stop polling.\n * @param[in] user      User parameter to be passed to fct termination function.\n * @returns             SSH_OK on success, SSH_AGAIN if timeout occurred,\n *                      SSH_ERROR otherwise.\n */\nint ssh_handle_packets_termination(ssh_session session,\n                                   int timeout,\n                                   ssh_termination_function fct,\n                                   void *user)\n{\n    struct ssh_timestamp ts;\n    int timeout_ms = SSH_TIMEOUT_INFINITE;\n    int tm;\n    int ret = SSH_OK;\n\n    /* If a timeout has been provided, use it */\n    if (timeout >= 0) {\n        timeout_ms = timeout;\n    } else {\n        if (ssh_is_blocking(session)) {\n            if (timeout == SSH_TIMEOUT_USER || timeout == SSH_TIMEOUT_DEFAULT) {\n                if (session->opts.timeout > 0 ||\n                    session->opts.timeout_usec > 0) {\n                    timeout_ms =\n                        ssh_make_milliseconds(session->opts.timeout,\n                                              session->opts.timeout_usec);\n                }\n            }\n        } else {\n            timeout_ms = SSH_TIMEOUT_NONBLOCKING;\n        }\n    }\n\n    /* avoid unnecessary syscall for the SSH_TIMEOUT_NONBLOCKING case */\n    if (timeout_ms != SSH_TIMEOUT_NONBLOCKING) {\n        ssh_timestamp_init(&ts);\n    }\n\n    tm = timeout_ms;\n    while(!fct(user)) {\n        ret = ssh_handle_packets(session, tm);\n        if (ret == SSH_ERROR) {\n            break;\n        }\n        if (ssh_timeout_elapsed(&ts, timeout_ms)) {\n            ret = fct(user) ? SSH_OK : SSH_AGAIN;\n            break;\n        }\n\n        tm = ssh_timeout_update(&ts, timeout_ms);\n    }\n\n    return ret;\n}\n",
      "line_start": 794,
      "line_end": 843,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 66,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it orchestrates packet handling with loops, timeouts and branching based on external parameters and a user-supplied termination callback, so it can expose control-flow issues and timing-related bugs. It does not itself parse complex external formats or perform direct memory ops on untrusted data, so it is medium priority."
    },
    {
      "name": "ssh_get_pubkey_hash",
      "clean_name": "ssh_get_pubkey_hash",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "}\n\n/**\n * @deprecated Use ssh_get_publickey_hash()\n */\nint ssh_get_pubkey_hash(ssh_session session, unsigned char **hash)\n{\n    ssh_key pubkey = NULL;\n    ssh_string pubkey_blob = NULL;\n    MD5CTX ctx = NULL;\n    unsigned char *h = NULL;\n    int rc;\n\n    if (session == NULL || hash == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* In FIPS mode, we cannot use MD5 */\n    if (ssh_fips_mode()) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"In FIPS mode MD5 is not allowed.\"\n                      \"Try ssh_get_publickey_hash() with\"\n                      \"SSH_PUBLICKEY_HASH_SHA256\");\n        return SSH_ERROR;\n    }\n\n    *hash = NULL;\n    if (session->current_crypto == NULL ||\n        session->current_crypto->server_pubkey == NULL) {\n        ssh_set_error(session, SSH_FATAL, \"No current cryptographic context\");\n        return SSH_ERROR;\n    }\n\n    rc = ssh_get_server_publickey(session, &pubkey);\n    if (rc != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_pki_export_pubkey_blob(pubkey, &pubkey_blob);\n    ssh_key_free(pubkey);\n    if (rc != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    h = calloc(MD5_DIGEST_LEN, sizeof(unsigned char));\n    if (h == NULL) {\n        SSH_STRING_FREE(pubkey_blob);\n        return SSH_ERROR;\n    }\n\n    ctx = md5_init();\n    if (ctx == NULL) {\n        SSH_STRING_FREE(pubkey_blob);\n        SAFE_FREE(h);\n        return SSH_ERROR;\n    }\n\n    rc = md5_update(ctx,\n                    ssh_string_data(pubkey_blob),\n                    ssh_string_len(pubkey_blob));\n    if (rc != SSH_OK) {\n        SSH_STRING_FREE(pubkey_blob);\n        md5_ctx_free(ctx);\n        SAFE_FREE(h);\n        return rc;\n    }\n    SSH_STRING_FREE(pubkey_blob);\n    rc = md5_final(h, ctx);\n    if (rc != SSH_OK) {\n        SAFE_FREE(h);\n        return rc;\n    }\n\n    *hash = h;\n\n    return MD5_DIGEST_LEN;\n}\n",
      "line_start": 1101,
      "line_end": 1174,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 164,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it operates on untrusted data (server public-key blob) and performs memory operations (hashing) and allocation, but the function is largely a thin wrapper that delegates parsing/complex logic to other components. Limited internal branching/complexity reduces standalone fuzz value, though underlying exporters/parsers are higher priority."
    },
    {
      "name": "pki_crypto.c:pki_signature_from_rsa_blob",
      "clean_name": "pki_signature_from_rsa_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return sig_blob;\n}\n\nstatic int pki_signature_from_rsa_blob(const ssh_key pubkey,\n                                       const ssh_string sig_blob,\n                                       ssh_signature sig)\n{\n    size_t pad_len = 0;\n    char *blob_orig = NULL;\n    char *blob_padded_data = NULL;\n    ssh_string sig_blob_padded = NULL;\n\n    size_t rsalen = 0;\n    size_t len = ssh_string_len(sig_blob);\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    const RSA *rsa = EVP_PKEY_get0_RSA(pubkey->key);\n\n    if (rsa == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"RSA field NULL\");\n        goto errout;\n    }\n\n    rsalen = RSA_size(rsa);\n#else\n    if (EVP_PKEY_get_base_id(pubkey->key) != EVP_PKEY_RSA) {\n        SSH_LOG(SSH_LOG_TRACE, \"Key has no RSA pubkey\");\n        goto errout;\n    }\n\n    rsalen = EVP_PKEY_size(pubkey->key);\n#endif /* OPENSSL_VERSION_NUMBER */\n    if (len > rsalen) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Signature is too big: %lu > %lu\",\n                (unsigned long)len,\n                (unsigned long)rsalen);\n        goto errout;\n    }\n\n#ifdef DEBUG_CRYPTO\n    SSH_LOG(SSH_LOG_DEBUG, \"RSA signature len: %lu\", (unsigned long)len);\n    ssh_log_hexdump(\"RSA signature\", ssh_string_data(sig_blob), len);\n#endif /* DEBUG_CRYPTO */\n\n    if (len == rsalen) {\n        sig->raw_sig = ssh_string_copy(sig_blob);\n    } else {\n        /* pad the blob to the expected rsalen size */\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"RSA signature len %lu < %lu\",\n                (unsigned long)len,\n                (unsigned long)rsalen);\n\n        pad_len = rsalen - len;\n\n        sig_blob_padded = ssh_string_new(rsalen);\n        if (sig_blob_padded == NULL) {\n            goto errout;\n        }\n\n        blob_padded_data = (char *) ssh_string_data(sig_blob_padded);\n        blob_orig = (char *) ssh_string_data(sig_blob);\n\n        if (blob_padded_data == NULL || blob_orig == NULL) {\n            goto errout;\n        }\n\n        /* front-pad the buffer with zeroes */\n        explicit_bzero(blob_padded_data, pad_len);\n        /* fill the rest with the actual signature blob */\n        memcpy(blob_padded_data + pad_len, blob_orig, len);\n\n        sig->raw_sig = sig_blob_padded;\n    }\n\n    return SSH_OK;\n\nerrout:\n    SSH_STRING_FREE(sig_blob_padded);\n    return SSH_ERROR;\n}\n",
      "line_start": 2154,
      "line_end": 2233,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Processes untrusted signature blob and performs memory operations (explicit_bzero, memcpy) and conditional padding; interacts with crypto key structures but is relatively simple (few branches, no complex parsing or loops). Medium-value fuzz target."
    },
    {
      "name": "ssh_client_ecdh_init",
      "clean_name": "ssh_client_ecdh_init",
      "source_file": "/src/libssh/src/ecdh_crypto.c",
      "source_code": "}\n\n/** @internal\n * @brief Starts ecdh-sha2-nistp256 key exchange\n */\nint ssh_client_ecdh_init(ssh_session session)\n{\n    ssh_string client_pubkey = NULL;\n    int rc;\n\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_KEX_ECDH_INIT);\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\n\n    client_pubkey = ssh_ecdh_generate(session);\n    if (client_pubkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, client_pubkey);\n    if (rc < 0) {\n        ssh_string_free(client_pubkey);\n        return SSH_ERROR;\n    }\n\n    ssh_string_free(session->next_crypto->ecdh_client_pubkey);\n    session->next_crypto->ecdh_client_pubkey = client_pubkey;\n\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_ecdh_client_callbacks);\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n\n    rc = ssh_packet_send(session);\n\n    return rc;\n}\n",
      "line_start": 211,
      "line_end": 243,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Initiates ECDH key exchange and performs crypto and buffer/string operations (memory copies, allocation/free), so it can exercise security-critical code paths; however it contains little input parsing, low branching complexity, and no direct handling of external input, making it a moderate-value fuzz target."
    },
    {
      "name": "ssh_handle_key_exchange",
      "clean_name": "ssh_handle_key_exchange",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    rc = ssh_packet_send(session);\n    return rc;\n}\n\n/* Do the banner and key exchange */\nint ssh_handle_key_exchange(ssh_session session)\n{\n    int rc;\n\n    if (session->session_state != SSH_SESSION_STATE_NONE) {\n        goto pending;\n    }\n\n    rc = ssh_send_banner(session, 1);\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\n\n    session->alive = 1;\n\n    session->ssh_connection_callback = ssh_server_connection_callback;\n    session->session_state = SSH_SESSION_STATE_SOCKET_CONNECTED;\n    ssh_socket_set_callbacks(session->socket,&session->socket_callbacks);\n    session->socket_callbacks.data = callback_receive_banner;\n    session->socket_callbacks.exception = ssh_socket_exception_callback;\n    session->socket_callbacks.userdata = session;\n\n    rc = server_set_kex(session);\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\npending:\n    rc = ssh_handle_packets_termination(session, SSH_TIMEOUT_USER,\n                                        ssh_server_kex_termination,session);\n    SSH_LOG(SSH_LOG_PACKET, \"ssh_handle_key_exchange: current state : %d\",\n            session->session_state);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n    if (session->session_state == SSH_SESSION_STATE_ERROR ||\n        session->session_state == SSH_SESSION_STATE_DISCONNECTED) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 567,
      "line_end": 608,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 49,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Orchestrates a security\u2011critical operation (SSH key exchange) and sets callbacks that will drive complex parsing later, but the function itself does not parse external data or perform memory operations on untrusted input. It mainly checks session state, sends a banner, configures callbacks, and invokes server_set_kex/packet handling. Useful as part of a larger target (medium priority) but not a top standalone fuzz target."
    },
    {
      "name": "ssh_execute_message_callbacks",
      "clean_name": "ssh_execute_message_callbacks",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "        void *data) {\n  session->ssh_message_callback = ssh_bind_message_callback;\n  session->ssh_message_callback_data = data;\n}\n\nint ssh_execute_message_callbacks(ssh_session session){\n  ssh_message msg=NULL;\n  int ret;\n  ssh_handle_packets(session, SSH_TIMEOUT_NONBLOCKING);\n  if(!session->ssh_message_list)\n    return SSH_OK;\n  if(session->ssh_message_callback){\n    while((msg=ssh_message_pop_head(session)) != NULL) {\n      ret=session->ssh_message_callback(session,msg,\n                                        session->ssh_message_callback_data);\n      if(ret==1){\n        ret = ssh_message_reply_default(msg);\n        ssh_message_free(msg);\n        if(ret != SSH_OK)\n          return ret;\n      } else {\n        ssh_message_free(msg);\n      }\n    }\n  } else {\n    while((msg=ssh_message_pop_head(session)) != NULL) {\n      ret = ssh_message_reply_default(msg);\n      ssh_message_free(msg);\n      if(ret != SSH_OK)\n        return ret;\n    }\n  }\n  return SSH_OK;\n}\n",
      "line_start": 1256,
      "line_end": 1285,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 6.0,
      "reason": "Moderate-value fuzz target: it iterates over and dispatches SSH messages from the network and calls user callbacks (external input-driven loop and multiple code paths), but it does not itself perform complex parsing or memory-manipulating operations. Useful as a harness entrypoint to drive deeper parsers/handlers, but not a critical/high-priority target on its own."
    },
    {
      "name": "bignum.c:make_bignum_string",
      "clean_name": "make_bignum_string",
      "source_file": "/src/libssh/src/bignum.c",
      "source_code": "\n#include \"libssh/priv.h\"\n#include \"libssh/bignum.h\"\n#include \"libssh/string.h\"\n\nstatic ssh_string make_bignum_string(bignum num, size_t pad_to_len)\n{\n    ssh_string ptr = NULL;\n    size_t pad = 0;\n    size_t len = bignum_num_bytes(num);\n    size_t bits = bignum_num_bits(num);\n\n    if (pad_to_len == 0) {\n        /* If the first bit is set we have a negative number */\n        if (!(bits % 8) && bignum_is_bit_set(num, bits - 1)) {\n            pad++;\n        }\n    } else {\n        if (len > pad_to_len) {\n            return NULL;\n        }\n        pad = pad_to_len - len;\n    }\n\n#ifdef DEBUG_CRYPTO\n    SSH_LOG(SSH_LOG_TRACE, \"%zu bits, %zu bytes, %zu padding\", bits, len, pad);\n#endif /* DEBUG_CRYPTO */\n\n    ptr = ssh_string_new(len + pad);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    /* We have a negative number so we need a leading zero */\n    if (pad) {\n        memset(ptr->data, 0, pad);\n    }\n\n    bignum_bn2bin(num, len, ptr->data + pad);\n\n    return ptr;\n}\n",
      "line_start": 29,
      "line_end": 66,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 46,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Moderate fuzzing value: it performs memory operations (memset + bignum_bn2bin) and has input-dependent sizing/padding logic based on the bignum and pad_to_len, so allocation/overflow/length bugs are possible. However it is a small helper with low cyclomatic complexity and no complex parsing of external formats, so it is medium priority."
    },
    {
      "name": "config.c:ssh_config_make_absolute",
      "clean_name": "ssh_config_make_absolute",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "    SAFE_FREE(c);\n    return rv;\n}\n\nstatic char *\nssh_config_make_absolute(ssh_session session,\n                         const char *path,\n                         bool global)\n{\n    size_t outlen = 0;\n    char *out = NULL;\n    int rv;\n\n    /* Looks like absolute path */\n    if (path[0] == '/') {\n        return strdup(path);\n    }\n\n    /* relative path */\n    if (global) {\n        /* Parsing global config */\n        outlen = strlen(path) + strlen(\"/etc/ssh/\") + 1;\n        out = malloc(outlen);\n        if (out == NULL) {\n            ssh_set_error_oom(session);\n            return NULL;\n        }\n        rv = snprintf(out, outlen, \"/etc/ssh/%s\", path);\n        if (rv < 1) {\n            free(out);\n            return NULL;\n        }\n        return out;\n    }\n\n    /* paths starting with tilde are already absolute */\n    if (path[0] == '~') {\n        return ssh_path_expand_tilde(path);\n    }\n\n    /* Parsing user config relative to home directory (generally ~/.ssh) */\n    if (session->opts.sshdir == NULL) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n    outlen = strlen(path) + strlen(session->opts.sshdir) + 1 + 1;\n    out = malloc(outlen);\n    if (out == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    rv = snprintf(out, outlen, \"%s/%s\", session->opts.sshdir, path);\n    if (rv < 1) {\n        free(out);\n        return NULL;\n    }\n    return out;\n}\n",
      "line_start": 589,
      "line_end": 642,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Helper that constructs absolute paths from untrusted input: it does heap allocation and snprintf based on strlen(path) and session state and has multiple branches (absolute, tilde, global, user). This makes it a medium-priority fuzz target because it performs memory operations on external data and has some branching, and contains subtle issues to find (size calculation/truncation or size_t overflow), but it does not parse a complex file/protocol or contain heavy control-flow complexity."
    },
    {
      "name": "config.c:local_parse_glob",
      "clean_name": "local_parse_glob",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "    fclose(f);\n    return;\n}\n\n#if defined(HAVE_GLOB) && defined(HAVE_GLOB_GL_FLAGS_MEMBER)\nstatic void local_parse_glob(ssh_session session,\n                             const char *fileglob,\n                             int *parsing,\n                             unsigned int depth,\n                             bool global)\n{\n    glob_t globbuf = {\n        .gl_flags = 0,\n    };\n    int rt;\n    size_t i;\n\n    rt = glob(fileglob, GLOB_TILDE, NULL, &globbuf);\n    if (rt == GLOB_NOMATCH) {\n        globfree(&globbuf);\n        return;\n    } else if (rt != 0) {\n        SSH_LOG(SSH_LOG_RARE, \"Glob error: %s\",\n                fileglob);\n        globfree(&globbuf);\n        return;\n    }\n\n    for (i = 0; i < globbuf.gl_pathc; i++) {\n        local_parse_file(session, globbuf.gl_pathv[i], parsing, depth, global);\n    }\n\n    globfree(&globbuf);\n}\n",
      "line_start": 247,
      "line_end": 276,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 6.0,
      "reason": "Takes untrusted input (fileglob) and feeds it to glob(), then iterates over results and calls local_parse_file for each match \u2014 so it can reach file-parsing code and has an input-dependent loop. However, the function itself is simple glue logic with low internal complexity and most parsing/attack surface is delegated to glob() and local_parse_file, so it is a medium-priority fuzz target."
    },
    {
      "name": "ssh_socket_unix",
      "clean_name": "ssh_socket_unix",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "    SSH_BUFFER_FREE(s->in_buffer);\n    SSH_BUFFER_FREE(s->out_buffer);\n    SAFE_FREE(s);\n}\n\nint ssh_socket_unix(ssh_socket s, const char *path)\n{\n    struct sockaddr_un sunaddr;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n    socket_t fd;\n    sunaddr.sun_family = AF_UNIX;\n    snprintf(sunaddr.sun_path, sizeof(sunaddr.sun_path), \"%s\", path);\n\n    fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd == SSH_INVALID_SOCKET) {\n        ssh_set_error(s->session, SSH_FATAL,\n                      \"Error from socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_ERROR;\n    }\n\n#ifndef _WIN32\n    if (fcntl(fd, F_SETFD, 1) == -1) {\n        ssh_set_error(s->session, SSH_FATAL,\n                      \"Error from fcntl(fd, F_SETFD, 1): %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        CLOSE_SOCKET(fd);\n        return SSH_ERROR;\n    }\n#endif\n\n    if (connect(fd, (struct sockaddr *) &sunaddr, sizeof(sunaddr)) < 0) {\n        ssh_set_error(s->session, SSH_FATAL, \"Error from connect(%s): %s\",\n                      path,\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        CLOSE_SOCKET(fd);\n        return SSH_ERROR;\n    }\n    return ssh_socket_set_fd(s, fd);\n}\n",
      "line_start": 432,
      "line_end": 467,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 65,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Takes external input (a UNIX socket path) and uses it in a bounded snprintf and connect(), but contains simple logic and few branches. No complex parsing, heavy memory manipulation, or crypto; environment/system-call dependence gives some value for fuzzing (triggering connect/fcntl error paths), but overall low-to-moderate complexity and attack surface."
    },
    {
      "name": "ssh_socket_write",
      "clean_name": "ssh_socket_write",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "/** \\internal\n * \\brief buffered write of data\n * \\returns SSH_OK, or SSH_ERROR\n * \\warning has no effect on socket before a flush\n */\nint ssh_socket_write(ssh_socket s, const void *buffer, uint32_t len)\n{\n    if (len > 0) {\n        if (ssh_buffer_add_data(s->out_buffer, buffer, len) < 0) {\n            ssh_set_error_oom(s->session);\n            return SSH_ERROR;\n        }\n        ssh_socket_nonblocking_flush(s);\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 673,
      "line_end": 685,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple wrapper that writes caller-provided bytes into an output buffer and triggers a flush. It delegates the real memory operations and error handling to ssh_buffer_add_data and ssh_socket_nonblocking_flush, has minimal branching/logic, and no parsing or protocol handling itself \u2014 useful to fuzz as a sink but not a high-priority complex target."
    },
    {
      "name": "ssh_socket_nonblocking_flush",
      "clean_name": "ssh_socket_nonblocking_flush",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n/** \\internal\n * \\brief starts a nonblocking flush of the output buffer\n *\n */\nint ssh_socket_nonblocking_flush(ssh_socket s)\n{\n    ssh_session session = s->session;\n    uint32_t len;\n\n    if (!ssh_socket_is_open(s)) {\n        session->alive = 0;\n        if (s->callbacks && s->callbacks->exception) {\n            s->callbacks->exception(SSH_SOCKET_EXCEPTION_ERROR,\n                                    s->last_errno,\n                                    s->callbacks->userdata);\n        } else {\n            char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n            ssh_set_error(session,\n                          SSH_FATAL,\n                          \"Writing packet: error on socket (or connection \"\n                          \"closed): %s\",\n                          ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        }\n\n        return SSH_ERROR;\n    }\n\n    len = ssh_buffer_get_len(s->out_buffer);\n    if (!s->write_wontblock && s->poll_handle && len > 0) {\n        /* force the poll system to catch pollout events */\n        ssh_poll_add_events(s->poll_handle, POLLOUT);\n\n        return SSH_AGAIN;\n    }\n\n    if (s->write_wontblock && len > 0) {\n        ssize_t bwritten;\n\n        bwritten = ssh_socket_unbuffered_write(s,\n                                               ssh_buffer_get(s->out_buffer),\n                                               len);\n        if (bwritten < 0) {\n            session->alive = 0;\n            ssh_socket_close(s);\n\n            if (s->callbacks && s->callbacks->exception) {\n                s->callbacks->exception(SSH_SOCKET_EXCEPTION_ERROR,\n                                        s->last_errno,\n                                        s->callbacks->userdata);\n            } else {\n                char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n                ssh_set_error(session,\n                              SSH_FATAL,\n                              \"Writing packet: error on socket (or connection \"\n                              \"closed): %s\",\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n            }\n\n            return SSH_ERROR;\n        }\n\n        ssh_buffer_pass_bytes(s->out_buffer, (uint32_t)bwritten);\n        if (s->session->socket_counter != NULL) {\n            s->session->socket_counter->out_bytes += bwritten;\n        }\n    }\n\n    /* Is there some data pending? */\n    len = ssh_buffer_get_len(s->out_buffer);\n    if (s->poll_handle && len > 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"did not send all the data, queuing pollout event\");\n        /* force the poll system to catch pollout events */\n        ssh_poll_add_events(s->poll_handle, POLLOUT);\n\n        return SSH_AGAIN;\n    }\n\n    /* all data written */\n    return SSH_OK;\n}\n",
      "line_start": 691,
      "line_end": 768,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 94,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzz target: the function exercises buffer and socket I/O, has multiple branches and error paths (open/closed, nonblocking vs blocking, poll handling, write errors) and manipulates buffer lengths, but it does not parse complex external formats, perform crypto/auth, or directly operate on raw external input. It is a helper with moderate complexity and requires constructing internal socket/session state to reach interesting code paths."
    },
    {
      "name": "hmac_init",
      "clean_name": "hmac_init",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    return sshkdf_derive_key(crypto, key, key_len,\n                             key_type, output, requested_len);\n}\n#endif /* HAVE_OPENSSL_EVP_KDF_CTX */\n\nHMACCTX hmac_init(const void *key, size_t len, enum ssh_hmac_e type)\n{\n    HMACCTX ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    int rc = -1;\n\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL) {\n        return NULL;\n    }\n\n    pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key, (int)len);\n    if (pkey == NULL) {\n        goto error;\n    }\n\n    switch (type) {\n    case SSH_HMAC_SHA1:\n        rc = EVP_DigestSignInit(ctx, NULL, EVP_sha1(), NULL, pkey);\n        break;\n    case SSH_HMAC_SHA256:\n        rc = EVP_DigestSignInit(ctx, NULL, EVP_sha256(), NULL, pkey);\n        break;\n    case SSH_HMAC_SHA512:\n        rc = EVP_DigestSignInit(ctx, NULL, EVP_sha512(), NULL, pkey);\n        break;\n    case SSH_HMAC_MD5:\n        rc = EVP_DigestSignInit(ctx, NULL, EVP_md5(), NULL, pkey);\n        break;\n    default:\n        rc = -1;\n        break;\n    }\n\n    EVP_PKEY_free(pkey);\n    if (rc != 1) {\n        goto error;\n    }\n    return ctx;\n\nerror:\n    EVP_MD_CTX_free(ctx);\n    return NULL;\n}\n",
      "line_start": 340,
      "line_end": 384,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper around OpenSSL HMAC init that takes untrusted key bytes and a type enum but does little parsing or complex logic. Low branching (simple switch), no loops or direct buffer manipulation in this function \u2014 useful to exercise crypto API but moderate fuzz priority (helper-level)."
    },
    {
      "name": "libcrypto.c:evp_cipher_init",
      "clean_name": "evp_cipher_init",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    }\n\n    return rc;\n}\n\nstatic void evp_cipher_init(struct ssh_cipher_struct *cipher)\n{\n    if (cipher->ctx == NULL) {\n        cipher->ctx = EVP_CIPHER_CTX_new();\n    } else {\n        EVP_CIPHER_CTX_init(cipher->ctx);\n    }\n\n    switch(cipher->ciphertype){\n    case SSH_AES128_CBC:\n        cipher->cipher = EVP_aes_128_cbc();\n        break;\n    case SSH_AES192_CBC:\n        cipher->cipher = EVP_aes_192_cbc();\n        break;\n    case SSH_AES256_CBC:\n        cipher->cipher = EVP_aes_256_cbc();\n        break;\n    case SSH_AES128_CTR:\n        cipher->cipher = EVP_aes_128_ctr();\n        break;\n    case SSH_AES192_CTR:\n        cipher->cipher = EVP_aes_192_ctr();\n        break;\n    case SSH_AES256_CTR:\n        cipher->cipher = EVP_aes_256_ctr();\n        break;\n    case SSH_AEAD_AES128_GCM:\n        cipher->cipher = EVP_aes_128_gcm();\n        break;\n    case SSH_AEAD_AES256_GCM:\n        cipher->cipher = EVP_aes_256_gcm();\n        break;\n    case SSH_3DES_CBC:\n        cipher->cipher = EVP_des_ede3_cbc();\n        break;\n#ifdef HAVE_BLOWFISH\n    case SSH_BLOWFISH_CBC:\n        cipher->cipher = EVP_bf_cbc();\n        break;\n        /* ciphers not using EVP */\n#endif /* HAVE_BLOWFISH */\n    case SSH_AEAD_CHACHA20_POLY1305:\n        SSH_LOG(SSH_LOG_TRACE, \"The ChaCha cipher cannot be handled here\");\n        break;\n    case SSH_NO_CIPHER:\n        SSH_LOG(SSH_LOG_TRACE, \"No valid ciphertype found\");\n        break;\n    }\n}\n",
      "line_start": 403,
      "line_end": 453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple initializer: allocates/initializes an EVP_CIPHER_CTX and picks a cipher based on an enum. No parsing of complex external input, no loops or buffer manipulation on untrusted data, and limited branching. It touches crypto primitives (selection/initialization) but does not perform cryptographic operations or parse user-controlled data, so it's a medium-priority fuzz target."
    },
    {
      "name": "bind.c:bind_socket",
      "clean_name": "bind_socket",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "#include <netdb.h>\n#define SOCKOPT_TYPE_ARG4 int\n\n#endif /* _WIN32 */\n\nstatic socket_t bind_socket(ssh_bind sshbind, const char *hostname,\n    int port) {\n    char port_c[6];\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int opt = 1;\n    socket_t s;\n    int rc;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n    ZERO_STRUCT(hints);\n\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    snprintf(port_c, 6, \"%d\", port);\n    rc = getaddrinfo(hostname, port_c, &hints, &ai);\n    if (rc != 0) {\n        ssh_set_error(sshbind,\n                      SSH_FATAL,\n                      \"Resolving %s: %s\", hostname, gai_strerror(rc));\n        return -1;\n    }\n\n    s = socket (ai->ai_family,\n                           ai->ai_socktype,\n                           ai->ai_protocol);\n    if (s == SSH_INVALID_SOCKET) {\n        ssh_set_error(sshbind, SSH_FATAL, \"%s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        freeaddrinfo (ai);\n        return -1;\n    }\n\n    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n                   (char *)&opt, sizeof(opt)) < 0) {\n        ssh_set_error(sshbind,\n                      SSH_FATAL,\n                      \"Setting socket options failed: %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        freeaddrinfo (ai);\n        CLOSE_SOCKET(s);\n        return -1;\n    }\n\n    if (bind(s, ai->ai_addr, ai->ai_addrlen) != 0) {\n        ssh_set_error(sshbind,\n                      SSH_FATAL,\n                      \"Binding to %s:%d: %s\",\n                      hostname,\n                      port,\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        freeaddrinfo (ai);\n        CLOSE_SOCKET(s);\n        return -1;\n    }\n\n    freeaddrinfo (ai);\n    return s;\n}\n",
      "line_start": 73,
      "line_end": 133,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Accepts untrusted hostname and port and exercises system/network calls (getaddrinfo, socket, setsockopt, bind) with multiple error branches, but contains no complex parsing, heavy memory manipulation, or crypto. Moderate value as a fuzz target (tests error paths) but not high-priority for deep memory-corruption discovery."
    },
    {
      "name": "ssh_bind_config_parse_file",
      "clean_name": "ssh_bind_config_parse_file",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "\n    SAFE_FREE(x);\n    return rc;\n}\n\nint ssh_bind_config_parse_file(ssh_bind bind, const char *filename)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    unsigned int count = 0;\n    FILE *f = NULL;\n    uint32_t parser_flags;\n    int rv;\n\n    /* This local table is used during the parsing of the current file (and\n     * files included recursively in this file) to prevent an option to be\n     * redefined, i.e. the first value set is kept. But this DO NOT prevent the\n     * option to be redefined later by another file. */\n    uint8_t seen[BIND_CFG_MAX] = {0};\n\n    f = fopen(filename, \"r\");\n    if (f == NULL) {\n        return 0;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"Reading configuration data from %s\", filename);\n\n    parser_flags = PARSING;\n    while (fgets(line, sizeof(line), f)) {\n        count++;\n        rv = ssh_bind_config_parse_line(bind, line, count, &parser_flags, seen, 0);\n        if (rv) {\n            fclose(f);\n            return -1;\n        }\n    }\n\n    fclose(f);\n    return 0;\n}\n",
      "line_start": 624,
      "line_end": 658,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Reads external file line-by-line (untrusted input) and loops over input, but contains minimal parsing/logic itself and mainly delegates work to ssh_bind_config_parse_line. Low cyclomatic complexity and no direct unsafe memory manipulation here (uses fgets with bounded buffer). Fuzzing value is moderate \u2014 more value lies in the called parser function."
    },
    {
      "name": "bind_config.c:local_parse_file",
      "clean_name": "local_parse_file",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "                           uint8_t *seen,\n                           unsigned int depth);\n\n#define LIBSSH_BIND_CONF_MAX_DEPTH 16\nstatic void\nlocal_parse_file(ssh_bind bind,\n                 const char *filename,\n                 uint32_t *parser_flags,\n                 uint8_t *seen,\n                 unsigned int depth)\n{\n    FILE *f = NULL;\n    char line[MAX_LINE_SIZE] = {0};\n    unsigned int count = 0;\n    int rv;\n\n    if (depth > LIBSSH_BIND_CONF_MAX_DEPTH) {\n        ssh_set_error(bind, SSH_FATAL,\n                      \"ERROR - Too many levels of configuration includes \"\n                      \"when processing file '%s'\", filename);\n        return;\n    }\n\n    f = fopen(filename, \"r\");\n    if (f == NULL) {\n        SSH_LOG(SSH_LOG_RARE, \"Cannot find file %s to load\",\n                filename);\n        return;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"Reading additional configuration data from %s\",\n            filename);\n\n    while (fgets(line, sizeof(line), f)) {\n        count++;\n        rv = ssh_bind_config_parse_line(bind, line, count, parser_flags, seen, depth);\n        if (rv < 0) {\n            fclose(f);\n            return;\n        }\n    }\n\n    fclose(f);\n    return;\n}\n",
      "line_start": 196,
      "line_end": 236,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "This function reads untrusted file data and iterates over lines, but is largely a thin wrapper that delegates actual parsing to ssh_bind_config_parse_line. It has low cyclomatic complexity, uses bounded fgets (avoiding direct buffer overrun here), and only simple control flow (depth check, loop, error handling). Useful to exercise the real parser, but the function itself is medium-value as a fuzz target."
    },
    {
      "name": "ssh_userauth_none",
      "clean_name": "ssh_userauth_none",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @note Most server implementations do not permit changing the username during\n * authentication. The username should only be set with ssh_options_set() only\n * before you connect to the server.\n */\nint ssh_userauth_none(ssh_session session, const char *username)\n{\n    int rc;\n\n    switch (session->pending_call_state) {\n        case SSH_PENDING_CALL_NONE:\n            break;\n        case SSH_PENDING_CALL_AUTH_NONE:\n            goto pending;\n        default:\n            ssh_set_error(session, SSH_FATAL,\n                          \"Wrong state (%d) during pending SSH call\",\n                          session->pending_call_state);\n            return SSH_AUTH_ERROR;\n    }\n\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* request */\n    rc = ssh_buffer_pack(session->out_buffer, \"bsss\",\n            SSH2_MSG_USERAUTH_REQUEST,\n            username ? username : session->opts.username,\n            \"ssh-connection\",\n            \"none\"\n            );\n    if (rc < 0) {\n        goto fail;\n    }\n\n    session->auth.current_method = SSH_AUTH_METHOD_NONE;\n    session->auth.state = SSH_AUTH_STATE_AUTH_NONE_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_NONE;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n\n    return rc;\nfail:\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 409,
      "line_end": 464,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate value as a fuzz target: the function coordinates SSH auth (constructs a userauth request, writes into buffers and triggers packet send/response) and has several branches/state checks, but it does not parse complex external input itself nor perform substantial unsafe memory operations. Likely useful when exercised as part of a larger stateful SSH session fuzz harness, but by itself is a helper with limited direct exposure to complex input parsing."
    },
    {
      "name": "ssh_userauth_agent_pubkey",
      "clean_name": "ssh_userauth_agent_pubkey",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "\n    return SSH_AUTH_ERROR;\n}\n\n/* LEGACY */\nint ssh_userauth_agent_pubkey(ssh_session session,\n                              const char *username,\n                              ssh_public_key publickey)\n{\n    ssh_key key = NULL;\n    int rc;\n\n    key = ssh_key_new();\n    if (key == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n\n    key->type = publickey->type;\n    key->type_c = ssh_key_type_to_char(key->type);\n    key->flags = SSH_KEY_FLAG_PUBLIC;\n#if defined(HAVE_LIBMBEDCRYPTO)\n    key->pk = publickey->rsa_pub;\n#elif defined(HAVE_LIBCRYPTO)\n    key->key = publickey->key_pub;\n#else\n    key->rsa = publickey->rsa_pub;\n#endif /* HAVE_LIBCRYPTO */\n\n    rc = ssh_userauth_agent_publickey(session, username, key);\n\n#if defined(HAVE_LIBMBEDCRYPTO)\n    key->pk = NULL;\n#elif defined(HAVE_LIBCRYPTO)\n    key->key = NULL;\n#else\n    key->rsa = NULL;\n#endif /* HAVE_LIBCRYPTO */\n    ssh_key_free(key);\n\n    return rc;\n}\n",
      "line_start": 1781,
      "line_end": 1817,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Legacy wrapper with minimal logic: allocates a key struct, assigns pointer fields from an input publickey and forwards to ssh_userauth_agent_publickey. It touches memory allocation and pointer manipulation but contains little parsing, branching, or input-dependent loops. Most security/crypto work likely happens in the callee, so this function is a medium-priority fuzz target."
    },
    {
      "name": "ssh_kbdint_free",
      "clean_name": "ssh_kbdint_free",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "\n    return kbd;\n}\n\n\nvoid ssh_kbdint_free(ssh_kbdint kbd)\n{\n    size_t i, n;\n\n    if (kbd == NULL) {\n        return;\n    }\n\n    SAFE_FREE(kbd->name);\n    SAFE_FREE(kbd->instruction);\n    SAFE_FREE(kbd->echo);\n\n    n = kbd->nprompts;\n    if (kbd->prompts) {\n        for (i = 0; i < n; i++) {\n            if (kbd->prompts[i] != NULL) {\n                explicit_bzero(kbd->prompts[i], strlen(kbd->prompts[i]));\n            }\n            SAFE_FREE(kbd->prompts[i]);\n        }\n        SAFE_FREE(kbd->prompts);\n    }\n\n    n = kbd->nanswers;\n    if (kbd->answers) {\n        for (i = 0; i < n; i++) {\n            if (kbd->answers[i] != NULL) {\n                explicit_bzero(kbd->answers[i], strlen(kbd->answers[i]));\n            }\n            SAFE_FREE(kbd->answers[i]);\n        }\n        SAFE_FREE(kbd->answers);\n    }\n\n    SAFE_FREE(kbd);\n}\n",
      "line_start": 1831,
      "line_end": 1867,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 98,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium priority: a cleanup/free function that performs memory operations and loops based on fields in the ssh_kbdint struct. It does not parse external file/protocol formats, but it reads nprompts/nanswers and calls strlen on pointers and frees arrays \u2014 these behaviours can trigger OOB reads/crashes with malformed/untrusted struct data, so it is a reasonable but not top-priority fuzz target."
    },
    {
      "name": "ssh_userauth_kbdint_setanswer",
      "clean_name": "ssh_userauth_kbdint_setanswer",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *                      UTF-8.\n *\n * @return              0 on success, < 0 on error.\n */\nint\nssh_userauth_kbdint_setanswer(ssh_session session, unsigned int i,\n                              const char *answer)\n{\n    if (session == NULL) {\n        return -1;\n    }\n    if (answer == NULL || session->kbdint == NULL ||\n            i >= session->kbdint->nprompts) {\n        ssh_set_error_invalid(session);\n        return -1;\n    }\n\n    if (session->kbdint->answers == NULL) {\n        session->kbdint->answers = calloc(session->kbdint->nprompts, sizeof(char *));\n        if (session->kbdint->answers == NULL) {\n            ssh_set_error_oom(session);\n            return -1;\n        }\n    }\n\n    if (session->kbdint->answers[i]) {\n        explicit_bzero(session->kbdint->answers[i],\n                strlen(session->kbdint->answers[i]));\n        SAFE_FREE(session->kbdint->answers[i]);\n    }\n\n    session->kbdint->answers[i] = strdup(answer);\n    if (session->kbdint->answers[i] == NULL) {\n        ssh_set_error_oom(session);\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 2353,
      "line_end": 2387,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 59,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Helper function with low cyclomatic complexity that mostly allocates/frees and copies an untrusted C string. It does perform memory operations on external input (strdup, explicit_bzero, free) and has index bounds checks, so it has some value for fuzzing, but it lacks complex parsing, loops, or many input-dependent branches \u2014 moderate priority."
    },
    {
      "name": "ssh_userauth_gssapi",
      "clean_name": "ssh_userauth_gssapi",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *                            have to use another method\\n\n *          SSH_AUTH_SUCCESS: Authentication success\\n\n *          SSH_AUTH_AGAIN:   In nonblocking mode, you've got to call this again\n *                            later.\n */\nint ssh_userauth_gssapi(ssh_session session)\n{\n    int rc = SSH_AUTH_DENIED;\n#ifdef WITH_GSSAPI\n    switch(session->pending_call_state) {\n    case SSH_PENDING_CALL_NONE:\n        break;\n    case SSH_PENDING_CALL_AUTH_GSSAPI_MIC:\n        goto pending;\n    default:\n        ssh_set_error(session,\n                SSH_FATAL,\n                \"Wrong state (%d) during pending SSH call\",\n                session->pending_call_state);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    } else if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"Authenticating with gssapi-with-mic\");\n\n    session->auth.current_method = SSH_AUTH_METHOD_GSSAPI_MIC;\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_GSSAPI_MIC;\n    rc = ssh_gssapi_auth_mic(session);\n\n    if (rc == SSH_AUTH_ERROR || rc == SSH_AUTH_DENIED) {\n        session->auth.state = SSH_AUTH_STATE_NONE;\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n        return rc;\n    }\n\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN) {\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    }\n#else\n    (void) session; /* unused */\n#endif\n    return rc;\n}\n",
      "line_start": 2401,
      "line_end": 2447,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a coordinator/state-machine for GSSAPI auth with branching and state transitions and calls into other auth/IO routines, but it does not itself parse complex external input or perform memory/buffer operations on untrusted data. Moderate fuzz value (medium priority) because the real parsing likely happens in the called functions."
    },
    {
      "name": "auth.c:ssh_userauth_get_response",
      "clean_name": "ssh_userauth_get_response",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *                           of authentication is needed.\n *          SSH_AUTH_INFO    Data for keyboard-interactive\n *          SSH_AUTH_AGAIN   In nonblocking mode, call has to be made again\n *          SSH_AUTH_ERROR   Error during the process.\n */\nstatic int ssh_userauth_get_response(ssh_session session)\n{\n    int rc = SSH_AUTH_ERROR;\n\n    rc = ssh_handle_packets_termination(session, SSH_TIMEOUT_USER,\n        ssh_auth_response_termination, session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\n    if (!ssh_auth_response_termination(session)) {\n        return SSH_AUTH_AGAIN;\n    }\n\n    switch(session->auth.state) {\n        case SSH_AUTH_STATE_ERROR:\n            rc = SSH_AUTH_ERROR;\n            break;\n        case SSH_AUTH_STATE_FAILED:\n            rc = SSH_AUTH_DENIED;\n            break;\n        case SSH_AUTH_STATE_INFO:\n            rc = SSH_AUTH_INFO;\n            break;\n        case SSH_AUTH_STATE_PARTIAL:\n            rc = SSH_AUTH_PARTIAL;\n            break;\n        case SSH_AUTH_STATE_PK_OK:\n        case SSH_AUTH_STATE_SUCCESS:\n            rc = SSH_AUTH_SUCCESS;\n            break;\n        case SSH_AUTH_STATE_KBDINT_SENT:\n        case SSH_AUTH_STATE_GSSAPI_REQUEST_SENT:\n        case SSH_AUTH_STATE_GSSAPI_TOKEN:\n        case SSH_AUTH_STATE_GSSAPI_MIC_SENT:\n        case SSH_AUTH_STATE_PUBKEY_OFFER_SENT:\n        case SSH_AUTH_STATE_PUBKEY_AUTH_SENT:\n        case SSH_AUTH_STATE_PASSWORD_AUTH_SENT:\n        case SSH_AUTH_STATE_AUTH_NONE_SENT:\n        case SSH_AUTH_STATE_NONE:\n            /* not reached */\n            rc = SSH_AUTH_ERROR;\n            break;\n    }\n\n    return rc;\n}\n",
      "line_start": 143,
      "line_end": 189,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple state-dispatch helper: it maps session->auth.state to return codes and calls packet-termination helpers, but contains no parsing of external data, no buffer/memory operations, and minimal branching/complex logic. It has some value because it depends on session state (which may be influenced by packet handling), but as a fuzz target itself the attack surface is limited."
    },
    {
      "name": "auth.c:build_pubkey_auth_request",
      "clean_name": "build_pubkey_auth_request",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @param[in] sig_type_c    The signature algorithm name.\n * @param[in] pubkey_s      The public key string.\n *\n * @return  SSH_OK on success, SSH_ERROR if an error occurred.\n */\nstatic int build_pubkey_auth_request(ssh_session session,\n                                     const char *username,\n                                     int has_signature,\n                                     const char *sig_type_c,\n                                     ssh_string pubkey_s)\n{\n    int rc;\n    const char *auth_method = \"publickey\";\n\n    if (session->extensions & SSH_EXT_PUBLICKEY_HOSTBOUND) {\n        auth_method = \"publickey-hostbound-v00@openssh.com\";\n    }\n\n    /* request */\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bsssbsS\",\n                         SSH2_MSG_USERAUTH_REQUEST,\n                         username ? username : session->opts.username,\n                         \"ssh-connection\",\n                         auth_method,\n                         has_signature, /* private key? */\n                         sig_type_c,    /* algo */\n                         pubkey_s       /* public key */\n    );\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\n\n    if (session->extensions & SSH_EXT_PUBLICKEY_HOSTBOUND) {\n        rc = add_hostbound_pubkey(session);\n        if (rc < 0) {\n            return SSH_ERROR;\n        }\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 529,
      "line_end": 566,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "This is a serializer that builds an SSH publickey auth request using external inputs (username, sig type, public key). It touches authentication flow but contains simple logic and minimal branching (two paths: extension flag and username fallback) and delegates the actual buffer manipulation to ssh_buffer_pack/add_hostbound_pubkey. Moderate fuzz value (exposed to untrusted data) but low internal complexity and no parsing/crypto in this function itself."
    },
    {
      "name": "auth.c:ssh_userauth_kbdint_init",
      "clean_name": "ssh_userauth_kbdint_init",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "}\n\n/*\n * This function sends the first packet as explained in RFC 3066 section 3.1.\n */\nstatic int ssh_userauth_kbdint_init(ssh_session session,\n                                    const char *username,\n                                    const char *submethods)\n{\n    int rc;\n\n    if (session->pending_call_state == SSH_PENDING_CALL_AUTH_KBDINT_INIT) {\n        goto pending;\n    }\n    if (session->pending_call_state != SSH_PENDING_CALL_NONE) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_userauth_request_service(session);\n    if (rc == SSH_AGAIN) {\n        return SSH_AUTH_AGAIN;\n    }\n    if (rc != SSH_OK) {\n        return SSH_AUTH_ERROR;\n    }\n\n    /* request */\n    rc = ssh_buffer_pack(session->out_buffer, \"bsssss\",\n            SSH2_MSG_USERAUTH_REQUEST,\n            username ? username : session->opts.username,\n            \"ssh-connection\",\n            \"keyboard-interactive\",\n            \"\", /* lang (ignore it) */\n            submethods ? submethods : \"\"\n    );\n    if (rc < 0) {\n        goto fail;\n    }\n\n\n    session->auth.state = SSH_AUTH_STATE_KBDINT_SENT;\n    session->pending_call_state = SSH_PENDING_CALL_AUTH_KBDINT_INIT;\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Sending keyboard-interactive init request\");\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return SSH_AUTH_ERROR;\n    }\npending:\n    rc = ssh_userauth_get_response(session);\n    if (rc != SSH_AUTH_AGAIN)\n        session->pending_call_state = SSH_PENDING_CALL_NONE;\n    return rc;\nfail:\n    ssh_set_error_oom(session);\n    ssh_buffer_reinit(session->out_buffer);\n\n    return SSH_AUTH_ERROR;\n}\n",
      "line_start": 1906,
      "line_end": 1963,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple helper that builds/sends an auth packet using username/submethods (untrusted strings) and manages small state transitions; it delegates real parsing/complex logic to other functions, has low cyclomatic complexity and limited direct memory-manipulation exposure."
    },
    {
      "name": "ssh_buffer_allocate",
      "clean_name": "ssh_buffer_allocate",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @param[in]  len      The length of the data to add.\n *\n * @return              Pointer on the allocated space\n *                      NULL on error.\n */\nvoid *ssh_buffer_allocate(struct ssh_buffer_struct *buffer, uint32_t len)\n{\n    void *ptr = NULL;\n\n    buffer_verify(buffer);\n\n    if (buffer->used + len < len) {\n        return NULL;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return NULL;\n        }\n    }\n\n    ptr = buffer->data + buffer->used;\n    buffer->used+=len;\n    buffer_verify(buffer);\n\n    return ptr;\n}\n",
      "line_start": 371,
      "line_end": 397,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Helper buffer-allocation routine: manipulates memory (pointer arithmetic, reallocation), checks for integer wrap, and has branches for shifting/reallocating. It is moderate risk/complexity but not a parser or protocol handler, so medium fuzzing priority."
    },
    {
      "name": "ssh_buffer_get_data",
      "clean_name": "ssh_buffer_get_data",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The length to read from the buffer.\n *\n * @returns             0 if there is not enough data in buffer, len otherwise.\n */\nuint32_t ssh_buffer_get_data(struct ssh_buffer_struct *buffer, void *data, uint32_t len)\n{\n    int rc;\n\n    /*\n     * Check for a integer overflow first, then check if not enough data is in\n     * the buffer.\n     */\n    rc = ssh_buffer_validate_length(buffer, len);\n    if (rc != SSH_OK) {\n        return 0;\n    }\n    memcpy(data,buffer->data+buffer->pos,len);\n    buffer->pos+=len;\n    return len;   /* no yet support for partial reads (is it really needed ?? ) */\n}\n",
      "line_start": 683,
      "line_end": 699,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that performs a memcpy after calling ssh_buffer_validate_length. It does memory operations on potentially untrusted data (so misuse/validation bugs matter) but has very low complexity and no parsing/branching \u2014 medium fuzz priority."
    },
    {
      "name": "buffer.c:buffer_shift",
      "clean_name": "buffer_shift",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": "\n/** @internal\n * @brief shifts a buffer to remove unused data in the beginning\n * @param buffer SSH buffer\n */\nstatic void buffer_shift(ssh_buffer buffer)\n{\n    size_t burn_pos = buffer->pos;\n\n    buffer_verify(buffer);\n\n    if (buffer->pos == 0) {\n        return;\n    }\n    memmove(buffer->data,\n            buffer->data + buffer->pos,\n            buffer->used - buffer->pos);\n    buffer->used -= buffer->pos;\n    buffer->pos = 0;\n\n    if (buffer->secure) {\n        void *ptr = buffer->data + buffer->used;\n        explicit_bzero(ptr, burn_pos);\n    }\n\n    buffer_verify(buffer);\n}\n",
      "line_start": 226,
      "line_end": 248,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple buffer-manipulation helper: does memmove and explicit_bzero based on buffer->pos/used with minimal branching. Could expose memory-safety issues if buffer invariants are violated, but it lacks complex parsing, loops, or security logic\u2014moderate fuzz priority."
    },
    {
      "name": "channel_rcv_close",
      "clean_name": "channel_rcv_close",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    }\n\n    return false;\n}\n\nSSH_PACKET_CALLBACK(channel_rcv_close)\n{\n    ssh_channel channel = NULL;\n    (void)user;\n    (void)type;\n\n    channel = channel_from_msg(session,packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n        \"Received close on channel (%\" PRIu32 \":%\" PRIu32 \")\",\n        channel->local_channel,\n        channel->remote_channel);\n\n    if (!ssh_channel_has_unread_data(channel)) {\n        channel->state = SSH_CHANNEL_STATE_CLOSED;\n    } else {\n        channel->delayed_close = 1;\n    }\n\n    if (channel->remote_eof == 0) {\n        SSH_LOG(SSH_LOG_PACKET,\n            \"Remote host not polite enough to send an eof before close\");\n    }\n    /*\n    * The remote eof doesn't break things if there was still data into read\n    * buffer because the eof is ignored until the buffer is empty.\n    */\n    channel->remote_eof = 1;\n\n    ssh_callbacks_execute_list(channel->callbacks,\n                               ssh_channel_callbacks,\n                               channel_close_function,\n                               channel->session,\n                               channel);\n\n    channel->flags |= SSH_CHANNEL_FLAG_CLOSED_REMOTE;\n    if(channel->flags & SSH_CHANNEL_FLAG_FREED_LOCAL)\n        ssh_channel_do_free(channel);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 755,
      "line_end": 801,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Handles a network packet and updates channel state, but does little parsing itself and has fairly simple branching. It invokes callbacks and may free channel (some attack surface), so it's a reasonable medium-priority fuzz target but not high/critical compared to functions that parse complex formats or perform memory ops on untrusted data."
    },
    {
      "name": "ssh_channel_open_forward",
      "clean_name": "ssh_channel_open_forward",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @warning This function does not bind the local port and does not automatically\n *          forward the content of a socket to the channel. You still have to\n *          use ssh_channel_read and ssh_channel_write for this.\n */\nint ssh_channel_open_forward(ssh_channel channel, const char *remotehost,\n    int remoteport, const char *sourcehost, int localport)\n{\n    ssh_session session = NULL;\n    ssh_buffer payload = NULL;\n    ssh_string str = NULL;\n    int rc = SSH_ERROR;\n\n    if (channel == NULL) {\n        return rc;\n    }\n\n    session = channel->session;\n\n    if (remotehost == NULL || sourcehost == NULL) {\n        ssh_set_error_invalid(session);\n        return rc;\n    }\n\n    payload = ssh_buffer_new();\n    if (payload == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(payload,\n                         \"sdsd\",\n                         remotehost,\n                         remoteport,\n                         sourcehost,\n                         localport);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = channel_open(channel,\n                      \"direct-tcpip\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      payload);\n\nerror:\n    SSH_BUFFER_FREE(payload);\n    SSH_STRING_FREE(str);\n\n    return rc;\n}\n",
      "line_start": 1134,
      "line_end": 1182,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 86,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium priority: the function accepts untrusted strings/ports and performs buffer packing (memory operations) and calls channel_open, so fuzzing it can exercise downstream code. However the function itself is thin with simple validation, no loops or complex branching \u2014 better fuzz targets are the packer/channel_open internals or protocol parsers."
    },
    {
      "name": "ssh_channel_open_forward_unix",
      "clean_name": "ssh_channel_open_forward_unix",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @warning This function does not bind the local port and does not\n *          automatically forward the content of a socket to the channel.\n *          You still have to use ssh_channel_read and ssh_channel_write for this.\n * @warning Requires support of OpenSSH for UNIX domain socket forwarding.\n  */\nint ssh_channel_open_forward_unix(ssh_channel channel,\n                                  const char *remotepath,\n                                  const char *sourcehost,\n                                  int localport)\n{\n    ssh_session session = NULL;\n    ssh_buffer payload = NULL;\n    int rc = SSH_ERROR;\n    int version;\n\n    if (channel == NULL) {\n        return rc;\n    }\n\n    session = channel->session;\n\n    version = ssh_get_openssh_version(session);\n    if (version == 0) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"We're not connected to an OpenSSH server!\");\n        return SSH_ERROR;\n    }\n\n    if (remotepath == NULL || sourcehost == NULL) {\n        ssh_set_error_invalid(session);\n        return rc;\n    }\n\n    payload = ssh_buffer_new();\n    if (payload == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(payload,\n                         \"ssd\",\n                         remotepath,\n                         sourcehost,\n                         localport);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = channel_open(channel,\n                      \"direct-streamlocal@openssh.com\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      payload);\n\nerror:\n    SSH_BUFFER_FREE(payload);\n\n    return rc;\n}\n",
      "line_start": 1207,
      "line_end": 1263,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 87,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper that packs two strings and an int into an SSH buffer and calls channel_open. It touches untrusted input and performs memory operations via ssh_buffer_pack, but has low cyclomatic complexity and minimal parsing/logic \u2014 better fuzz targets exist deeper (parsers/packet handling)."
    },
    {
      "name": "ssh_channel_request_subsystem",
      "clean_name": "ssh_channel_request_subsystem",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n *\n * @warning You normally don't have to call it for sftp, see sftp_new().\n */\nint ssh_channel_request_subsystem(ssh_channel channel, const char *subsys)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return SSH_ERROR;\n  }\n  if(subsys == NULL) {\n      ssh_set_error_invalid(channel->session);\n      return rc;\n  }\n  switch(channel->request_state){\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer, \"s\", subsys);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\npending:\n  rc = channel_request(channel, \"subsystem\", buffer, 1);\nerror:\n  SSH_BUFFER_FREE(buffer);\n\n  return rc;\n}\n",
      "line_start": 2155,
      "line_end": 2192,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper that accepts untrusted string input and packs it into a buffer (string/memory ops) then forwards to channel_request. Low cyclomatic complexity and simple logic, so only moderate standalone fuzz value; more valuable when combined with channel_request or higher-level flows."
    },
    {
      "name": "ssh_channel_request_x11",
      "clean_name": "ssh_channel_request_x11",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n */\nint ssh_channel_request_x11(ssh_channel channel, int single_connection, const char *protocol,\n    const char *cookie, int screen_number)\n{\n  ssh_buffer buffer = NULL;\n  char *c = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return SSH_ERROR;\n  }\n  switch(channel->request_state){\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  if (cookie == NULL) {\n    c = generate_cookie();\n    if (c == NULL) {\n      ssh_set_error_oom(channel->session);\n      goto error;\n    }\n  }\n\n  rc = ssh_buffer_pack(buffer,\n                       \"bssd\",\n                       single_connection == 0 ? 0 : 1,\n                       protocol ? protocol : \"MIT-MAGIC-COOKIE-1\",\n                       cookie ? cookie : c,\n                       screen_number);\n  if (c != NULL){\n      SAFE_FREE(c);\n  }\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\npending:\n  rc = channel_request(channel, \"x11-req\", buffer, 1);\n\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 2259,
      "line_end": 2310,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 95,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzzing value. Accepts external strings (protocol, cookie) and packs them into a buffer (memory operations) so it can exercise buffer/serialization code, but the function itself has simple control flow, no loops, and minimal parsing/branching. Better targets exist that parse complex file/protocol formats or contain more input-dependent logic."
    },
    {
      "name": "ssh_channel_listen_forward",
      "clean_name": "ssh_channel_listen_forward",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n **/\nint ssh_channel_listen_forward(ssh_session session,\n                               const char *address,\n                               int port,\n                               int *bound_port)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(session->global_req_state != SSH_CHANNEL_REQ_STATE_NONE)\n    goto pending;\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer,\n                       \"sd\",\n                       address ? address : \"\",\n                       port);\n  if (rc != SSH_OK){\n    ssh_set_error_oom(session);\n    goto error;\n  }\npending:\n  rc = ssh_global_request(session, \"tcpip-forward\", buffer, 1);\n\n  /* TODO: FIXME no guarantee the last packet we received contains\n   * that info */\n  if (rc == SSH_OK && port == 0 && bound_port != NULL) {\n    rc = ssh_buffer_unpack(session->in_buffer, \"d\", bound_port);\n    if (rc != SSH_OK)\n        *bound_port = 0;\n  }\n\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 2592,
      "line_end": 2632,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 86,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts external input (address, port) and performs buffer pack/unpack and a network/global request, so it touches untrusted data and memory APIs. However it is a thin wrapper with low cyclomatic complexity, few branches, and no complex parsing or loops \u2014 a medium-priority fuzz target rather than high/critical."
    },
    {
      "name": "ssh_channel_cancel_forward",
      "clean_name": "ssh_channel_cancel_forward",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n */\nint ssh_channel_cancel_forward(ssh_session session,\n                               const char *address,\n                               int port)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(session->global_req_state != SSH_CHANNEL_REQ_STATE_NONE)\n    goto pending;\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer, \"sd\",\n                       address ? address : \"\",\n                       port);\n  if (rc != SSH_OK){\n      ssh_set_error_oom(session);\n      goto error;\n  }\npending:\n  rc = ssh_global_request(session, \"cancel-tcpip-forward\", buffer, 1);\n\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 2701,
      "line_end": 2731,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 54,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Packs an untrusted address string and port into an SSH buffer and issues a global request\u2014so it touches memory/string ops on external input, but it is a thin wrapper with minimal branching and no complex parsing or loops. Moderate value as a fuzz target (medium priority)."
    },
    {
      "name": "ssh_channel_request_env",
      "clean_name": "ssh_channel_request_env",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n * @warning Some environment variables may be refused by security reasons.\n */\nint ssh_channel_request_env(ssh_channel channel, const char *name, const char *value)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return SSH_ERROR;\n  }\n  if(name == NULL || value == NULL) {\n      ssh_set_error_invalid(channel->session);\n      return rc;\n  }\n  switch(channel->request_state){\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer,\n                       \"ss\",\n                       name,\n                       value);\n  if (rc != SSH_OK){\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\npending:\n  rc = channel_request(channel, \"env\", buffer,1);\nerror:\n  SSH_BUFFER_FREE(buffer);\n\n  return rc;\n}\n",
      "line_start": 2753,
      "line_end": 2792,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzz value \u2014 the function packs two external strings into an SSH buffer and performs memory operations (string copying/serialization), so malformed/large inputs could exercise allocation and buffer code, but the function itself is simple with minimal branching and no parsing/validation logic or protocol state complexity. It\u2019s a helper-level target rather than a high\u2011complexity parser."
    },
    {
      "name": "ssh_channel_request_exec",
      "clean_name": "ssh_channel_request_exec",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * Attempting to run multiple consecutive commands in one channel will fail.\n * See RFC 4254 Section 6.5.\n *\n * @see ssh_channel_request_shell()\n */\nint ssh_channel_request_exec(ssh_channel channel, const char *cmd)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return SSH_ERROR;\n  }\n  if(cmd == NULL) {\n      ssh_set_error_invalid(channel->session);\n      return rc;\n  }\n\n  switch(channel->request_state){\n  case SSH_CHANNEL_REQ_STATE_NONE:\n    break;\n  default:\n    goto pending;\n  }\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer, \"s\", cmd);\n\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\npending:\n  rc = channel_request(channel, \"exec\", buffer, 1);\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 2830,
      "line_end": 2867,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a small wrapper that validates pointers, allocates a buffer and packs a command string before calling channel_request. It accepts external input (cmd) but performs no parsing, branching, or complex memory manipulation itself. The real parsing/memory work likely occurs in ssh_buffer_pack/channel_request, so this function is a medium-value fuzz target (helper-level) rather than high/critical priority."
    },
    {
      "name": "ssh_channel_read_nonblocking",
      "clean_name": "ssh_channel_read_nonblocking",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              The number of bytes read, SSH_AGAIN if nothing is\n * available, SSH_ERROR on error, and SSH_EOF if the channel is EOF.\n *\n * @see ssh_channel_is_eof()\n */\nint ssh_channel_read_nonblocking(ssh_channel channel,\n                                 void *dest,\n                                 uint32_t count,\n                                 int is_stderr)\n{\n    ssh_session session = NULL;\n    uint32_t to_read;\n    int rc;\n    int blocking;\n\n    if(channel == NULL) {\n        return SSH_ERROR;\n    }\n    if(dest == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return SSH_ERROR;\n    }\n\n    session = channel->session;\n\n    rc = ssh_channel_poll(channel, is_stderr);\n\n    if (rc <= 0) {\n        if (session->session_state == SSH_SESSION_STATE_ERROR){\n            return SSH_ERROR;\n        }\n\n        return rc; /* may be an error code */\n    }\n\n    to_read = (unsigned int)rc;\n\n    if (to_read > count) {\n        to_read = count;\n    }\n    blocking = ssh_is_blocking(session);\n    ssh_set_blocking(session, 0);\n    rc = ssh_channel_read(channel, dest, to_read, is_stderr);\n    ssh_set_blocking(session,blocking);\n\n    return rc;\n}\n",
      "line_start": 3231,
      "line_end": 3273,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a thin wrapper: it validates pointers, polls the channel, bounds the read size, toggles blocking, and delegates actual I/O to ssh_channel_read. Moderate complexity with a few branches but no direct parsing or memory manipulation here; the real risk/complexity is in ssh_channel_read and underlying I/O, which would be higher-priority fuzz targets."
    },
    {
      "name": "ssh_channel_poll_timeout",
      "clean_name": "ssh_channel_poll_timeout",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @warning When the channel is in EOF state, the function returns SSH_EOF.\n *          When a channel is freed the function returns SSH_ERROR immediately.\n *\n * @see ssh_channel_is_eof()\n */\nint ssh_channel_poll_timeout(ssh_channel channel, int timeout, int is_stderr)\n{\n    ssh_session session = NULL;\n    ssh_buffer stdbuf = NULL;\n    struct ssh_channel_read_termination_struct ctx;\n    size_t len;\n    int rc;\n\n    if ((channel == NULL) || (channel->flags & SSH_CHANNEL_FLAG_FREED_LOCAL)) {\n        return SSH_ERROR;\n    }\n\n    session = channel->session;\n    stdbuf = channel->stdout_buffer;\n\n    if (is_stderr) {\n        stdbuf = channel->stderr_buffer;\n    }\n    ctx.buffer = stdbuf;\n    ctx.channel = channel;\n    rc = ssh_handle_packets_termination(channel->session,\n                                        timeout,\n                                        ssh_channel_read_termination,\n                                        &ctx);\n    if (rc == SSH_ERROR ||\n        session->session_state == SSH_SESSION_STATE_ERROR) {\n        rc = SSH_ERROR;\n        goto out;\n    } else if (rc == SSH_AGAIN) {\n        /* If the above timeout expired, it is ok and we do not need to\n         * attempt to check the read buffer. The calling functions do not\n         * expect us to return SSH_AGAIN either here. */\n        rc = SSH_OK;\n        goto out;\n    }\n    len = ssh_buffer_get_len(stdbuf);\n    if (len > 0) {\n        if (len > INT_MAX) {\n            rc = SSH_ERROR;\n        } else {\n            rc = (int)len;\n        }\n        goto out;\n    }\n    if (channel->remote_eof) {\n        rc = SSH_EOF;\n    }\n\nout:\n    return rc;\n}\n",
      "line_start": 3346,
      "line_end": 3397,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 65,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium-priority helper/orchestrator: small amount of branching and returns based on buffer length/state but no direct parsing or memory manipulation. It mainly delegates to ssh_handle_packets_termination (where real parsing occurs), so fuzzing this function alone has moderate value but requires complex channel/session setup to reach interesting behavior."
    },
    {
      "name": "ssh_channel_open_x11",
      "clean_name": "ssh_channel_open_x11",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      to be done again.\n * @warning This function does not bind the local port and does not automatically\n *          forward the content of a socket to the channel. You still have to\n *          use shh_channel_read and ssh_channel_write for this.\n */\nint ssh_channel_open_x11(ssh_channel channel,\n                         const char *orig_addr, int orig_port)\n{\n    ssh_session session = NULL;\n    ssh_buffer payload = NULL;\n    int rc = SSH_ERROR;\n\n    if (channel == NULL) {\n        return rc;\n    }\n    if (orig_addr == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return rc;\n    }\n    session = channel->session;\n\n    if (channel->state != SSH_CHANNEL_STATE_NOT_OPEN)\n        goto pending;\n\n    payload = ssh_buffer_new();\n    if (payload == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(payload, \"sd\", orig_addr, orig_port);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\npending:\n    rc = channel_open(channel,\n                      \"x11\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      payload);\n\nerror:\n    SSH_BUFFER_FREE(payload);\n\n    return rc;\n}\n",
      "line_start": 3901,
      "line_end": 3943,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 75,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts untrusted orig_addr/orig_port and performs memory operations (ssh_buffer_pack) and builds a network channel payload, so it is a valid fuzz target. However the control flow is simple (few branches, no loops, no complex parsing, no crypto/auth), so it is medium priority."
    },
    {
      "name": "ssh_channel_request_send_exit_signal",
      "clean_name": "ssh_channel_request_send_exit_signal",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @param[in]  errmsg   A CRLF explanation text about the error condition\n * @param[in]  lang     The language used in the message (format: RFC 3066)\n *\n * @return              SSH_OK on success, SSH_ERROR if an error occurred\n */\nint ssh_channel_request_send_exit_signal(ssh_channel channel, const char *sig,\n                                         int core, const char *errmsg, const char *lang)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return rc;\n  }\n  if(sig == NULL || errmsg == NULL || lang == NULL) {\n      ssh_set_error_invalid(channel->session);\n      return rc;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer,\n                       \"sbss\",\n                       sig,\n                       core ? 1 : 0,\n                       errmsg,\n                       lang);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = channel_request(channel, \"exit-signal\", buffer, 0);\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 4000,
      "line_end": 4036,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 74,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzz target value: it serializes untrusted strings into a buffer and calls channel_request (so memory/serialization code may be exercised), but the function itself has simple control flow, no loops or complex parsing/validation, and mainly acts as a thin wrapper around buffer packing and send logic."
    },
    {
      "name": "ssh_send_banner",
      "clean_name": "ssh_send_banner",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " *\n * @param server       Send client or server banner.\n *\n * @return 0 on success, < 0 on error.\n */\nint ssh_send_banner(ssh_session session, int server)\n{\n    const char *banner = CLIENT_BANNER_SSH2;\n    const char *terminator = \"\\r\\n\";\n    /* The maximum banner length is 255 for SSH2 */\n    char buffer[256] = {0};\n    size_t len;\n    int rc = SSH_ERROR;\n\n    if (server == 1) {\n        if (session->server_opts.custombanner == NULL) {\n            session->serverbanner = strdup(banner);\n            if (session->serverbanner == NULL) {\n                goto end;\n            }\n        } else {\n            len = strlen(session->server_opts.custombanner);\n            session->serverbanner = malloc(len + 8 + 1);\n            if(session->serverbanner == NULL) {\n                goto end;\n            }\n            snprintf(session->serverbanner,\n                     len + 8 + 1,\n                     \"SSH-2.0-%s\",\n                     session->server_opts.custombanner);\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->serverbanner,\n                 terminator);\n    } else {\n        session->clientbanner = strdup(banner);\n        if (session->clientbanner == NULL) {\n            goto end;\n        }\n\n        snprintf(buffer,\n                 sizeof(buffer),\n                 \"%s%s\",\n                 session->clientbanner,\n                 terminator);\n    }\n\n    rc = ssh_socket_write(session->socket, buffer, (uint32_t)strlen(buffer));\n    if (rc == SSH_ERROR) {\n        goto end;\n    }\n#ifdef WITH_PCAP\n    if (session->pcap_ctx != NULL) {\n        ssh_pcap_context_write(session->pcap_ctx,\n                               SSH_PCAP_DIR_OUT,\n                               buffer,\n                               (uint32_t)strlen(buffer),\n                               (uint32_t)strlen(buffer));\n    }\n#endif\n\n    rc = SSH_OK;\nend:\n    return rc;\n}\n",
      "line_start": 183,
      "line_end": 246,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 61,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Takes untrusted banner text (session->server_opts.custombanner), performs length-based malloc/strdup and snprintf into a 256-byte stack buffer and writes to a socket \u2014 so it does memory operations on external data but the logic is simple (few branches, no parsing, no loops). Moderate fuzz value due to string handling and potential truncation/size issues, but overall low complexity and limited attack surface."
    },
    {
      "name": "ssh_disconnect",
      "clean_name": "ssh_disconnect",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * socket. This is new behavior in libssh 0.10.\n *\n * @param[in]  session  The SSH session to use.\n */\nvoid\nssh_disconnect(ssh_session session)\n{\n    struct ssh_iterator *it = NULL;\n    int rc;\n\n    if (session == NULL) {\n        return;\n    }\n\n#ifndef _WIN32\n#ifdef HAVE_PTHREAD\n    /* Only send the disconnect to all other threads when the root session calls\n     * ssh_disconnect() */\n    if (session->proxy_root) {\n        proxy_disconnect = 1;\n    }\n#endif /* HAVE_PTHREAD */\n#endif /* _WIN32 */\n\n    if (session->disconnect_message == NULL) {\n        session->disconnect_message = strdup(\"Bye Bye\") ;\n        if (session->disconnect_message == NULL) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n    }\n\n    if (session->socket != NULL && ssh_socket_is_open(session->socket)) {\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bdss\",\n                             SSH2_MSG_DISCONNECT,\n                             SSH2_DISCONNECT_BY_APPLICATION,\n                             session->disconnect_message,\n                             \"\"); /* language tag */\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n\n        ssh_packet_send(session);\n        ssh_session_socket_close(session);\n    }\n\nerror:\n    session->recv_seq = 0;\n    session->send_seq = 0;\n    session->alive = 0;\n    if (session->socket != NULL){\n        ssh_socket_reset(session->socket);\n    }\n    session->opts.fd = SSH_INVALID_SOCKET;\n    session->session_state = SSH_SESSION_STATE_DISCONNECTED;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n\n    while ((it = ssh_list_get_iterator(session->channels)) != NULL) {\n        ssh_channel_do_free(ssh_iterator_value(ssh_channel, it));\n        ssh_list_remove(session->channels, it);\n    }\n    if (session->current_crypto) {\n      crypto_free(session->current_crypto);\n      session->current_crypto = NULL;\n    }\n    if (session->next_crypto) {\n        crypto_free(session->next_crypto);\n        session->next_crypto = crypto_new();\n        if (session->next_crypto == NULL) {\n            ssh_set_error_oom(session);\n        }\n    }\n    if (session->in_buffer) {\n        ssh_buffer_reinit(session->in_buffer);\n    }\n    if (session->out_buffer) {\n        ssh_buffer_reinit(session->out_buffer);\n    }\n    if (session->in_hashbuf) {\n        ssh_buffer_reinit(session->in_hashbuf);\n    }\n    if (session->out_hashbuf) {\n        ssh_buffer_reinit(session->out_hashbuf);\n    }\n    session->auth.supported_methods = 0;\n    SAFE_FREE(session->serverbanner);\n    SAFE_FREE(session->clientbanner);\n    SAFE_FREE(session->disconnect_message);\n\n    if (session->ssh_message_list) {\n        ssh_message msg = NULL;\n\n        while ((msg = ssh_list_pop_head(ssh_message,\n                                        session->ssh_message_list)) != NULL) {\n              ssh_message_free(msg);\n        }\n        ssh_list_free(session->ssh_message_list);\n        session->ssh_message_list = NULL;\n    }\n\n    if (session->packet_callbacks) {\n        ssh_list_free(session->packet_callbacks);\n        session->packet_callbacks = NULL;\n    }\n}\n",
      "line_start": 793,
      "line_end": 895,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 141,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium-value fuzz target: performs memory operations, buffer packing and socket send and walks/free lists (potential for UAF/double-free/resource bugs), but contains little parsing/validation logic and low branching complexity \u2014 not a high-priority protocol parser."
    },
    {
      "name": "connect.c:getai",
      "clean_name": "getai",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": "#else\n    return close(s);\n#endif\n}\n\nstatic int getai(const char *host, int port, struct addrinfo **ai)\n{\n    const char *service = NULL;\n    struct addrinfo hints;\n    char s_port[10];\n\n    ZERO_STRUCT(hints);\n\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_family = PF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    if (port == 0) {\n        hints.ai_flags = AI_PASSIVE;\n    } else {\n        snprintf(s_port, sizeof(s_port), \"%hu\", (unsigned short)port);\n        service = s_port;\n#ifdef AI_NUMERICSERV\n        hints.ai_flags = AI_NUMERICSERV;\n#endif\n    }\n\n    if (ssh_is_ipaddr(host) == 1) {\n        /* this is an IP address */\n        SSH_LOG(SSH_LOG_PACKET, \"host %s matches an IP address\", host);\n        hints.ai_flags |= AI_NUMERICHOST;\n    }\n\n    return getaddrinfo(host, service, &hints, ai);\n}\n",
      "line_start": 111,
      "line_end": 141,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Thin wrapper around getaddrinfo: small amount of input handling (host string, port -> snprintf) and a couple of branches (port==0, ip address check). The function itself is low-complexity and contains no loops or heavy memory manipulation, but it delegates to getaddrinfo which does complex parsing of host/service. Worth fuzzing at a higher level (resolver/lookup) rather than this small wrapper alone."
    },
    {
      "name": "connect.c:ssh_select_cb",
      "clean_name": "ssh_select_cb",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": " * @addtogroup libssh_session\n *\n * @{\n */\n\nstatic int ssh_select_cb (socket_t fd, int revents, void *userdata)\n{\n    fd_set *set = (fd_set *)userdata;\n    if (revents & POLLIN) {\n        FD_SET(fd, set);\n    }\n    return 0;\n}\n",
      "line_start": 295,
      "line_end": 303,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Small helper with a single branch that sets a bit in an fd_set. Limited logic and low cyclomatic complexity, but it does perform a memory write via FD_SET on caller-provided fd/userdata (no bounds check), so it has a moderate fuzzing surface (possible OOB if fd is out-of-range)."
    },
    {
      "name": "ssh_connector_set_event",
      "clean_name": "ssh_connector_set_event",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    }\n\n    return 0;\n}\n\nint ssh_connector_set_event(ssh_connector connector, ssh_event event)\n{\n    int rc = SSH_OK;\n\n    if ((connector->in_fd == SSH_INVALID_SOCKET &&\n         connector->in_channel == NULL)\n        || (connector->out_fd == SSH_INVALID_SOCKET &&\n            connector->out_channel == NULL)) {\n        rc = SSH_ERROR;\n        ssh_set_error(connector->session,SSH_FATAL,\"Connector not complete\");\n        goto error;\n    }\n\n    connector->event = event;\n    if (connector->in_fd != SSH_INVALID_SOCKET) {\n        if (connector->in_poll == NULL) {\n            connector->in_poll = ssh_poll_new(connector->in_fd,\n                                              POLLIN|POLLERR,\n                                              ssh_connector_fd_cb,\n                                              connector);\n        }\n        rc = ssh_event_add_poll(event, connector->in_poll);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n    }\n\n    if (connector->out_fd != SSH_INVALID_SOCKET) {\n        if (connector->out_poll == NULL) {\n            connector->out_poll = ssh_poll_new(connector->out_fd,\n                                               POLLOUT|POLLERR,\n                                               ssh_connector_fd_cb,\n                                               connector);\n        }\n\n        rc = ssh_event_add_poll(event, connector->out_poll);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n    }\n    if (connector->in_channel != NULL) {\n        rc = ssh_event_add_session(event,\n                ssh_channel_get_session(connector->in_channel));\n        if (rc != SSH_OK)\n            goto error;\n        if (ssh_channel_poll_timeout(connector->in_channel, 0, 0) > 0){\n            connector->in_available = 1;\n        }\n    }\n    if(connector->out_channel != NULL) {\n        ssh_session session = ssh_channel_get_session(connector->out_channel);\n\n        rc =  ssh_event_add_session(event, session);\n        if (rc != SSH_OK) {\n            goto error;\n        }\n        if (ssh_channel_window_size(connector->out_channel) > 0) {\n            connector->out_wontblock = 1;\n        }\n    }\n\nerror:\n    return rc;\n}\n",
      "line_start": 567,
      "line_end": 631,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 102,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium-priority: a helper that registers poll/session objects with moderate branching and interactions with external resources (fds, channels) but it does not parse complex external input, perform memory operations on untrusted data, or implement heavy input-dependent logic. Useful to fuzz in context but not a high-value standalone target."
    },
    {
      "name": "connector.c:ssh_connector_fd_read",
      "clean_name": "ssh_connector_fd_read",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " * @internal\n *\n * @brief read len bytes from socket into buffer\n *\n */\nstatic ssize_t ssh_connector_fd_read(ssh_connector connector,\n                                     void *buffer,\n                                     uint32_t len)\n{\n    ssize_t nread = -1;\n\n    if (connector->fd_is_socket) {\n        nread = recv(connector->in_fd,buffer, len, 0);\n    } else {\n        nread = read(connector->in_fd,buffer, len);\n    }\n\n    return nread;\n}\n",
      "line_start": 716,
      "line_end": 730,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple wrapper around read/recv that copies untrusted data into a caller-provided buffer with a single branch (socket vs. not). It performs memory I/O on external input but has no parsing, validation, or complex control flow\u2014moderate fuzz value as a helper function."
    },
    {
      "name": "connector.c:ssh_connector_fd_out_cb",
      "clean_name": "ssh_connector_fd_out_cb",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "\n/** @internal\n * @brief Callback called when a poll event is received on an output fd\n */\nstatic void\nssh_connector_fd_out_cb(ssh_connector connector)\n{\n    unsigned char buffer[CHUNKSIZE];\n    ssize_t r;\n    ssize_t w;\n    ssize_t total = 0;\n    SSH_LOG(SSH_LOG_TRACE, \"connector POLLOUT event for fd %d\",\n            connector->out_fd);\n\n    if (connector->in_available) {\n        if (connector->in_channel != NULL) {\n            r = ssh_channel_read_nonblocking(connector->in_channel, buffer,\n                                             CHUNKSIZE, 0);\n            if (r == SSH_ERROR) {\n                ssh_connector_except_channel(connector, connector->in_channel);\n                return;\n            } else if (r == 0 && ssh_channel_is_eof(connector->in_channel)) {\n                close(connector->out_fd);\n                connector->out_fd = SSH_INVALID_SOCKET;\n                return;\n            } else if (r > 0) {\n                /* loop around write in case the write blocks even for CHUNKSIZE bytes */\n                while (total != r) {\n                    w = ssh_connector_fd_write(connector,\n                                               buffer + total,\n                                               (uint32_t)(r - total));\n                    if (w < 0) {\n                        ssh_connector_except(connector, connector->out_fd);\n                        return;\n                    }\n                    total += w;\n                }\n            }\n        } else if (connector->in_fd != SSH_INVALID_SOCKET) {\n            /* fallback on the socket input callback */\n            connector->out_wontblock = 1;\n            ssh_connector_fd_in_cb(connector);\n        } else {\n            ssh_set_error(connector->session,\n                          SSH_FATAL,\n                          \"Output socket or channel closed\");\n            return;\n        }\n        connector->in_available = 0;\n        connector->out_wontblock = 0;\n    } else {\n        connector->out_wontblock = 1;\n    }\n}\n",
      "line_start": 319,
      "line_end": 368,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Medium priority: function performs I/O on untrusted data and does memory operations (reads into a fixed-size buffer and loops to write), with some branching and error handling. However it does not parse complex structured input or perform security-critical crypto/auth operations \u2014 mostly I/O plumbing \u2014 so it is a moderate-value fuzz target."
    },
    {
      "name": "ssh_client_sntrup761x25519_init",
      "clean_name": "ssh_client_sntrup761x25519_init",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "}\n\n/** @internal\n * @brief Starts sntrup761x25519-sha512@openssh.com key exchange\n */\nint ssh_client_sntrup761x25519_init(ssh_session session)\n{\n    int rc;\n\n    rc = ssh_sntrup761x25519_init(session);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bdPP\",\n                         SSH2_MSG_KEX_ECDH_INIT,\n                         CURVE25519_PUBKEY_SIZE + SNTRUP761_PUBLICKEY_SIZE,\n                         (size_t)SNTRUP761_PUBLICKEY_SIZE,\n                         session->next_crypto->sntrup761_client_pubkey,\n                         (size_t)CURVE25519_PUBKEY_SIZE,\n                         session->next_crypto->curve25519_client_pubkey);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_sntrup761x25519_client_callbacks);\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n    rc = ssh_packet_send(session);\n\n    return rc;\n}\n",
      "line_start": 111,
      "line_end": 140,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Small initializer that prepares and sends a KEX init packet: it touches cryptographic state and performs buffer packing (memory ops) but contains simple, linear logic with no parsing of external input or input-dependent loops. Valuable as part of a larger fuzz target but low standalone fuzzing priority."
    },
    {
      "name": "ssh_client_dh_init",
      "clean_name": "ssh_client_dh_init",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "};\n\n/** @internal\n * @brief Starts diffie-hellman-group1 key exchange\n */\nint ssh_client_dh_init(ssh_session session){\n  struct ssh_crypto_struct *crypto = session->next_crypto;\n#if !defined(HAVE_LIBCRYPTO) || OPENSSL_VERSION_NUMBER < 0x30000000L\n  const_bignum pubkey;\n#else\n  bignum pubkey = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n  int rc;\n\n  rc = ssh_dh_init_common(crypto);\n  if (rc == SSH_ERROR) {\n    goto error;\n  }\n\n  rc = ssh_dh_keypair_gen_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR);\n  if (rc == SSH_ERROR){\n      goto error;\n  }\n  rc = ssh_dh_keypair_get_keys(crypto->dh_ctx, DH_CLIENT_KEYPAIR,\n                               NULL, &pubkey);\n  if (rc != SSH_OK) {\n    goto error;\n  }\n  rc = ssh_buffer_pack(session->out_buffer, \"bB\", SSH2_MSG_KEXDH_INIT, pubkey);\n  if (rc != SSH_OK) {\n    goto error;\n  }\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n  bignum_safe_free(pubkey);\n#endif\n\n  /* register the packet callbacks */\n  ssh_packet_set_callbacks(session, &ssh_dh_client_callbacks);\n  session->dh_handshake_state = DH_STATE_INIT_SENT;\n\n  rc = ssh_packet_send(session);\n  return rc;\nerror:\n#if defined(HAVE_LIBCRYPTO) && OPENSSL_VERSION_NUMBER >= 0x30000000L\n  bignum_safe_free(pubkey);\n#endif\n  ssh_dh_cleanup(crypto);\n  return SSH_ERROR;\n}\n",
      "line_start": 311,
      "line_end": 355,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Performs cryptographic key-generation and buffer packing (memory ops) and touches security-critical code paths, but it does not parse or validate complex external input. Low cyclomatic complexity and few input-dependent branches make it a moderate-value fuzz target rather than high/critical."
    },
    {
      "name": "ssh_dh_is_known_group",
      "clean_name": "ssh_dh_is_known_group",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": " * @addtogroup libssh_session\n *\n * @{\n */\n\nbool ssh_dh_is_known_group(bignum modulus, bignum generator)\n{\n    int cmp, bits;\n    bignum m = NULL;\n\n    bits = bignum_num_bits(modulus);\n    if (bits < 3072) {\n        m = ssh_dh_group14;\n    } else if (bits < 6144) {\n        m = ssh_dh_group16;\n    } else {\n        m = ssh_dh_group18;\n    }\n\n    cmp = bignum_cmp(m, modulus);\n    if (cmp != 0) {\n        return false;\n    }\n\n    cmp = bignum_cmp(ssh_dh_generator, generator);\n    if (cmp != 0) {\n        return false;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"The received primes in FIPS are known\");\n    return true;\n}\n",
      "line_start": 623,
      "line_end": 650,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 37,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that compares two bignums against known DH groups: it uses bit-length and equality checks with a small number of branches but no loops, no complex parsing, and no direct memory manipulation. Valuable only as a medium-priority target (issues are more likely in upstream bignum parsing/ops than in this function itself)."
    },
    {
      "name": "_ssh_set_error",
      "clean_name": "_ssh_set_error",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " *\n * @param  descr       The description, which can be a format string.\n *\n * @param  ...         The arguments for the format string.\n */\nvoid _ssh_set_error(void *error,\n                    int code,\n                    const char *function,\n                    const char *descr, ...)\n{\n    struct ssh_common_struct *err = error;\n    va_list va;\n\n    va_start(va, descr);\n    vsnprintf(err->error.error_buffer, ERROR_BUFFERLEN, descr, va);\n    va_end(va);\n\n    err->error.error_code = code;\n    if (ssh_get_log_level() == SSH_LOG_TRACE) {\n        ssh_log_function(SSH_LOG_TRACE,\n                         function,\n                         err->error.error_buffer);\n    }\n}\n",
      "line_start": 52,
      "line_end": 71,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Helper that formats and stores an error string using vsnprintf (bounded write) and sets a code. Low cyclomatic complexity and no complex parsing, but it processes external strings and uses a format string/varargs (potential format-string interest). Limited fuzz value due to simple logic and the difficulty of exercising varargs."
    },
    {
      "name": "kdf.c:ssh_mac_update",
      "clean_name": "ssh_mac_update",
      "source_file": "/src/libssh/src/kdf.c",
      "source_code": "        break;\n    }\n    SAFE_FREE(ctx);\n}\n\nstatic int ssh_mac_update(ssh_mac_ctx ctx, const void *data, size_t len)\n{\n    switch (ctx->digest_type) {\n    case SSH_KDF_SHA1:\n        return sha1_update(ctx->ctx.sha1_ctx, data, len);\n    case SSH_KDF_SHA256:\n        return sha256_update(ctx->ctx.sha256_ctx, data, len);\n    case SSH_KDF_SHA384:\n        return sha384_update(ctx->ctx.sha384_ctx, data, len);\n    case SSH_KDF_SHA512:\n        return sha512_update(ctx->ctx.sha512_ctx, data, len);\n    }\n    return SSH_ERROR;\n}\n",
      "line_start": 114,
      "line_end": 128,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple wrapper that dispatches to underlying SHA update functions based on ctx->digest_type. It processes external data (data/len) but contains minimal logic (a small switch) and no complex parsing or authentication logic \u2014 medium priority; fuzzing is more valuable against the underlying hash implementations."
    },
    {
      "name": "ssh_set_client_kex",
      "clean_name": "ssh_set_client_kex",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "\n/**\n * @brief sets the key exchange parameters to be sent to the server,\n *        in function of the options and available methods.\n */\nint ssh_set_client_kex(ssh_session session)\n{\n    struct ssh_kex_struct *client = &session->next_crypto->client_kex;\n    const char *wanted = NULL;\n    int ok;\n    int i;\n\n    /* Skip if already set, for example for the rekey or when we do the guessing\n     * it could have been already used to make some protocol decisions. */\n    if (client->methods[0] != NULL) {\n        return SSH_OK;\n    }\n\n    ok = ssh_get_random(client->cookie, 16, 0);\n    if (!ok) {\n        ssh_set_error(session, SSH_FATAL, \"PRNG error\");\n        return SSH_ERROR;\n    }\n\n    /* Set the list of allowed algorithms in order of preference, if it hadn't\n     * been set yet. */\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        if (i == SSH_HOSTKEYS) {\n            /* Set the hostkeys in the following order:\n             * - First: keys present in known_hosts files ordered by preference\n             * - Next: other wanted algorithms ordered by preference */\n            client->methods[i] = ssh_client_select_hostkeys(session);\n            if (client->methods[i] == NULL) {\n                ssh_set_error_oom(session);\n                return SSH_ERROR;\n            }\n            continue;\n        }\n\n        wanted = session->opts.wanted_methods[i];\n        if (wanted == NULL) {\n            if (ssh_fips_mode()) {\n                wanted = fips_methods[i];\n            } else {\n                wanted = default_methods[i];\n            }\n        }\n        client->methods[i] = strdup(wanted);\n        if (client->methods[i] == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n    }\n\n    /* For rekeying, skip the extension negotiation */\n    if (session->flags & SSH_SESSION_FLAG_AUTHENTICATED) {\n        return SSH_OK;\n    }\n\n    ok = ssh_kex_append_extensions(session, client);\n    if (ok != SSH_OK){\n        return ok;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 778,
      "line_end": 839,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 85,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: it initializes key-exchange parameters, allocates strings in a loop, and consults session options/known_hosts (file-derived input) so it touches external configuration and has branching. However it does not itself parse complex external formats or perform risky memory operations on untrusted network data \u2014 most heavy work is delegated to other functions \u2014 so it is medium priority for fuzzing."
    },
    {
      "name": "ssh_add_to_default_algos",
      "clean_name": "ssh_add_to_default_algos",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * @param[in] list  The list to be appended\n *\n * @return A newly allocated list containing the default algorithms and the\n * algorithms in list at the end; NULL in case of error.\n */\nchar *ssh_add_to_default_algos(enum ssh_kex_types_e algo, const char *list)\n{\n    char *tmp = NULL, *ret = NULL;\n\n    if (algo > SSH_LANG_S_C || list == NULL || list[0] == '\\0') {\n        return NULL;\n    }\n\n    if (ssh_fips_mode()) {\n        tmp = ssh_append_without_duplicates(fips_methods[algo], list);\n        ret = ssh_find_all_matching(fips_methods[algo], tmp);\n    } else {\n        tmp = ssh_append_without_duplicates(default_methods[algo], list);\n        ret = ssh_find_all_matching(supported_methods[algo], tmp);\n    }\n\n    free(tmp);\n    return ret;\n}\n",
      "line_start": 1263,
      "line_end": 1282,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper that validates inputs and delegates real work to helper functions that do string/appending and matching. It touches untrusted string data and does allocation/freeing, but has low cyclomatic complexity and minimal logic itself. Worth fuzzing as a medium-priority target (helper-level risk) rather than critical."
    },
    {
      "name": "ssh_prefix_default_algos",
      "clean_name": "ssh_prefix_default_algos",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " *\n * @return A newly allocated list containing the default algorithms prioritized\n * with the algorithms in list at the beginning of the list; NULL in case\n * of error.\n */\nchar *ssh_prefix_default_algos(enum ssh_kex_types_e algo, const char *list)\n{\n    char *ret = NULL, *tmp = NULL;\n\n    if (algo > SSH_LANG_S_C || list == NULL || list[0] == '\\0') {\n        return NULL;\n    }\n\n    if (ssh_fips_mode()) {\n        tmp = ssh_prefix_without_duplicates(fips_methods[algo], list);\n        ret = ssh_find_all_matching(fips_methods[algo], tmp);\n    } else {\n        tmp = ssh_prefix_without_duplicates(default_methods[algo], list);\n        ret = ssh_find_all_matching(supported_methods[algo], tmp);\n    }\n\n    free(tmp);\n    return ret;\n}\n",
      "line_start": 1334,
      "line_end": 1353,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Small wrapper that validates input and dispatches to parsing helpers; the function itself is simple with minimal branching (fips vs non-fips) and only frees tmp. However it hands untrusted 'list' to other functions that likely perform complex parsing and memory ops, so the real surface for fuzzing is in those helpers rather than this wrapper."
    },
    {
      "name": "ssh_hashbufout_add_cookie",
      "clean_name": "ssh_hashbufout_add_cookie",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "#endif /* OPENSSL_VERSION_NUMBER */\n\n    return rc;\n}\n\nint ssh_hashbufout_add_cookie(ssh_session session)\n{\n    int rc;\n\n    session->out_hashbuf = ssh_buffer_new();\n    if (session->out_hashbuf == NULL) {\n        return -1;\n    }\n\n    rc = ssh_buffer_allocate_size(session->out_hashbuf,\n            sizeof(uint8_t) + 16);\n    if (rc < 0) {\n        ssh_buffer_reinit(session->out_hashbuf);\n        return -1;\n    }\n\n    if (ssh_buffer_add_u8(session->out_hashbuf, 20) < 0) {\n        ssh_buffer_reinit(session->out_hashbuf);\n        return -1;\n    }\n\n    if (session->server) {\n        if (ssh_buffer_add_data(session->out_hashbuf,\n                    session->next_crypto->server_kex.cookie, 16) < 0) {\n            ssh_buffer_reinit(session->out_hashbuf);\n            return -1;\n        }\n    } else {\n        if (ssh_buffer_add_data(session->out_hashbuf,\n                    session->next_crypto->client_kex.cookie, 16) < 0) {\n            ssh_buffer_reinit(session->out_hashbuf);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 1674,
      "line_end": 1711,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that allocates a buffer and copies a fixed-size (16-byte) cookie from session state with a single branch on session->server. It performs memory operations on potentially untrusted data but has no complex parsing, no loops, and low cyclomatic complexity\u2014useful but medium priority as a fuzz target."
    },
    {
      "name": "ssh_hashbufin_add_cookie",
      "clean_name": "ssh_hashbufin_add_cookie",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n\n    return 0;\n}\n\nint ssh_hashbufin_add_cookie(ssh_session session, unsigned char *cookie)\n{\n    int rc;\n\n    session->in_hashbuf = ssh_buffer_new();\n    if (session->in_hashbuf == NULL) {\n        return -1;\n    }\n\n    rc = ssh_buffer_allocate_size(session->in_hashbuf,\n            sizeof(uint8_t) + 20 + 16);\n    if (rc < 0) {\n        ssh_buffer_reinit(session->in_hashbuf);\n        return -1;\n    }\n\n    if (ssh_buffer_add_u8(session->in_hashbuf, 20) < 0) {\n        ssh_buffer_reinit(session->in_hashbuf);\n        return -1;\n    }\n    if (ssh_buffer_add_data(session->in_hashbuf,cookie, 16) < 0) {\n        ssh_buffer_reinit(session->in_hashbuf);\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 1712,
      "line_end": 1739,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Helper that allocates a buffer and copies a fixed 16-byte cookie from caller-provided memory. It performs memory operations on external data but has minimal logic/branching, no parsing or variable-length loops, and limited attack surface; useful mainly as part of a larger code path rather than a high-value standalone fuzz target."
    },
    {
      "name": "ssh_session_update_known_hosts",
      "clean_name": "ssh_session_update_known_hosts",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *\n * @param[in]  session  The session to use to write the entry.\n *\n * @return SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_session_update_known_hosts(ssh_session session)\n{\n    FILE *fp = NULL;\n    char *entry = NULL;\n    char *dir = NULL;\n    size_t nwritten;\n    size_t len;\n    int rc;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n    if (session->opts.knownhosts == NULL) {\n        rc = ssh_options_apply(session);\n        if (rc != SSH_OK) {\n            ssh_set_error(session, SSH_FATAL, \"Can't find a known_hosts file\");\n            return SSH_ERROR;\n        }\n    }\n\n    errno = 0;\n    fp = fopen(session->opts.knownhosts, \"a\");\n    if (fp == NULL) {\n        if (errno == ENOENT) {\n            dir = ssh_dirname(session->opts.knownhosts);\n            if (dir == NULL) {\n                ssh_set_error(session, SSH_FATAL, \"%s\",\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                return SSH_ERROR;\n            }\n\n            rc = ssh_mkdirs(dir, 0700);\n            if (rc < 0) {\n                ssh_set_error(session, SSH_FATAL,\n                              \"Cannot create %s directory: %s\",\n                              dir,\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                SAFE_FREE(dir);\n                return SSH_ERROR;\n            }\n            SAFE_FREE(dir);\n\n            errno = 0;\n            fp = fopen(session->opts.knownhosts, \"a\");\n            if (fp == NULL) {\n                ssh_set_error(session, SSH_FATAL,\n                              \"Couldn't open known_hosts file %s\"\n                              \" for appending: %s\",\n                              session->opts.knownhosts,\n                              ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                return SSH_ERROR;\n            }\n        } else {\n            ssh_set_error(session, SSH_FATAL,\n                          \"Couldn't open known_hosts file %s for appending: %s\",\n                          session->opts.knownhosts, strerror(errno));\n            return SSH_ERROR;\n        }\n    }\n\n    rc = ssh_session_export_known_hosts_entry(session, &entry);\n    if (rc != SSH_OK) {\n        fclose(fp);\n        return rc;\n    }\n\n    len = strlen(entry);\n    nwritten = fwrite(entry, sizeof(char), len, fp);\n    SAFE_FREE(entry);\n    if (nwritten != len || ferror(fp)) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Couldn't append to known_hosts file %s: %s\",\n                      session->opts.knownhosts,\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        fclose(fp);\n        return SSH_ERROR;\n    }\n\n    fclose(fp);\n    return SSH_OK;\n}\n",
      "line_start": 992,
      "line_end": 1071,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 117,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: this function performs filesystem I/O and simple string ops (fopen/fwrite/strlen), branches on errno and creation-retry logic, and calls ssh_session_export_known_hosts_entry which may introduce more complex parsing. It does not itself parse complex external formats or perform unsafe memory manipulation, so it is medium priority \u2014 useful to fuzz for error-handling and path/permission issues but not a critical parser hotspot."
    },
    {
      "name": "knownhosts.c:ssh_session_get_host_port",
      "clean_name": "ssh_session_get_host_port",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "error:\n    fclose(fp);\n    return SSH_ERROR;\n}\n\nstatic char *ssh_session_get_host_port(ssh_session session)\n{\n    char *host_port = NULL;\n    char *host = NULL;\n\n    if (session->opts.host == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Can't verify server in known hosts if the host we \"\n                      \"should connect to has not been set\");\n\n        return NULL;\n    }\n\n    host = ssh_lowercase(session->opts.host);\n    if (host == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    if (session->opts.port == 0 || session->opts.port == 22) {\n        host_port = host;\n    } else {\n        host_port = ssh_hostport(host, session->opts.port);\n        SAFE_FREE(host);\n        if (host_port == NULL) {\n            ssh_set_error_oom(session);\n            return NULL;\n        }\n    }\n\n    return host_port;\n}\n",
      "line_start": 312,
      "line_end": 345,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Helper that builds a host[:port] string from session->opts.host and opts.port. It touches external input and invokes string-manipulation/allocation helpers (potential memory operations and OOM paths), but contains simple control flow with no parsing of complex formats, no loops, and limited attack surface \u2014 medium fuzz priority."
    },
    {
      "name": "knownhosts.c:ssh_known_hosts_entries_compare",
      "clean_name": "ssh_known_hosts_entries_compare",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "\n    return -1;\n}\n\nstatic int\nssh_known_hosts_entries_compare(struct ssh_knownhosts_entry *k1,\n                                struct ssh_knownhosts_entry *k2)\n{\n    int cmp;\n\n    if (k1 == NULL || k2 == NULL) {\n        return 1;\n    }\n\n    cmp = strcmp(k1->hostname, k2->hostname);\n    if (cmp != 0) {\n        return cmp;\n    }\n\n    cmp = ssh_key_cmp(k1->publickey, k2->publickey, SSH_KEY_CMP_PUBLIC);\n    if (cmp != 0) {\n        return cmp;\n    }\n\n    return 0;\n}\n",
      "line_start": 196,
      "line_end": 217,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Medium-priority helper: does untrusted string operations (strcmp on hostname) and calls ssh_key_cmp (which may perform more complex key logic), so it can exercise memory/string handling, but the function itself is simple with low cyclomatic complexity and limited parsing/validation logic."
    },
    {
      "name": "knownhosts.c:hash_hostname",
      "clean_name": "hash_hostname",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * @addtogroup libssh_session\n *\n * @{\n */\n\nstatic int hash_hostname(const char *name,\n                         unsigned char *salt,\n                         unsigned int salt_size,\n                         unsigned char **hash,\n                         size_t *hash_size)\n{\n    int rc;\n    HMACCTX mac_ctx = NULL;\n\n    mac_ctx = hmac_init(salt, salt_size, SSH_HMAC_SHA1);\n    if (mac_ctx == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = hmac_update(mac_ctx, name, strlen(name));\n    if (rc != 1)\n        return SSH_ERROR;\n\n    rc = hmac_final(mac_ctx, *hash, hash_size);\n    if (rc != 1)\n        return SSH_ERROR;\n\n    return SSH_OK;\n}\n",
      "line_start": 56,
      "line_end": 80,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Thin wrapper around HMAC over a hostname and salt: accepts external input but has very low cyclomatic complexity (no branches/loops) and performs no parsing or bounds logic itself. It delegates memory/crypto work to underlying HMAC functions, so it\u2019s a medium-priority fuzz target useful mainly to exercise the HMAC implementation rather than complex input-parsing logic."
    },
    {
      "name": "match.c:cidr_match_4",
      "clean_name": "cidr_match_4",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " *\n * @return 0 on a negative match.\n * @return 1 on a positive match.\n */\nstatic int\ncidr_match_4(struct in_addr *host_addr,\n             struct in_addr *net_addr,\n             unsigned int bits)\n{\n    if (bits == 0) {\n        /* C99 6.5.7 (3): u32 << 32 is undefined behaviour */\n        return 1;\n    }\n\n    return !((host_addr->s_addr ^ net_addr->s_addr) &\n             htonl((0xFFFFFFFFu << (32 - bits)) & 0xFFFFFFFFu));\n}\n",
      "line_start": 277,
      "line_end": 289,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple IPv4 CIDR-match helper: only bitwise ops and one branch (bits==0). Low cyclomatic complexity and no parsing, memory copies or loops. Limited attack surface for fuzzing, though malformed 'bits' (>32) can trigger undefined-shift behavior so targeted fuzzing could still find issues."
    },
    {
      "name": "match.c:cidr_match_6",
      "clean_name": "cidr_match_6",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " *\n * @return 0 on a negative match.\n * @return 1 on a positive match.\n */\nstatic int\ncidr_match_6(struct in6_addr *host_addr,\n             struct in6_addr *net_addr,\n             unsigned int bits)\n{\n    const uint8_t *a = host_addr->s6_addr;\n    const uint8_t *b = net_addr->s6_addr;\n\n    unsigned int byte_whole, bits_left;\n\n    /* The number of a complete byte covered by the prefix */\n    byte_whole = bits / 8;\n\n    /*\n     * The number of bits remaining in the incomplete (last) byte\n     * covered by the prefix\n     */\n    bits_left = bits % 8;\n\n    if (byte_whole) {\n        if (memcmp(a, b, byte_whole) != 0) {\n            return 0;\n        }\n    }\n\n    if (bits_left) {\n        if ((a[byte_whole] ^ b[byte_whole]) & (0xFFu << (8 - bits_left))) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n",
      "line_start": 229,
      "line_end": 261,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple helper that checks IPv6 CIDR equality: uses memcmp and a small bitmask check but has low cyclomatic complexity, no loops or complex parsing. Useful to fuzz as part of a larger parser, but alone is moderate priority."
    },
    {
      "name": "ssh_message_free",
      "clean_name": "ssh_message_free",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "/**\n * @brief Free a SSH message.\n *\n * @param[in] msg       The message to release the memory.\n */\nvoid ssh_message_free(ssh_message msg){\n  if (msg == NULL) {\n    return;\n  }\n\n  switch(msg->type) {\n    case SSH_REQUEST_AUTH:\n      SAFE_FREE(msg->auth_request.username);\n      SAFE_FREE(msg->auth_request.sigtype);\n      if (msg->auth_request.password) {\n        explicit_bzero(msg->auth_request.password,\n                       strlen(msg->auth_request.password));\n        SAFE_FREE(msg->auth_request.password);\n      }\n      ssh_key_free(msg->auth_request.pubkey);\n      ssh_key_free(msg->auth_request.server_pubkey);\n      break;\n    case SSH_REQUEST_CHANNEL_OPEN:\n      SAFE_FREE(msg->channel_request_open.originator);\n      SAFE_FREE(msg->channel_request_open.destination);\n      break;\n    case SSH_REQUEST_CHANNEL:\n      SAFE_FREE(msg->channel_request.TERM);\n      SAFE_FREE(msg->channel_request.modes);\n      SAFE_FREE(msg->channel_request.var_name);\n      SAFE_FREE(msg->channel_request.var_value);\n      SAFE_FREE(msg->channel_request.command);\n      SAFE_FREE(msg->channel_request.subsystem);\n      switch (msg->channel_request.type) {\n      case SSH_CHANNEL_REQUEST_EXEC:\n          SAFE_FREE(msg->channel_request.command);\n          break;\n      case SSH_CHANNEL_REQUEST_ENV:\n          SAFE_FREE(msg->channel_request.var_name);\n          SAFE_FREE(msg->channel_request.var_value);\n          break;\n      case SSH_CHANNEL_REQUEST_PTY:\n          SAFE_FREE(msg->channel_request.TERM);\n          break;\n      case SSH_CHANNEL_REQUEST_SUBSYSTEM:\n          SAFE_FREE(msg->channel_request.subsystem);\n          break;\n      case SSH_CHANNEL_REQUEST_X11:\n          SAFE_FREE(msg->channel_request.x11_auth_protocol);\n          SAFE_FREE(msg->channel_request.x11_auth_cookie);\n          break;\n      }\n      break;\n    case SSH_REQUEST_SERVICE:\n      SAFE_FREE(msg->service_request.service);\n      break;\n    case SSH_REQUEST_GLOBAL:\n      SAFE_FREE(msg->global_request.bind_address);\n      break;\n  }\n  ZERO_STRUCTP(msg);\n  SAFE_FREE(msg);\n}\n",
      "line_start": 662,
      "line_end": 720,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 210,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is primarily a free/cleanup helper with moderate branching (switch on message type and nested switch) and many pointer frees, so it can expose double-free/NULL-deref/strlen-use issues (explicit_bzero(strlen(...))). It does not parse complex external input or perform heavy data transformation, so it is a medium-priority fuzz target rather than high/critical."
    },
    {
      "name": "ssh_message_channel_request_reply_success",
      "clean_name": "ssh_message_channel_request_reply_success",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param msg   A message to reply to\n *\n * @returns     SSH_OK on success, SSH_ERROR if an error occurred.\n */\nint ssh_message_channel_request_reply_success(ssh_message msg)\n{\n    uint32_t channel;\n    int rc;\n\n    if (msg == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (msg->channel_request.want_reply) {\n        channel = msg->channel_request.channel->remote_channel;\n\n        SSH_LOG(SSH_LOG_PACKET,\n                \"Sending a channel_request success to channel %\" PRIu32,\n                channel);\n\n        rc = ssh_buffer_pack(msg->session->out_buffer,\n                             \"bd\",\n                             SSH2_MSG_CHANNEL_SUCCESS,\n                             channel);\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(msg->session);\n            return SSH_ERROR;\n        }\n\n        return ssh_packet_send(msg->session);\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"The client doesn't want to know the request succeeded\");\n\n    return SSH_OK;\n}\n",
      "line_start": 1651,
      "line_end": 1684,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Small helper that sends a channel-success reply: limited branching and low cyclomatic complexity. It reads fields from an ssh_message and calls ssh_buffer_pack/ssh_packet_send (memory ops), but does not parse complex external formats or perform heavy input-dependent logic. Medium-value fuzz target (possible NULL deref/pack issues) rather than high-priority parser/crypto target."
    },
    {
      "name": "messages.c:ssh_execute_client_request",
      "clean_name": "ssh_execute_client_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    ssh_message_reply_default(msg);\n\n    return SSH_OK;\n}\n\nstatic int ssh_execute_client_request(ssh_session session, ssh_message msg)\n{\n    ssh_channel channel = NULL;\n    int rc = SSH_AGAIN;\n\n    if (msg->type == SSH_REQUEST_CHANNEL_OPEN\n        && msg->channel_request_open.type == SSH_CHANNEL_X11\n        && ssh_callbacks_exists(session->common.callbacks, channel_open_request_x11_function)) {\n        channel = session->common.callbacks->channel_open_request_x11_function (session,\n                msg->channel_request_open.originator,\n                msg->channel_request_open.originator_port,\n                session->common.callbacks->userdata);\n\n        return ssh_reply_channel_open_request(msg, channel);\n    } else if (msg->type == SSH_REQUEST_CHANNEL_OPEN\n               && msg->channel_request_open.type == SSH_CHANNEL_AUTH_AGENT\n               && ssh_callbacks_exists(session->common.callbacks, channel_open_request_auth_agent_function)) {\n        channel = session->common.callbacks->channel_open_request_auth_agent_function (session,\n                session->common.callbacks->userdata);\n\n        return ssh_reply_channel_open_request(msg, channel);\n    } else if (msg->type == SSH_REQUEST_CHANNEL_OPEN\n               && msg->channel_request_open.type == SSH_CHANNEL_FORWARDED_TCPIP\n               && ssh_callbacks_exists(session->common.callbacks, channel_open_request_forwarded_tcpip_function)) {\n        channel = session->common.callbacks->channel_open_request_forwarded_tcpip_function(session,\n                msg->channel_request_open.destination,\n                msg->channel_request_open.destination_port,\n                msg->channel_request_open.originator,\n                msg->channel_request_open.originator_port,\n                session->common.callbacks->userdata);\n\n        return ssh_reply_channel_open_request(msg, channel);\n    }\n\n    return rc;\n}\n",
      "line_start": 392,
      "line_end": 428,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Dispatcher for SSH channel-open messages that examines structured external input and dispatches to callbacks. It has simple branching on message/type fields but no loops, memory operations, or cryptographic/auth logic \u2014 moderate fuzz value as a helper-level target."
    },
    {
      "name": "messages.c:ssh_send_disconnect",
      "clean_name": "ssh_send_disconnect",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "  return SSH_ERROR;\n}\n\n#endif\n\nstatic int ssh_send_disconnect(ssh_session session)\n{\n    int rc = SSH_ERROR;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (session->disconnect_message == NULL) {\n        session->disconnect_message = strdup(\"Bye Bye\");\n        if (session->disconnect_message == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n    }\n\n    if (session->socket != NULL && ssh_socket_is_open(session->socket)) {\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bdss\",\n                             SSH2_MSG_DISCONNECT,\n                             SSH2_DISCONNECT_BY_APPLICATION,\n                             session->disconnect_message,\n                             \"\"); /* language tag */\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n\n        rc = ssh_packet_send(session);\n        ssh_session_socket_close(session);\n    }\n\n    return rc;\n}\n",
      "line_start": 99,
      "line_end": 133,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 64,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Moderate priority. The function is a wrapper that prepares and sends a disconnect packet: it touches potentially untrusted string data (session->disconnect_message), does a strdup, calls ssh_buffer_pack (buffer/string packing) and ssh_packet_send, and interacts with a socket \u2014 so there are memory operations on external data and a surface for buffer issues. However, the function itself contains little parsing/complex logic or many code paths (simple NULL checks and one main path), so it is not as high-value as a full protocol parser and is best treated as a medium-priority fuzz target."
    },
    {
      "name": "ssh_basename",
      "clean_name": "ssh_basename",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *                      \".\" is returned. The caller needs to free this memory\n *                      ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_basename (const char *path)\n{\n  char *new = NULL;\n  const char *s = NULL;\n  size_t len;\n\n  if (path == NULL || *path == '\\0') {\n    return strdup(\".\");\n  }\n\n  len = strlen(path);\n  /* Remove trailing slashes */\n  while(len > 0 && path[len - 1] == '/') --len;\n\n  /* We have only slashes */\n  if (len == 0) {\n    return strdup(\"/\");\n  }\n\n  while(len > 0 && path[len - 1] != '/') --len;\n\n  if (len > 0) {\n    s = path + len;\n    len = strlen(s);\n\n    while(len > 0 && s[len - 1] == '/') --len;\n  } else {\n    return strdup(path);\n  }\n\n  new = malloc(len + 1);\n  if (new == NULL) {\n    return NULL;\n  }\n\n  strncpy(new, s, len);\n  new[len] = '\\0';\n\n  return new;\n}\n",
      "line_start": 1005,
      "line_end": 1045,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple basename implementation: performs untrusted string manipulation and memory allocation with a few input-dependent loops and branches but lacks complex parsing, protocol handling, or security-critical logic \u2014 moderate fuzzing value as a helper function."
    },
    {
      "name": "ssh_mkdirs",
      "clean_name": "ssh_mkdirs",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @return              0 on success, < 0 on error with errno set.\n *\n * @note mode is ignored on Windows systems.\n */\nint ssh_mkdirs(const char *pathname, mode_t mode)\n{\n    int rc = 0;\n    char *parent = NULL;\n\n    if (pathname == NULL ||\n        pathname[0] == '\\0' ||\n        !strcmp(pathname, \"/\") ||\n        !strcmp(pathname, \".\"))\n    {\n        errno = EINVAL;\n        return -1;\n    }\n\n    errno = 0;\n\n#ifdef _WIN32\n    rc = _mkdir(pathname);\n#else\n    rc = mkdir(pathname, mode);\n#endif\n\n    if (rc < 0) {\n        /* If a directory was missing, try to create the parent */\n        if (errno == ENOENT) {\n            parent = ssh_dirname(pathname);\n            if (parent == NULL) {\n                errno = ENOMEM;\n                return -1;\n            }\n\n            rc = ssh_mkdirs(parent, mode);\n            if (rc < 0) {\n                /* We could not create the parent */\n                SAFE_FREE(parent);\n                return -1;\n            }\n\n            SAFE_FREE(parent);\n\n            /* Try again */\n            errno = 0;\n#ifdef _WIN32\n            rc = _mkdir(pathname);\n#else\n            rc = mkdir(pathname, mode);\n#endif\n        }\n    }\n\n    return rc;\n}\n",
      "line_start": 1081,
      "line_end": 1133,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts untrusted pathname and performs filesystem operations (mkdir) with recursive parent creation via ssh_dirname, so it can exercise system calls and recursion based on input. However the logic is simple (low cyclomatic complexity), does not parse a complex external format or perform memory-manipulating parsing, and has side effects on the filesystem; overall it is a medium-priority fuzz target."
    },
    {
      "name": "ssh_newline_vis",
      "clean_name": "ssh_newline_vis",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in]  buf_len  Size of the provided output buffer\n *\n * @returns SSH_ERROR on error; length of the resulting string not counting the\n * terminating '\\0' otherwise\n */\nint ssh_newline_vis(const char *string, char *buf, size_t buf_len)\n{\n    const char *in = NULL;\n    char *out = NULL;\n\n    if (string == NULL || buf == NULL || buf_len == 0) {\n        return SSH_ERROR;\n    }\n\n    if ((2 * strlen(string) + 1) > buf_len) {\n        SSH_LOG(SSH_LOG_TRACE, \"Buffer too small\");\n        return SSH_ERROR;\n    }\n\n    out = buf;\n    for (in = string; *in != '\\0'; in++) {\n        if (*in == '\\n') {\n            *out++ = '\\\\';\n            *out++ = 'n';\n        } else {\n            *out++ = *in;\n        }\n    }\n    *out = '\\0';\n\n    return (int)(out - buf);\n}\n",
      "line_start": 1875,
      "line_end": 1902,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that escapes newlines by emitting '\\n'. It processes external input and writes to a caller-supplied buffer, but has straightforward linear logic, minimal branching, and an explicit buffer-size check. Limited attack surface and low complexity \u2014 medium fuzzing priority."
    },
    {
      "name": "ssh_tmpname",
      "clean_name": "ssh_tmpname",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @param[in,out]  name   Any input string with last 6 characters as 'X'.\n * @returns -1 as error when the last 6 characters of the input to be replaced are not 'X'\n * 0 otherwise.\n */\nint ssh_tmpname(char *name)\n{\n    char *tmp = NULL;\n    size_t i = 0;\n    int rc = 0;\n    uint8_t random[6];\n\n    if (name == NULL) {\n        goto err;\n    }\n\n    tmp = name + strlen(name) - 6;\n    if (tmp < name) {\n        goto err;\n    }\n\n    for (i = 0; i < 6; i++) {\n        if (tmp[i] != 'X') {\n            SSH_LOG(SSH_LOG_WARNING,\n                    \"Invalid input. Last six characters of the input must be \\'X\\'\");\n            goto err;\n        }\n    }\n\n    rc = ssh_get_random(random, 6, 0);\n    if (!rc) {\n        SSH_LOG(SSH_LOG_WARNING,\n                \"Could not generate random data\\n\");\n        goto err;\n    }\n\n    for (i = 0; i < 6; i++) {\n        /* Limit the random[i] < 32 */\n        random[i] &= 0x1f;\n        /* For values from 0 to 9 use numbers, otherwise use letters */\n        tmp[i] = random[i] > 9 ? random[i] + 'a' - 10 : random[i] + '0';\n    }\n\n    return 0;\n\nerr:\n    errno = EINVAL;\n    return -1;\n}\n",
      "line_start": 1912,
      "line_end": 1956,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium-value fuzz target: it processes external input and writes back into the buffer (replacing last 6 chars), but it does not parse complex formats or perform heavy control-flow. Cyclomatic complexity is low and branches are limited (length check, six-character 'X' checks, random generation). It is somewhat security-relevant (temporary name creation) but lacks rich parsing or many input-dependent code paths, so it is a moderate-priority target for fuzzing."
    },
    {
      "name": "ssh_strreplace",
      "clean_name": "ssh_strreplace",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * NULL if allocation fails or if src is NULL. The returned memory needs to be\n * freed using ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_strreplace(const char *src, const char *pattern, const char *replace)\n{\n    char *p = NULL;\n    char *src_replaced = NULL;\n\n    if (src == NULL) {\n        return NULL;\n    }\n\n    if (pattern == NULL || replace == NULL) {\n        return strdup(src);\n    }\n\n    p = strstr(src, pattern);\n\n    if (p != NULL) {\n        size_t offset = p - src;\n        size_t pattern_len = strlen(pattern);\n        size_t replace_len = strlen(replace);\n        size_t len  = strlen(src);\n        size_t len_replaced = len + replace_len - pattern_len + 1;\n\n        src_replaced = (char *)malloc(len_replaced);\n\n        if (src_replaced == NULL) {\n            return NULL;\n        }\n\n        memset(src_replaced, 0, len_replaced);\n        memcpy(src_replaced, src, offset);\n        memcpy(src_replaced + offset, replace, replace_len);\n        memcpy(src_replaced + offset + replace_len, src + offset + pattern_len, len - offset - pattern_len);\n        return src_replaced; /* free in the caller */\n    } else {\n        return strdup(src);\n    }\n}\n",
      "line_start": 1974,
      "line_end": 2011,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Performs memory operations (malloc/memcpy/strstr/strlen) on external strings, so it has some value as a fuzz target, but the logic is simple (single first-occurrence replace, few branches, no loops or complex parsing). Moderate risk/complexity \u2014 medium priority for fuzzing."
    },
    {
      "name": "ssh_readn",
      "clean_name": "ssh_readn",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @returns               Number of bytes read on success,\n *                        SSH_ERROR on error with errno set to indicate the\n *                        error.\n */\nssize_t ssh_readn(int fd, void *buf, size_t nbytes)\n{\n    size_t total_bytes_read = 0;\n    ssize_t bytes_read;\n\n    if (fd < 0 || buf == NULL || nbytes == 0) {\n        errno = EINVAL;\n        return SSH_ERROR;\n    }\n\n    do {\n        bytes_read = read(fd,\n                          ((char *)buf) + total_bytes_read,\n                          nbytes - total_bytes_read);\n        if (bytes_read == -1) {\n            if (errno == EINTR) {\n                /* Ignoring errors due to signal interrupts */\n                continue;\n            }\n\n            return SSH_ERROR;\n        }\n\n        if (bytes_read == 0) {\n            /* EOF encountered on the local file before reading nbytes */\n            break;\n        }\n\n        total_bytes_read += (size_t)bytes_read;\n    } while (total_bytes_read < nbytes);\n\n    return total_bytes_read;\n}\n",
      "line_start": 2072,
      "line_end": 2105,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 49,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple read-wrapper: it reads untrusted bytes into a caller-provided buffer with an input-dependent loop and EINTR handling, but contains no parsing, transformation, or complex branching. Useful as a supporting target but low priority compared to real parsers/protocol handlers."
    },
    {
      "name": "ssh_check_username_syntax",
      "clean_name": "ssh_check_username_syntax",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param username The username to be checked, has to be null terminated\n *\n * @return SSH_OK if the username passes syntax check\n *         SSH_ERROR otherwise or if username is NULL or empty string\n */\nint ssh_check_username_syntax(const char *username)\n{\n    size_t username_len;\n\n    if (username == NULL || *username == '-') {\n        return SSH_ERROR;\n    }\n\n    username_len = strlen(username);\n    if (username_len == 0 || username[username_len - 1] == '\\\\' ||\n        strpbrk(username, \"'`\\\";&<>|(){}\") != NULL) {\n        return SSH_ERROR;\n    }\n    for (size_t i = 0; i < username_len; i++) {\n        if (isspace(username[i]) != 0 && username[i + 1] == '-') {\n            return SSH_ERROR;\n        }\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 2233,
      "line_end": 2254,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple input validation of an externally provided username with modest branching and a single input-dependent loop. Low attack surface (no memory copies, crypto, or complex parsing), so useful as a fuzz target only as part of larger parsing logic rather than high-priority standalone."
    },
    {
      "name": "ssh_options_get",
      "clean_name": "ssh_options_get",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *               your responsibility to free the memory using\n *               ssh_string_free_char().\n *\n * @return       SSH_OK on success, SSH_ERROR on error.\n */\nint ssh_options_get(ssh_session session, enum ssh_options_e type, char** value)\n{\n    char *src = NULL;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (value == NULL) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n\n    switch(type)\n    {\n        case SSH_OPTIONS_HOST:\n            src = session->opts.host;\n            break;\n\n        case SSH_OPTIONS_USER:\n            src = session->opts.username;\n            break;\n\n        case SSH_OPTIONS_IDENTITY: {\n            struct ssh_iterator *it = NULL;\n            it = ssh_list_get_iterator(session->opts.identity);\n            if (it == NULL) {\n                it = ssh_list_get_iterator(session->opts.identity_non_exp);\n            }\n            if (it == NULL) {\n                return SSH_ERROR;\n            }\n            src = ssh_iterator_value(char *, it);\n            break;\n        }\n\n        case SSH_OPTIONS_PROXYCOMMAND:\n            src = session->opts.ProxyCommand;\n            break;\n\n        case SSH_OPTIONS_KNOWNHOSTS:\n            src = session->opts.knownhosts;\n            break;\n\n        case SSH_OPTIONS_GLOBAL_KNOWNHOSTS:\n            src = session->opts.global_knownhosts;\n            break;\n        case SSH_OPTIONS_CONTROL_PATH:\n            src = session->opts.control_path;\n            break;\n\n        case SSH_OPTIONS_CIPHERS_C_S:\n            src = ssh_options_get_algo(session, SSH_CRYPT_C_S);\n            break;\n\n        case SSH_OPTIONS_CIPHERS_S_C:\n            src = ssh_options_get_algo(session, SSH_CRYPT_S_C);\n            break;\n\n        case SSH_OPTIONS_KEY_EXCHANGE:\n            src = ssh_options_get_algo(session, SSH_KEX);\n            break;\n\n        case SSH_OPTIONS_HOSTKEYS:\n            src = ssh_options_get_algo(session, SSH_HOSTKEYS);\n            break;\n\n        case SSH_OPTIONS_PUBLICKEY_ACCEPTED_TYPES:\n            src = session->opts.pubkey_accepted_types;\n            break;\n\n        case SSH_OPTIONS_HMAC_C_S:\n            src = ssh_options_get_algo(session, SSH_MAC_C_S);\n            break;\n\n        case SSH_OPTIONS_HMAC_S_C:\n            src = ssh_options_get_algo(session, SSH_MAC_S_C);\n            break;\n\n        case SSH_OPTIONS_COMPRESSION_C_S:\n            src = ssh_options_get_algo(session, SSH_COMP_C_S);\n            break;\n\n        case SSH_OPTIONS_COMPRESSION_S_C:\n            src = ssh_options_get_algo(session, SSH_COMP_S_C);\n            break;\n\n        default:\n            ssh_set_error(session, SSH_REQUEST_DENIED, \"Unknown ssh option %d\", type);\n            return SSH_ERROR;\n        break;\n    }\n    if (src == NULL) {\n        return SSH_ERROR;\n    }\n    *value = strdup(src);\n    if (*value == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 1520,
      "line_end": 1622,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 115,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: a getter with multiple switch branches (moderate cyclomatic complexity) that performs memory operations (strdup) and dereferences session-controlled pointers. However it does not parse complex external input or implement heavy validation/looping logic \u2014 mostly a helper accessor that delegates real parsing to other functions."
    },
    {
      "name": "ssh_options_parse_config",
      "clean_name": "ssh_options_parse_config",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *\n * @return 0 on success, < 0 on error.\n *\n * @see ssh_options_set()\n */\nint ssh_options_parse_config(ssh_session session, const char *filename)\n{\n    char *expanded_filename = NULL;\n    int r;\n    FILE *fp = NULL;\n\n    if (session == NULL) {\n        return -1;\n    }\n    if (session->opts.host == NULL) {\n        ssh_set_error_invalid(session);\n        return -1;\n    }\n\n    if (session->opts.sshdir == NULL) {\n        r = ssh_options_set(session, SSH_OPTIONS_SSH_DIR, NULL);\n        if (r < 0) {\n            ssh_set_error_oom(session);\n            return -1;\n        }\n    }\n\n    /* set default filename */\n    if (filename == NULL) {\n        expanded_filename = ssh_path_expand_escape(session, \"%d/config\");\n    } else {\n        expanded_filename = ssh_path_expand_escape(session, filename);\n    }\n    if (expanded_filename == NULL) {\n        return -1;\n    }\n\n    r = ssh_config_parse_file(session, expanded_filename);\n    if (r < 0) {\n        goto out;\n    }\n    if (filename == NULL) {\n        if ((fp = fopen(GLOBAL_CLIENT_CONFIG, \"r\")) != NULL) {\n            filename = GLOBAL_CLIENT_CONFIG;\n#ifdef USR_GLOBAL_CLIENT_CONFIG\n        } else if ((fp = fopen(USR_GLOBAL_CLIENT_CONFIG, \"r\")) != NULL) {\n            filename = USR_GLOBAL_CLIENT_CONFIG;\n#endif\n        }\n\n        if (fp) {\n            SSH_LOG(SSH_LOG_PACKET,\n                    \"Reading configuration data from %s\",\n                    filename);\n            r = ssh_config_parse(session, fp, true);\n            fclose(fp);\n        }\n    }\n\n    /* Do not process the default configuration as part of connection again */\n    session->opts.config_processed = true;\nout:\n    free(expanded_filename);\n    return r;\n}\n",
      "line_start": 1826,
      "line_end": 1886,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is mainly a thin wrapper that expands a path, opens config files, and delegates actual parsing to ssh_config_parse_file/ssh_config_parse. It has low cyclomatic complexity and does little direct manipulation of untrusted data, so its standalone fuzz value is moderate (better to fuzz the underlying config parsers directly)."
    },
    {
      "name": "options.c:ssh_bind_key_size_allowed",
      "clean_name": "ssh_bind_key_size_allowed",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "}\n\n/** @} */\n\n#ifdef WITH_SERVER\nstatic bool ssh_bind_key_size_allowed(ssh_bind sshbind, ssh_key key)\n{\n    int min_size = 0;\n\n    switch (ssh_key_type(key)) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA_CERT01:\n        min_size = sshbind->rsa_min_size;\n        return ssh_key_size_allowed_rsa(min_size, key);\n    default:\n        return true;\n    }\n}\n",
      "line_start": 2034,
      "line_end": 2047,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple helper that dispatches based on key type and delegates RSA checks to ssh_key_size_allowed_rsa. Contains minimal branching and no parsing, memory ops, loops, or complex logic \u2014 moderate fuzz value only as part of larger key-handling code."
    },
    {
      "name": "ssh_pcap_file_write_packet",
      "clean_name": "ssh_pcap_file_write_packet",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "\n/** @internal\n * @brief prepends a packet with the pcap header and writes packet\n * on file\n */\nint ssh_pcap_file_write_packet(ssh_pcap_file pcap, ssh_buffer packet, uint32_t original_len)\n{\n    ssh_buffer header = ssh_buffer_new();\n    struct timeval now;\n    int err;\n\n    if (header == NULL) {\n        return SSH_ERROR;\n    }\n\n    gettimeofday(&now, NULL);\n    err = ssh_buffer_allocate_size(header,\n                                   sizeof(uint32_t) * 4 +\n                                   ssh_buffer_get_len(packet));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u32(header, htonl(now.tv_sec));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u32(header, htonl(now.tv_usec));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u32(header, htonl(ssh_buffer_get_len(packet)));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u32(header, htonl(original_len));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_buffer(header, packet);\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_pcap_file_write(pcap, header);\nerror:\n    SSH_BUFFER_FREE(header);\n    return err;\n}\n",
      "line_start": 159,
      "line_end": 201,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that prepends a pcap header and copies an existing buffer. It performs memory allocation and buffer copy based on external input length (possible allocation/DoS issues) but contains little branching, no parsing of complex formats or protocol state, and low cyclomatic complexity \u2014 medium priority for fuzzing."
    },
    {
      "name": "ssh_key_clean",
      "clean_name": "ssh_key_clean",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "\n/**\n * @brief clean up the key and deallocate all existing keys\n * @param[in] key ssh_key to clean\n */\nvoid ssh_key_clean (ssh_key key)\n{\n    if (key == NULL)\n        return;\n\n    pki_key_clean(key);\n\n#ifndef HAVE_LIBCRYPTO\n    if (key->ed25519_privkey != NULL) {\n        explicit_bzero(key->ed25519_privkey, sizeof(ed25519_privkey));\n        SAFE_FREE(key->ed25519_privkey);\n    }\n    SAFE_FREE(key->ed25519_pubkey);\n#endif /* HAVE_LIBCRYPTO */\n    if (key->cert != NULL) {\n        SSH_BUFFER_FREE(key->cert);\n    }\n    if (is_sk_key_type(key->type)) {\n        ssh_string_burn(key->sk_application);\n        ssh_string_free(key->sk_application);\n        ssh_string_burn(key->sk_key_handle);\n        ssh_string_free(key->sk_key_handle);\n        ssh_string_burn(key->sk_reserved);\n        ssh_string_free(key->sk_reserved);\n        key->sk_flags = 0;\n    }\n    key->cert_type = SSH_KEYTYPE_UNKNOWN;\n    key->flags = SSH_KEY_FLAG_EMPTY;\n    key->type = SSH_KEYTYPE_UNKNOWN;\n    key->ecdsa_nid = 0;\n    key->type_c = NULL;\n}\n",
      "line_start": 210,
      "line_end": 242,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a cleanup/deallocation helper with simple conditional frees, zeroing, and state resets. It has moderate branching (NULL checks, conditional frees, SK-specific wipes) but does not parse external input, lacks loops or complex parsing logic, and mainly performs memory cleanup. It can surface memory-management bugs (double-free/use-after-free) but is not a high-value fuzzing target compared to parsers/protocol handlers."
    },
    {
      "name": "ssh_pki_export_privkey_file_format",
      "clean_name": "ssh_pki_export_privkey_file_format",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return     SSH_OK on success, SSH_ERROR on error.\n */\n\nint\nssh_pki_export_privkey_file_format(const ssh_key privkey,\n                                   const char *passphrase,\n                                   ssh_auth_callback auth_fn,\n                                   void *auth_data,\n                                   const char *filename,\n                                   enum ssh_file_format_e format)\n{\n    ssh_string blob = NULL;\n    FILE *fp = NULL;\n    int rc;\n\n    if (privkey == NULL || !ssh_key_is_private(privkey)) {\n        return SSH_ERROR;\n    }\n\n    fp = fopen(filename, \"wb\");\n    if (fp == NULL) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"Error opening %s: %s\",\n                filename, ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_EOF;\n    }\n\n    /*\n     * For historic reasons, the Ed25519 keys are exported in OpenSSH file\n     * format by default also when built with OpenSSL.\n     *\n     * The FIDO2/U2F security keys are an extension to the SSH protocol\n     * proposed by OpenSSH, and do not have any representation in PEM format.\n     * So, they are always exported in the OpenSSH file format.\n     */\n#ifdef HAVE_LIBCRYPTO\n    if (format == SSH_FILE_FORMAT_DEFAULT &&\n        privkey->type != SSH_KEYTYPE_ED25519 &&\n        !is_sk_key_type(privkey->type)) {\n\n        format = SSH_FILE_FORMAT_PEM;\n    }\n#endif /* HAVE_LIBCRYPTO */\n\n    switch (format) {\n    case SSH_FILE_FORMAT_PEM:\n        blob = pki_private_key_to_pem(privkey,\n                                      passphrase,\n                                      auth_fn,\n                                      auth_data);\n        break;\n    case SSH_FILE_FORMAT_DEFAULT:\n        /* default except (OpenSSL && !ED25519) handled above */\n    case SSH_FILE_FORMAT_OPENSSH:\n        blob = ssh_pki_openssh_privkey_export(privkey,\n                                              passphrase,\n                                              auth_fn,\n                                              auth_data);\n        break;\n    }\n    if (blob == NULL) {\n        fclose(fp);\n        return -1;\n    }\n\n    rc = fwrite(ssh_string_data(blob), ssh_string_len(blob), 1, fp);\n    SSH_STRING_FREE(blob);\n    if (rc != 1 || ferror(fp)) {\n        fclose(fp);\n        unlink(filename);\n        return SSH_ERROR;\n    }\n    fclose(fp);\n\n    return SSH_OK;\n}\n",
      "line_start": 1204,
      "line_end": 1276,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a thin wrapper that validates the key, selects an exporter, and writes the resulting blob to a file. It touches untrusted inputs (filename, passphrase, auth callback) and triggers complex serialization routines (PEM/OpenSSH exporters), but the function itself has low cyclomatic complexity and minimal direct parsing/processing. Medium-priority: useful as a harness entrypoint but better fuzz targets are the exporter functions it calls."
    },
    {
      "name": "ssh_pki_export_pubkey_file",
      "clean_name": "ssh_pki_export_pubkey_file",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param filename The name of the output file\n *\n * @returns SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_pki_export_pubkey_file(const ssh_key key,\n                               const char *filename)\n{\n    char key_buf[MAX_LINE_SIZE];\n    char host[256];\n    char *b64_key = NULL;\n    char *user = NULL;\n    FILE *fp = NULL;\n    int rc;\n\n    if (key == NULL || filename == NULL || *filename == '\\0') {\n        return SSH_ERROR;\n    }\n\n    user = ssh_get_local_username();\n    if (user == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = gethostname(host, sizeof(host));\n    if (rc < 0) {\n        free(user);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_pki_export_pubkey_base64(key, &b64_key);\n    if (rc < 0) {\n        free(user);\n        return SSH_ERROR;\n    }\n\n    rc = snprintf(key_buf, sizeof(key_buf),\n                  \"%s %s %s@%s\\n\",\n                  key->type_c,\n                  b64_key,\n                  user,\n                  host);\n    free(user);\n    free(b64_key);\n    if (rc < 0) {\n        return SSH_ERROR;\n    }\n\n    fp = fopen(filename, \"wb+\");\n    if (fp == NULL) {\n        return SSH_ERROR;\n    }\n    rc = fwrite(key_buf, strlen(key_buf), 1, fp);\n    if (rc != 1 || ferror(fp)) {\n        fclose(fp);\n        unlink(filename);\n        return SSH_ERROR;\n    }\n    fclose(fp);\n\n    return SSH_OK;\n}\n",
      "line_start": 2481,
      "line_end": 2538,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate value as a fuzz target: it handles external inputs (ssh_key and filename), performs string formatting and file I/O, and calls a base64 export routine, so memory/IO issues (e.g. snprintf truncation, write errors, filename handling) could be exposed. However it does not parse complex external formats or contain heavy branching/crypto logic itself, so it is a medium priority target."
    },
    {
      "name": "ssh_pki_export_signature_blob",
      "clean_name": "ssh_pki_export_signature_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    privkey->cert = cert_buffer;\n    privkey->cert_type = certkey->type;\n    return SSH_OK;\n}\n\nint ssh_pki_export_signature_blob(const ssh_signature sig,\n                                  ssh_string *sig_blob)\n{\n    ssh_buffer buf = NULL;\n    ssh_string str = NULL;\n    int rc;\n\n    if (sig == NULL || sig_blob == NULL) {\n        return SSH_ERROR;\n    }\n\n    buf = ssh_buffer_new();\n    if (buf == NULL) {\n        return SSH_ERROR;\n    }\n\n    str = ssh_string_from_char(sig->type_c);\n    if (str == NULL) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_ssh_string(buf, str);\n    SSH_STRING_FREE(str);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    str = pki_signature_to_blob(sig);\n    if (str == NULL) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_ssh_string(buf, str);\n    SSH_STRING_FREE(str);\n    if (rc < 0) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    if (is_sk_key_type(sig->type)) {\n        /* Add flags and counter for SK keys */\n        rc = ssh_buffer_pack(buf, \"bd\", sig->sk_flags, sig->sk_counter);\n        if (rc < 0) {\n            SSH_BUFFER_FREE(buf);\n            return SSH_ERROR;\n        }\n    }\n\n    str = ssh_string_new(ssh_buffer_get_len(buf));\n    if (str == NULL) {\n        SSH_BUFFER_FREE(buf);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_string_fill(str, ssh_buffer_get(buf), ssh_buffer_get_len(buf));\n    SSH_BUFFER_FREE(buf);\n    if (rc < 0) {\n        SSH_STRING_FREE(str);\n        return SSH_ERROR;\n    }\n\n    *sig_blob = str;\n\n    return SSH_OK;\n}\n",
      "line_start": 2587,
      "line_end": 2655,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 193,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Serializer that constructs a signature blob: does perform memory/string ops and has a small conditional path (SK keys) but is not parsing complex external input or handling many code paths \u2014 moderate fuzz value (medium priority)."
    },
    {
      "name": "ssh_srv_pki_do_sign_sessionid",
      "clean_name": "ssh_srv_pki_do_sign_sessionid",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "\n    return sig_blob;\n}\n\n#ifdef WITH_SERVER\nssh_string ssh_srv_pki_do_sign_sessionid(ssh_session session,\n                                         const ssh_key privkey,\n                                         const enum ssh_digest_e digest)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    bool allowed;\n    ssh_signature sig = NULL;\n    ssh_string sig_blob = NULL;\n\n    ssh_buffer sign_input = NULL;\n\n    int rc;\n\n    if (session == NULL || privkey == NULL || !ssh_key_is_private(privkey)) {\n        return NULL;\n    }\n\n    allowed = ssh_key_size_allowed(session, privkey);\n    if (!allowed) {\n        ssh_set_error(session, SSH_FATAL, \"The hostkey size too small\");\n        return NULL;\n    }\n\n    crypto = session->next_crypto ? session->next_crypto :\n                                    session->current_crypto;\n\n    if (crypto->secret_hash == NULL){\n        ssh_set_error(session, SSH_FATAL, \"Missing secret_hash\");\n        return NULL;\n    }\n\n    /* Fill the input */\n    sign_input = ssh_buffer_new();\n    if (sign_input == NULL) {\n        goto end;\n    }\n    ssh_buffer_set_secure(sign_input);\n\n    rc = ssh_buffer_pack(sign_input,\n                         \"P\",\n                         crypto->digest_len,\n                         crypto->secret_hash);\n    if (rc != SSH_OK) {\n        goto end;\n    }\n\n    /* Generate the signature */\n    sig = pki_do_sign(privkey,\n                      ssh_buffer_get(sign_input),\n                      ssh_buffer_get_len(sign_input),\n                      digest);\n    if (sig == NULL) {\n        goto end;\n    }\n\n    /* Convert the signature to blob */\n    rc = ssh_pki_export_signature_blob(sig, &sig_blob);\n    if (rc < 0) {\n        sig_blob = NULL;\n    }\n\nend:\n    ssh_signature_free(sig);\n    SSH_BUFFER_FREE(sign_input);\n\n    return sig_blob;\n}\n",
      "line_start": 3583,
      "line_end": 3650,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 99,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzzing value: this helper performs memory operations (buffer packing) and calls into crypto/signature export routines, but it does not parse complex external input or implement heavy branching/loops. Inputs are internal objects (session/privkey) rather than raw serialized data, so it\u2019s medium priority for fuzzing (potentially useful to exercise crypto code called by it)."
    },
    {
      "name": "ssh_poll_ctx_remove",
      "clean_name": "ssh_poll_ctx_remove",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @brief  Remove a poll object from a poll context.\n *\n * @param  ctx          Pointer to an already allocated poll context.\n * @param  p            Pointer to an already allocated poll object.\n */\nvoid ssh_poll_ctx_remove(ssh_poll_ctx ctx, ssh_poll_handle p)\n{\n    size_t i;\n\n    i = p->x.idx;\n    p->x.fd = ctx->pollfds[i].fd;\n    p->ctx = NULL;\n\n    ctx->polls_used--;\n\n    /* fill the empty poll slot with the last one */\n    if (ctx->polls_used > 0 && ctx->polls_used != i) {\n        ctx->pollfds[i] = ctx->pollfds[ctx->polls_used];\n        ctx->pollptrs[i] = ctx->pollptrs[ctx->polls_used];\n        ctx->pollptrs[i]->x.idx = i;\n    }\n\n    /* this will always leave at least chunk_size polls allocated */\n    if (ctx->polls_allocated - ctx->polls_used > ctx->chunk_size) {\n        ssh_poll_ctx_resize(ctx, ctx->polls_allocated - ctx->chunk_size);\n    }\n}\n",
      "line_start": 661,
      "line_end": 683,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: it performs index-based memory/array manipulation and can trigger realloc via ssh_poll_ctx_resize (potential OOB or use-after-free if ctx/p are corrupted), but it does not parse complex external input, handle crypto/auth, or contain high branching complexity \u2014 so medium priority for fuzzing."
    },
    {
      "name": "ssh_event_add_session",
      "clean_name": "ssh_event_add_session",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param session   The session to add to the event.\n *\n * @returns SSH_OK      on success\n *          SSH_ERROR   on failure\n */\nint ssh_event_add_session(ssh_event event, ssh_session session)\n{\n    ssh_poll_handle p = NULL;\n#ifdef WITH_SERVER\n    struct ssh_iterator *iterator = NULL;\n#endif\n    int rc;\n\n    if (event == NULL || event->ctx == NULL || session == NULL) {\n        return SSH_ERROR;\n    }\n    if (session->default_poll_ctx == NULL) {\n        return SSH_ERROR;\n    }\n    while (session->default_poll_ctx->polls_used > 0) {\n        p = session->default_poll_ctx->pollptrs[0];\n        /*\n         * ssh_poll_ctx_remove() decrements\n         * session->default_poll_ctx->polls_used\n         */\n        ssh_poll_ctx_remove(session->default_poll_ctx, p);\n        rc = ssh_poll_ctx_add(event->ctx, p);\n        if (rc != SSH_OK) {\n            return rc;\n        }\n        /* associate the pollhandler with a session so we can put it back\n         * at ssh_event_free()\n         */\n        p->session = session;\n    }\n#ifdef WITH_SERVER\n    iterator = ssh_list_get_iterator(event->sessions);\n    while (iterator != NULL) {\n        if ((ssh_session)iterator->data == session) {\n            /* allow only one instance of this session */\n            return SSH_OK;\n        }\n        iterator = iterator->next;\n    }\n    if (ssh_list_append(event->sessions, session) == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n#endif\n    return SSH_OK;\n}\n",
      "line_start": 964,
      "line_end": 1009,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: it manipulates poll handle arrays and session pointers and has a loop driven by session->default_poll_ctx->polls_used, which can expose memory-management issues. However it does not parse complex external input or implement protocol/crypto logic, and its control flow is relatively simple, so it is medium priority for fuzzing."
    },
    {
      "name": "ssh_event_remove_session",
      "clean_name": "ssh_event_remove_session",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  session      The session to remove.\n *\n * @returns SSH_OK      on success\n *          SSH_ERROR   on failure\n */\nint ssh_event_remove_session(ssh_event event, ssh_session session)\n{\n    ssh_poll_handle p = NULL;\n    register size_t i, used;\n    int rc = SSH_ERROR;\n#ifdef WITH_SERVER\n    struct ssh_iterator *iterator = NULL;\n#endif\n\n    if (event == NULL || event->ctx == NULL || session == NULL) {\n        return SSH_ERROR;\n    }\n\n    used = event->ctx->polls_used;\n    for (i = 0; i < used; i++) {\n        p = event->ctx->pollptrs[i];\n        if (p->session == session) {\n            /*\n             * ssh_poll_ctx_remove() decrements\n             * event->ctx->polls_used\n             */\n            ssh_poll_ctx_remove(event->ctx, p);\n            p->session = NULL;\n            rc = ssh_poll_ctx_add(session->default_poll_ctx, p);\n            if (rc != SSH_OK) {\n                return rc;\n            }\n            rc = SSH_OK;\n            /*\n             * Restart the loop!\n             * A session can initially have two pollhandlers.\n             */\n            used = event->ctx->polls_used;\n            i = 0;\n        }\n    }\n#ifdef WITH_SERVER\n    iterator = ssh_list_get_iterator(event->sessions);\n    while (iterator != NULL) {\n        if ((ssh_session)iterator->data == session) {\n            ssh_list_remove(event->sessions, iterator);\n            /* there should be only one instance of this session */\n            break;\n        }\n        iterator = iterator->next;\n    }\n#endif\n\n    return rc;\n}\n",
      "line_start": 1113,
      "line_end": 1163,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Internal session-removal helper that manipulates poll handles and list state with loops and pointer updates. Moderate cyclomatic complexity and potential for logic bugs (double-remove, use-after-free) but it does not parse complex external input or perform raw memory operations on untrusted data, so it's a medium-priority fuzz target."
    },
    {
      "name": "ssh_free",
      "clean_name": "ssh_free",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @param[in] session   The SSH session to free.\n *\n * @see ssh_disconnect()\n * @see ssh_new()\n */\nvoid ssh_free(ssh_session session)\n{\n  int i;\n  struct ssh_iterator *it = NULL;\n  struct ssh_buffer_struct *b = NULL;\n\n  if (session == NULL) {\n    return;\n  }\n\n  /*\n   * Delete all channels\n   *\n   * This needs the first thing we clean up cause if there is still an open\n   * channel we call ssh_channel_close() first. So we need a working socket\n   * and poll context for it.\n   */\n  for (it = ssh_list_get_iterator(session->channels);\n       it != NULL;\n       it = ssh_list_get_iterator(session->channels)) {\n      ssh_channel_do_free(ssh_iterator_value(ssh_channel,it));\n      ssh_list_remove(session->channels, it);\n  }\n  ssh_list_free(session->channels);\n  session->channels = NULL;\n\n#ifdef WITH_PCAP\n  if (session->pcap_ctx) {\n      ssh_pcap_context_free(session->pcap_ctx);\n      session->pcap_ctx = NULL;\n  }\n#endif\n\n  ssh_socket_free(session->socket);\n  session->socket = NULL;\n\n  if (session->default_poll_ctx) {\n      ssh_poll_ctx_free(session->default_poll_ctx);\n  }\n\n  SSH_BUFFER_FREE(session->in_buffer);\n  SSH_BUFFER_FREE(session->out_buffer);\n  session->in_buffer = session->out_buffer = NULL;\n\n  if (session->in_hashbuf != NULL) {\n      SSH_BUFFER_FREE(session->in_hashbuf);\n  }\n  if (session->out_hashbuf != NULL) {\n      SSH_BUFFER_FREE(session->out_hashbuf);\n  }\n\n  crypto_free(session->current_crypto);\n  crypto_free(session->next_crypto);\n\n  ssh_agent_free(session->agent);\n\n  ssh_key_free(session->srv.rsa_key);\n  session->srv.rsa_key = NULL;\n  ssh_key_free(session->srv.ecdsa_key);\n  session->srv.ecdsa_key = NULL;\n  ssh_key_free(session->srv.ed25519_key);\n  session->srv.ed25519_key = NULL;\n\n  if (session->ssh_message_list) {\n      ssh_message msg;\n\n      for (msg = ssh_list_pop_head(ssh_message, session->ssh_message_list);\n           msg != NULL;\n           msg = ssh_list_pop_head(ssh_message, session->ssh_message_list)) {\n          ssh_message_free(msg);\n      }\n      ssh_list_free(session->ssh_message_list);\n  }\n\n  if (session->kbdint != NULL) {\n    ssh_kbdint_free(session->kbdint);\n  }\n\n  if (session->packet_callbacks) {\n    ssh_list_free(session->packet_callbacks);\n  }\n\n#ifdef WITH_GSSAPI\n    ssh_gssapi_free(session);\n#endif\n\n  /* options */\n  if (session->opts.identity) {\n      char *id = NULL;\n\n      for (id = ssh_list_pop_head(char *, session->opts.identity);\n           id != NULL;\n           id = ssh_list_pop_head(char *, session->opts.identity)) {\n          SAFE_FREE(id);\n      }\n      ssh_list_free(session->opts.identity);\n  }\n\n  if (session->opts.identity_non_exp) {\n      char *id = NULL;\n\n      for (id = ssh_list_pop_head(char *, session->opts.identity_non_exp);\n           id != NULL;\n           id = ssh_list_pop_head(char *, session->opts.identity_non_exp)) {\n          SAFE_FREE(id);\n      }\n      ssh_list_free(session->opts.identity_non_exp);\n  }\n\n    if (session->opts.certificate) {\n        char *cert = NULL;\n\n        for (cert = ssh_list_pop_head(char *, session->opts.certificate);\n             cert != NULL;\n             cert = ssh_list_pop_head(char *, session->opts.certificate)) {\n            SAFE_FREE(cert);\n        }\n        ssh_list_free(session->opts.certificate);\n    }\n\n    if (session->opts.certificate_non_exp) {\n        char *cert = NULL;\n\n        for (cert = ssh_list_pop_head(char *, session->opts.certificate_non_exp);\n             cert != NULL;\n             cert = ssh_list_pop_head(char *, session->opts.certificate_non_exp)) {\n            SAFE_FREE(cert);\n        }\n        ssh_list_free(session->opts.certificate_non_exp);\n    }\n\n    ssh_proxyjumps_free(session->opts.proxy_jumps);\n    SSH_LIST_FREE(session->opts.proxy_jumps);\n    SSH_LIST_FREE(session->opts.proxy_jumps_user_cb);\n\n    while ((b = ssh_list_pop_head(struct ssh_buffer_struct *,\n                                  session->out_queue)) != NULL) {\n        SSH_BUFFER_FREE(b);\n    }\n    ssh_list_free(session->out_queue);\n\n  ssh_agent_state_free(session->agent_state);\n  session->agent_state = NULL;\n\n  SAFE_FREE(session->auth.auto_state);\n  SAFE_FREE(session->serverbanner);\n  SAFE_FREE(session->clientbanner);\n  SAFE_FREE(session->banner);\n  SAFE_FREE(session->disconnect_message);\n  SAFE_FREE(session->peer_discon_msg);\n\n  SAFE_FREE(session->opts.agent_socket);\n  SAFE_FREE(session->opts.bindaddr);\n  SAFE_FREE(session->opts.username);\n  SAFE_FREE(session->opts.host);\n  SAFE_FREE(session->opts.sshdir);\n  SAFE_FREE(session->opts.knownhosts);\n  SAFE_FREE(session->opts.global_knownhosts);\n  SAFE_FREE(session->opts.ProxyCommand);\n  SAFE_FREE(session->opts.gss_server_identity);\n  SAFE_FREE(session->opts.gss_client_identity);\n  SAFE_FREE(session->opts.pubkey_accepted_types);\n  SAFE_FREE(session->opts.control_path);\n\n  for (i = 0; i < SSH_KEX_METHODS; i++) {\n      if (session->opts.wanted_methods[i]) {\n          SAFE_FREE(session->opts.wanted_methods[i]);\n      }\n  }\n\n  SAFE_FREE(session->server_opts.custombanner);\n  SAFE_FREE(session->server_opts.moduli_file);\n\n  _ssh_remove_legacy_log_cb();\n\n  /* burn connection, it could contain sensitive data */\n  explicit_bzero(session, sizeof(struct ssh_session_struct));\n  SAFE_FREE(session);\n}\n",
      "line_start": 212,
      "line_end": 391,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 420,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is primarily a cleanup/free routine (ssh_free) with moderate cyclomatic complexity and many conditional branches and list-iteration loops. It does a lot of memory operations (frees, explicit_bzero) so it can reveal memory-safety bugs (double-free, use-after-free) if given a corrupted/partially-initialized session, but it does not parse complex external input, handle protocols, or perform input-dependent parsing/transformations\u2014so it is a medium-priority fuzz target."
    },
    {
      "name": "ssh_send_ignore",
      "clean_name": "ssh_send_ignore",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @param[in] session   The SSH session\n * @param[in] data      Data to be sent\n *\n * @return              SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_send_ignore (ssh_session session, const char *data) {\n    const int type = SSH2_MSG_IGNORE;\n    int rc;\n\n    if (ssh_socket_is_open(session->socket)) {\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bs\",\n                             type,\n                             data);\n        if (rc != SSH_OK){\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        ssh_packet_send(session);\n        ssh_handle_packets(session, 0);\n    }\n\n    return SSH_OK;\n\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n    return SSH_ERROR;\n}\n",
      "line_start": 999,
      "line_end": 1022,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Accepts untrusted string and forwards it into ssh_buffer_pack and packet send (memory operations on external data), but the function itself is simple (single conditional, no parsing/validation or complex control flow), so it is a medium-priority fuzz target."
    },
    {
      "name": "ssh_get_publickey_hash",
      "clean_name": "ssh_get_publickey_hash",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @see ssh_session_update_known_hosts()\n * @see ssh_get_hexa()\n * @see ssh_print_hash()\n * @see ssh_clean_pubkey_hash()\n */\nint ssh_get_publickey_hash(const ssh_key key,\n                           enum ssh_publickey_hash_type type,\n                           unsigned char **hash,\n                           size_t *hlen)\n{\n    ssh_string blob = NULL;\n    unsigned char *h = NULL;\n    int rc;\n\n    rc = ssh_pki_export_pubkey_blob(key, &blob);\n    if (rc < 0) {\n        return rc;\n    }\n\n    switch (type) {\n    case SSH_PUBLICKEY_HASH_SHA1: {\n        SHACTX ctx = NULL;\n\n        h = calloc(1, SHA_DIGEST_LEN);\n        if (h == NULL) {\n            rc = -1;\n            goto out;\n        }\n\n        ctx = sha1_init();\n        if (ctx == NULL) {\n            free(h);\n            rc = -1;\n            goto out;\n        }\n\n        rc = sha1_update(ctx, ssh_string_data(blob), ssh_string_len(blob));\n        if (rc != SSH_OK) {\n            free(h);\n            sha1_ctx_free(ctx);\n            goto out;\n        }\n        rc = sha1_final(h, ctx);\n        if (rc != SSH_OK) {\n            free(h);\n            goto out;\n        }\n\n        *hlen = SHA_DIGEST_LEN;\n        break;\n    }\n    case SSH_PUBLICKEY_HASH_SHA256: {\n        SHA256CTX ctx = NULL;\n\n        h = calloc(1, SHA256_DIGEST_LEN);\n        if (h == NULL) {\n            rc = -1;\n            goto out;\n        }\n\n        ctx = sha256_init();\n        if (ctx == NULL) {\n            free(h);\n            rc = -1;\n            goto out;\n        }\n\n        rc = sha256_update(ctx, ssh_string_data(blob), ssh_string_len(blob));\n        if (rc != SSH_OK) {\n            free(h);\n            sha256_ctx_free(ctx);\n            goto out;\n        }\n        rc = sha256_final(h, ctx);\n        if (rc != SSH_OK) {\n            free(h);\n            goto out;\n        }\n\n        *hlen = SHA256_DIGEST_LEN;\n        break;\n    }\n    case SSH_PUBLICKEY_HASH_MD5: {\n        MD5CTX ctx = NULL;\n\n        /* In FIPS mode, we cannot use MD5 */\n        if (ssh_fips_mode()) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"In FIPS mode MD5 is not allowed.\"\n                    \"Try using SSH_PUBLICKEY_HASH_SHA256\");\n            rc = SSH_ERROR;\n            goto out;\n        }\n\n        h = calloc(1, MD5_DIGEST_LEN);\n        if (h == NULL) {\n            rc = -1;\n            goto out;\n        }\n\n        ctx = md5_init();\n        if (ctx == NULL) {\n            free(h);\n            rc = -1;\n            goto out;\n        }\n\n        rc = md5_update(ctx, ssh_string_data(blob), ssh_string_len(blob));\n        if (rc != SSH_OK) {\n            free(h);\n            md5_ctx_free(ctx);\n            goto out;\n        }\n        rc = md5_final(h, ctx);\n        if (rc != SSH_OK) {\n            free(h);\n            goto out;\n        }\n\n        *hlen = MD5_DIGEST_LEN;\n        break;\n    }\n    default:\n        rc = -1;\n        goto out;\n    }\n\n    *hash = h;\n    rc = 0;\nout:\n    SSH_STRING_FREE(blob);\n    return rc;\n}\n",
      "line_start": 1257,
      "line_end": 1385,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 152,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a small helper that exports a public-key blob and computes a digest (SHA1/SHA256/MD5). It does perform memory allocation and uses crypto primitives on external blob data, but it contains little parsing logic, low cyclomatic complexity (single switch), and no complex input-dependent loops. The real attack surface is in ssh_pki_export_pubkey_blob/any key-parsing code, so this function is a medium-priority fuzz target rather than high/critical."
    },
    {
      "name": "ssh_string_fill",
      "clean_name": "ssh_string_fill",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param len      Size of data.\n *\n * @return         0 on success, < 0 on error.\n */\nint ssh_string_fill(struct ssh_string_struct *s, const void *data, size_t len)\n{\n    if ((s == NULL) || (data == NULL) || (len == 0) ||\n        (len > ssh_string_len(s))) {\n        return -1;\n    }\n\n    memcpy(s->data, data, len);\n\n    return 0;\n}\n",
      "line_start": 86,
      "line_end": 97,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that copies external data with a single bounds check and a memcpy. It does perform memory operations on untrusted input (useful to fuzz as a sink), but has very low complexity, no parsing/validation logic beyond a length check, and few code paths \u2014 medium priority as a fuzz target."
    },
    {
      "name": "ssh_string_from_char",
      "clean_name": "ssh_string_from_char",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " * @return              The newly allocated string, NULL on error with errno\n *                      set.\n *\n * @note The null byte is not copied nor counted in the output string.\n */\nstruct ssh_string_struct *ssh_string_from_char(const char *what)\n{\n    struct ssh_string_struct *ptr = NULL;\n    size_t len;\n\n    if (what == NULL) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    len = strlen(what);\n\n    ptr = ssh_string_new(len);\n    if (ptr == NULL) {\n        return NULL;\n    }\n\n    memcpy(ptr->data, what, len);\n\n    return ptr;\n}\n",
      "line_start": 108,
      "line_end": 129,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Takes untrusted input and performs memory operations (strlen loop + memcpy), so it can be interesting to fuzz for OOB reads if non\u2011null-terminated data is passed. However it is a very simple wrapper with no parsing, branching, or security logic, so overall it is a medium\u2011priority fuzz target."
    },
    {
      "name": "ssh_string_get_char",
      "clean_name": "ssh_string_get_char",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param[in] s         The SSH string to get the C string from.\n *\n * @return              The char pointer, NULL on error.\n */\nconst char *ssh_string_get_char(struct ssh_string_struct *s)\n{\n    if (s == NULL) {\n        return NULL;\n    }\n    s->data[ssh_string_len(s)] = '\\0';\n\n    return (const char *)s->data;\n}\n",
      "line_start": 162,
      "line_end": 171,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that null-terminates and returns an internal buffer. It performs a memory write on (potentially) untrusted data and can cause OOB writes if the buffer has no space for the terminator, so it has security relevance, but its logic is trivial (low cyclomatic complexity, no parsing or complex branches), placing it at medium fuzz priority."
    },
    {
      "name": "ssh_string_to_char",
      "clean_name": "ssh_string_to_char",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *                      set.\n *\n * @note If the input SSH string contains zeroes, some parts of the output\n * string may not be readable with regular libc functions.\n */\nchar *ssh_string_to_char(struct ssh_string_struct *s)\n{\n    size_t len;\n    char *new = NULL;\n\n    if (s == NULL) {\n        return NULL;\n    }\n\n    len = ssh_string_len(s);\n    if (len + 1 < len) {\n        return NULL;\n    }\n\n    new = malloc(len + 1);\n    if (new == NULL) {\n        return NULL;\n    }\n    memcpy(new, s->data, len);\n    new[len] = '\\0';\n\n    return new;\n}\n",
      "line_start": 183,
      "line_end": 206,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Medium priority: a simple helper that copies an ssh_string into a newly allocated, NUL-terminated buffer. It does perform memory operations on potentially untrusted data and checks for integer overflow, but it has very low cyclomatic complexity and minimal parsing/validation logic. Useful to fuzz as part of larger parsing flow, but as a standalone target it is not high-risk or complex."
    },
    {
      "name": "ssh_append_without_duplicates",
      "clean_name": "ssh_append_without_duplicates",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " *\n * @return  A newly allocated copy list containing all the elements of the\n * kept_list appended with the elements of the appended_list without duplicates;\n * NULL in case of error.\n */\nchar *ssh_append_without_duplicates(const char *list,\n                                    const char *appended_list)\n{\n    size_t concat_len = 0;\n    char *ret = NULL, *concat = NULL;\n    int rc = 0;\n\n    if (list != NULL) {\n        concat_len = strlen(list);\n    }\n\n    if (appended_list != NULL) {\n        concat_len += strlen(appended_list);\n    }\n\n    if (concat_len == 0) {\n        return NULL;\n    }\n\n    /* Add room for ending '\\0' and for middle ',' */\n    concat_len += 2;\n    concat = calloc(1, concat_len);\n    if (concat == NULL) {\n        return NULL;\n    }\n\n    rc = snprintf(concat, concat_len, \"%s%s%s\",\n                  list == NULL ? \"\" : list,\n                  list == NULL ? \"\" : \",\",\n                  appended_list == NULL ? \"\" : appended_list);\n    if (rc < 0) {\n        SAFE_FREE(concat);\n        return NULL;\n    }\n\n    ret = ssh_remove_duplicates(concat);\n\n    SAFE_FREE(concat);\n\n    return ret;\n}\n",
      "line_start": 373,
      "line_end": 414,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Helper that concatenates two input strings and calls ssh_remove_duplicates. It performs memory ops on untrusted data (strlen, snprintf, calloc) but has simple control flow, no input-dependent loops, and low cyclomatic complexity. The real parsing/complexity likely lives in ssh_remove_duplicates, so this wrapper is medium priority as a fuzz target."
    },
    {
      "name": "ssh_prefix_without_duplicates",
      "clean_name": "ssh_prefix_without_duplicates",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " *\n * @return  A newly allocated list containing all the elements\n * of the list prefixed with the elements of the prefixed_list without\n * duplicates; NULL in case of error.\n */\nchar *ssh_prefix_without_duplicates(const char *list,\n                                    const char *prefixed_list)\n{\n    size_t concat_len = 0;\n    char *ret = NULL, *concat = NULL;\n    int rc = 0;\n\n    if (list != NULL) {\n        concat_len = strlen(list);\n    }\n\n    if (prefixed_list != NULL) {\n        concat_len += strlen(prefixed_list);\n    }\n\n    if (concat_len == 0) {\n        return NULL;\n    }\n\n    /* Add room for ending '\\0' and for middle ',' */\n    concat_len += 2;\n    concat = calloc(concat_len, 1);\n    if (concat == NULL) {\n        return NULL;\n    }\n\n    rc = snprintf(concat, concat_len, \"%s%s%s\",\n                  prefixed_list == NULL ? \"\" : prefixed_list,\n                  prefixed_list == NULL ? \"\" : \",\",\n                  list == NULL ? \"\" : list);\n    if (rc < 0) {\n        SAFE_FREE(concat);\n        return NULL;\n    }\n\n    ret = ssh_remove_duplicates(concat);\n\n    SAFE_FREE(concat);\n\n    return ret;\n}\n",
      "line_start": 504,
      "line_end": 545,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that concatenates two strings and calls ssh_remove_duplicates. Low cyclomatic complexity and minimal branching; performs basic memory ops on untrusted data but most parsing/removal work is delegated to ssh_remove_duplicates. Possible issues (missing snprintf truncation check, large-allocation/resource exhaustion) raise some interest, but on its own it is a medium-priority fuzz target."
    },
    {
      "name": "pki_signature_from_blob",
      "clean_name": "pki_signature_from_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "        ECDSA_SIG_free(ecdsa_sig);\n    }\n    return SSH_ERROR;\n}\n\nssh_signature pki_signature_from_blob(const ssh_key pubkey,\n                                      const ssh_string sig_blob,\n                                      enum ssh_keytypes_e type,\n                                      enum ssh_digest_e hash_type)\n{\n    ssh_signature sig;\n    int rc;\n\n    if (ssh_key_type_plain(pubkey->type) != type) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Incompatible public key provided (%d) expecting (%d)\",\n                type,\n                pubkey->type);\n        return NULL;\n    }\n\n    sig = ssh_signature_new();\n    if (sig == NULL) {\n        return NULL;\n    }\n\n    sig->type = type;\n    sig->type_c = ssh_key_signature_to_char(type, hash_type);\n    sig->hash_type = hash_type;\n\n    switch(type) {\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            rc = pki_signature_from_rsa_blob(pubkey, sig_blob, sig);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n            break;\n        case SSH_KEYTYPE_ED25519:\n        case SSH_KEYTYPE_SK_ED25519:\n            rc = pki_signature_from_ed25519_blob(sig, sig_blob);\n            if (rc != SSH_OK){\n                goto error;\n            }\n            break;\n        case SSH_KEYTYPE_ECDSA_P256:\n        case SSH_KEYTYPE_ECDSA_P384:\n        case SSH_KEYTYPE_ECDSA_P521:\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n        case SSH_KEYTYPE_SK_ECDSA:\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n#ifdef HAVE_OPENSSL_ECC\n            rc = pki_signature_from_ecdsa_blob(pubkey, sig_blob, sig);\n            if (rc != SSH_OK) {\n                goto error;\n            }\n            break;\n#endif\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            SSH_LOG(SSH_LOG_TRACE, \"Unknown signature type\");\n            goto error;\n    }\n\n    return sig;\n\nerror:\n    ssh_signature_free(sig);\n    return NULL;\n}\n",
      "line_start": 2375,
      "line_end": 2442,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 67,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This function is a simple dispatcher: it validates key type, allocates and initializes a signature object, and calls type-specific parsers. It does not itself parse or manipulate untrusted blob contents or perform memory operations, so it is of moderate fuzzing value \u2014 important only insofar as the downstream pki_signature_from_* functions do the actual complex parsing."
    },
    {
      "name": "ssh_key_size",
      "clean_name": "ssh_key_size",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    EVP_MD_CTX_free(ctx);\n    EVP_PKEY_free(pkey);\n    return rc;\n}\n\nint ssh_key_size(ssh_key key)\n{\n    int bits = 0;\n    EVP_PKEY *pkey = NULL;\n\n    switch (key->type) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_SK_ECDSA:\n    case SSH_KEYTYPE_SK_ECDSA_CERT01:\n        pkey = pki_key_to_pkey(key);\n        if (pkey == NULL) {\n            return SSH_ERROR;\n        }\n        bits = EVP_PKEY_bits(pkey);\n        EVP_PKEY_free(pkey);\n        return bits;\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_SK_ED25519:\n    case SSH_KEYTYPE_SK_ED25519_CERT01:\n        /* ed25519 keys have fixed size */\n        return 255;\n    case SSH_KEYTYPE_DSS:   /* deprecated */\n    case SSH_KEYTYPE_DSS_CERT01:    /* deprecated */\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        return SSH_ERROR;\n    }\n}\n",
      "line_start": 2747,
      "line_end": 2784,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Small wrapper/helper: simple switch over key->type with limited branching and no loops. It delegates real work to pki_key_to_pkey/EVP_PKEY_bits (crypto library), but the function itself does not parse complex external input or perform memory operations on raw untrusted data, so medium fuzz priority."
    },
    {
      "name": "pki_key_generate_ed25519",
      "clean_name": "pki_key_generate_ed25519",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    default:\n        return SSH_ERROR;\n    }\n}\n\nint pki_key_generate_ed25519(ssh_key key)\n{\n    int evp_rc;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *pkey = NULL;\n\n    if (key == NULL) {\n        return SSH_ERROR;\n    }\n\n    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_ED25519, NULL);\n    if (pctx == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create ed25519 EVP_PKEY_CTX: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto error;\n    }\n\n    evp_rc = EVP_PKEY_keygen_init(pctx);\n    if (evp_rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to initialize ed25519 key generation: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto error;\n    }\n\n    evp_rc = EVP_PKEY_keygen(pctx, &pkey);\n    if (evp_rc != 1) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to generate ed25519 key: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        goto error;\n    }\n    key->key = pkey;\n\n    EVP_PKEY_CTX_free(pctx);\n    return SSH_OK;\n\nerror:\n    if (pctx != NULL) {\n        EVP_PKEY_CTX_free(pctx);\n    }\n    if (pkey != NULL) {\n        EVP_PKEY_free(pkey);\n    }\n\n    return SSH_ERROR;\n}\n",
      "line_start": 2785,
      "line_end": 2833,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 57,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Wrapper around OpenSSL ed25519 key generation: minimal control flow (null check + error paths), no parsing of external/structured input or buffer/string ops. It does perform cryptographic operations (could exercise OpenSSL internals), but the function itself has low complexity and little direct user-controllable data, so it's of moderate value as a fuzz target."
    },
    {
      "name": "pki_crypto.c:pem_get_password",
      "clean_name": "pem_get_password",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "struct pem_get_password_struct {\n    ssh_auth_callback fn;\n    void *data;\n};\n\nstatic int pem_get_password(char *buf, int size, int rwflag, void *userdata) {\n    struct pem_get_password_struct *pgp = userdata;\n\n    (void) rwflag; /* unused */\n\n    if (buf == NULL) {\n        return 0;\n    }\n\n    memset(buf, '\\0', size);\n    if (pgp) {\n        int rc;\n\n        rc = pgp->fn(\"Passphrase for private key:\",\n                     buf, size, 0, 0,\n                     pgp->data);\n        if (rc == 0) {\n            return (int)strlen(buf);\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 70,
      "line_end": 93,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Small helper that clears a buffer and invokes a user-supplied callback to fill a passphrase. It performs memory ops on untrusted data and uses strlen (risking OOB read if the callback writes a full buffer without a NUL), but has very low complexity and no parsing/format handling \u2014 medium fuzz value."
    },
    {
      "name": "sha1",
      "clean_name": "sha1",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha1(const unsigned char *digest, size_t len, unsigned char *hash)\n{\n    SHACTX c = sha1_init();\n    int rc;\n\n    if (c == NULL) {\n        return SSH_ERROR;\n    }\n    rc = sha1_update(c, digest, len);\n    if (rc != SSH_OK) {\n        EVP_MD_CTX_free(c);\n        return SSH_ERROR;\n    }\n    return sha1_final(hash, c);\n}\n",
      "line_start": 78,
      "line_end": 93,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "A simple wrapper around SHA-1: it takes a buffer/length, calls init/update/final and returns the hash. It performs a security-critical (cryptographic) operation but contains almost no parsing, branching, or input-dependent loops; minimal internal logic. Useful to fuzz only to exercise the underlying sha1_update/EVP implementation, otherwise low-to-medium priority as a direct fuzz target."
    },
    {
      "name": "md5_update",
      "clean_name": "md5_update",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "{\n    EVP_MD_CTX_free(c);\n}\n\nint\nmd5_update(MD5CTX c, const void *data, size_t len)\n{\n    int rc = EVP_DigestUpdate(c, data, len);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 303,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper around EVP_DigestUpdate that accepts external data/length and forwards it to the crypto library. It processes untrusted input but contains no parsing, branching, or buffer manipulation itself \u2014 moderate fuzz value (exercises crypto code but low internal complexity)."
    },
    {
      "name": "ssh_dh_keypair_gen_keys",
      "clean_name": "ssh_dh_keypair_gen_keys",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": " * @param peer Select either client or server key storage. Valid values are:\n *        DH_CLIENT_KEYPAIR or DH_SERVER_KEYPAIR\n *\n * @return SSH_OK on success, SSH_ERROR on error\n */\nint ssh_dh_keypair_gen_keys(struct dh_ctx *dh_ctx, int peer)\n{\n    int rc;\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    EVP_PKEY_CTX *evp_ctx = NULL;\n#endif\n\n    if ((dh_ctx == NULL) || (dh_ctx->keypair[peer] == NULL)) {\n        return SSH_ERROR;\n    }\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    rc = DH_generate_key(dh_ctx->keypair[peer]);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n#else\n    evp_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, dh_ctx->keypair[peer], NULL);\n    if (evp_ctx == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_keygen_init(evp_ctx);\n    if (rc != 1) {\n        EVP_PKEY_CTX_free(evp_ctx);\n        return SSH_ERROR;\n    }\n\n    rc = EVP_PKEY_generate(evp_ctx, &(dh_ctx->keypair[peer]));\n    if (rc != 1) {\n        EVP_PKEY_CTX_free(evp_ctx);\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to generate DH: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    EVP_PKEY_CTX_free(evp_ctx);\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    return SSH_OK;\n}\n",
      "line_start": 470,
      "line_end": 512,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Wrapper around OpenSSL DH key generation: minimal local logic (null checks, error handling) and low cyclomatic complexity. It does perform a security-critical operation (key generation) by calling complex library code, which makes it somewhat interesting to fuzz for downstream library bugs, but it does not parse or manipulate untrusted external input itself and has no loops or complex branching \u2014 medium priority."
    },
    {
      "name": "ssh_get_key_params",
      "clean_name": "ssh_get_key_params",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  SSH_LOG(SSH_LOG_DEBUG, \"Calling next KEXDH handler\");\n  return SSH_PACKET_NOT_USED;\n}\n\nint\nssh_get_key_params(ssh_session session,\n                   ssh_key *privkey,\n                   enum ssh_digest_e *digest)\n{\n    ssh_key pubkey = NULL;\n    ssh_string pubkey_blob = NULL;\n    int rc;\n\n    switch(session->srv.hostkey) {\n      case SSH_KEYTYPE_RSA:\n        *privkey = session->srv.rsa_key;\n        break;\n      case SSH_KEYTYPE_ECDSA_P256:\n      case SSH_KEYTYPE_ECDSA_P384:\n      case SSH_KEYTYPE_ECDSA_P521:\n        *privkey = session->srv.ecdsa_key;\n        break;\n      case SSH_KEYTYPE_ED25519:\n        *privkey = session->srv.ed25519_key;\n        break;\n      case SSH_KEYTYPE_RSA1:\n      case SSH_KEYTYPE_UNKNOWN:\n      default:\n        *privkey = NULL;\n    }\n\n    *digest = session->srv.hostkey_digest;\n    rc = ssh_pki_export_privkey_to_pubkey(*privkey, &pubkey);\n    if (rc < 0) {\n      ssh_set_error(session, SSH_FATAL,\n          \"Could not get the public key from the private key\");\n\n      return -1;\n    }\n\n    rc = ssh_pki_export_pubkey_blob(pubkey, &pubkey_blob);\n    ssh_key_free(pubkey);\n    if (rc < 0) {\n      ssh_set_error_oom(session);\n      return -1;\n    }\n\n    rc = ssh_dh_import_next_pubkey_blob(session, pubkey_blob);\n    SSH_STRING_FREE(pubkey_blob);\n    if (rc != 0) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Could not import server public key\");\n        return -1;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 279,
      "line_end": 332,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate-value fuzz target: it exercises cryptographic key export/import and has multiple error paths, but it does not directly parse or operate on external/untrusted input (it uses session-held keys). Cyclomatic complexity and crypto interactions make it potentially useful, but it is not high-priority compared with functions that parse external formats or manipulate untrusted buffers."
    },
    {
      "name": "ssh_message_service_reply_success",
      "clean_name": "ssh_message_service_reply_success",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param msg The message to reply to\n *\n * @returns SSH_OK when success otherwise SSH_ERROR\n */\nint ssh_message_service_reply_success(ssh_message msg)\n{\n    ssh_session session = NULL;\n    int rc;\n\n    if (msg == NULL) {\n        return SSH_ERROR;\n    }\n    session = msg->session;\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Sending a SERVICE_ACCEPT for service %s\", msg->service_request.service);\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bs\",\n                         SSH2_MSG_SERVICE_ACCEPT,\n                         msg->service_request.service);\n    if (rc != SSH_OK){\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    rc = ssh_packet_send(msg->session);\n    return rc;\n}\n",
      "line_start": 726,
      "line_end": 750,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Simple helper that constructs/sends a SERVICE_ACCEPT using msg->service_request.service (untrusted string) so it does perform memory/packing operations on external data, but has low cyclomatic complexity and minimal parsing/logic. Moderate fuzzing value as it exercises buffer packing/packet send, but not a complex parser or protocol state machine."
    },
    {
      "name": "ssh_message_global_request_reply_success",
      "clean_name": "ssh_message_global_request_reply_success",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param bound_port The remote bind port\n *\n * @returns SSH_OK on success, otherwise SSH_ERROR\n */\nint ssh_message_global_request_reply_success(ssh_message msg, uint16_t bound_port) {\n    int rc;\n\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"Accepting a global request\");\n\n    if (msg->global_request.want_reply) {\n        if (ssh_buffer_add_u8(msg->session->out_buffer\n                    , SSH2_MSG_REQUEST_SUCCESS) < 0) {\n            goto error;\n        }\n\n        if(msg->global_request.type == SSH_GLOBAL_REQUEST_TCPIP_FORWARD\n                                && msg->global_request.bind_port == 0) {\n            rc = ssh_buffer_pack(msg->session->out_buffer, \"d\", bound_port);\n            if (rc != SSH_OK) {\n                ssh_set_error_oom(msg->session);\n                goto error;\n            }\n        }\n\n        return ssh_packet_send(msg->session);\n    }\n\n    if(msg->global_request.type == SSH_GLOBAL_REQUEST_TCPIP_FORWARD\n                                && msg->global_request.bind_port == 0) {\n        SSH_LOG(SSH_LOG_PACKET,\n                \"The client doesn't want to know the remote port!\");\n    }\n\n    return SSH_OK;\nerror:\n    return SSH_ERROR;\n}\n",
      "line_start": 760,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Moderate fuzz target: it acts on untrusted ssh_message flags and performs buffer writes/packing and branching, but contains no complex parsing, loops, or heavy input-dependent logic. Potentially interesting due to memory operations on session buffers, but overall low cyclomatic complexity and limited attack surface."
    },
    {
      "name": "ssh_message_auth_reply_pk_ok",
      "clean_name": "ssh_message_auth_reply_pk_ok",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param pubkey The accepted public key\n *\n * @returns SSH_OK on success, otherwise SSH_ERROR\n */\nint ssh_message_auth_reply_pk_ok(ssh_message msg, ssh_string algo, ssh_string pubkey) {\n    int rc;\n    if (msg == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_pack(msg->session->out_buffer,\n                         \"bSS\",\n                         SSH2_MSG_USERAUTH_PK_OK,\n                         algo,\n                         pubkey);\n    if(rc != SSH_OK){\n        ssh_set_error_oom(msg->session);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_packet_send(msg->session);\n    return rc;\n}\n",
      "line_start": 1108,
      "line_end": 1127,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Thin wrapper that packs and sends provided algo/pubkey to the session buffer. It operates on external input (strings) and may trigger memory operations in called functions, but contains minimal logic/branching itself. More valuable to fuzz the underlying ssh_buffer_pack/ssh_packet_send implementations or higher-level parsing routines."
    },
    {
      "name": "server.c:ssh_server_send_extensions",
      "clean_name": "ssh_server_send_extensions",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    }\n\n    return server_set_kex(session);\n}\n\nstatic int ssh_server_send_extensions(ssh_session session)\n{\n    int rc;\n    const char *hostkey_algorithms = NULL;\n\n    SSH_LOG(SSH_LOG_PACKET, \"Sending SSH_MSG_EXT_INFO\");\n\n    if (session->opts.pubkey_accepted_types) {\n        hostkey_algorithms = session->opts.pubkey_accepted_types;\n    } else {\n        if (ssh_fips_mode()) {\n            hostkey_algorithms = ssh_kex_get_fips_methods(SSH_HOSTKEYS);\n        } else {\n            /* There are no restrictions to the accepted public keys */\n            hostkey_algorithms = ssh_kex_get_default_methods(SSH_HOSTKEYS);\n        }\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bdssss\",\n                         SSH2_MSG_EXT_INFO,\n                         2, /* nr. of extensions */\n                         \"server-sig-algs\",\n                         hostkey_algorithms,\n                         \"publickey-hostbound@openssh.com\",\n                         \"0\");\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    if (ssh_packet_send(session) == SSH_ERROR) {\n        goto error;\n    }\n\n    return 0;\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n\n    return -1;\n}\n",
      "line_start": 213,
      "line_end": 253,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Composes and sends an SSH extension message and selects a hostkey algorithm string based on session options/FIPS mode, then calls buffer packing and send routines. It touches memory-ops indirectly but contains simple branching and no complex parsing, loops, or heavy input-dependent logic\u2014useful as a small helper fuzz target but not high-priority on its own."
    },
    {
      "name": "server.c:ssh_message_channel_request_reply_default",
      "clean_name": "ssh_message_channel_request_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\n    rc = ssh_packet_send(msg->session);\n    return rc;\n}\n\nstatic int ssh_message_channel_request_reply_default(ssh_message msg) {\n  uint32_t channel;\n  int rc;\n\n  if (msg->channel_request.want_reply) {\n    channel = msg->channel_request.channel->remote_channel;\n\n    SSH_LOG(SSH_LOG_PACKET,\n        \"Sending a default channel_request denied to channel %\" PRIu32, channel);\n\n    rc = ssh_buffer_pack(msg->session->out_buffer,\n                         \"bd\",\n                         SSH2_MSG_CHANNEL_FAILURE,\n                         channel);\n    if (rc != SSH_OK){\n        ssh_set_error_oom(msg->session);\n        return SSH_ERROR;\n    }\n    return ssh_packet_send(msg->session);\n  }\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"The client doesn't want to know the request failed!\");\n\n  return SSH_OK;\n}\n",
      "line_start": 687,
      "line_end": 713,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Small helper that only checks want_reply and either sends a canned CHANNEL_FAILURE or returns OK. Low cyclomatic complexity (single branch), no parsing or loops over external data; only delegates to buffer/packet APIs which are better fuzz targets themselves. Moderate priority as part of protocol handling but limited surface for direct fuzzing."
    },
    {
      "name": "dh-gex.c:dhgroup_better_size",
      "clean_name": "dhgroup_better_size",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": " * @brief Determines if the proposed modulus size is more appropriate than the\n * current one.\n *\n * @returns 1 if it's more appropriate. Returns 0 if same or less appropriate\n */\nstatic bool dhgroup_better_size(uint32_t pmin,\n                                uint32_t pn,\n                                uint32_t pmax,\n                                size_t current_size,\n                                size_t proposed_size)\n{\n    if (current_size == proposed_size) {\n        return false;\n    }\n\n    if (current_size == pn) {\n        /* can't do better */\n        return false;\n    }\n\n    if (current_size == 0 && proposed_size >= pmin && proposed_size <= pmax) {\n        return true;\n    }\n\n    if (proposed_size < pmin || proposed_size > pmax) {\n        /* out of bounds */\n        return false;\n    }\n\n    if (current_size == 0) {\n        /* not in the allowed window */\n        return false;\n    }\n\n    if (proposed_size >= pn && proposed_size < current_size) {\n        return true;\n    }\n\n    if (proposed_size <= pn && proposed_size > current_size) {\n        return true;\n    }\n\n    if (proposed_size >= pn && current_size < pn) {\n        return true;\n    }\n\n    /* We're in the allowed window but a better match already exists. */\n    return false;\n}\n",
      "line_start": 330,
      "line_end": 374,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 79,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple decision helper that only compares numeric bounds. It has multiple conditional branches (moderate cyclomatic complexity) but no parsing, memory operations, loops, or security-sensitive work, so it\u2019s of medium fuzzing value as a unit target."
    },
    {
      "name": "bin_to_base64",
      "clean_name": "bin_to_base64",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": " *\n * @brief Converts binary data to a base64 string.\n *\n * @returns the converted string\n */\nuint8_t *bin_to_base64(const uint8_t *source, size_t len)\n{\n    uint8_t *base64 = NULL;\n    uint8_t *ptr = NULL;\n    size_t flen = 0;\n\n    /* Set the artificial upper limit for the input. Otherwise on 32b arch, the\n     * following line could overflow for sizes larger than SIZE_MAX / 4 */\n    if (len > BASE64_MAX_INPUT_LEN) {\n        return NULL;\n    }\n\n    flen = len + (3 - (len % 3)); /* round to upper 3 multiple */\n    flen = (4 * flen) / 3 + 1;\n\n    base64 = malloc(flen);\n    if (base64 == NULL) {\n        return NULL;\n    }\n    ptr = base64;\n\n    while (len > 0) {\n        _bin_to_base64(ptr, source, len > 3 ? 3 : len);\n        ptr += 4;\n        if (len < 3) {\n            break;\n        }\n        source += 3;\n        len -= 3;\n    }\n    ptr[0] = '\\0';\n\n    return base64;\n}\n",
      "line_start": 279,
      "line_end": 313,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "Converts untrusted binary to base64 and performs memory operations and an input-dependent loop (allocation, pointer increments), so it has some fuzz value. However it is simple with low branching/cyclomatic complexity, no parsing of complex formats or security-critical logic, so it is a medium-priority target."
    },
    {
      "name": "ssh_config_parse",
      "clean_name": "ssh_config_parse",
      "source_file": "/src/libssh/src/config.c",
      "source_code": " * @params[in] fp        A valid file pointer\n * @params[in] global    Whether the config is global or not\n *\n * @returns    0 on successful parsing the configuration file, -1 on error\n */\nint ssh_config_parse(ssh_session session, FILE *fp, bool global)\n{\n    char line[MAX_LINE_SIZE] = {0};\n    unsigned int count = 0;\n    int parsing, rv;\n\n    parsing = 1;\n    while (fgets(line, sizeof(line), fp)) {\n        count++;\n        rv = ssh_config_parse_line(session, line, count, &parsing, 0, global);\n        if (rv < 0) {\n            return -1;\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 1461,
      "line_end": 1478,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This function is a simple file-reading wrapper: it reads lines from an external file into a fixed-size buffer and delegates all parsing to ssh_config_parse_line. It handles untrusted input and contains an input-driven loop, so it has some value as a fuzz target, but its own logic is trivial (minimal branching and no direct complex parsing or memory manipulation). The real risk/complexity likely resides in the called parsing function, which would be a higher-priority target."
    },
    {
      "name": "config.c:ssh_config_match",
      "clean_name": "ssh_config_match",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "\n    return MATCH_UNKNOWN;\n}\n\nstatic int\nssh_config_match(char *value, const char *pattern, bool negate)\n{\n    int ok, result = 0;\n\n    ok = match_pattern_list(value, pattern, strlen(pattern), 0);\n    if (ok <= 0 && negate == true) {\n        result = 1;\n    } else if (ok > 0 && negate == false) {\n        result = 1;\n    }\n    SSH_LOG(SSH_LOG_TRACE, \"%s '%s' against pattern '%s'%s (ok=%d)\",\n            result == 1 ? \"Matched\" : \"Not matched\", value, pattern,\n            negate == true ? \" (negated)\" : \"\", ok);\n    return result;\n}\n",
      "line_start": 293,
      "line_end": 308,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Simple wrapper around match_pattern_list: accepts external inputs (value, pattern) but contains minimal logic (negate check, logging). The real parsing/risk is in match_pattern_list, so this function itself is medium-priority as a fuzz target."
    },
    {
      "name": "config.c:ssh_match_localnetwork",
      "clean_name": "ssh_match_localnetwork",
      "source_file": "/src/libssh/src/config.c",
      "source_code": " * @return 1 if match found.\n * @return 0 if no match found.\n * @return -1 on errors.\n */\nstatic int\nssh_match_localnetwork(const char *addrlist, bool negate)\n{\n    struct ifaddrs *ifa = NULL, *ifaddrs = NULL;\n    int r, found = 0;\n    char address[NI_MAXHOST], err_msg[SSH_ERRNO_MSG_MAX] = {0};\n    socklen_t sa_len;\n\n    r = getifaddrs(&ifaddrs);\n    if (r != 0) {\n        SSH_LOG(SSH_LOG_WARN,\n                \"Match localnetwork: getifaddrs() failed: %s\",\n                ssh_strerror(r, err_msg, SSH_ERRNO_MSG_MAX));\n        return -1;\n    }\n\n    for (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {\n        if (ifa->ifa_addr == NULL || (ifa->ifa_flags & IFF_UP) == 0) {\n            continue;\n        }\n\n        switch (ifa->ifa_addr->sa_family) {\n        case AF_INET:\n            sa_len = sizeof(struct sockaddr_in);\n            break;\n        case AF_INET6:\n            sa_len = sizeof(struct sockaddr_in6);\n            break;\n        default:\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Interface %s: unsupported address family %d\",\n                    ifa->ifa_name,\n                    ifa->ifa_addr->sa_family);\n            continue;\n        }\n\n        r = getnameinfo(ifa->ifa_addr,\n                        sa_len,\n                        address,\n                        sizeof(address),\n                        NULL,\n                        0,\n                        NI_NUMERICHOST);\n        if (r != 0) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Interface %s getnameinfo failed: %s\",\n                    ifa->ifa_name,\n                    gai_strerror(r));\n            continue;\n        }\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Interface %s address %s\",\n                ifa->ifa_name,\n                address);\n\n        r = match_cidr_address_list(address,\n                                    addrlist,\n                                    ifa->ifa_addr->sa_family);\n        if (r == 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Matched interface %s: address %s in %s\",\n                    ifa->ifa_name,\n                    address,\n                    addrlist);\n            found = 1;\n            break;\n        }\n    }\n\n    freeifaddrs(ifaddrs);\n\n    return (found == (negate ? 0 : 1));\n}\n",
      "line_start": 662,
      "line_end": 734,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 69,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Medium value as a fuzz target. The function takes a user-controllable addrlist but does not itself implement complex parsing or direct memory manipulation \u2014 it mostly iterates system interfaces (getifaddrs/getnameinfo) and delegates parsing to match_cidr_address_list. Moderate control flow and external system dependence make it more useful for integration testing than for focused fuzzing; the real parsing surface to fuzz is in match_cidr_address_list."
    },
    {
      "name": "compress_buffer",
      "clean_name": "compress_buffer",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "\n    return dest;\n}\n\nint\ncompress_buffer(ssh_session session, ssh_buffer buf)\n{\n    ssh_buffer dest = NULL;\n    int rv;\n\n    dest = gzip_compress(session, buf, session->opts.compressionlevel);\n    if (dest == NULL) {\n        return -1;\n    }\n\n    if (ssh_buffer_reinit(buf) < 0) {\n        SSH_BUFFER_FREE(dest);\n        return -1;\n    }\n\n    rv = ssh_buffer_add_data(buf,\n                             ssh_buffer_get(dest),\n                             ssh_buffer_get_len(dest));\n    if (rv < 0) {\n        SSH_BUFFER_FREE(dest);\n        return -1;\n    }\n\n    SSH_BUFFER_FREE(dest);\n    return 0;\n}\n",
      "line_start": 121,
      "line_end": 147,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 46,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a thin helper that wraps gzip_compress and performs buffer reinitialization and data copies. It manipulates (potentially untrusted) buffer data and does memory operations, but the function itself has low cyclomatic complexity and simple control flow \u2014 the complex work likely lives in gzip_compress. Medium fuzzing priority as a useful target mainly to exercise buffer-handling and error paths."
    },
    {
      "name": "decompress_buffer",
      "clean_name": "decompress_buffer",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "\n    return dest;\n}\n\nint\ndecompress_buffer(ssh_session session, ssh_buffer buf, size_t maxlen)\n{\n    ssh_buffer dest = NULL;\n    int rv;\n\n    dest = gzip_decompress(session, buf, maxlen);\n    if (dest == NULL) {\n        return -1;\n    }\n\n    if (ssh_buffer_reinit(buf) < 0) {\n        SSH_BUFFER_FREE(dest);\n        return -1;\n    }\n\n    rv = ssh_buffer_add_data(buf,\n                             ssh_buffer_get(dest),\n                             ssh_buffer_get_len(dest));\n    if (rv < 0) {\n        SSH_BUFFER_FREE(dest);\n        return -1;\n    }\n\n    SSH_BUFFER_FREE(dest);\n    return 0;\n}\n",
      "line_start": 238,
      "line_end": 264,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 46,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 5.0,
      "reason": "This is a thin wrapper around gzip_decompress that handles untrusted compressed data and performs buffer/memory operations (reinit and add_data) but contains minimal branching and logic itself. The real parsing/risk likely lives in gzip_decompress; thus this function is medium-priority as a fuzz target (nontrivial buffer manipulation but low internal complexity)."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:known_hosts_read_line",
      "clean_name": "known_hosts_read_line",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "    ssh_key_free(entry->publickey);\n    SAFE_FREE(entry->comment);\n    SAFE_FREE(entry);\n}\n\nstatic int known_hosts_read_line(FILE *fp,\n                                 char *buf,\n                                 size_t buf_size,\n                                 size_t *buf_len,\n                                 size_t *lineno)\n{\n    while (fgets(buf, (int)buf_size, fp) != NULL) {\n        size_t len;\n        if (buf[0] == '\\0') {\n            continue;\n        }\n\n        *lineno += 1;\n        len = strlen(buf);\n        if (buf_len != NULL) {\n            *buf_len = len;\n        }\n        if (buf[len - 1] == '\\n' || feof(fp)) {\n            return 0;\n        } else {\n            errno = E2BIG;\n            return -1;\n        }\n    }\n\n    return -1;\n}\n",
      "line_start": 167,
      "line_end": 194,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 5.0,
      "reason": "Medium value: reads untrusted file input with fgets and performs simple length/newline checks and a lineno update. Low cyclomatic complexity and no complex parsing, crypto, or heavy memory manipulation, though the buf_size->int cast and newline/length handling make it useful for finding line-length/truncation and related edge-case bugs."
    },
    {
      "name": "libcrypto.c:evp_cipher_aead_get_length",
      "clean_name": "evp_cipher_aead_get_length",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "        EVP_CIPHER_CTX_free(cipher->ctx);\n    }\n}\n\nstatic int\nevp_cipher_aead_get_length(struct ssh_cipher_struct *cipher,\n                           void *in,\n                           uint8_t *out,\n                           size_t len,\n                           uint64_t seq)\n{\n    (void)cipher;\n    (void)seq;\n\n    /* The length is not encrypted: Copy it to the result buffer */\n    memcpy(out, in, len);\n\n    return SSH_OK;\n}\n",
      "line_start": 575,
      "line_end": 589,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Trivial wrapper that simply memcpy()s len bytes from in to out and returns OK. It performs a memory operation on external data (so can trigger crashes if callers pass bad lengths), but has no parsing, validation, or branching \u2014 low complexity and limited fuzz value beyond detecting obvious buffer-overflow issues."
    },
    {
      "name": "bind_config.c:ssh_bind_config_get_opcode",
      "clean_name": "ssh_bind_config_get_opcode",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "        .opcode = BIND_MATCH_UNKNOWN\n    },\n};\n\nstatic enum ssh_bind_config_opcode_e\nssh_bind_config_get_opcode(char *keyword, uint32_t *parser_flags)\n{\n    int i;\n\n    for (i = 0; ssh_bind_config_keyword_table[i].name != NULL; i++) {\n        if (strcasecmp(keyword, ssh_bind_config_keyword_table[i].name) == 0) {\n            if ((*parser_flags & IN_MATCH) &&\n                !(ssh_bind_config_keyword_table[i].allowed_in_match))\n            {\n                return BIND_CFG_NOT_ALLOWED_IN_MATCH;\n            }\n            return ssh_bind_config_keyword_table[i].opcode;\n        }\n    }\n\n    return BIND_CFG_UNKNOWN;\n}\n",
      "line_start": 168,
      "line_end": 185,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple keyword lookup using strcasecmp over a static table with a small loop and one branch on parser_flags. Low complexity and limited attack surface (read-only comparisons, no parsing of complex formats or memory writes), so only medium/low fuzz priority."
    },
    {
      "name": "ssh_packet_userauth_banner",
      "clean_name": "ssh_packet_userauth_banner",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @brief Handles a SSH_USERAUTH_BANNER packet.\n *\n * This banner should be shown to user prior to authentication\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_banner)\n{\n    ssh_string banner = NULL;\n    (void)type;\n    (void)user;\n\n    banner = ssh_buffer_get_ssh_string(packet);\n    if (banner == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Invalid SSH_USERAUTH_BANNER packet\");\n    } else {\n        SSH_LOG(SSH_LOG_DEBUG,\n                \"Received SSH_USERAUTH_BANNER packet\");\n        if (session->banner != NULL)\n            SSH_STRING_FREE(session->banner);\n        session->banner = banner;\n    }\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 197,
      "line_end": 217,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple packet handler: it reads an SSH string from a packet and stores it on the session, with minimal branching and no loops or complex parsing. It touches external input but contains no parsing/validation or complex memory manipulation, so medium fuzz priority."
    },
    {
      "name": "ssh_userauth_kbdint",
      "clean_name": "ssh_userauth_kbdint",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @see ssh_userauth_kbdint_getname()\n * @see ssh_userauth_kbdint_getinstruction()\n * @see ssh_userauth_kbdint_getprompt()\n * @see ssh_userauth_kbdint_setanswer()\n */\nint ssh_userauth_kbdint(ssh_session session, const char *user,\n                        const char *submethods)\n{\n    int rc = SSH_AUTH_ERROR;\n\n    if (session == NULL) {\n        return SSH_AUTH_ERROR;\n    }\n\n    if ((session->pending_call_state == SSH_PENDING_CALL_NONE && session->kbdint == NULL) ||\n            session->pending_call_state == SSH_PENDING_CALL_AUTH_KBDINT_INIT)\n        rc = ssh_userauth_kbdint_init(session, user, submethods);\n    else if (session->pending_call_state == SSH_PENDING_CALL_AUTH_KBDINT_SEND ||\n            session->kbdint != NULL) {\n        /*\n         * If we are at this point, it is because session->kbdint exists.\n         * It means the user has set some information there we need to send\n         * the server and then we need to ack the status (new questions or ok\n         * pass in).\n         * It is possible that session->kbdint is NULL while we're waiting for\n         * a reply, hence the test for the pending call.\n         */\n        rc = ssh_userauth_kbdint_send(session);\n    } else {\n        /* We are here because session->kbdint == NULL & state != NONE.\n         * This should not happen\n         */\n        rc = SSH_AUTH_ERROR;\n        ssh_set_error(session, SSH_FATAL, \"Invalid state in %s\", __func__);\n    }\n    return rc;\n}\n",
      "line_start": 2146,
      "line_end": 2178,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple state-machine wrapper: checks session pointer and pending_call_state/kbdint and delegates to init/send. No direct parsing of external input, no memory ops on untrusted data; modest branching makes it a medium-priority helper target but not high-value on its own."
    },
    {
      "name": "ssh_buffer_add_ssh_string",
      "clean_name": "ssh_buffer_add_ssh_string",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @param[in]  string   The SSH String to add.\n *\n * @return              0 on success, < 0 on error.\n */\nint\nssh_buffer_add_ssh_string(struct ssh_buffer_struct *buffer,\n                          struct ssh_string_struct *string)\n{\n    size_t len;\n    int rc;\n\n    if (string == NULL) {\n        return -1;\n    }\n\n    len = ssh_string_len(string) + sizeof(uint32_t);\n    /* this can't overflow the uint32_t as the\n     * STRING_SIZE_MAX is (UINT32_MAX >> 8) + 1 */\n    rc = ssh_buffer_add_data(buffer, string, (uint32_t)len);\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 410,
      "line_end": 430,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small wrapper/helper: simple null check, length computation and a single call to ssh_buffer_add_data. Minimal branching/cyclomatic complexity and no direct parsing of complex external formats. Some memory-copy behavior is implied via the called function, so it has modest value as a fuzz target mainly to reach lower-level routines, but by itself is low-priority."
    },
    {
      "name": "ssh_buffer_add_buffer",
      "clean_name": "ssh_buffer_add_buffer",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @param[in]  source   The source buffer to append. It doesn't take the\n *                      position of the buffer into account.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_add_buffer(struct ssh_buffer_struct *buffer,\n    struct ssh_buffer_struct *source)\n{\n    int rc;\n\n    rc = ssh_buffer_add_data(buffer,\n                             ssh_buffer_get(source),\n                             ssh_buffer_get_len(source));\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 577,
      "line_end": 591,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Thin wrapper that simply forwards a source buffer to ssh_buffer_add_data; no parsing or branching here. Memory operations and validation happen in the callee, so this function is a low\u2011complexity helper (medium priority at best)."
    },
    {
      "name": "ssh_channel_new",
      "clean_name": "ssh_channel_new",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              A pointer to a newly allocated channel, NULL on error.\n *                      The channel needs to be freed with ssh_channel_free().\n *\n * @see ssh_channel_free()\n */\nssh_channel ssh_channel_new(ssh_session session)\n{\n    ssh_channel channel = NULL;\n\n    if (session == NULL) {\n        return NULL;\n    }\n\n    /* Check if we have an authenticated session */\n    if (!(session->flags & SSH_SESSION_FLAG_AUTHENTICATED)) {\n        return NULL;\n    }\n\n    channel = calloc(1, sizeof(struct ssh_channel_struct));\n    if (channel == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    channel->stdout_buffer = ssh_buffer_new();\n    if (channel->stdout_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(channel);\n        return NULL;\n    }\n\n    channel->stderr_buffer = ssh_buffer_new();\n    if (channel->stderr_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(channel->stdout_buffer);\n        SAFE_FREE(channel);\n        return NULL;\n    }\n\n    channel->session = session;\n    channel->exit.code = (uint32_t)-1;\n    channel->flags = SSH_CHANNEL_FLAG_NOT_BOUND;\n\n    if (session->channels == NULL) {\n        session->channels = ssh_list_new();\n        if (session->channels == NULL) {\n            ssh_set_error_oom(session);\n            SSH_BUFFER_FREE(channel->stdout_buffer);\n            SSH_BUFFER_FREE(channel->stderr_buffer);\n            SAFE_FREE(channel);\n            return NULL;\n        }\n    }\n\n    ssh_list_prepend(session->channels, channel);\n\n    /* Set states explicitly */\n    channel->state = SSH_CHANNEL_STATE_NOT_OPEN;\n    channel->request_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    return channel;\n}\n",
      "line_start": 89,
      "line_end": 146,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 117,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple allocator/initializer: checks session/auth flag, allocates/initializes buffers and list nodes and sets state. Has low cyclomatic complexity and does not parse or manipulate untrusted input or perform risky memory operations, so limited value as a fuzz target (medium priority for fuzzing)."
    },
    {
      "name": "ssh_channel_request_send_signal",
      "clean_name": "ssh_channel_request_send_signal",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SIGUSR1  -> USR1 \\n\n *                      SIGUSR2  -> USR2 \\n\n *\n * @return              SSH_OK on success, SSH_ERROR if an error occurred.\n */\nint ssh_channel_request_send_signal(ssh_channel channel, const char *sig)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if (channel == NULL) {\n      return SSH_ERROR;\n  }\n  if (sig == NULL) {\n      ssh_set_error_invalid(channel->session);\n      return rc;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer, \"s\", sig);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = channel_request(channel, \"signal\", buffer, 0);\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 2896,
      "line_end": 2926,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple wrapper: checks pointers, allocates a buffer, packs the provided sig string and forwards it to channel_request. It touches untrusted input (string packing/memory ops) but has minimal branching or parsing logic itself; most complexity likely lives in channel_request, so as a standalone fuzz target it is medium/low priority."
    },
    {
      "name": "ssh_channel_open_reverse_forward",
      "clean_name": "ssh_channel_open_reverse_forward",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @warning This function does not bind the local port and does not automatically\n *          forward the content of a socket to the channel. You still have to\n *          use ssh_channel_read and ssh_channel_write for this.\n */\nint ssh_channel_open_reverse_forward(ssh_channel channel, const char *remotehost,\n                                     int remoteport, const char *sourcehost, int localport)\n{\n    ssh_session session = NULL;\n    ssh_buffer payload = NULL;\n    int rc = SSH_ERROR;\n\n    if (channel == NULL) {\n        return rc;\n    }\n    if (remotehost == NULL || sourcehost == NULL) {\n        ssh_set_error_invalid(channel->session);\n        return rc;\n    }\n\n    session = channel->session;\n\n    if (channel->state != SSH_CHANNEL_STATE_NOT_OPEN)\n        goto pending;\n    payload = ssh_buffer_new();\n    if (payload == NULL) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n    rc = ssh_buffer_pack(payload,\n                         \"sdsd\",\n                         remotehost,\n                         remoteport,\n                         sourcehost,\n                         localport);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\npending:\n    rc = channel_open(channel,\n                      \"forwarded-tcpip\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      payload);\n\nerror:\n    SSH_BUFFER_FREE(payload);\n\n    return rc;\n}\n",
      "line_start": 3837,
      "line_end": 3883,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 79,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Thin wrapper that does simple NULL checks, packs two host strings and ports into a buffer and calls channel_open. It does perform memory operations via ssh_buffer_pack (copying untrusted strings) but has low cyclomatic complexity and no parsing/validation of complex formats or crypto. Useful as a low/medium-priority fuzz target but not high priority on its own."
    },
    {
      "name": "channels.c:channel_from_msg",
      "clean_name": "channel_from_msg",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      be moved after the call.\n *\n * @return              The related ssh_channel, or NULL if the channel is\n *                      unknown or the packet is invalid.\n */\nstatic ssh_channel channel_from_msg(ssh_session session, ssh_buffer packet)\n{\n    ssh_channel channel = NULL;\n    uint32_t chan;\n    int rc;\n\n    rc = ssh_buffer_unpack(packet, \"d\", &chan);\n    if (rc != SSH_OK) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Getting channel from message: short read\");\n        return NULL;\n    }\n\n    channel = ssh_channel_from_local(session, chan);\n    if (channel == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Server specified invalid channel %\" PRIu32,\n                      (uint32_t)chan);\n    }\n\n    return channel;\n}\n",
      "line_start": 509,
      "line_end": 533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Only unpacks a single 32-bit value from a buffer and does a simple channel lookup. Minimal parsing logic, no loops or memory manipulation in this function itself and very low cyclomatic complexity\u2014useful but low-priority as a fuzz target (the real risk surface is in ssh_buffer_unpack/ssh_channel_from_local)."
    },
    {
      "name": "channels.c:grow_window",
      "clean_name": "grow_window",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @brief grows the local window and sends a packet to the other party\n * @param session SSH session\n * @param channel SSH channel\n * @return            SSH_OK if successful; SSH_ERROR otherwise.\n */\nstatic int grow_window(ssh_session session,\n                       ssh_channel channel)\n{\n  uint32_t used;\n  uint32_t increment;\n  int rc;\n\n  /* Calculate the increment taking into account what the peer may still send\n   * (local_window) and what we've already buffered (stdout_buffer and\n   * stderr_buffer).\n  */\n  used = channel->local_window;\n  if (channel->stdout_buffer != NULL) {\n    used += ssh_buffer_get_len(channel->stdout_buffer);\n  }\n  if (channel->stderr_buffer != NULL) {\n    used += ssh_buffer_get_len(channel->stderr_buffer);\n  }\n  /* Avoid a negative increment in case the peer sent more than the window allowed */\n  increment = WINDOW_DEFAULT > used ? WINDOW_DEFAULT - used : 0;\n  /* Don't grow until we can request at least half a window */\n  if (increment < (WINDOW_DEFAULT / 2)) {\n    SSH_LOG(SSH_LOG_DEBUG,\n        \"growing window (channel %\" PRIu32 \":%\" PRIu32 \") to %\" PRIu32 \" bytes : not needed (%\" PRIu32 \" bytes)\",\n        channel->local_channel, channel->remote_channel, WINDOW_DEFAULT,\n        channel->local_window);\n\n    return SSH_OK;\n  }\n\n  rc = ssh_buffer_pack(session->out_buffer,\n                       \"bdd\",\n                       SSH2_MSG_CHANNEL_WINDOW_ADJUST,\n                       channel->remote_channel,\n                       increment);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  if (ssh_packet_send(session) == SSH_ERROR) {\n    goto error;\n  }\n\n  SSH_LOG(SSH_LOG_DEBUG,\n      \"growing window (channel %\" PRIu32 \":%\" PRIu32 \") by %\" PRIu32 \" bytes\",\n      channel->local_channel,\n      channel->remote_channel,\n      increment);\n\n  channel->local_window += increment;\n\n  return SSH_OK;\nerror:\n  ssh_buffer_reinit(session->out_buffer);\n\n  return SSH_ERROR;\n}\n",
      "line_start": 437,
      "line_end": 495,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 81,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple helper that adjusts channel window: small number of branches, no parsing of external file/protocol data here, no loops, no complex control flow or crypto. It touches buffers and serializes a packet (potential surface in ssh_buffer_pack/ssh_packet_send), so worth medium priority but not a high-value fuzz target on its own."
    },
    {
      "name": "connector.c:ssh_connector_fd_write",
      "clean_name": "ssh_connector_fd_write",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " * @internal\n *\n * @brief brief writes len bytes from buffer to socket\n *\n */\nstatic ssize_t ssh_connector_fd_write(ssh_connector connector,\n                                      const void *buffer,\n                                      uint32_t len)\n{\n    ssize_t bwritten = -1;\n    int flags = 0;\n\n#ifdef MSG_NOSIGNAL\n    flags |= MSG_NOSIGNAL;\n#endif\n\n    if (connector->fd_is_socket) {\n        bwritten = send(connector->out_fd,buffer, len, flags);\n    } else {\n        bwritten = write(connector->out_fd, buffer, len);\n    }\n\n    return bwritten;\n}\n",
      "line_start": 737,
      "line_end": 756,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Thin I/O wrapper that forwards a buffer to send/write. No parsing or complex logic, minimal branching (socket vs file), no loops or memory manipulation beyond delegating to the OS. Useful as a small integration target but low standalone fuzzing value."
    },
    {
      "name": "ssh_fallback_group",
      "clean_name": "ssh_fallback_group",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": " * @param[in] pmax maximum requestsd group size\n * @param[out] modulus\n * @param[out] generator\n * @returns SSH_OK on success, SSH_ERROR otherwise\n */\nint ssh_fallback_group(uint32_t pmax,\n                       bignum *modulus,\n                       bignum *generator)\n{\n    *modulus = NULL;\n    *generator = NULL;\n\n    if (pmax < 3072) {\n        bignum_dup(ssh_dh_group14, modulus);\n    } else if (pmax < 6144) {\n        bignum_dup(ssh_dh_group16, modulus);\n    } else {\n        bignum_dup(ssh_dh_group18, modulus);\n    }\n    if (*modulus == NULL) {\n        return SSH_ERROR;\n    }\n\n    bignum_dup(ssh_dh_generator, generator);\n    if (*generator == NULL) {\n        bignum_safe_free((*modulus));\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 588,
      "line_end": 614,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 74,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple helper that selects one of a few static Diffie\u2011Hellman groups based on pmax and duplicates them; low cyclomatic complexity and no parsing of external structured input. It is crypto\u2011related (affects security) but the function itself has limited attack surface and performs no direct memory ops on untrusted data, so medium-low fuzz priority."
    },
    {
      "name": "dh.c:ssh_get_b64_unpadded",
      "clean_name": "ssh_get_b64_unpadded",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": " *\n * @return              The base64 string or NULL on error.\n *\n * @see ssh_string_free_char()\n */\nstatic char *ssh_get_b64_unpadded(const unsigned char *hash, size_t len)\n{\n    char *b64_padded = NULL;\n    char *b64_unpadded = NULL;\n    size_t k;\n\n    b64_padded = (char *)bin_to_base64(hash, len);\n    if (b64_padded == NULL) {\n        return NULL;\n    }\n    for (k = strlen(b64_padded); k != 0 && b64_padded[k-1] == '='; k--);\n\n    b64_unpadded = strndup(b64_padded, k);\n    SAFE_FREE(b64_padded);\n\n    return b64_unpadded;\n}\n",
      "line_start": 697,
      "line_end": 714,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Small helper that converts binary to base64 and trims '=' padding. It performs string and allocation operations on external data but has simple linear logic and low cyclomatic complexity. Useful as a fuzz target only insofar as underlying bin_to_base64 or allocation routines are exercised; the function itself has limited attack surface."
    },
    {
      "name": "ssh_remove_from_default_algos",
      "clean_name": "ssh_remove_from_default_algos",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * @param[in] list  The list to be exclude\n *\n * @return A newly allocated list containing the default algorithms without the\n * algorithms in list; NULL in case of error.\n */\nchar *ssh_remove_from_default_algos(enum ssh_kex_types_e algo, const char *list)\n{\n    if (algo > SSH_LANG_S_C) {\n        return NULL;\n    }\n\n    if (list == NULL || list[0] == '\\0') {\n        if (ssh_fips_mode()) {\n            return strdup(fips_methods[algo]);\n        } else {\n            return strdup(default_methods[algo]);\n        }\n    }\n\n    if (ssh_fips_mode()) {\n        return ssh_remove_all_matching(fips_methods[algo], list);\n    } else {\n        return ssh_remove_all_matching(default_methods[algo], list);\n    }\n}\n",
      "line_start": 1296,
      "line_end": 1316,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Thin wrapper that chooses between default/FIPS method strings and either strdup()s them or forwards to ssh_remove_all_matching(). It accepts external input but has very simple branching and low cyclomatic complexity; the real parsing and memory ops happen in ssh_remove_all_matching(), so this function itself is a medium-value fuzz target (helper-level)."
    },
    {
      "name": "kex.c:cmp_first_kex_algo",
      "clean_name": "cmp_first_kex_algo",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * @brief returns whether the first client key exchange algorithm or\n *        hostkey type matches its server counterpart\n * @returns whether the first client key exchange algorithm or hostkey type\n *          matches its server counterpart\n */\nstatic int cmp_first_kex_algo(const char *client_str,\n                              const char *server_str) {\n    size_t client_kex_len;\n    size_t server_kex_len;\n\n    char *colon = NULL;\n\n    int is_wrong = 1;\n\n    if (client_str == NULL || server_str == NULL) {\n        return is_wrong;\n    }\n\n    colon = strchr(client_str, ',');\n    if (colon == NULL) {\n        client_kex_len = strlen(client_str);\n    } else {\n        client_kex_len = colon - client_str;\n    }\n\n    colon = strchr(server_str, ',');\n    if (colon == NULL) {\n        server_kex_len = strlen(server_str);\n    } else {\n        server_kex_len = colon - server_str;\n    }\n\n    if (client_kex_len != server_kex_len) {\n        return is_wrong;\n    }\n\n    is_wrong = (strncmp(client_str, server_str, client_kex_len) != 0);\n\n    return is_wrong;\n}\n",
      "line_start": 338,
      "line_end": 373,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple helper that parses two comma-separated strings and compares the first token. Low cyclomatic complexity, no loops or memory writes, only basic string ops (strchr/strlen/strncmp) on untrusted input \u2014 limited attack surface and modest value as a fuzz target."
    },
    {
      "name": "kex.c:kex_select_kex_type",
      "clean_name": "kex_select_kex_type",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n    return NULL;\n}\n\nstatic enum ssh_key_exchange_e\nkex_select_kex_type(const char *kex)\n{\n    if (strcmp(kex, \"diffie-hellman-group1-sha1\") == 0) {\n        return SSH_KEX_DH_GROUP1_SHA1;\n    } else if (strcmp(kex, \"diffie-hellman-group14-sha1\") == 0) {\n        return SSH_KEX_DH_GROUP14_SHA1;\n    } else if (strcmp(kex, \"diffie-hellman-group14-sha256\") == 0) {\n        return SSH_KEX_DH_GROUP14_SHA256;\n    } else if (strcmp(kex, \"diffie-hellman-group16-sha512\") == 0) {\n        return SSH_KEX_DH_GROUP16_SHA512;\n    } else if (strcmp(kex, \"diffie-hellman-group18-sha512\") == 0) {\n        return SSH_KEX_DH_GROUP18_SHA512;\n#ifdef WITH_GEX\n    } else if (strcmp(kex, \"diffie-hellman-group-exchange-sha1\") == 0) {\n        return SSH_KEX_DH_GEX_SHA1;\n    } else if (strcmp(kex, \"diffie-hellman-group-exchange-sha256\") == 0) {\n        return SSH_KEX_DH_GEX_SHA256;\n#endif /* WITH_GEX */\n    } else if (strcmp(kex, \"ecdh-sha2-nistp256\") == 0) {\n        return SSH_KEX_ECDH_SHA2_NISTP256;\n    } else if (strcmp(kex, \"ecdh-sha2-nistp384\") == 0) {\n        return SSH_KEX_ECDH_SHA2_NISTP384;\n    } else if (strcmp(kex, \"ecdh-sha2-nistp521\") == 0) {\n        return SSH_KEX_ECDH_SHA2_NISTP521;\n    } else if (strcmp(kex, \"curve25519-sha256@libssh.org\") == 0) {\n        return SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG;\n    } else if (strcmp(kex, \"curve25519-sha256\") == 0) {\n        return SSH_KEX_CURVE25519_SHA256;\n    } else if (strcmp(kex, \"sntrup761x25519-sha512@openssh.com\") == 0) {\n        return SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM;\n    }\n    /* should not happen. We should be getting only valid names at this stage */\n    return 0;\n}\n",
      "line_start": 896,
      "line_end": 930,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 67,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple mapping of a single input string to enum values via a chain of strcmp() calls. There are many branches (moderate cyclomatic complexity) but no parsing of complex/structured input, no memory manipulation, no loops, and it does not perform cryptographic operations itself. Useful only as a low/medium-value fuzz target (logic is trivial and unlikely to trigger memory faults)."
    },
    {
      "name": "ssh_session_export_known_hosts_entry",
      "clean_name": "ssh_session_export_known_hosts_entry",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *                           line of the entry. The user must free it using\n *                           ssh_string_free_char().\n *\n * @return SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_session_export_known_hosts_entry(ssh_session session,\n                                         char **pentry_string)\n{\n    ssh_key server_pubkey = NULL;\n    char *host = NULL;\n    char entry_buf[MAX_LINE_SIZE] = {0};\n    char *b64_key = NULL;\n    int rc;\n\n    if (pentry_string == NULL) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n\n    if (session->opts.host == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Can't create known_hosts entry - hostname unknown\");\n        return SSH_ERROR;\n    }\n\n    host = ssh_session_get_host_port(session);\n    if (host == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (session->current_crypto == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"No current crypto context, please connect first\");\n        SAFE_FREE(host);\n        return SSH_ERROR;\n    }\n\n    server_pubkey = ssh_dh_get_current_server_publickey(session);\n    if (server_pubkey == NULL){\n        ssh_set_error(session, SSH_FATAL, \"No public key present\");\n        SAFE_FREE(host);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_pki_export_pubkey_base64(server_pubkey, &b64_key);\n    if (rc < 0) {\n        SAFE_FREE(host);\n        return SSH_ERROR;\n    }\n\n    snprintf(entry_buf, sizeof(entry_buf),\n                \"%s %s %s\\n\",\n                host,\n                server_pubkey->type_c,\n                b64_key);\n\n    SAFE_FREE(host);\n    SAFE_FREE(b64_key);\n\n    *pentry_string = strdup(entry_buf);\n    if (*pentry_string == NULL) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 919,
      "line_end": 980,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 118,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple exporter/formatter: it composes a known_hosts line from session state using snprintf/strdup with no parsing, no loops, and very little branching. It uses cryptographic state (public key) but does not perform parsing or complex memory manipulation on untrusted input; bounded snprintf limits overflow risk. Overall low-medium fuzzing value (helper with simple logic)."
    },
    {
      "name": "match_group",
      "clean_name": "match_group",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " *\n * @param[in] object    Object to match.\n *\n * @returns             1 if there is a match, 0 if there is no match at all.\n */\nint match_group(const char *group, const char *object)\n{\n    const char *a = NULL;\n    const char *z = NULL;\n\n    if (group == NULL || object == NULL) {\n        return 0;\n    }\n\n    z = group;\n    do {\n        a = strchr(z, ',');\n        if (a == NULL) {\n            if (strcmp(z, object) == 0) {\n                return 1;\n            }\n            return 0;\n        } else {\n            if (strncmp(z, object, a - z) == 0) {\n                return 1;\n            }\n        }\n        z = a + 1;\n    } while (1);\n\n    /* not reached */\n    return 0;\n}\n",
      "line_start": 602,
      "line_end": 630,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 37,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple comma-separated token matcher that only performs read-only string comparisons (strchr, strcmp, strncmp). Low cyclomatic complexity and no memory writes or complex parsing; limited attack surface. Could exhibit minor logic bugs (prefix-matching via strncmp) but not a high-value fuzz target."
    },
    {
      "name": "ssh_print_hexa",
      "clean_name": "ssh_print_hexa",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "}\n\n/**\n * @deprecated          Please use ssh_print_hash() instead\n */\nvoid ssh_print_hexa(const char *descr, const unsigned char *what, size_t len)\n{\n    char *hexa = ssh_get_hexa(what, len);\n\n    if (hexa == NULL) {\n      return;\n    }\n    fprintf(stderr, \"%s: %s\\n\", descr, hexa);\n\n    free(hexa);\n}\n",
      "line_start": 512,
      "line_end": 523,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple wrapper that converts bytes to hex and prints them. It has minimal logic/branching and no complex parsing or loops; memory operations and potential risks live in ssh_get_hexa, not here. Low-value fuzz target (helper-level)."
    },
    {
      "name": "pki_key_dup_common_init",
      "clean_name": "pki_key_dup_common_init",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * error.\n *\n * @note The caller is responsible for freeing the returned key with\n * ssh_key_free().\n */\nssh_key pki_key_dup_common_init(const ssh_key key, int demote)\n{\n    ssh_key new = NULL;\n\n    if (key == NULL) {\n        return NULL;\n    }\n\n    new = ssh_key_new();\n    if (new == NULL) {\n        return NULL;\n    }\n\n    new->type = key->type;\n    new->type_c = key->type_c;\n    if (demote) {\n        new->flags = SSH_KEY_FLAG_PUBLIC;\n    } else {\n        new->flags = key->flags;\n    }\n\n    /* Copy security key fields if present */\n    if (is_sk_key_type(key->type)) {\n        new->sk_application = ssh_string_copy(key->sk_application);\n        if (new->sk_application == NULL) {\n            goto fail;\n        }\n\n        if (!demote) {\n            new->sk_flags = key->sk_flags;\n\n            new->sk_key_handle = ssh_string_copy(key->sk_key_handle);\n            if (new->sk_key_handle == NULL) {\n                goto fail;\n            }\n\n            new->sk_reserved = ssh_string_copy(key->sk_reserved);\n            if (new->sk_reserved == NULL) {\n                goto fail;\n            }\n        }\n    }\n\n    return new;\n\nfail:\n    SSH_KEY_FREE(new);\n    return NULL;\n}\n",
      "line_start": 140,
      "line_end": 189,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 74,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple helper that duplicates an ssh_key: copies a few fields, conditionally copies string blobs and handles allocation failures. It does not parse complex external input or perform heavy branching/loops; limited attack surface makes it a modest-value fuzz target (helper-level complexity)."
    },
    {
      "name": "ssh_key_size_allowed",
      "clean_name": "ssh_key_size_allowed",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] session The SSH session\n * @param[in] key     The SSH key\n * @returns           true if the key is allowed, false otherwise\n */\nbool ssh_key_size_allowed(ssh_session session, ssh_key key)\n{\n    int min_size = 0;\n\n    switch (ssh_key_type(key)) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA_CERT01:\n        min_size = session->opts.rsa_min_size;\n        return ssh_key_size_allowed_rsa(min_size, key);\n    default:\n        return true;\n    }\n}\n",
      "line_start": 467,
      "line_end": 480,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple wrapper that checks the key type and delegates to ssh_key_size_allowed_rsa; minimal branching and no loops or direct memory operations. Limited standalone fuzzing value unless combined with the rsa-specific implementation which does actual parsing/validation."
    },
    {
      "name": "pki_buffer_unpack_sk_priv_data",
      "clean_name": "pki_buffer_unpack_sk_priv_data",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_buffer_unpack()\n */\nint pki_buffer_unpack_sk_priv_data(ssh_buffer buffer, ssh_key key)\n{\n    return ssh_buffer_unpack(buffer,\n                             \"SbSS\",\n                             &key->sk_application,\n                             &key->sk_flags,\n                             &key->sk_key_handle,\n                             &key->sk_reserved);\n}\n",
      "line_start": 2348,
      "line_end": 2357,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple wrapper that delegates to ssh_buffer_unpack to unpack SK private-key fields; minimal internal logic, no loops or branching. It does touch external input indirectly, but the parsing/memory operations occur in the called function, so this specific function is of moderate fuzzing value."
    },
    {
      "name": "ssh_pki_copy_cert_to_privkey",
      "clean_name": "ssh_pki_copy_cert_to_privkey",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in]  privkey  The target private key to copy the certificate to.\n *\n * @returns SSH_OK on success, SSH_ERROR otherwise.\n **/\nint ssh_pki_copy_cert_to_privkey(const ssh_key certkey, ssh_key privkey)\n{\n    ssh_buffer cert_buffer = NULL;\n    int rc, cmp;\n\n    if (certkey == NULL || privkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (privkey->cert != NULL) {\n        return SSH_ERROR;\n    }\n\n    if (certkey->cert == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* make sure the public keys match */\n    cmp = ssh_key_cmp(certkey, privkey, SSH_KEY_CMP_PUBLIC);\n    if (cmp != 0) {\n        return SSH_ERROR;\n    }\n\n    cert_buffer = ssh_buffer_new();\n    if (cert_buffer == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_buffer_add_buffer(cert_buffer, certkey->cert);\n    if (rc != 0) {\n        SSH_BUFFER_FREE(cert_buffer);\n        return SSH_ERROR;\n    }\n\n    privkey->cert = cert_buffer;\n    privkey->cert_type = certkey->type;\n    return SSH_OK;\n}\n",
      "line_start": 2548,
      "line_end": 2586,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 70,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple helper that validates pointers, checks key equality, and copies an existing buffer. It has low cyclomatic complexity and no parsing of external formats or complex memory manipulation itself (heavy work delegated to ssh_key_cmp and ssh_buffer_*). Limited fuzzing value compared with parsers/protocol handlers."
    },
    {
      "name": "ssh_send_debug",
      "clean_name": "ssh_send_debug",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *                             SHOULD NOT be displayed unless debugging\n *                             information has been explicitly requested.\n *\n * @return                     SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_send_debug (ssh_session session, const char *message, int always_display) {\n    int rc;\n\n    if (ssh_socket_is_open(session->socket)) {\n        rc = ssh_buffer_pack(session->out_buffer,\n                             \"bbsd\",\n                             SSH2_MSG_DEBUG,\n                             always_display != 0 ? 1 : 0,\n                             message,\n                             0); /* empty language tag */\n        if (rc != SSH_OK) {\n            ssh_set_error_oom(session);\n            goto error;\n        }\n        ssh_packet_send(session);\n        ssh_handle_packets(session, 0);\n    }\n\n    return SSH_OK;\n\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n    return SSH_ERROR;\n}\n",
      "line_start": 1034,
      "line_end": 1058,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "This is a thin API wrapper that packs and sends a debug string: it accepts untrusted data (message) and triggers buffer packing/sending but contains minimal logic and branching. It does perform memory/string operations indirectly (via ssh_buffer_pack) so it has some value to fuzz as part of larger stateful testing, but its cyclomatic complexity and parsing/validation work are low, making it a medium-priority target."
    },
    {
      "name": "ssh_string_cmp",
      "clean_name": "ssh_string_cmp",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @return              0 if the strings are equal,\n *                      < 0 if s1 is less than s2,\n *                      > 0 if s1 is greater than s2.\n */\nint ssh_string_cmp(struct ssh_string_struct *s1, struct ssh_string_struct *s2)\n{\n    size_t len1, len2, min_len;\n    int cmp;\n\n    /* Both are NULL */\n    if (s1 == NULL && s2 == NULL) {\n        return 0;\n    }\n\n    /* Only one is NULL - NULL is considered \"less than\" non-NULL */\n    if (s1 == NULL) {\n        return -1;\n    } else if (s2 == NULL) {\n        return 1;\n    }\n\n    /* Get lengths */\n    len1 = ssh_string_len(s1);\n    len2 = ssh_string_len(s2);\n    min_len = MIN(len1, len2);\n\n    /* Compare data up to the shorter length */\n    if (min_len > 0) {\n        cmp = memcmp(s1->data, s2->data, min_len);\n        if (cmp != 0) {\n            return cmp;\n        }\n    }\n\n    /* If common prefix is equal, compare lengths */\n    if (len1 < len2) {\n        return -1;\n    } else if (len1 > len2) {\n        return 1;\n    }\n\n    return 0;\n}\n",
      "line_start": 256,
      "line_end": 295,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple comparator helper: checks NULLs, obtains lengths, does a single memcmp over min_len and then compares lengths. Minimal branching and no parsing/loops/crypto; although it touches untrusted data via memcmp, the logic is trivial so it is a low-value fuzz target (medium priority at best)."
    },
    {
      "name": "ssh_config_get_long",
      "clean_name": "ssh_config_get_long",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "out:\n    *str = c;\n    return r;\n}\n\nlong ssh_config_get_long(char **str, long notfound)\n{\n    char *p = NULL, *endp = NULL;\n    long i;\n\n    p = ssh_config_get_token(str);\n    if (p && *p) {\n        i = strtol(p, &endp, 10);\n        if (p == endp) {\n            return notfound;\n        }\n        return i;\n    }\n\n    return notfound;\n}\n",
      "line_start": 123,
      "line_end": 139,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small helper that tokenizes and calls strtol on the token. It does parse external input but has trivial control flow, no loops, no memory copies or buffer manipulation, and limited branching \u2014 low complexity and low attack surface, so only medium fuzzing priority."
    },
    {
      "name": "ssh_config_get_yesno",
      "clean_name": "ssh_config_get_yesno",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "    }\n\n    return def;\n}\n\nint ssh_config_get_yesno(char **str, int notfound)\n{\n    const char *p = NULL;\n\n    p = ssh_config_get_str_tok(str, NULL);\n    if (p == NULL) {\n        return notfound;\n    }\n\n    if (strncasecmp(p, \"yes\", 3) == 0) {\n        return 1;\n    } else if (strncasecmp(p, \"no\", 2) == 0) {\n        return 0;\n    }\n\n    return notfound;\n}\n",
      "line_start": 152,
      "line_end": 169,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Small helper that interprets a yes/no token: calls ssh_config_get_str_tok then does two strncasecmp checks and returns a default. Low cyclomatic complexity, no loops or direct memory ops on untrusted buffers. Upstream token parsing might be more interesting to fuzz, but this function itself is a low-medium priority target."
    },
    {
      "name": "ssh_tokenize",
      "clean_name": "ssh_tokenize",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * @param[in] chain         The string to split\n * @param[in] separator     The character used to separate the tokens.\n *\n * @return  A newly allocated tokens list structure; NULL in case of error.\n */\nstruct ssh_tokens_st *ssh_tokenize(const char *chain, char separator)\n{\n\n    struct ssh_tokens_st *tokens = NULL;\n    size_t num_tokens = 1, i = 1;\n\n    char *found, *c;\n\n    if (chain == NULL) {\n        return NULL;\n    }\n\n    tokens = calloc(1, sizeof(struct ssh_tokens_st));\n    if (tokens == NULL) {\n        return NULL;\n    }\n\n    tokens->buffer = strdup(chain);\n    if (tokens->buffer == NULL) {\n        goto error;\n    }\n\n    c = tokens->buffer;\n    do {\n        found = strchr(c, separator);\n        if (found != NULL) {\n            c = found + 1;\n            num_tokens++;\n        }\n    } while(found != NULL);\n\n    /* Allocate tokens list */\n    tokens->tokens = calloc(num_tokens + 1, sizeof(char *));\n    if (tokens->tokens == NULL) {\n        goto error;\n    }\n\n    /* First token starts in the beginning of the chain */\n    tokens->tokens[0] = tokens->buffer;\n    c = tokens->buffer;\n\n    for (i = 1; i < num_tokens; i++) {\n        /* Find next separator */\n        found = strchr(c, separator);\n        if (found == NULL) {\n            break;\n        }\n\n        /* Replace it with a string terminator */\n        *found = '\\0';\n\n        /* The next token starts in the next byte */\n        c = found + 1;\n\n        /* If we did not reach the end of the chain yet, set the next token */\n        if (*c != '\\0') {\n            tokens->tokens[i] = c;\n        } else {\n            break;\n        }\n    }\n\n    return tokens;\n\nerror:\n    ssh_tokens_free(tokens);\n    return NULL;\n}\n",
      "line_start": 72,
      "line_end": 140,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 68,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple tokenizer that operates on a duplicated input buffer. It processes external input and has loops that depend on input content, but the logic is straightforward with low branching and no complex parsing, crypto, or high-risk memory manipulation \u2014 medium-low fuzz priority."
    },
    {
      "name": "ssh_server_init_kex",
      "clean_name": "ssh_server_init_kex",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\n    rc = ssh_kex_append_extensions(session, server);\n    return rc;\n}\n\nint ssh_server_init_kex(ssh_session session) {\n    int i;\n\n    if (session->session_state > SSH_SESSION_STATE_BANNER_RECEIVED) {\n        return SSH_ERROR;\n    }\n\n    /* free any currently-set methods: server_set_kex will allocate new ones */\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        SAFE_FREE(session->next_crypto->server_kex.methods[i]);\n    }\n\n    return server_set_kex(session);\n}\n",
      "line_start": 198,
      "line_end": 212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple helper that cleans up and reinitializes KEX methods: small loop with a fixed bound freeing pointers and a simple state check. It does perform memory operations but does not parse complex external input or contain significant branching/validation logic \u2014 medium-low fuzz priority (useful as part of a larger target but not high-value on its own)."
    },
    {
      "name": "ssh_message_auth_reply_pk_ok_simple",
      "clean_name": "ssh_message_auth_reply_pk_ok_simple",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param msg The message\n *\n * @returns SSH_OK on success, otherwise SSH_ERROR\n */\nint ssh_message_auth_reply_pk_ok_simple(ssh_message msg)\n{\n    ssh_string algo = NULL;\n    ssh_string pubkey_blob = NULL;\n    int ret;\n\n    algo = ssh_string_from_char(msg->auth_request.sigtype);\n    if (algo == NULL) {\n        return SSH_ERROR;\n    }\n\n    ret = ssh_pki_export_pubkey_blob(msg->auth_request.pubkey, &pubkey_blob);\n    if (ret < 0) {\n        SSH_STRING_FREE(algo);\n        return SSH_ERROR;\n    }\n\n    ret = ssh_message_auth_reply_pk_ok(msg, algo, pubkey_blob);\n\n    SSH_STRING_FREE(algo);\n    SSH_STRING_FREE(pubkey_blob);\n\n    return ret;\n}\n",
      "line_start": 1135,
      "line_end": 1159,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Simple wrapper: it mostly converts fields and forwards them to ssh_pki_export_pubkey_blob and ssh_message_auth_reply_pk_ok, with minimal branching and no loops. It does touch external msg data but performs no complex parsing or memory manipulation itself, so it is a moderate/low-value fuzz target compared to functions that directly parse file/protocol data or perform crypto operations."
    },
    {
      "name": "base64.c:_bin_to_base64",
      "clean_name": "_bin_to_base64",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": "\n    return num;\n}\n\n/* thanks sysk for debugging my mess :) */\nstatic void _bin_to_base64(uint8_t *dest,\n                           const uint8_t source[3],\n                           size_t len)\n{\n#define BITS(n) ((1 << (n)) - 1)\n    switch (len) {\n        case 1:\n            dest[0] = alphabet[(source[0] >> 2)];\n            dest[1] = alphabet[((source[0] & BITS(2)) << 4)];\n            dest[2] = '=';\n            dest[3] = '=';\n            break;\n        case 2:\n            dest[0] = alphabet[source[0] >> 2];\n            dest[1] = alphabet[(source[1] >> 4) | ((source[0] & BITS(2)) << 4)];\n            dest[2] = alphabet[(source[1] & BITS(4)) << 2];\n            dest[3] = '=';\n            break;\n        case 3:\n            dest[0] = alphabet[(source[0] >> 2)];\n            dest[1] = alphabet[(source[1] >> 4) | ((source[0] & BITS(2)) << 4)];\n            dest[2] = alphabet[(source[2] >> 6) | (source[1] & BITS(4)) << 2];\n            dest[3] = alphabet[source[2] & BITS(6)];\n            break;\n    }\n#undef BITS\n}\n",
      "line_start": 244,
      "line_end": 271,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple helper that encodes up to 3 bytes to 4 base64 chars. It performs basic bit ops and memory writes but has low cyclomatic complexity (3-case switch), no parsing of complex formats, no loops or authentication/crypto logic. Useful to fuzz as part of larger encoder/decoder plumbing but low standalone value."
    },
    {
      "name": "pki_signature_from_ed25519_blob",
      "clean_name": "pki_signature_from_ed25519_blob",
      "source_file": "/src/libssh/src/pki_ed25519_common.c",
      "source_code": " *\n * @param[in] sig_blob a signature blob\n *\n * @return SSH_ERROR on error, SSH_OK on success\n */\nint pki_signature_from_ed25519_blob(ssh_signature sig, ssh_string sig_blob)\n{\n    size_t len;\n\n    len = ssh_string_len(sig_blob);\n    if (len != ED25519_SIG_LEN){\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid ssh-ed25519 signature len: %zu\", len);\n        return SSH_ERROR;\n    }\n\n#ifdef HAVE_LIBCRYPTO\n    sig->raw_sig = ssh_string_copy(sig_blob);\n#else\n    sig->ed25519_sig = malloc(ED25519_SIG_LEN);\n    if (sig->ed25519_sig == NULL){\n        return SSH_ERROR;\n    }\n    memcpy(sig->ed25519_sig, ssh_string_data(sig_blob), ED25519_SIG_LEN);\n#endif\n\n    return SSH_OK;\n}\n",
      "line_start": 87,
      "line_end": 109,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 4.0,
      "reason": "Very limited parsing and branching: only a length check and a fixed-size copy/alloc of ED25519_SIG_LEN bytes. Touches signature data (security-relevant) but has low cyclomatic complexity and little input-dependent logic, so modest value as a fuzz target."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:ssh_session_get_host_port",
      "clean_name": "ssh_session_get_host_port",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "error:\n    fclose(fp);\n    return SSH_ERROR;\n}\n\nstatic char *ssh_session_get_host_port(ssh_session session)\n{\n    char *host_port = NULL;\n    char *host = NULL;\n\n    if (session->opts.host == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Can't verify server in known hosts if the host we \"\n                      \"should connect to has not been set\");\n\n        return NULL;\n    }\n\n    host = ssh_lowercase(session->opts.host);\n    if (host == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    if (session->opts.port == 0 || session->opts.port == 22) {\n        host_port = host;\n    } else {\n        host_port = ssh_hostport(host, session->opts.port);\n        SAFE_FREE(host);\n        if (host_port == NULL) {\n            ssh_set_error_oom(session);\n            return NULL;\n        }\n    }\n\n    return host_port;\n}\n",
      "line_start": 312,
      "line_end": 345,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 51,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 4.0,
      "reason": "Simple helper that validates and normalizes a host string and optionally appends a port; minimal branching, no loops or complex parsing, and no direct memory-manipulation here (real surface for fuzzing lies in ssh_lowercase/ssh_hostport)."
    },
    {
      "name": "pki_key_make_ecpoint_string",
      "clean_name": "pki_key_make_ecpoint_string",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "}\n\n#endif /* OPENSSL_VERSION_NUMBER */\n\nssh_string\npki_key_make_ecpoint_string(const EC_GROUP *g, const EC_POINT *p)\n{\n    ssh_string s = NULL;\n    size_t len;\n\n    len = EC_POINT_point2oct(g,\n                             p,\n                             POINT_CONVERSION_UNCOMPRESSED,\n                             NULL,\n                             0,\n                             NULL);\n    if (len == 0) {\n        return NULL;\n    }\n\n    s = ssh_string_new(len);\n    if (s == NULL) {\n        return NULL;\n    }\n\n    len = EC_POINT_point2oct(g,\n                             p,\n                             POINT_CONVERSION_UNCOMPRESSED,\n                             ssh_string_data(s),\n                             ssh_string_len(s),\n                             NULL);\n    if (len != ssh_string_len(s)) {\n        SSH_STRING_FREE(s);\n        return NULL;\n    }\n\n    return s;\n}\n",
      "line_start": 1599,
      "line_end": 1632,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper around OpenSSL EC_POINT_point2oct: minimal branching, simple allocation/length checks, no parsing of complex external input or loops. Potential issues would be in the OpenSSL call itself, so this function alone is a low-value direct fuzz target (helper/adapter level)."
    },
    {
      "name": "ssh_packet_userauth_pk_ok",
      "clean_name": "ssh_packet_userauth_pk_ok",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @brief Handles a SSH_USERAUTH_PK_OK or SSH_USERAUTH_INFO_REQUEST packet.\n *\n * Since the two types of packets share the same code, additional work is done\n * to understand if we are in a public key or keyboard-interactive context.\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_pk_ok) {\n    int rc;\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Received SSH_USERAUTH_PK_OK/INFO_REQUEST/GSSAPI_RESPONSE\");\n\n    if (session->auth.state == SSH_AUTH_STATE_KBDINT_SENT) {\n        /* Assuming we are in keyboard-interactive context */\n        SSH_LOG(SSH_LOG_TRACE,\n                \"keyboard-interactive context, \"\n                \"assuming SSH_USERAUTH_INFO_REQUEST\");\n        rc = ssh_packet_userauth_info_request(session,type,packet,user);\n#ifdef WITH_GSSAPI\n    } else if (session->auth.state == SSH_AUTH_STATE_GSSAPI_REQUEST_SENT) {\n        rc = ssh_packet_userauth_gssapi_response(session, type, packet, user);\n#endif\n    } else if (session->auth.state == SSH_AUTH_STATE_PUBKEY_OFFER_SENT) {\n        session->auth.state = SSH_AUTH_STATE_PK_OK;\n        SSH_LOG(SSH_LOG_TRACE, \"Assuming SSH_USERAUTH_PK_OK\");\n        rc = SSH_PACKET_USED;\n    } else {\n        session->auth.state = SSH_AUTH_STATE_ERROR;\n        SSH_LOG(SSH_LOG_TRACE, \"SSH_USERAUTH_PK_OK received in wrong state\");\n        rc = SSH_PACKET_USED;\n    }\n\n    return rc;\n}\n",
      "line_start": 330,
      "line_end": 358,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin dispatch handler: small number of branches based on internal auth state and then delegates to other handlers. It does not parse packet contents, perform memory/string operations, or complex input-dependent logic itself \u2014 limited value as a direct fuzz target (indirect value only via called handlers)."
    },
    {
      "name": "ssh_userauth_kbdint_getprompt",
      "clean_name": "ssh_userauth_kbdint_getprompt",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *   prompt = ssh_userauth_kbdint_getprompt(session, 0, &echo);\n *   if (echo) ...\n * @endcode\n */\nconst char *\nssh_userauth_kbdint_getprompt(ssh_session session, unsigned int i, char *echo)\n{\n    if (session == NULL)\n        return NULL;\n    if (session->kbdint == NULL) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n    if (i > session->kbdint->nprompts) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n\n    if (echo) {\n        *echo = (char)session->kbdint->echo[i];\n    }\n\n    return session->kbdint->prompts[i];\n}\n",
      "line_start": 2274,
      "line_end": 2293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "This is essentially a simple accessor with minimal logic (null checks and an index check), so it has low fuzzing value. It does read from session-controlled arrays and returns pointers into them, and contains an off-by-one bounds check (uses '>' against nprompts) which could lead to an out-of-bounds read\u2014so it is not zero priority but remains a low-priority fuzz target."
    },
    {
      "name": "auth.c:add_hostbound_pubkey",
      "clean_name": "add_hostbound_pubkey",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @param[in]  session          The SSH session.\n *\n * @returns SSH_OK on success, SSH_ERROR if an error occurred.\n */\nstatic int add_hostbound_pubkey(ssh_session session)\n{\n    int rc;\n    ssh_string server_pubkey_s = NULL;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (session->current_crypto == NULL ||\n        session->current_crypto->server_pubkey == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid session or server public key\");\n        return SSH_ERROR;\n    }\n\n    rc = ssh_pki_export_pubkey_blob(session->current_crypto->server_pubkey,\n                                    &server_pubkey_s);\n    if (rc < 0) {\n        goto error;\n    }\n\n    rc = ssh_buffer_add_ssh_string(session->out_buffer, server_pubkey_s);\n    if (rc < 0) {\n        goto error;\n    }\n\nerror:\n    SSH_STRING_FREE(server_pubkey_s);\n    return rc;\n}\n",
      "line_start": 478,
      "line_end": 510,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Thin wrapper/helper: performs null checks, calls export and buffer-add routines and frees resources. No parsing of external structured input, no loops or complex branching \u2014 minimal attack surface in this function itself (risk lies in the called functions)."
    },
    {
      "name": "ssh_buffer_pass_bytes",
      "clean_name": "ssh_buffer_pass_bytes",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The number of bytes to eat.\n *\n * @return              The new size of the buffer.\n */\nuint32_t ssh_buffer_pass_bytes(struct ssh_buffer_struct *buffer, uint32_t len){\n    buffer_verify(buffer);\n\n    if (buffer->pos + len < len || buffer->used < buffer->pos + len) {\n        return 0;\n    }\n\n    buffer->pos+=len;\n    /* if the buffer is empty after having passed the whole bytes into it, we can clean it */\n    if(buffer->pos==buffer->used){\n        buffer->pos=0;\n        buffer->used=0;\n    }\n    buffer_verify(buffer);\n    return len;\n}\n",
      "line_start": 632,
      "line_end": 648,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple state-update helper that advances an internal buffer position. It performs a couple of basic bounds/wrap checks but does not parse complex external input, perform memory copies, or contain loops/branches of significant complexity. Limited attack surface (integer wrap check) makes it low-priority for fuzzing."
    },
    {
      "name": "_ssh_buffer_pack",
      "clean_name": "_ssh_buffer_pack",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @returns             SSH_OK on success\n *                      SSH_ERROR on error\n * @warning             when using 'P' with a constant size (e.g. 8), do not\n *                      forget to cast to (size_t).\n */\nint _ssh_buffer_pack(struct ssh_buffer_struct *buffer,\n                     const char *format,\n                     size_t argc,\n                     ...)\n{\n    va_list ap;\n    int rc;\n\n    if (argc > 256) {\n        return SSH_ERROR;\n    }\n\n    va_start(ap, argc);\n    rc = ssh_buffer_pack_allocate_va(buffer, format, argc, ap);\n    va_end(ap);\n\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    va_start(ap, argc);\n    rc = ssh_buffer_pack_va(buffer, format, argc, ap);\n    va_end(ap);\n\n    return rc;\n}\n",
      "line_start": 1089,
      "line_end": 1115,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper that only bounds-checks argc (<=256) and forwards varargs to ssh_buffer_pack_allocate_va and ssh_buffer_pack_va. The real parsing/memory operations occur in the underlying functions, so this wrapper has minimal logic and low fuzzing value itself."
    },
    {
      "name": "channel_rcv_eof",
      "clean_name": "channel_rcv_eof",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    ssh_callbacks_iterate_end();\n\n    return SSH_PACKET_USED;\n}\n\nSSH_PACKET_CALLBACK(channel_rcv_eof)\n{\n    ssh_channel channel = NULL;\n    (void)user;\n    (void)type;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received eof on channel (%\" PRIu32 \":%\" PRIu32 \")\",\n            channel->local_channel,\n            channel->remote_channel);\n    /* channel->remote_window = 0; */\n    channel->remote_eof = 1;\n\n    ssh_callbacks_execute_list(channel->callbacks,\n                               ssh_channel_callbacks,\n                               channel_eof_function,\n                               channel->session,\n                               channel);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 709,
      "line_end": 737,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Minimal logic: it mainly looks up a channel, sets a remote_eof flag and invokes callbacks. The heavy parsing/validation likely happens in channel_from_msg (outside this function). No memory ops, loops, or complex branching here, so low fuzzing priority though exercising callbacks may be useful as part of larger targets."
    },
    {
      "name": "ssh_channel_free",
      "clean_name": "ssh_channel_free",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  channel  The channel to free.\n *\n * @warning Any data unread on this channel will be lost.\n */\nvoid ssh_channel_free(ssh_channel channel)\n{\n    ssh_session session = NULL;\n\n    if (channel == NULL) {\n        return;\n    }\n\n    session = channel->session;\n    if (session->alive) {\n        bool send_close = false;\n\n        switch (channel->state) {\n        case SSH_CHANNEL_STATE_OPEN:\n            send_close = true;\n            break;\n        case SSH_CHANNEL_STATE_CLOSED:\n            if (channel->flags & SSH_CHANNEL_FLAG_CLOSED_REMOTE) {\n                send_close = true;\n            }\n            if (channel->flags & SSH_CHANNEL_FLAG_CLOSED_LOCAL) {\n                send_close = false;\n            }\n            break;\n        default:\n            send_close = false;\n            break;\n        }\n\n        if (send_close) {\n            ssh_channel_close(channel);\n        }\n    }\n    channel->flags |= SSH_CHANNEL_FLAG_FREED_LOCAL;\n\n    if (channel->callbacks != NULL) {\n        ssh_list_free(channel->callbacks);\n        channel->callbacks = NULL;\n    }\n\n    /* The idea behind the flags is the following : it is well possible\n     * that a client closes a channel that still exists on the server side.\n     * We definitively close the channel when we receive a close message *and*\n     * the user closed it.\n     */\n    if ((channel->flags & SSH_CHANNEL_FLAG_CLOSED_REMOTE) ||\n        (channel->flags & SSH_CHANNEL_FLAG_NOT_BOUND)) {\n        ssh_channel_do_free(channel);\n    }\n}\n",
      "line_start": 1271,
      "line_end": 1321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 63,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "This is primarily a resource cleanup/free function with simple branching and flag checks. It does not parse or validate external input, does not perform direct memory operations on untrusted data, and has limited complexity. While it calls other functions that might be more interesting to fuzz, this function itself is low priority as a fuzz target."
    },
    {
      "name": "ssh_channel_close",
      "clean_name": "ssh_channel_close",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success, SSH_ERROR if an error occurred.\n *\n * @see ssh_channel_free()\n * @see ssh_channel_is_eof()\n */\nint ssh_channel_close(ssh_channel channel)\n{\n    ssh_session session = NULL;\n    int rc = 0;\n\n    if(channel == NULL) {\n        return SSH_ERROR;\n    }\n\n    /* If the channel close has already been sent we're done here. */\n    if (channel->flags & SSH_CHANNEL_FLAG_CLOSED_LOCAL) {\n        return SSH_OK;\n    }\n\n    session = channel->session;\n\n    rc = ssh_channel_send_eof(channel);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bd\",\n                         SSH2_MSG_CHANNEL_CLOSE,\n                         channel->remote_channel);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_packet_send(session);\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Sent a close on client channel (%\" PRIu32 \":%\" PRIu32 \")\",\n            channel->local_channel,\n            channel->remote_channel);\n\n    if (rc == SSH_OK) {\n        channel->state = SSH_CHANNEL_STATE_CLOSED;\n        channel->flags |= SSH_CHANNEL_FLAG_CLOSED_LOCAL;\n    }\n\n    rc = ssh_channel_flush(channel);\n    if(rc == SSH_ERROR) {\n        goto error;\n    }\n\n    return rc;\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n\n    return rc;\n}\n",
      "line_start": 1439,
      "line_end": 1491,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 76,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Mostly an orchestration/wrapper function: performs state updates and calls into other routines (send EOF, pack, send packet, flush). It has minimal branching, no parsing of complex external input, no loops with input-dependent bounds, and little direct memory/string manipulation on untrusted data. Higher-value fuzz targets are the underlying packet/packet-parsing and buffer routines this function calls."
    },
    {
      "name": "ssh_packet_channel_failure",
      "clean_name": "ssh_packet_channel_failure",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "/**\n * @internal\n *\n * @brief Handle a SSH_CHANNEL_FAILURE packet and set the channel state.\n */\nSSH_PACKET_CALLBACK(ssh_packet_channel_failure)\n{\n    ssh_channel channel = NULL;\n    (void)type;\n    (void)user;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received SSH_CHANNEL_FAILURE on channel (%\" PRIu32 \":%\" PRIu32 \")\",\n            channel->local_channel,\n            channel->remote_channel);\n    if (channel->request_state != SSH_CHANNEL_REQ_STATE_PENDING) {\n        SSH_LOG(SSH_LOG_RARE,\n                \"SSH_CHANNEL_FAILURE received in incorrect state %d\",\n                channel->request_state);\n    } else {\n        channel->request_state = SSH_CHANNEL_REQ_STATE_DENIED;\n\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_request_response_function,\n                                   channel->session,\n                                   channel);\n    }\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 1841,
      "line_end": 1874,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 46,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin packet handler with very simple control flow: looks up channel, logs, checks a single state and sets it to DENIED, then invokes callbacks. It does not parse or manipulate untrusted data, perform memory ops, or contain loops/complex branching. The real parsing likely happens in channel_from_msg, so this function is low-value as a direct fuzz target."
    },
    {
      "name": "ssh_channel_get_exit_state",
      "clean_name": "ssh_channel_get_exit_state",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * exit status!\n *\n * @see ssh_channel_exit_status_callback\n * @see ssh_channel_exit_signal_callback\n */\nint ssh_channel_get_exit_state(ssh_channel channel,\n                               uint32_t *pexit_code,\n                               char **pexit_signal,\n                               int *pcore_dumped)\n{\n    ssh_session session = NULL;\n    int rc;\n\n    if ((channel == NULL) || (channel->flags & SSH_CHANNEL_FLAG_FREED_LOCAL)) {\n        return SSH_ERROR;\n    }\n    session = channel->session;\n\n    rc = ssh_handle_packets_termination(channel->session,\n                                        SSH_TIMEOUT_DEFAULT,\n                                        ssh_channel_exit_status_termination,\n                                        channel);\n    if (rc == SSH_ERROR || channel->session->session_state ==\n        SSH_SESSION_STATE_ERROR) {\n        return SSH_ERROR;\n    }\n\n    /* If we don't have any kind of exit state, return SSH_AGAIN */\n    if (!channel->exit.status) {\n        return SSH_AGAIN;\n    }\n\n    if (pexit_code != NULL) {\n        *pexit_code = channel->exit.code;\n    }\n\n    if (pexit_signal != NULL) {\n        *pexit_signal = NULL;\n        if (channel->exit.signal != NULL) {\n            *pexit_signal = strdup(channel->exit.signal);\n            if (pexit_signal == NULL) {\n                ssh_set_error_oom(session);\n                return SSH_ERROR;\n            }\n        }\n    }\n\n    if (pcore_dumped != NULL) {\n        *pcore_dumped = channel->exit.core_dumped;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 3456,
      "line_end": 3504,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 73,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Primarily a simple accessor/getter with light control flow. It mainly calls a packet-wait helper and copies an existing channel string with strdup; it does not parse complex external input, perform raw memory operations, or contain heavy branching. (Note: there is a minor bug in the strdup null-check, but overall this is low-value as a fuzz target.)"
    },
    {
      "name": "dh_handshake",
      "clean_name": "dh_handshake",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * @param session session handle\n * @returns SSH_OK or SSH_ERROR\n * @warning this function returning is no proof that DH handshake is\n * completed\n */\nint dh_handshake(ssh_session session)\n{\n    int rc = SSH_AGAIN;\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"dh_handshake_state = %d, kex_type = %d\",\n            session->dh_handshake_state,\n            session->next_crypto->kex_type);\n\n    switch (session->dh_handshake_state) {\n    case DH_STATE_INIT:\n        switch (session->next_crypto->kex_type) {\n        case SSH_KEX_DH_GROUP1_SHA1:\n        case SSH_KEX_DH_GROUP14_SHA1:\n        case SSH_KEX_DH_GROUP14_SHA256:\n        case SSH_KEX_DH_GROUP16_SHA512:\n        case SSH_KEX_DH_GROUP18_SHA512:\n            rc = ssh_client_dh_init(session);\n            break;\n#ifdef WITH_GEX\n        case SSH_KEX_DH_GEX_SHA1:\n        case SSH_KEX_DH_GEX_SHA256:\n            rc = ssh_client_dhgex_init(session);\n            break;\n#endif /* WITH_GEX */\n#ifdef HAVE_ECDH\n        case SSH_KEX_ECDH_SHA2_NISTP256:\n        case SSH_KEX_ECDH_SHA2_NISTP384:\n        case SSH_KEX_ECDH_SHA2_NISTP521:\n            rc = ssh_client_ecdh_init(session);\n            break;\n#endif\n#ifdef HAVE_CURVE25519\n        case SSH_KEX_CURVE25519_SHA256:\n        case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n            rc = ssh_client_curve25519_init(session);\n            break;\n#endif\n#ifdef HAVE_SNTRUP761\n        case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n            rc = ssh_client_sntrup761x25519_init(session);\n            break;\n#endif\n        default:\n            rc = SSH_ERROR;\n        }\n\n        break;\n    case DH_STATE_INIT_SENT:\n    \t/* wait until ssh_packet_dh_reply is called */\n    \tbreak;\n    case DH_STATE_NEWKEYS_SENT:\n    \t/* wait until ssh_packet_newkeys is called */\n    \tbreak;\n    case DH_STATE_FINISHED:\n        return SSH_OK;\n    default:\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid state in dh_handshake(): %d\",\n                      session->dh_handshake_state);\n\n        return SSH_ERROR;\n    }\n\n    return rc;\n}\n",
      "line_start": 254,
      "line_end": 321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 54,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Mostly a dispatcher: switches on session state and kex type and calls various init functions. Contains minimal branching, no parsing of external input, no loops or direct memory ops on untrusted data. Security-sensitive area but the real parsing/crypto work happens in called functions, so this specific function is a low-priority fuzz target."
    },
    {
      "name": "kdf.c:ssh_mac_final",
      "clean_name": "ssh_mac_final",
      "source_file": "/src/libssh/src/kdf.c",
      "source_code": "        return sha512_update(ctx->ctx.sha512_ctx, data, len);\n    }\n    return SSH_ERROR;\n}\n\nstatic int ssh_mac_final(unsigned char *md, ssh_mac_ctx ctx)\n{\n    int rc = SSH_ERROR;\n\n    switch (ctx->digest_type) {\n    case SSH_KDF_SHA1:\n        rc = sha1_final(md, ctx->ctx.sha1_ctx);\n        break;\n    case SSH_KDF_SHA256:\n        rc = sha256_final(md, ctx->ctx.sha256_ctx);\n        break;\n    case SSH_KDF_SHA384:\n        rc = sha384_final(md, ctx->ctx.sha384_ctx);\n        break;\n    case SSH_KDF_SHA512:\n        rc = sha512_final(md, ctx->ctx.sha512_ctx);\n        break;\n    }\n    SAFE_FREE(ctx);\n    return rc;\n}\n",
      "line_start": 129,
      "line_end": 150,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple wrapper that dispatches to hash-finalize functions based on a small switch and frees the context. Minimal branching and no parsing or direct memory operations on untrusted input, so low value as a fuzz target."
    },
    {
      "name": "ssh_send_rekex",
      "clean_name": "ssh_send_rekex",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "\n/*\n * Key re-exchange (rekey) is triggered by this function.\n * It can not be called again after the rekey is initialized!\n */\nint ssh_send_rekex(ssh_session session)\n{\n    int rc;\n\n    if (session->dh_handshake_state != DH_STATE_FINISHED) {\n        /* Rekey/Key exchange is already in progress */\n        SSH_LOG(SSH_LOG_PACKET, \"Attempting rekey in bad state\");\n        return SSH_ERROR;\n    }\n\n    if (session->current_crypto == NULL) {\n        /* No current crypto used -- can not exchange it */\n        SSH_LOG(SSH_LOG_PACKET, \"No crypto to rekey\");\n        return SSH_ERROR;\n    }\n\n    if (session->client) {\n        rc = ssh_set_client_kex(session);\n        if (rc != SSH_OK) {\n            SSH_LOG(SSH_LOG_PACKET, \"Failed to set client kex\");\n            return rc;\n        }\n    } else {\n#ifdef WITH_SERVER\n        rc = server_set_kex(session);\n        if (rc == SSH_ERROR) {\n            SSH_LOG(SSH_LOG_PACKET, \"Failed to set server kex\");\n            return rc;\n        }\n#else\n        SSH_LOG(SSH_LOG_PACKET, \"Invalid session state.\");\n        return SSH_ERROR;\n#endif /* WITH_SERVER */\n    }\n\n    session->dh_handshake_state = DH_STATE_INIT;\n    rc = ssh_send_kex(session);\n    if (rc < 0) {\n        SSH_LOG(SSH_LOG_PACKET, \"Failed to send kex\");\n        return rc;\n    }\n\n    /* Reset the handshake state */\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n    return SSH_OK;\n}\n",
      "line_start": 1170,
      "line_end": 1216,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper that initiates a rekey: simple state checks and calls into kex/send functions. It is security-relevant (triggers crypto operations) but contains no parsing of external input, no memory manipulation on untrusted data, no loops, and low cyclomatic complexity \u2014 low priority as a direct fuzz target (better to fuzz the underlying kex/parsing functions it calls)."
    },
    {
      "name": "knownhosts.c:known_hosts_read_line",
      "clean_name": "known_hosts_read_line",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "    ssh_key_free(entry->publickey);\n    SAFE_FREE(entry->comment);\n    SAFE_FREE(entry);\n}\n\nstatic int known_hosts_read_line(FILE *fp,\n                                 char *buf,\n                                 size_t buf_size,\n                                 size_t *buf_len,\n                                 size_t *lineno)\n{\n    while (fgets(buf, (int)buf_size, fp) != NULL) {\n        size_t len;\n        if (buf[0] == '\\0') {\n            continue;\n        }\n\n        *lineno += 1;\n        len = strlen(buf);\n        if (buf_len != NULL) {\n            *buf_len = len;\n        }\n        if (buf[len - 1] == '\\n' || feof(fp)) {\n            return 0;\n        } else {\n            errno = E2BIG;\n            return -1;\n        }\n    }\n\n    return -1;\n}\n",
      "line_start": 167,
      "line_end": 194,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple line-reader: reads external file input with fgets and does minor buffer/length checks but contains minimal branching, no complex parsing, no heavy memory manipulation or security-critical logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_vlog",
      "clean_name": "ssh_vlog",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "    }\n\n    ssh_log_stderr(verbosity, function, buffer);\n}\n\nvoid ssh_vlog(int verbosity,\n              const char *function,\n              const char *format,\n              va_list *va)\n{\n    char buffer[LOG_SIZE];\n\n    vsnprintf(buffer, sizeof(buffer), format, *va);\n    ssh_log_function(verbosity, function, buffer);\n}\n",
      "line_start": 125,
      "line_end": 135,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple logging wrapper: formats into a fixed-size buffer with vsnprintf and forwards to ssh_log_function. Very low complexity and few code paths. Limited attack surface (possible issues with a NULL va pointer or malicious format strings), but overall a low-value fuzz target."
    },
    {
      "name": "match.c:get_address_family",
      "clean_name": "get_address_family",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " *\n * @return The value of the address family if no errors.\n * @return -1 in case of errors.\n */\nstatic int\nget_address_family(const char *address)\n{\n    struct addrinfo hints, *ai = NULL;\n    int rc = -1, rv;\n\n    ZERO_STRUCT(hints);\n    if (address == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad arguments\");\n        goto out;\n    }\n\n    hints.ai_flags = AI_NUMERICHOST;\n    rv = getaddrinfo(address, NULL, &hints, &ai);\n    if (rv != 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Couldn't get address information - getaddrinfo() failed: %s\",\n                gai_strerror(rv));\n        goto out;\n    }\n\n    rc = ai->ai_family;\n    freeaddrinfo(ai);\n\nout:\n    return rc;\n}\n",
      "line_start": 325,
      "line_end": 351,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Thin wrapper around getaddrinfo with only a NULL check and a single call; no memory operations, limited branching, and AI_NUMERICHOST restricts input to numeric addresses. Low intrinsic fuzzing value (may only surface bugs in the system resolver)."
    },
    {
      "name": "messages.c:ssh_message_queue",
      "clean_name": "ssh_message_queue",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param[in]  session  The SSH session to add the message.\n *\n * @param[in]  message  The message to add to the queue.\n */\nstatic void ssh_message_queue(ssh_session session, ssh_message message)\n{\n#ifdef WITH_SERVER\n    int ret;\n#endif\n\n    if (message == NULL) {\n        return;\n    }\n\n#ifdef WITH_SERVER\n    /* probably not the best place to execute server callbacks, but still better\n     * than nothing.\n     */\n    ret = ssh_execute_server_callbacks(session, message);\n    if (ret == SSH_OK) {\n        SSH_MESSAGE_FREE(message);\n        return;\n    }\n#endif /* WITH_SERVER */\n\n    if (session->ssh_message_callback != NULL) {\n        /* This will transfer the message, do not free. */\n        ssh_execute_message_callback(session, message);\n        return;\n    }\n\n    if (session->server_callbacks != NULL) {\n        /* if we have server callbacks, but nothing was executed, it means we are\n         * in non-synchronous mode, and we just don't care about the message we\n         * received. Just send a default response. Do not queue it.\n         */\n        ssh_message_reply_default(message);\n        SSH_MESSAGE_FREE(message);\n        return;\n    }\n\n    if (session->ssh_message_list == NULL) {\n        session->ssh_message_list = ssh_list_new();\n        if (session->ssh_message_list == NULL) {\n            /*\n             * If the message list couldn't be allocated, the message can't be\n             * enqueued\n             */\n            ssh_message_reply_default(message);\n            ssh_set_error_oom(session);\n            SSH_MESSAGE_FREE(message);\n            return;\n        }\n    }\n\n    /* This will transfer the message, do not free. */\n    ssh_list_append(session->ssh_message_list, message);\n    return;\n}\n",
      "line_start": 483,
      "line_end": 538,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 72,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple dispatcher/queue with minimal logic: checks NULL, calls callbacks, allocates/appends a list. It does not parse or manipulate untrusted data, perform buffer/memory ops on input, or contain input-dependent loops \u2014 low value as a direct fuzz target (callbacks called may be more interesting)."
    },
    {
      "name": "messages.c:ssh_execute_message_callback",
      "clean_name": "ssh_execute_message_callback",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    return rc;\n}\n\n#endif /* WITH_SERVER */\n\nstatic int ssh_execute_message_callback(ssh_session session, ssh_message msg) {\n\tint ret;\n    if(session->ssh_message_callback != NULL) {\n        ret = session->ssh_message_callback(session, msg,\n                session->ssh_message_callback_data);\n        if(ret == 1) {\n            ret = ssh_message_reply_default(msg);\n            SSH_MESSAGE_FREE(msg);\n            if(ret != SSH_OK) {\n                return ret;\n            }\n        } else {\n            SSH_MESSAGE_FREE(msg);\n        }\n    } else {\n        ret = ssh_message_reply_default(msg);\n        SSH_MESSAGE_FREE(msg);\n        if(ret != SSH_OK) {\n            return ret;\n        }\n    }\n    return SSH_OK;\n}\n",
      "line_start": 449,
      "line_end": 472,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 50,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple dispatcher/wrapper: minimal branching and no parsing or memory manipulation of msg contents. It mainly calls a callback and default-reply/free routines, so it has limited surface for finding parser/memory bugs and is a low-priority fuzz target."
    },
    {
      "name": "ssh_hostport",
      "clean_name": "ssh_hostport",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n\n    return new;\n}\n\nchar *ssh_hostport(const char *host, int port)\n{\n    char *dest = NULL;\n    size_t len;\n\n    if (host == NULL) {\n        return NULL;\n    }\n\n    /* 3 for []:, 5 for 65536 and 1 for nul */\n    len = strlen(host) + 3 + 5 + 1;\n    dest = malloc(len);\n    if (dest == NULL) {\n        return NULL;\n    }\n    snprintf(dest, len, \"[%s]:%d\", host, port);\n\n    return dest;\n}\n",
      "line_start": 450,
      "line_end": 469,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Trivial helper that formats a host:port string. Low cyclomatic complexity and no parsing of complex formats or protocols. Uses malloc and snprintf (minor risks: huge host may cause OOM and port formatting can be truncated if longer than assumed), but overall a small attack surface and low fuzz priority."
    },
    {
      "name": "_ssh_list_pop_head",
      "clean_name": "_ssh_list_pop_head",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in]  list     The ssh_list to remove the element.\n *\n * @returns             A pointer to the element being stored in head, or NULL\n *                      if the list is empty.\n */\nconst void *_ssh_list_pop_head(struct ssh_list *list)\n{\n  struct ssh_iterator *iterator = NULL;\n  const void *data = NULL;\n\n  if (list == NULL) {\n      return NULL;\n  }\n\n  iterator = list->root;\n  if (iterator == NULL) {\n      return NULL;\n  }\n  data=iterator->data;\n  list->root=iterator->next;\n  if(list->end==iterator)\n    list->end=NULL;\n  SAFE_FREE(iterator);\n  return data;\n}\n",
      "line_start": 906,
      "line_end": 926,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple linked-list pop helper: minimal branching, no parsing of external formats, no loops, and no complex validation. It does free an iterator and returns a stored pointer (so misuse could lead to UAF at call sites), but as a standalone fuzz target it has low attack surface and limited value compared to parsing/crypto code."
    },
    {
      "name": "ssh_dirname",
      "clean_name": "ssh_dirname",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *                      \".\" is returned. The memory needs to be freed using\n *                      ssh_string_free_char().\n *\n * @see ssh_string_free_char()\n */\nchar *ssh_dirname (const char *path)\n{\n  char *new = NULL;\n  size_t len;\n\n  if (path == NULL || *path == '\\0') {\n    return strdup(\".\");\n  }\n\n  len = strlen(path);\n\n  /* Remove trailing slashes */\n  while(len > 0 && path[len - 1] == '/') --len;\n\n  /* We have only slashes */\n  if (len == 0) {\n    return strdup(\"/\");\n  }\n\n  /* goto next slash */\n  while(len > 0 && path[len - 1] != '/') --len;\n\n  if (len == 0) {\n    return strdup(\".\");\n  } else if (len == 1) {\n    return strdup(\"/\");\n  }\n\n  /* Remove slashes again */\n  while(len > 0 && path[len - 1] == '/') --len;\n\n  new = malloc(len + 1);\n  if (new == NULL) {\n    return NULL;\n  }\n\n  strncpy(new, path, len);\n  new[len] = '\\0';\n\n  return new;\n}\n",
      "line_start": 946,
      "line_end": 987,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 62,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple dirname-like helper: scans and trims a path string and allocates/returns a substring. It touches untrusted data and performs basic memory ops (strlen, strncpy, malloc) but has low complexity, few branches and no parsing of complex formats or security-sensitive logic \u2014 low-value fuzz target."
    },
    {
      "name": "uint64_inc",
      "clean_name": "uint64_inc",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "}\n#endif /* ! HAVE_STRNDUP */\n\n/* Increment 64b integer in network byte order */\nvoid\nuint64_inc(unsigned char *counter)\n{\n    int i;\n\n    for (i = 7; i >= 0; i--) {\n        counter[i]++;\n        if (counter[i])\n          return;\n    }\n}\n",
      "line_start": 1665,
      "line_end": 1675,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Very simple helper that increments an 8-byte big-endian counter in-place. Fixed 8-iteration loop, minimal branching, no parsing or validation logic. Although it touches caller-supplied memory, it lacks complex input-dependent behaviour or formats that make it a high-value fuzz target."
    },
    {
      "name": "ssh_writen",
      "clean_name": "ssh_writen",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @returns               Number of bytes written on success,\n *                        SSH_ERROR on error with errno set to indicate the\n *                        error.\n */\nssize_t ssh_writen(int fd, const void *buf, size_t nbytes)\n{\n    size_t total_bytes_written = 0;\n    ssize_t bytes_written;\n\n    if (fd < 0 || buf == NULL || nbytes == 0) {\n        errno = EINVAL;\n        return SSH_ERROR;\n    }\n\n    do {\n        bytes_written = write(fd,\n                              ((const char *)buf) + total_bytes_written,\n                              nbytes - total_bytes_written);\n        if (bytes_written == -1) {\n            if (errno == EINTR) {\n                /* Ignoring errors due to signal interrupts */\n                continue;\n            }\n\n            return SSH_ERROR;\n        }\n\n        total_bytes_written += (size_t)bytes_written;\n    } while (total_bytes_written < nbytes);\n\n    return total_bytes_written;\n}\n",
      "line_start": 2128,
      "line_end": 2156,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple I/O helper: a small wrapper around write() with an EINTR-retry loop and basic parameter checks. Low cyclomatic complexity, no parsing/validation of complex external formats or risky memory operations \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_bind_options_parse_config",
      "clean_name": "ssh_bind_options_parse_config",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *                      configuration is parsed and applied (if it hasn't been\n *                      processed before).\n *\n * @return 0 on success, < 0 on error.\n */\nint ssh_bind_options_parse_config(ssh_bind sshbind, const char *filename)\n{\n    int rc = 0;\n    char *expanded_filename = NULL;\n\n    if (sshbind == NULL) {\n        return -1;\n    }\n\n    /* If the global default configuration hasn't been processed yet, process it\n     * before the provided configuration. */\n    if (!(sshbind->config_processed)) {\n        if (ssh_file_readaccess_ok(GLOBAL_BIND_CONFIG)) {\n            rc = ssh_bind_config_parse_file(sshbind, GLOBAL_BIND_CONFIG);\n#ifdef USR_GLOBAL_BIND_CONFIG\n        } else {\n            rc = ssh_bind_config_parse_file(sshbind, USR_GLOBAL_BIND_CONFIG);\n#endif\n        }\n        if (rc != 0) {\n            return rc;\n        }\n        sshbind->config_processed = true;\n    }\n\n    if (filename != NULL) {\n        expanded_filename = ssh_bind_options_expand_escape(sshbind, filename);\n        if (expanded_filename == NULL) {\n            return -1;\n        }\n\n        /* Apply the user provided configuration */\n        rc = ssh_bind_config_parse_file(sshbind, expanded_filename);\n        free(expanded_filename);\n    }\n\n    return rc;\n}\n",
      "line_start": 2727,
      "line_end": 2765,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 44,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper that orchestrates parsing: it validates args, conditionally expands a filename and calls ssh_bind_config_parse_file. Minimal logic and memory ops here; actual complex parsing happens in other functions, so this is a low-priority fuzz target."
    },
    {
      "name": "ssh_packet_unimplemented",
      "clean_name": "ssh_packet_unimplemented",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "}\n\n/** @internal\n * @brief handles a SSH_MSG_UNIMPLEMENTED packet\n */\nSSH_PACKET_CALLBACK(ssh_packet_unimplemented){\n    uint32_t seq;\n    int rc;\n\n    (void)session; /* unused */\n    (void)type;\n    (void)user;\n\n    rc = ssh_buffer_unpack(packet, \"d\", &seq);\n    if (rc != SSH_OK) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Could not unpack SSH_MSG_UNIMPLEMENTED packet\");\n    }\n\n    SSH_LOG(SSH_LOG_RARE,\n            \"Received SSH_MSG_UNIMPLEMENTED (sequence number %\" PRIu32 \")\",seq);\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 1705,
      "line_end": 1724,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Only unpacks a single uint32 sequence number and logs it; minimal control flow, no loops or buffer manipulation in this function. The real risk would be in ssh_buffer_unpack, so this specific target is low priority for fuzzing."
    },
    {
      "name": "packet.c:ssh_init_rekey_state",
      "clean_name": "ssh_init_rekey_state",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "\n    return rc;\n}\n\nstatic void\nssh_init_rekey_state(struct ssh_session_struct *session,\n                     struct ssh_cipher_struct *cipher)\n{\n    /* Reset the counters: should be NOOP */\n    cipher->packets = 0;\n    cipher->blocks = 0;\n\n    /* Default rekey limits for ciphers as specified in RFC4344, Section 3.2 */\n    if (cipher->blocksize >= 16) {\n        /* For larger block size (L bits) use maximum of 2**(L/4) blocks */\n        cipher->max_blocks = (uint64_t)1 << (cipher->blocksize*2);\n    } else {\n        /* For smaller blocks use limit of 1 GB as recommended in RFC4253 */\n        cipher->max_blocks = ((uint64_t)1 << 30) / cipher->blocksize;\n    }\n    /* If we have limit provided by user, use the smaller one */\n    if (session->opts.rekey_data != 0) {\n        cipher->max_blocks = MIN(cipher->max_blocks,\n                                 session->opts.rekey_data / cipher->blocksize);\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"Set rekey after %\" PRIu64 \" blocks\",\n            cipher->max_blocks);\n}\n",
      "line_start": 2022,
      "line_end": 2047,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple initializer with minimal logic: resets counters and computes max_blocks via basic arithmetic and one branch. It touches externally-configurable values (cipher->blocksize and session->opts.rekey_data) but does not parse complex input, perform memory ops, or contain loops/complex branching. Low-value fuzz target (minor risk from integer-shift/overflow/UB if blocksize is attacker-controlled)."
    },
    {
      "name": "pcap.c:ssh_pcap_context_connect",
      "clean_name": "ssh_pcap_context_connect",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "}\n\n/** @internal\n * @brief sets the IP and port parameters in the connection\n */\nstatic int ssh_pcap_context_connect(ssh_pcap_context ctx)\n{\n    ssh_session session=ctx->session;\n    struct sockaddr_in local = {\n        .sin_family = AF_UNSPEC,\n    };\n    struct sockaddr_in remote = {\n        .sin_family = AF_UNSPEC,\n    };\n    socket_t fd;\n    socklen_t len;\n    int rc;\n    char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (session->socket == NULL) {\n        return SSH_ERROR;\n    }\n\n    fd = ssh_socket_get_fd(session->socket);\n\n    /* TODO: adapt for windows */\n    if (fd < 0) {\n        return SSH_ERROR;\n    }\n\n    len = sizeof(local);\n    rc = getsockname(fd, (struct sockaddr *)&local, &len);\n    if (rc < 0) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Getting local IP address: %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_ERROR;\n    }\n\n    len = sizeof(remote);\n    rc = getpeername(fd, (struct sockaddr *)&remote, &len);\n    if (rc < 0) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Getting remote IP address: %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        return SSH_ERROR;\n    }\n\n    if (local.sin_family != AF_INET) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Only IPv4 supported for pcap logging\");\n        return SSH_ERROR;\n    }\n\n    memcpy(&ctx->ipsource, &local.sin_addr, sizeof(ctx->ipsource));\n    memcpy(&ctx->ipdest, &remote.sin_addr, sizeof(ctx->ipdest));\n    memcpy(&ctx->portsource, &local.sin_port, sizeof(ctx->portsource));\n    memcpy(&ctx->portdest, &remote.sin_port, sizeof(ctx->portdest));\n\n    ctx->connected = 1;\n    return SSH_OK;\n}\n",
      "line_start": 321,
      "line_end": 385,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 68,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Low fuzz value: simple helper that queries socket info and copies sockaddr fields. Minimal branching, no parsing of complex external input or loops, only a few safety checks and memcpy of system-provided data. Hard to reach interesting behavior without mocking socket/syscalls, so low priority for fuzzing."
    },
    {
      "name": "ssh_key_type_to_hash",
      "clean_name": "ssh_key_type_to_hash",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in]  type     The type to convert.\n *\n * @return              A hash type to be used.\n */\nenum ssh_digest_e ssh_key_type_to_hash(ssh_session session,\n                                       enum ssh_keytypes_e type)\n{\n    switch (type) {\n    case SSH_KEYTYPE_RSA_CERT01:\n        /* If we are talking to an old OpenSSH version which does not support\n         * SHA2 in certificates */\n        if ((session->openssh > 0) &&\n            (session->openssh < SSH_VERSION_INT(7, 2, 0)))\n        {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"We are talking to an old OpenSSH (%x); \"\n                    \"returning SSH_DIGEST_SHA1\",\n                    session->openssh);\n\n            return SSH_DIGEST_SHA1;\n        }\n        FALL_THROUGH;\n    case SSH_KEYTYPE_RSA:\n        if (ssh_key_algorithm_allowed(session, \"rsa-sha2-512\") &&\n            (session->extensions & SSH_EXT_SIG_RSA_SHA512)) {\n            return SSH_DIGEST_SHA512;\n        }\n\n        if (ssh_key_algorithm_allowed(session, \"rsa-sha2-256\") &&\n            (session->extensions & SSH_EXT_SIG_RSA_SHA256)) {\n            return SSH_DIGEST_SHA256;\n        }\n\n        /* Default algorithm for RSA is SHA1 */\n        return SSH_DIGEST_SHA1;\n\n    default:\n        return key_type_to_hash(type);\n    }\n\n    /* We should never reach this */\n    return SSH_DIGEST_AUTO;\n}\n",
      "line_start": 547,
      "line_end": 586,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Small decision logic around key type and session flags: no parsing of external formats, no memory ops, no loops, low cyclomatic complexity. It mostly routes based on enums/flags (a thin wrapper), so low fuzzing value on its own."
    },
    {
      "name": "ssh_pki_convert_key_to_publickey",
      "clean_name": "ssh_pki_convert_key_to_publickey",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "                                              filename,\n                                              SSH_FILE_FORMAT_DEFAULT);\n}\n\n/* temporary function to migrate seamlessly to ssh_key */\nssh_public_key ssh_pki_convert_key_to_publickey(const ssh_key key)\n{\n    ssh_public_key pub = NULL;\n    ssh_key tmp = NULL;\n\n    if (key == NULL) {\n        return NULL;\n    }\n\n    tmp = ssh_key_dup(key);\n    if (tmp == NULL) {\n        return NULL;\n    }\n\n    pub = calloc(1, sizeof(struct ssh_public_key_struct));\n    if (pub == NULL) {\n        ssh_key_free(tmp);\n        return NULL;\n    }\n\n    pub->type = tmp->type;\n    pub->type_c = tmp->type_c;\n\n#if defined(HAVE_LIBMBEDCRYPTO)\n    pub->rsa_pub = tmp->pk;\n    tmp->pk = NULL;\n#elif defined(HAVE_LIBCRYPTO)\n    pub->key_pub = tmp->key;\n    tmp->key = NULL;\n#else\n    pub->rsa_pub = tmp->rsa;\n    tmp->rsa = NULL;\n#endif /* HAVE_LIBCRYPTO */\n\n    ssh_key_free(tmp);\n\n    return pub;\n}\n",
      "line_start": 1310,
      "line_end": 1348,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple wrapper/adapter: it duplicates an ssh_key, allocates a public-key struct and transfers pointers. Low cyclomatic complexity, no parsing of external data, no loops or input-dependent branching. While it touches crypto structures and does memory allocation, it does not perform complex validation or memory operations on raw untrusted input, so it is a low-priority fuzz target."
    },
    {
      "name": "ssh_pki_export_pubkey_base64",
      "clean_name": "ssh_pki_export_pubkey_base64",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_string_free_char()\n */\nint ssh_pki_export_pubkey_base64(const ssh_key key,\n                                 char **b64_key)\n{\n    ssh_string key_blob = NULL;\n    unsigned char *b64 = NULL;\n\n    if (key == NULL || b64_key == NULL) {\n        return SSH_ERROR;\n    }\n\n    key_blob = pki_key_to_blob(key, SSH_KEY_PUBLIC);\n    if (key_blob == NULL) {\n        return SSH_ERROR;\n    }\n\n    b64 = bin_to_base64(ssh_string_data(key_blob), ssh_string_len(key_blob));\n    SSH_STRING_FREE(key_blob);\n    if (b64 == NULL) {\n        return SSH_ERROR;\n    }\n\n    *b64_key = (char *)b64;\n\n    return SSH_OK;\n}\n",
      "line_start": 2443,
      "line_end": 2468,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple wrapper: only null checks and calls to pki_key_to_blob and bin_to_base64, minimal branching and no direct parsing of complex external input or risky memory manipulation in this function itself. Limited value as a standalone fuzz target (higher value would come from fuzzing the called serializers/encoders)."
    },
    {
      "name": "pki_key_check_hash_compatible",
      "clean_name": "pki_key_check_hash_compatible",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param[in]   key         The key to be checked.\n * @param[in]   hash_type   The digest algorithm to be checked.\n *\n * @return  SSH_OK if compatible; SSH_ERROR otherwise\n */\nint pki_key_check_hash_compatible(ssh_key key,\n                                  enum ssh_digest_e hash_type)\n{\n    if (key == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Null pointer provided as key to \"\n                               \"pki_key_check_hash_compatible()\");\n        return SSH_ERROR;\n    }\n\n    switch(key->type) {\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_RSA:\n        if (hash_type == SSH_DIGEST_SHA1) {\n            if (ssh_fips_mode()) {\n                SSH_LOG(SSH_LOG_TRACE, \"SHA1 is not allowed in FIPS mode\");\n                return SSH_ERROR;\n            } else {\n                return SSH_OK;\n            }\n        }\n\n        if (hash_type == SSH_DIGEST_SHA256 ||\n            hash_type == SSH_DIGEST_SHA512)\n        {\n            return SSH_OK;\n        }\n        break;\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_SK_ECDSA_CERT01:\n    case SSH_KEYTYPE_SK_ECDSA:\n        if (hash_type == SSH_DIGEST_SHA256) {\n            return SSH_OK;\n        }\n        break;\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384:\n        if (hash_type == SSH_DIGEST_SHA384) {\n            return SSH_OK;\n        }\n        break;\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521:\n        if (hash_type == SSH_DIGEST_SHA512) {\n            return SSH_OK;\n        }\n        break;\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_SK_ED25519_CERT01:\n    case SSH_KEYTYPE_SK_ED25519:\n        if (hash_type == SSH_DIGEST_AUTO) {\n            return SSH_OK;\n        }\n        break;\n    case SSH_KEYTYPE_DSS:   /* deprecated */\n    case SSH_KEYTYPE_DSS_CERT01:    /* deprecated */\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_ECDSA:\n    case SSH_KEYTYPE_UNKNOWN:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown key type %d\", key->type);\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"Key type %d incompatible with hash type  %d\",\n            key->type, hash_type);\n\n    return SSH_ERROR;\n}\n",
      "line_start": 2740,
      "line_end": 2809,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 105,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple, small decision function that only checks a key->type enum and a hash_type enum (plus a global ssh_fips_mode). It performs no parsing or memory operations on external data, has low complexity and no loops, and offers limited attack surface \u2014 useful for unit tests but low value as a fuzz target."
    },
    {
      "name": "ssh_poll_ctx_add",
      "clean_name": "ssh_poll_ctx_add",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  ctx          Pointer to an already allocated poll context.\n * @param  p            Pointer to an already allocated poll object.\n *\n * @return              0 on success, < 0 on error\n */\nint ssh_poll_ctx_add(ssh_poll_ctx ctx, ssh_poll_handle p)\n{\n    socket_t fd;\n\n    if (p->ctx != NULL) {\n        /* already attached to a context */\n        return -1;\n    }\n\n    if (ctx->polls_used == ctx->polls_allocated &&\n        ssh_poll_ctx_resize(ctx, ctx->polls_allocated + ctx->chunk_size) < 0) {\n        return -1;\n    }\n\n    fd = p->x.fd;\n    p->x.idx = ctx->polls_used++;\n    ctx->pollptrs[p->x.idx] = p;\n    ctx->pollfds[p->x.idx].fd = fd;\n    ctx->pollfds[p->x.idx].events = p->events;\n    ctx->pollfds[p->x.idx].revents = 0;\n    p->ctx = ctx;\n\n    return 0;\n}\n",
      "line_start": 611,
      "line_end": 635,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple state-manipulation helper: performs basic checks and array/field updates, no parsing of external data, no complex control flow or loops. Limited value as a fuzz target (small attack surface), though underlying resize/allocation failures could be indirectly interesting."
    },
    {
      "name": "ssh_event_remove_fd",
      "clean_name": "ssh_event_remove_fd",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  fd           The fd to remove.\n *\n * @returns SSH_OK      on success\n *          SSH_ERROR   on failure\n */\nint ssh_event_remove_fd(ssh_event event, socket_t fd)\n{\n    register size_t i, used;\n    int rc = SSH_ERROR;\n\n    if (event == NULL || event->ctx == NULL) {\n        return SSH_ERROR;\n    }\n\n    used = event->ctx->polls_used;\n    for (i = 0; i < used; i++) {\n        if (fd == event->ctx->pollfds[i].fd) {\n            ssh_poll_handle p = event->ctx->pollptrs[i];\n            if (p->session != NULL) {\n                /* we cannot free that handle, it's owned by its session */\n                continue;\n            }\n            if (p->cb == ssh_event_fd_wrapper_callback) {\n                struct ssh_event_fd_wrapper *pw = p->cb_data;\n                SAFE_FREE(pw);\n            }\n\n            /*\n             * The free function calls ssh_poll_ctx_remove() and decrements\n             * event->ctx->polls_used.\n             */\n            ssh_poll_free(p);\n            rc = SSH_OK;\n\n            /* restart the loop */\n            used = event->ctx->polls_used;\n            i = 0;\n        }\n    }\n\n    return rc;\n}\n",
      "line_start": 1066,
      "line_end": 1103,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "This function is primarily an internal resource-removal helper: it iterates over an internal poll list, compares an fd, and frees associated structures. It does perform memory frees and pointer checks (possible logic bugs if the surrounding state is corrupted), but it does not parse complex external input, perform buffer/string operations, or implement protocol parsing. Low fuzz priority unless you can fuzz the whole event/ctx state; otherwise it's mostly internal control logic."
    },
    {
      "name": "ssh_dh_init_common",
      "clean_name": "ssh_dh_init_common",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "\n/**\n * @internal\n * @brief allocate and initialize ephemeral values used in dh kex\n */\nint ssh_dh_init_common(struct ssh_crypto_struct *crypto)\n{\n    struct dh_ctx *ctx = NULL;\n    int rc;\n\n    /* Cleanup any previously allocated dh_ctx */\n    if (crypto->dh_ctx != NULL) {\n        ssh_dh_cleanup(crypto);\n    }\n\n    ctx = calloc(1, sizeof(*ctx));\n    if (ctx == NULL) {\n        return SSH_ERROR;\n    }\n    crypto->dh_ctx = ctx;\n\n    switch (crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n        rc = ssh_dh_set_parameters(ctx, ssh_dh_group1, ssh_dh_generator);\n        break;\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n        rc = ssh_dh_set_parameters(ctx, ssh_dh_group14, ssh_dh_generator);\n        break;\n    case SSH_KEX_DH_GROUP16_SHA512:\n        rc = ssh_dh_set_parameters(ctx, ssh_dh_group16, ssh_dh_generator);\n        break;\n    case SSH_KEX_DH_GROUP18_SHA512:\n        rc = ssh_dh_set_parameters(ctx, ssh_dh_group18, ssh_dh_generator);\n        break;\n    default:\n        rc = SSH_OK;\n        break;\n    }\n\n    if (rc != SSH_OK) {\n        ssh_dh_cleanup(crypto);\n    }\n    return rc;\n}\n",
      "line_start": 404,
      "line_end": 444,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple initializer: allocates and sets up a DH context based on an internal kex_type. Low cyclomatic complexity, no parsing of external input, no memory or string ops on untrusted data. Although related to crypto, it does not perform security-critical parsing or complex transformations, so low fuzz priority."
    },
    {
      "name": "ssh_send_issue_banner",
      "clean_name": "ssh_send_issue_banner",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "{\n    /* accept only methods in range */\n    session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;\n}\n\nint ssh_send_issue_banner(ssh_session session, const ssh_string banner)\n{\n    int rc = SSH_ERROR;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Sending a server issue banner\");\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bSs\",\n                         SSH2_MSG_USERAUTH_BANNER,\n                         banner,\n                         \"\");\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_packet_send(session);\n    return rc;\n}\n",
      "line_start": 541,
      "line_end": 565,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Thin wrapper that validates session pointer then packs and sends a banner. Minimal logic and branching, no parsing or complex input handling in this function itself. Any memory work is delegated to lower-level routines, so as a fuzz target it has low priority."
    },
    {
      "name": "ssh_auth_reply_default",
      "clean_name": "ssh_auth_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "/* messages */\n\n/** @internal\n * replies to an SSH_AUTH packet with a default (denied) response.\n */\nint ssh_auth_reply_default(ssh_session session,int partial) {\n  char methods_c[128] = {0};\n  int rc = SSH_ERROR;\n\n\n  if (session->auth.supported_methods == 0) {\n    session->auth.supported_methods = SSH_AUTH_METHOD_PUBLICKEY | SSH_AUTH_METHOD_PASSWORD;\n  }\n  if (session->auth.supported_methods & SSH_AUTH_METHOD_PUBLICKEY) {\n    strncat(methods_c, \"publickey,\",\n            sizeof(methods_c) - strlen(methods_c) - 1);\n  }\n  if (session->auth.supported_methods & SSH_AUTH_METHOD_GSSAPI_MIC){\n\t  strncat(methods_c,\"gssapi-with-mic,\",\n\t\t\t  sizeof(methods_c) - strlen(methods_c) - 1);\n  }\n  if (session->auth.supported_methods & SSH_AUTH_METHOD_INTERACTIVE) {\n    strncat(methods_c, \"keyboard-interactive,\",\n            sizeof(methods_c) - strlen(methods_c) - 1);\n  }\n  if (session->auth.supported_methods & SSH_AUTH_METHOD_PASSWORD) {\n    strncat(methods_c, \"password,\",\n            sizeof(methods_c) - strlen(methods_c) - 1);\n  }\n  if (session->auth.supported_methods & SSH_AUTH_METHOD_HOSTBASED) {\n    strncat(methods_c, \"hostbased,\",\n            sizeof(methods_c) - strlen(methods_c) - 1);\n  }\n\n  if (methods_c[0] == '\\0' || methods_c[strlen(methods_c)-1] != ',') {\n      return SSH_ERROR;\n  }\n\n  /* Strip the comma. */\n  methods_c[strlen(methods_c) - 1] = '\\0'; // strip the comma. We are sure there is at\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Sending a auth failure. methods that can continue: %s\", methods_c);\n\n  rc = ssh_buffer_pack(session->out_buffer,\n                       \"bsb\",\n                       SSH2_MSG_USERAUTH_FAILURE,\n                       methods_c,\n                       partial ? 1 : 0);\n  if (rc != SSH_OK){\n      ssh_set_error_oom(session);\n      return SSH_ERROR;\n  }\n  rc = ssh_packet_send(session);\n  return rc;\n}\n",
      "line_start": 614,
      "line_end": 665,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 77,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Minimal logic and low complexity: builds a small methods string from session flags and calls buffer/packet send. No parsing of complex external input, no input-dependent loops, and limited memory manipulation (bounded strncat). Small branching makes it a low-value fuzz target; only surface is the session->auth flags and 'partial' flag, so score 3 (low priority)."
    },
    {
      "name": "ssh_agent_is_running",
      "clean_name": "ssh_agent_is_running",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "    }\n\n    return key;\n}\n\nint ssh_agent_is_running(ssh_session session)\n{\n    if (session == NULL || session->agent == NULL) {\n        return 0;\n    }\n\n    if (ssh_socket_is_open(session->agent->sock)) {\n        return 1;\n    } else {\n        if (agent_connect(session) < 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n",
      "line_start": 496,
      "line_end": 514,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 3.0,
      "reason": "Simple wrapper/check function with minimal logic: null checks and a single socket-open check, then delegates to agent_connect. No parsing of complex external input, no memory manipulation, low cyclomatic complexity. It may trigger network behavior via agent_connect, but the function itself is low-value as a direct fuzz target."
    },
    {
      "name": "agent.c:agent_connect",
      "clean_name": "agent_connect",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "        }\n        SAFE_FREE(agent);\n    }\n}\n\nstatic int agent_connect(ssh_session session)\n{\n    const char *auth_sock = NULL;\n\n    if (session == NULL || session->agent == NULL) {\n        return -1;\n    }\n\n    if (session->agent->channel != NULL) {\n        return 0;\n    }\n\n    auth_sock = session->opts.agent_socket ? session->opts.agent_socket\n                                           : getenv(\"SSH_AUTH_SOCK\");\n\n    if (auth_sock && *auth_sock) {\n        if (ssh_socket_unix(session->agent->sock, auth_sock) < 0) {\n            return -1;\n        }\n        return 0;\n    }\n\n    return -1;\n}\n",
      "line_start": 242,
      "line_end": 266,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple wrapper that selects an agent socket path and calls ssh_socket_unix. Minimal branching and no parsing or memory-manipulating operations on untrusted data; limited value as a fuzz target (better to fuzz ssh_socket_unix or callers that produce opts.agent_socket)."
    },
    {
      "name": "base64.c:_base64_to_bin",
      "clean_name": "_base64_to_bin",
      "source_file": "/src/libssh/src/base64.c",
      "source_code": "\n    return 0;\n}\n\n/* num = numbers of final bytes to be decoded */\nstatic int _base64_to_bin(unsigned char dest[3], const char *source, int num)\n{\n    unsigned long block;\n\n    if (to_block4(&block, source, num) < 0) {\n        return -1;\n    }\n    dest[0] = GET_A(block);\n    dest[1] = GET_B(block);\n    dest[2] = GET_C(block);\n\n    return 0;\n}\n",
      "line_start": 214,
      "line_end": 227,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Trivial wrapper: it just calls to_block4() and copies three bytes into dest. No loops, minimal branching or parsing logic here \u2014 the real work and parsing/validation is in to_block4. Low-value as a primary fuzz target; fuzzing should focus on to_block4 or higher-level parsers."
    },
    {
      "name": "config.c:ssh_config_get_opcode",
      "clean_name": "ssh_config_get_opcode",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "};\n\nstatic int ssh_config_parse_line(ssh_session session, const char *line,\n    unsigned int count, int *parsing, unsigned int depth, bool global);\n\nstatic enum ssh_config_opcode_e ssh_config_get_opcode(char *keyword) {\n  int i;\n\n  for (i = 0; ssh_config_keyword_table[i].name != NULL; i++) {\n    if (strcasecmp(keyword, ssh_config_keyword_table[i].name) == 0) {\n      return ssh_config_keyword_table[i].opcode;\n    }\n  }\n\n  return SOC_UNKNOWN;\n}\n",
      "line_start": 193,
      "line_end": 204,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple lookup: performs a linear scan comparing the provided keyword (external input) against an internal table using strcasecmp and returns an opcode. Low complexity, no memory writes, no parsing, no loops or bounds driven by input \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_client_fuzzer.c:select_loop",
      "clean_name": "select_loop",
      "source_file": "/src/libssh/tests/fuzz/ssh_client_fuzzer.c",
      "source_code": "struct ssh_callbacks_struct cb = {\n    .userdata = NULL,\n    .auth_function = auth_callback,\n};\n\nstatic void select_loop(ssh_session session, ssh_channel channel)\n{\n    ssh_connector connector_in, connector_out, connector_err;\n\n    ssh_event event = ssh_event_new();\n\n    /* stdin */\n    connector_in = ssh_connector_new(session);\n    ssh_connector_set_out_channel(connector_in, channel, SSH_CONNECTOR_STDINOUT);\n    ssh_connector_set_in_fd(connector_in, 0);\n    ssh_event_add_connector(event, connector_in);\n\n    /* stdout */\n    connector_out = ssh_connector_new(session);\n    ssh_connector_set_out_fd(connector_out, 1);\n    ssh_connector_set_in_channel(connector_out, channel, SSH_CONNECTOR_STDINOUT);\n    ssh_event_add_connector(event, connector_out);\n\n    /* stderr */\n    connector_err = ssh_connector_new(session);\n    ssh_connector_set_out_fd(connector_err, 2);\n    ssh_connector_set_in_channel(connector_err, channel, SSH_CONNECTOR_STDERR);\n    ssh_event_add_connector(event, connector_err);\n\n    while (ssh_channel_is_open(channel)) {\n        ssh_event_dopoll(event, 60000);\n    }\n    ssh_event_remove_connector(event, connector_in);\n    ssh_event_remove_connector(event, connector_out);\n    ssh_event_remove_connector(event, connector_err);\n\n    ssh_connector_free(connector_in);\n    ssh_connector_free(connector_out);\n    ssh_connector_free(connector_err);\n\n    ssh_event_free(event);\n}\n",
      "line_start": 48,
      "line_end": 85,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple orchestration of libssh connectors and an event loop with minimal branching and no parsing or memory operations on untrusted data; only behavior depends on channel open/close, so it has low value as a fuzz target."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:ssh_known_hosts_entries_compare",
      "clean_name": "ssh_known_hosts_entries_compare",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": "\n    return -1;\n}\n\nstatic int\nssh_known_hosts_entries_compare(struct ssh_knownhosts_entry *k1,\n                                struct ssh_knownhosts_entry *k2)\n{\n    int cmp;\n\n    if (k1 == NULL || k2 == NULL) {\n        return 1;\n    }\n\n    cmp = strcmp(k1->hostname, k2->hostname);\n    if (cmp != 0) {\n        return cmp;\n    }\n\n    cmp = ssh_key_cmp(k1->publickey, k2->publickey, SSH_KEY_CMP_PUBLIC);\n    if (cmp != 0) {\n        return cmp;\n    }\n\n    return 0;\n}\n",
      "line_start": 196,
      "line_end": 217,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 3.0,
      "reason": "Simple comparator with minimal logic: checks for NULL, does strcmp on hostname and delegates to ssh_key_cmp. No parsing, no loops, no complex branching or direct memory manipulation\u2014low-value fuzz target."
    },
    {
      "name": "ssh_socket_set_callbacks",
      "clean_name": "ssh_socket_set_callbacks",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": " * upon a socket event.\n * @param s socket to set callbacks on.\n * @param callbacks a ssh_socket_callback object reference.\n */\n\nvoid ssh_socket_set_callbacks(ssh_socket s, ssh_socket_callbacks callbacks)\n{\n    s->callbacks = callbacks;\n}\n",
      "line_start": 222,
      "line_end": 226,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: simply assigns a callbacks pointer to a socket struct. No parsing, no memory operations, no branching or validation \u2014 minimal value as a direct fuzz target (low priority)."
    },
    {
      "name": "ssh_socket_set_connected",
      "clean_name": "ssh_socket_set_connected",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "void ssh_socket_set_callbacks(ssh_socket s, ssh_socket_callbacks callbacks)\n{\n    s->callbacks = callbacks;\n}\n\nvoid ssh_socket_set_connected(ssh_socket s, struct ssh_poll_handle_struct *p)\n{\n    s->state = SSH_SOCKET_CONNECTED;\n    /* POLLOUT is the event to wait for in a nonblocking connect */\n    if (p != NULL) {\n        ssh_poll_set_events(p, POLLIN | POLLOUT);\n    }\n}\n",
      "line_start": 227,
      "line_end": 235,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple state/setter function: it just sets s->state and optionally calls ssh_poll_set_events(p, POLLIN|POLLOUT). No parsing of external input, no memory ops, no loops or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_socket_free",
      "clean_name": "ssh_socket_free",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief Deletes a socket object\n */\nvoid ssh_socket_free(ssh_socket s)\n{\n    if (s == NULL) {\n        return;\n    }\n    ssh_socket_close(s);\n    SSH_BUFFER_FREE(s->in_buffer);\n    SSH_BUFFER_FREE(s->out_buffer);\n    SAFE_FREE(s);\n}\n",
      "line_start": 421,
      "line_end": 431,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a destructor/free function with a single null-check and calls to ssh_socket_close and free macros. It contains no parsing, limited branching, no input-dependent loops or complex logic\u2014low value as a fuzz target (aside from incidental double-free/use-after-free issues)."
    },
    {
      "name": "ssh_socket_close",
      "clean_name": "ssh_socket_close",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief closes a socket\n */\nvoid ssh_socket_close(ssh_socket s)\n{\n    if (ssh_socket_is_open(s)) {\n#ifdef _WIN32\n        CLOSE_SOCKET(s->fd);\n        s->last_errno = WSAGetLastError();\n#else\n        CLOSE_SOCKET(s->fd);\n        s->last_errno = errno;\n#endif\n    }\n\n    if (s->poll_handle != NULL && !ssh_poll_is_locked(s->poll_handle)) {\n        ssh_poll_free(s->poll_handle);\n        s->poll_handle = NULL;\n    }\n\n    s->state = SSH_SOCKET_CLOSED;\n\n#ifndef _WIN32\n    /* If the proxy command still runs try to kill it */\n    if (s->proxy_pid != 0) {\n        int status;\n        pid_t pid = s->proxy_pid;\n\n        s->proxy_pid = 0;\n        kill(pid, SIGTERM);\n        while (waitpid(pid, &status, 0) == -1) {\n            if (errno != EINTR) {\n                char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n                SSH_LOG(SSH_LOG_TRACE, \"waitpid failed: %s\",\n                        ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n                return;\n            }\n        }\n        if (!WIFEXITED(status)) {\n            SSH_LOG(SSH_LOG_TRACE, \"Proxy command exited abnormally\");\n            return;\n        }\n        SSH_LOG(SSH_LOG_TRACE, \"Proxy command returned %d\", WEXITSTATUS(status));\n    }\n#endif\n}\n",
      "line_start": 471,
      "line_end": 514,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a cleanup/close routine that mainly performs OS/resource operations (close socket, free poll handle, kill/waitpid) with limited branching and no parsing of external/complex input. It has side effects on the system (kill/waitpid) which makes it a poor/unsafe fuzz target; there is little input-dependent logic to exercise parsing or memory-handling vulnerabilities."
    },
    {
      "name": "ssh_socket_set_fd",
      "clean_name": "ssh_socket_set_fd",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": " * @param[out] s ssh_socket to update\n * @param[in] fd file descriptor to set\n * @warning this function updates both the input and output\n * file descriptors\n */\nint ssh_socket_set_fd(ssh_socket s, socket_t fd)\n{\n    ssh_poll_handle h = NULL;\n\n    s->fd = fd;\n\n    if (s->poll_handle) {\n        ssh_poll_set_fd(s->poll_handle,fd);\n    } else {\n        s->state = SSH_SOCKET_CONNECTING;\n        h = ssh_socket_get_poll_handle(s);\n        if (h == NULL) {\n            return SSH_ERROR;\n        }\n\n        /* POLLOUT is the event to wait for in a nonblocking connect */\n        ssh_poll_set_events(h, POLLOUT);\n#ifdef _WIN32\n        ssh_poll_add_events(h, POLLWRNORM);\n#endif\n    }\n    return SSH_OK;\n}\n",
      "line_start": 523,
      "line_end": 546,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/updater: it assigns a file descriptor and adjusts poll state/flags with minimal branching. No parsing of external complex input, no memory/-buffer operations, no loops or heavy logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_socket_fd_isset",
      "clean_name": "ssh_socket_fd_isset",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief returns nonzero if the current socket is in the fd_set\n */\nint ssh_socket_fd_isset(ssh_socket s, fd_set *set)\n{\n    if(s->fd == SSH_INVALID_SOCKET) {\n        return 0;\n    }\n    return FD_ISSET(s->fd,set);\n}\n",
      "line_start": 641,
      "line_end": 648,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/accessor: checks socket fd against SSH_INVALID_SOCKET then calls FD_ISSET. Minimal logic, no parsing or memory/buffer operations, low value as a fuzz target."
    },
    {
      "name": "ssh_socket_fd_set",
      "clean_name": "ssh_socket_fd_set",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n/** \\internal\n * \\brief sets the current fd in a fd_set and updates the max_fd\n */\n\nvoid ssh_socket_fd_set(ssh_socket s, fd_set *set, socket_t *max_fd)\n{\n    if (s->fd == SSH_INVALID_SOCKET) {\n        return;\n    }\n\n    FD_SET(s->fd,set);\n\n    if (s->fd >= 0 &&\n        s->fd >= *max_fd &&\n        s->fd != SSH_INVALID_SOCKET) {\n        *max_fd = s->fd + 1;\n    }\n}\n",
      "line_start": 653,
      "line_end": 667,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that sets an fd in an fd_set and updates max_fd; minimal branching and logic, no complex parsing or loops, no memory-manipulation on large/untrusted buffers or security-critical operations\u2014limited value as a fuzz target."
    },
    {
      "name": "ssh_socket_set_write_wontblock",
      "clean_name": "ssh_socket_set_write_wontblock",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n    /* all data written */\n    return SSH_OK;\n}\n\nvoid ssh_socket_set_write_wontblock(ssh_socket s)\n{\n    s->write_wontblock = 1;\n}\n",
      "line_start": 769,
      "line_end": 773,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: simply sets a flag on the provided ssh_socket. No parsing, no memory ops, no branching or loops, and no security-critical logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_socket_set_except",
      "clean_name": "ssh_socket_set_except",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "void ssh_socket_set_read_wontblock(ssh_socket s)\n{\n    s->read_wontblock = 1;\n}\n\nvoid ssh_socket_set_except(ssh_socket s)\n{\n    s->data_except = 1;\n}\n",
      "line_start": 779,
      "line_end": 783,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter functions that simply assign a field to 1. No parsing of external input, no branching, no memory operations or loops \u2014 minimal value as a fuzz target (low priority)."
    },
    {
      "name": "ssh_socket_buffered_write_bytes",
      "clean_name": "ssh_socket_buffered_write_bytes",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "/** @internal\n * @brief returns the number of outgoing bytes currently buffered\n * @param s the socket\n * @returns numbers of bytes buffered, or 0 if the socket isn't connected\n */\nint ssh_socket_buffered_write_bytes(ssh_socket s)\n{\n    if (s==NULL || s->out_buffer == NULL) {\n        return 0;\n    }\n\n    return ssh_buffer_get_len(s->out_buffer);\n}\n",
      "line_start": 799,
      "line_end": 807,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only null checks and a call to get buffer length. No parsing, no memory operations on untrusted data, and no input-dependent control flow \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_socket_get_status",
      "clean_name": "ssh_socket_get_status",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n    return ssh_buffer_get_len(s->out_buffer);\n}\n\n\nint ssh_socket_get_status(ssh_socket s)\n{\n    int r = 0;\n\n    if (ssh_buffer_get_len(s->in_buffer) > 0) {\n        r |= SSH_READ_PENDING;\n    }\n\n    if (ssh_buffer_get_len(s->out_buffer) > 0) {\n        r |= SSH_WRITE_PENDING;\n    }\n\n    if (s->data_except) {\n        r |= SSH_CLOSED_ERROR;\n    }\n\n    return r;\n}\n",
      "line_start": 809,
      "line_end": 827,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple status/accessor function: it just checks buffer lengths and a flag and returns bitflags. No parsing of external input, no memory operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_socket_get_poll_flags",
      "clean_name": "ssh_socket_get_poll_flags",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "    }\n\n    return r;\n}\n\nint ssh_socket_get_poll_flags(ssh_socket s)\n{\n    int r = 0;\n    if (s->poll_handle != NULL && (ssh_poll_get_events (s->poll_handle) & POLLIN) > 0) {\n        r |= SSH_READ_PENDING;\n    }\n    if (s->poll_handle != NULL && (ssh_poll_get_events (s->poll_handle) & POLLOUT) > 0) {\n        r |= SSH_WRITE_PENDING;\n    }\n    return r;\n}\n",
      "line_start": 828,
      "line_end": 839,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor-style function: checks poll_handle and maps poll events to flags. Minimal logic (two small conditionals), no parsing of external input, no memory copies or complex control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_socket_set_nonblocking",
      "clean_name": "ssh_socket_set_nonblocking",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "    u_long nonblocking = 0;\n    return ioctlsocket(fd, FIONBIO, &nonblocking);\n}\n\n#else /* _WIN32 */\nint ssh_socket_set_nonblocking(socket_t fd)\n{\n    return fcntl(fd, F_SETFL, O_NONBLOCK);\n}\n",
      "line_start": 854,
      "line_end": 858,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around an OS call to set a socket non-blocking. Minimal logic, no parsing or memory manipulation, no branching or complex input-dependent behavior \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_socket_set_blocking",
      "clean_name": "ssh_socket_set_blocking",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "int ssh_socket_set_nonblocking(socket_t fd)\n{\n    return fcntl(fd, F_SETFL, O_NONBLOCK);\n}\n\nint ssh_socket_set_blocking(socket_t fd)\n{\n    return fcntl(fd, F_SETFL, 0);\n}\n",
      "line_start": 859,
      "line_end": 863,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple thin wrapper around fcntl to set/clear O_NONBLOCK on a socket; no parsing, no control-flow, no memory operations or input-dependent loops. Minimal value as a fuzz target other than triggering system-call errors from bogus fds."
    },
    {
      "name": "ssh_socket_connect",
      "clean_name": "ssh_socket_connect",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": " * @param port port number to connect to.\n * @param bind_addr address to bind to, or NULL for default.\n * @returns SSH_OK socket is being connected.\n * @returns SSH_ERROR error while connecting to remote host.\n */\nint ssh_socket_connect(ssh_socket s,\n                       const char *host,\n                       uint16_t port,\n                       const char *bind_addr)\n{\n    socket_t fd;\n\n    if (s->state != SSH_SOCKET_NONE) {\n        ssh_set_error(s->session, SSH_FATAL,\n                      \"ssh_socket_connect called on socket not unconnected\");\n        return SSH_ERROR;\n    }\n    fd = ssh_connect_host_nonblocking(s->session, host, bind_addr, port);\n    SSH_LOG(SSH_LOG_DEBUG, \"Nonblocking connection socket: %d\", fd);\n    if (fd == SSH_INVALID_SOCKET) {\n        return SSH_ERROR;\n    }\n    return ssh_socket_set_fd(s, fd);\n}\n",
      "line_start": 877,
      "line_end": 896,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that performs a simple state check and delegates to ssh_connect_host_nonblocking and ssh_socket_set_fd. Minimal branching, no parsing or memory manipulation of untrusted data; real surface lies in the called functions, so this function itself is low-value as a fuzz target."
    },
    {
      "name": "socket.c:ssh_socket_unbuffered_read",
      "clean_name": "ssh_socket_unbuffered_read",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief read len bytes from socket into buffer\n */\nstatic ssize_t ssh_socket_unbuffered_read(ssh_socket s,\n                                          void *buffer,\n                                          uint32_t len)\n{\n    ssize_t rc = -1;\n\n    if (s->data_except) {\n        return -1;\n    }\n    if (s->fd_is_socket) {\n        rc = recv(s->fd, buffer, len, 0);\n    } else {\n        rc = read(s->fd, buffer, len);\n    }\n#ifdef _WIN32\n    s->last_errno = WSAGetLastError();\n#else\n    s->last_errno = errno;\n#endif\n    s->read_wontblock = 0;\n\n    if (rc < 0) {\n        s->data_except = 1;\n    } else {\n        SSH_LOG(SSH_LOG_TRACE, \"read %zd\", rc);\n    }\n\n    return rc;\n}\n",
      "line_start": 566,
      "line_end": 595,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper around read/recv: it simply forwards a length and buffer to OS read calls, sets errno and minor state flags. It does not parse or transform input, has minimal branching and no internal memory manipulation, so it is a low-priority fuzz target."
    },
    {
      "name": "socket.c:ssh_socket_unbuffered_write",
      "clean_name": "ssh_socket_unbuffered_write",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief writes len bytes from buffer to socket\n */\nstatic ssize_t ssh_socket_unbuffered_write(ssh_socket s,\n                                           const void *buffer,\n                                           uint32_t len)\n{\n    ssize_t w = -1;\n    int flags = 0;\n\n#ifdef MSG_NOSIGNAL\n    flags |= MSG_NOSIGNAL;\n#endif\n\n    if (s->data_except) {\n        return -1;\n    }\n\n    if (s->fd_is_socket) {\n        w = send(s->fd, buffer, len, flags);\n    } else {\n        w = write(s->fd, buffer, len);\n    }\n#ifdef _WIN32\n    s->last_errno = WSAGetLastError();\n#else\n    s->last_errno = errno;\n#endif\n    s->write_wontblock = 0;\n    /* Reactive the POLLOUT detector in the poll multiplexer system */\n    if (s->poll_handle) {\n        SSH_LOG(SSH_LOG_PACKET, \"Enabling POLLOUT for socket\");\n        ssh_poll_add_events(s->poll_handle, POLLOUT);\n    }\n    if (w < 0) {\n        s->data_except = 1;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"wrote %zd\", w);\n    return w;\n}\n",
      "line_start": 599,
      "line_end": 637,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "This is a thin wrapper around send/write with minimal branching and no parsing or manipulation of the input buffer. It accepts external data but does not perform complex validation, memory ops, or protocol parsing, so it is a low-value fuzz target on its own (useful only as an I/O sink in broader end-to-end tests)."
    },
    {
      "name": "socket.c:verify_knownhost",
      "clean_name": "verify_knownhost",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "#endif /* WITH_EXEC */\n\n#ifndef _WIN32\n#ifdef HAVE_PTHREAD\nstatic int\nverify_knownhost(ssh_session session)\n{\n    enum ssh_known_hosts_e state;\n\n    state = ssh_session_is_known_server(session);\n\n    switch (state) {\n    case SSH_KNOWN_HOSTS_OK:\n        break; /* ok */\n    default:\n        SSH_LOG(SSH_LOG_WARN, \"Couldn't verify knownhost during proxyjump.\");\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 1015,
      "line_end": 1031,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper: calls ssh_session_is_known_server and checks an enum. No parsing/memory operations, no loops or branching beyond a single switch. The real surface to fuzz is ssh_session_is_known_server/known_hosts parsing, not this function."
    },
    {
      "name": "ssh_threads_set_callbacks",
      "clean_name": "ssh_threads_set_callbacks",
      "source_file": "/src/libssh/src/threads.c",
      "source_code": "void ssh_threads_finalize(void)\n{\n    crypto_thread_finalize();\n}\n\nint ssh_threads_set_callbacks(struct ssh_threads_callbacks_struct *cb)\n{\n\n    int rc;\n\n    if (user_callbacks != NULL) {\n        crypto_thread_finalize();\n    }\n\n    user_callbacks = cb;\n\n    rc = crypto_thread_init(user_callbacks);\n\n    return rc;\n}\n",
      "line_start": 70,
      "line_end": 85,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper: assigns a callback pointer and calls crypto_thread_init/finalize. Minimal logic (one null check), no parsing of external input, no memory manipulation or complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_threads_get_type",
      "clean_name": "ssh_threads_get_type",
      "source_file": "/src/libssh/src/threads.c",
      "source_code": "    rc = crypto_thread_init(user_callbacks);\n\n    return rc;\n}\n\nconst char *ssh_threads_get_type(void)\n{\n    if (user_callbacks != NULL) {\n        return user_callbacks->type;\n    }\n    return NULL;\n}\n",
      "line_start": 86,
      "line_end": 93,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple getter: returns a field from a global struct or NULL. No parsing of external input, no memory operations, no loops or branching of security relevance \u2014 minimal value as a fuzz target."
    },
    {
      "name": "pthread.c:ssh_pthread_mutex_init",
      "clean_name": "ssh_pthread_mutex_init",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "\n#include <errno.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nstatic int ssh_pthread_mutex_init (void **mutex)\n{\n    int rc = 0;\n\n    if (mutex == NULL) {\n        return EINVAL;\n    }\n\n    *mutex = malloc(sizeof(pthread_mutex_t));\n    if (*mutex == NULL) {\n        return ENOMEM;\n    }\n\n    rc = pthread_mutex_init ((pthread_mutex_t *)*mutex, NULL);\n    if (rc){\n        free (*mutex);\n        *mutex = NULL;\n    }\n\n    return rc;\n}\n",
      "line_start": 29,
      "line_end": 50,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper that allocates and initializes a pthread_mutex_t. Minimal branching and no parsing or manipulation of attacker-controlled data (no buffer ops, no loops, no complex logic). Only failure modes are malloc or pthread_mutex_init errors \u2014 low value as a fuzz target."
    },
    {
      "name": "pthread.c:ssh_pthread_mutex_destroy",
      "clean_name": "ssh_pthread_mutex_destroy",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "    }\n\n    return rc;\n}\n\nstatic int ssh_pthread_mutex_destroy (void **mutex)\n{\n\n    int rc = 0;\n\n    if (mutex == NULL) {\n        return EINVAL;\n    }\n\n    rc = pthread_mutex_destroy ((pthread_mutex_t *)*mutex);\n\n    free (*mutex);\n    *mutex = NULL;\n\n    return rc;\n}\n",
      "line_start": 51,
      "line_end": 67,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper that destroys and frees a pthread mutex. Minimal logic (null check + pthread_mutex_destroy + free), no parsing of external input, no complex control flow or data transformations. Low-value fuzz target \u2014 only potential issues stem from misuse (invalid pointer/double-free), not from input-parsing vulnerabilities."
    },
    {
      "name": "pthread.c:ssh_pthread_mutex_lock",
      "clean_name": "ssh_pthread_mutex_lock",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "    *mutex = NULL;\n\n    return rc;\n}\n\nstatic int ssh_pthread_mutex_lock (void **mutex)\n{\n    return pthread_mutex_lock((pthread_mutex_t *)*mutex);\n}\n",
      "line_start": 68,
      "line_end": 72,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper around pthread_mutex_lock with no parsing, branching, or memory manipulation of untrusted data. Minimal logic (single cast and call), so low value as a fuzz target."
    },
    {
      "name": "pthread.c:ssh_pthread_mutex_unlock",
      "clean_name": "ssh_pthread_mutex_unlock",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "static int ssh_pthread_mutex_lock (void **mutex)\n{\n    return pthread_mutex_lock((pthread_mutex_t *)*mutex);\n}\n\nstatic int ssh_pthread_mutex_unlock (void **mutex)\n{\n    return pthread_mutex_unlock((pthread_mutex_t *)*mutex);\n}\n",
      "line_start": 73,
      "line_end": 77,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper around pthread_mutex_unlock with no input parsing or complex logic. Minimal value as a fuzz target \u2014 only a simple accessor-style function (though misuse with invalid pointers could crash, it lacks structured input or branching)."
    },
    {
      "name": "ssh_kdf",
      "clean_name": "ssh_kdf",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    }\n    return 0;\n}\n\n#else\nint ssh_kdf(struct ssh_crypto_struct *crypto,\n            unsigned char *key, size_t key_len,\n            uint8_t key_type, unsigned char *output,\n            size_t requested_len)\n{\n    return sshkdf_derive_key(crypto, key, key_len,\n                             key_type, output, requested_len);\n}\n",
      "line_start": 330,
      "line_end": 338,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that immediately delegates to sshkdf_derive_key; contains no parsing, branching, loops, or direct memory operations on input. Underlying sshkdf_derive_key is the appropriate fuzz target."
    },
    {
      "name": "hmac_update",
      "clean_name": "hmac_update",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "error:\n    EVP_MD_CTX_free(ctx);\n    return NULL;\n}\n\nint hmac_update(HMACCTX ctx, const void *data, size_t len)\n{\n    return EVP_DigestSignUpdate(ctx, data, len);\n}\n",
      "line_start": 385,
      "line_end": 389,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that simply forwards a data buffer to EVP_DigestSignUpdate; no parsing, branching, or validation logic here. It accepts untrusted input (so may exercise OpenSSL internals), but the function itself is trivial and low-value as a fuzz target."
    },
    {
      "name": "pki_key_ecgroup_name_to_nid",
      "clean_name": "pki_key_ecgroup_name_to_nid",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    }\n\n    return s;\n}\n\nint pki_key_ecgroup_name_to_nid(const char *group)\n{\n    if (strcmp(group, NISTP256) == 0 ||\n        strcmp(group, \"secp256r1\") == 0 ||\n        strcmp(group, \"prime256v1\") == 0) {\n        return NID_X9_62_prime256v1;\n    } else if (strcmp(group, NISTP384) == 0 ||\n               strcmp(group, \"secp384r1\") == 0) {\n        return NID_secp384r1;\n    } else if (strcmp(group, NISTP521) == 0 ||\n               strcmp(group, \"secp521r1\") == 0) {\n        return NID_secp521r1;\n    }\n    return -1;\n}\n",
      "line_start": 1633,
      "line_end": 1648,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 37,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple string-to-constant mapping with a few strcmp branches. Minimal logic and no complex parsing, memory manipulation, or loops; limited attack surface (aside from a possible NULL dereference if group is NULL), so low value as a fuzz target."
    },
    {
      "name": "libcrypto.c:none_crypt",
      "clean_name": "none_crypt",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "}\n#endif /* HAVE_OPENSSL_EVP_CHACHA20 */\n\n#ifdef WITH_INSECURE_NONE\nstatic void\nnone_crypt(UNUSED_PARAM(struct ssh_cipher_struct *cipher),\n           void *in,\n           void *out,\n           size_t len)\n{\n    memcpy(out, in, len);\n}\n",
      "line_start": 1194,
      "line_end": 1201,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper that just memcpy's len bytes from in to out. No parsing, branching, or validation \u2014 minimal logic makes it a low-value fuzz target (any memory-safety issues depend on callers, not this function)."
    },
    {
      "name": "ssh_bind_listen",
      "clean_name": "ssh_bind_listen",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "  }\n\n  return SSH_OK;\n}\n\nint ssh_bind_listen(ssh_bind sshbind) {\n    const char *host = NULL;\n    socket_t fd;\n    int rc;\n\n    /* Apply global bind configurations, if it hasn't been applied before */\n    rc = ssh_bind_options_parse_config(sshbind, NULL);\n    if (rc != 0) {\n        ssh_set_error(sshbind, SSH_FATAL,\"Could not parse global config\");\n        return SSH_ERROR;\n    }\n\n    /* Set default hostkey paths if no hostkey was found before */\n    if (sshbind->ecdsakey == NULL &&\n        sshbind->rsakey == NULL &&\n        sshbind->ed25519key == NULL) {\n\n        sshbind->ecdsakey = strdup(\"/etc/ssh/ssh_host_ecdsa_key\");\n        sshbind->rsakey = strdup(\"/etc/ssh/ssh_host_rsa_key\");\n        sshbind->ed25519key = strdup(\"/etc/ssh/ssh_host_ed25519_key\");\n    }\n\n    /* Apply global bind configurations, if it hasn't been applied before */\n    rc = ssh_bind_options_parse_config(sshbind, NULL);\n    if (rc != 0) {\n        ssh_set_error(sshbind, SSH_FATAL, \"Could not parse global config\");\n        return SSH_ERROR;\n    }\n\n    /* Set default hostkey paths if no hostkey was found before */\n    if (sshbind->ecdsakey == NULL &&\n        sshbind->rsakey == NULL &&\n        sshbind->ed25519key == NULL) {\n\n        sshbind->ecdsakey = strdup(\"/etc/ssh/ssh_host_ecdsa_key\");\n        sshbind->rsakey = strdup(\"/etc/ssh/ssh_host_rsa_key\");\n        sshbind->ed25519key = strdup(\"/etc/ssh/ssh_host_ed25519_key\");\n    }\n\n    if (sshbind->rsa == NULL &&\n        sshbind->ecdsa == NULL &&\n        sshbind->ed25519 == NULL) {\n        rc = ssh_bind_import_keys(sshbind);\n        if (rc != SSH_OK) {\n            return SSH_ERROR;\n        }\n    }\n\n    if (sshbind->bindfd == SSH_INVALID_SOCKET) {\n        host = sshbind->bindaddr;\n        if (host == NULL) {\n            host = \"0.0.0.0\";\n        }\n\n        fd = bind_socket(sshbind, host, sshbind->bindport);\n        if (fd == SSH_INVALID_SOCKET) {\n            return SSH_ERROR;\n        }\n\n        if (listen(fd, 10) < 0) {\n            char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n            ssh_set_error(sshbind,\n                          SSH_FATAL,\n                          \"Listening to socket %d: %s\",\n                          fd,\n                          ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n            CLOSE_SOCKET(fd);\n            return SSH_ERROR;\n        }\n\n        sshbind->bindfd = fd;\n  } else {\n      SSH_LOG(SSH_LOG_DEBUG, \"Using app-provided bind socket\");\n  }\n  return 0;\n}\n",
      "line_start": 220,
      "line_end": 296,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 129,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Mostly a setup/wrapper function that binds/listens on a socket and sets default paths. It has some branching and calls into other functions (e.g., import/parse config), but it does not itself parse complex external formats or perform memory operations on untrusted input. Environment/system calls and resource side-effects make it a poor direct fuzz target; fuzzing should focus on the deeper parsers it invokes."
    },
    {
      "name": "ssh_bind_set_callbacks",
      "clean_name": "ssh_bind_set_callbacks",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "      SSH_LOG(SSH_LOG_DEBUG, \"Using app-provided bind socket\");\n  }\n  return 0;\n}\n\nint ssh_bind_set_callbacks(ssh_bind sshbind, ssh_bind_callbacks callbacks, void *userdata)\n{\n    if (sshbind == NULL) {\n        return SSH_ERROR;\n    }\n    if (callbacks == NULL) {\n        ssh_set_error_invalid(sshbind);\n        return SSH_ERROR;\n    }\n    if (callbacks->size <= 0 || callbacks->size > 1024 * sizeof(void *)) {\n        ssh_set_error(sshbind,\n                      SSH_FATAL,\n                      \"Invalid callback passed in (badly initialized)\");\n        return SSH_ERROR;\n    }\n    sshbind->bind_callbacks = callbacks;\n    sshbind->bind_callbacks_userdata = userdata;\n    return 0;\n}\n",
      "line_start": 297,
      "line_end": 316,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter-style function: only null checks and a single bounds check on callbacks->size, then stores pointers. No parsing, memory operations, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_bind_get_poll",
      "clean_name": "ssh_bind_get_poll",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "/** @internal\n * @brief returns the current poll handle, or creates it\n * @param sshbind the ssh_bind object\n * @returns a ssh_poll handle suitable for operation\n */\nssh_poll_handle ssh_bind_get_poll(ssh_bind sshbind)\n{\n    short events = POLLIN;\n\n    if (sshbind->poll) {\n        return sshbind->poll;\n    }\n\n#ifdef POLLRDHUP\n    events |= POLLRDHUP;\n#endif /* POLLRDHUP */\n\n    sshbind->poll = ssh_poll_new(sshbind->bindfd,\n                                 events,\n                                 ssh_bind_poll_callback,\n                                 sshbind);\n\n    return sshbind->poll;\n}\n",
      "line_start": 342,
      "line_end": 361,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/initializer: returns cached poll handle or creates one with a small bitmask and a single branch. No parsing of external data, no buffer/memory ops on untrusted input, no loops or complex control flow, and minimal attack surface \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_bind_set_blocking",
      "clean_name": "ssh_bind_set_blocking",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "                                 sshbind);\n\n    return sshbind->poll;\n}\n\nvoid ssh_bind_set_blocking(ssh_bind sshbind, int blocking)\n{\n    sshbind->blocking = blocking ? 1 : 0;\n}\n",
      "line_start": 362,
      "line_end": 366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: simply stores a boolean value into sshbind->blocking. No parsing, no memory operations, no branching or loops on external data \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_bind_get_fd",
      "clean_name": "ssh_bind_get_fd",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "void ssh_bind_set_blocking(ssh_bind sshbind, int blocking)\n{\n    sshbind->blocking = blocking ? 1 : 0;\n}\n\nsocket_t ssh_bind_get_fd(ssh_bind sshbind)\n{\n    return sshbind->bindfd;\n}\n",
      "line_start": 367,
      "line_end": 371,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor that returns an internal file descriptor; no parsing, no memory operations, no branching or loops, and no direct processing of untrusted input \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_bind_set_fd",
      "clean_name": "ssh_bind_set_fd",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "socket_t ssh_bind_get_fd(ssh_bind sshbind)\n{\n    return sshbind->bindfd;\n}\n\nvoid ssh_bind_set_fd(ssh_bind sshbind, socket_t fd)\n{\n    sshbind->bindfd = fd;\n}\n",
      "line_start": 372,
      "line_end": 376,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter/getter: ssh_bind_set_fd simply assigns a socket value to a structure field with no parsing, memory manipulation, branching, or validation. Minimal value as a fuzz target (low priority)."
    },
    {
      "name": "ssh_bind_fd_toaccept",
      "clean_name": "ssh_bind_fd_toaccept",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "void ssh_bind_set_fd(ssh_bind sshbind, socket_t fd)\n{\n    sshbind->bindfd = fd;\n}\n\nvoid ssh_bind_fd_toaccept(ssh_bind sshbind)\n{\n    sshbind->toaccept = 1;\n}\n",
      "line_start": 377,
      "line_end": 381,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter(s) with minimal logic: just assign fields (sshbind->toaccept = 1 and set bindfd). No parsing of external data, no memory operations, no loops or branching \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_bind_free",
      "clean_name": "ssh_bind_free",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "void ssh_bind_fd_toaccept(ssh_bind sshbind)\n{\n    sshbind->toaccept = 1;\n}\n\nvoid ssh_bind_free(ssh_bind sshbind){\n  int i;\n\n  if (sshbind == NULL) {\n    return;\n  }\n\n  if (sshbind->bindfd >= 0) {\n      CLOSE_SOCKET(sshbind->bindfd);\n  }\n  sshbind->bindfd = SSH_INVALID_SOCKET;\n\n  /* options */\n  SAFE_FREE(sshbind->banner);\n  SAFE_FREE(sshbind->moduli_file);\n  SAFE_FREE(sshbind->bindaddr);\n  SAFE_FREE(sshbind->config_dir);\n  SAFE_FREE(sshbind->pubkey_accepted_key_types);\n\n  SAFE_FREE(sshbind->rsakey);\n  SAFE_FREE(sshbind->ecdsakey);\n  SAFE_FREE(sshbind->ed25519key);\n\n  ssh_key_free(sshbind->rsa);\n  sshbind->rsa = NULL;\n  ssh_key_free(sshbind->ecdsa);\n  sshbind->ecdsa = NULL;\n  ssh_key_free(sshbind->ed25519);\n  sshbind->ed25519 = NULL;\n\n  for (i = 0; i < SSH_KEX_METHODS; i++) {\n    if (sshbind->wanted_methods[i]) {\n      SAFE_FREE(sshbind->wanted_methods[i]);\n    }\n  }\n\n  SAFE_FREE(sshbind);\n}\n",
      "line_start": 382,
      "line_end": 420,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 123,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a cleanup/free function (destructor) with minimal logic: closes a socket, frees various fields and keys, and iterates a fixed-size array. It does not parse external input, has no input-dependent loops or complex branching, and offers limited surface for fuzzing (aside from misuse scenarios like double-free/UAF), so it is low priority as a fuzz target."
    },
    {
      "name": "ssh_bind_accept",
      "clean_name": "ssh_bind_accept",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "    /* force PRNG to change state in case we fork after ssh_bind_accept */\n    ssh_reseed();\n    return SSH_OK;\n}\n\nint ssh_bind_accept(ssh_bind sshbind, ssh_session session)\n{\n    socket_t fd = SSH_INVALID_SOCKET;\n    int rc;\n\n    if (sshbind->bindfd == SSH_INVALID_SOCKET) {\n        ssh_set_error(sshbind, SSH_FATAL,\n                      \"Can't accept new clients on a not bound socket.\");\n        return SSH_ERROR;\n    }\n\n    if (session == NULL) {\n        ssh_set_error(sshbind, SSH_FATAL, \"session is null\");\n        return SSH_ERROR;\n    }\n\n    fd = accept(sshbind->bindfd, NULL, NULL);\n    if (fd == SSH_INVALID_SOCKET) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        if (errno == EINTR) {\n            ssh_set_error(sshbind, SSH_EINTR,\n                          \"Accepting a new connection (child signal error): %s\",\n                          ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        } else {\n            ssh_set_error(sshbind, SSH_FATAL,\n                          \"Accepting a new connection: %s\",\n                          ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        }\n        return SSH_ERROR;\n    }\n    rc = ssh_bind_accept_fd(sshbind, session, fd);\n\n    if (rc == SSH_ERROR) {\n        CLOSE_SOCKET(fd);\n        ssh_socket_free(session->socket);\n    }\n\n    return rc;\n}\n",
      "line_start": 561,
      "line_end": 600,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 68,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around accept(2) that validates arguments and forwards the accepted fd to ssh_bind_accept_fd. No parsing of complex external data, no buffer/string/memory ops on untrusted input and very low cyclomatic complexity. The real attack surface is in ssh_bind_accept_fd; this function itself is low-value as a fuzz target."
    },
    {
      "name": "bind.c:ssh_bind_poll_callback",
      "clean_name": "ssh_bind_poll_callback",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "\n/** @internal\n * @brief callback being called by poll when an event happens\n *\n */\nstatic int ssh_bind_poll_callback(ssh_poll_handle sshpoll, socket_t fd, int revents, void *user)\n{\n    ssh_bind sshbind = (ssh_bind)user;\n    (void)sshpoll;\n    (void)fd;\n\n    if (revents & POLLIN) {\n        /* new incoming connection */\n        if (ssh_callbacks_exists(sshbind->bind_callbacks, incoming_connection)) {\n            sshbind->bind_callbacks->incoming_connection(sshbind,\n                                                         sshbind->bind_callbacks_userdata);\n        }\n    }\n    return 0;\n}\n",
      "line_start": 321,
      "line_end": 336,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple poll callback with a single conditional that forwards to a user-provided handler. No parsing of external input, no memory operations, no loops or complex branching \u2014 minimal surface for fuzzing beyond exercising the callback invocation."
    },
    {
      "name": "bind_config.c:ssh_bind_config_get_match_opcode",
      "clean_name": "ssh_bind_config_get_match_opcode",
      "source_file": "/src/libssh/src/bind_config.c",
      "source_code": "    globfree(&globbuf);\n}\n#endif /* HAVE_GLOB HAVE_GLOB_GL_FLAGS_MEMBER */\n\nstatic enum ssh_bind_config_match_e\nssh_bind_config_get_match_opcode(const char *keyword)\n{\n    size_t i;\n\n    for (i = 0; ssh_bind_config_match_keyword_table[i].name != NULL; i++) {\n        if (strcasecmp(keyword, ssh_bind_config_match_keyword_table[i].name) == 0) {\n            return ssh_bind_config_match_keyword_table[i].opcode;\n        }\n    }\n\n    return BIND_MATCH_UNKNOWN;\n}\n",
      "line_start": 270,
      "line_end": 282,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple keyword lookup: iterates a static table and calls strcasecmp on the input. Minimal logic and complexity, no memory-manipulating operations, no parsing/validation or security-critical behavior \u2014 low fuzzing value."
    },
    {
      "name": "ssh_packet_userauth_success",
      "clean_name": "ssh_packet_userauth_success",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @brief Handles a SSH_USERAUTH_SUCCESS packet.\n *\n * It is also used to communicate the new to the upper levels.\n */\nSSH_PACKET_CALLBACK(ssh_packet_userauth_success)\n{\n  struct ssh_crypto_struct *crypto = NULL;\n\n  (void)packet;\n  (void)type;\n  (void)user;\n\n  SSH_LOG(SSH_LOG_DEBUG, \"Authentication successful\");\n  SSH_LOG(SSH_LOG_TRACE, \"Received SSH_USERAUTH_SUCCESS\");\n\n  session->auth.state = SSH_AUTH_STATE_SUCCESS;\n  session->session_state = SSH_SESSION_STATE_AUTHENTICATED;\n  session->flags |= SSH_SESSION_FLAG_AUTHENTICATED;\n\n  crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n  if (crypto != NULL && crypto->delayed_compress_out) {\n      SSH_LOG(SSH_LOG_DEBUG, \"Enabling delayed compression OUT\");\n      crypto->do_compress_out = 1;\n  }\n\n  crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n  if (crypto != NULL && crypto->delayed_compress_in) {\n      SSH_LOG(SSH_LOG_DEBUG, \"Enabling delayed compression IN\");\n      crypto->do_compress_in = 1;\n  }\n\n    /* Reset errors by previous authentication methods. */\n    ssh_reset_error(session);\n    session->auth.current_method = SSH_AUTH_METHOD_UNKNOWN;\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 289,
      "line_end": 321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very low fuzz value: the handler performs simple state updates and flag toggles, uses no parsing or memory/IO operations on untrusted data, has minimal branching and no complex logic. It mainly flips internal session/crypto flags and resets error state, so it is not a promising fuzz target."
    },
    {
      "name": "ssh_userauth_list",
      "clean_name": "ssh_userauth_list",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *                      - SSH_AUTH_METHOD_INTERACTIVE\n *\n * @warning Other reserved flags may appear in future versions.\n * @see ssh_userauth_none()\n */\nint ssh_userauth_list(ssh_session session, const char *username)\n{\n    (void) username; /* unused */\n\n    if (session == NULL) {\n        return 0;\n    }\n\n    return session->auth.supported_methods;\n}\n",
      "line_start": 379,
      "line_end": 389,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns session->auth.supported_methods; username is unused and there is no parsing, memory manipulation, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_userauth_publickey_auto_get_current_identity",
      "clean_name": "ssh_userauth_publickey_auto_get_current_identity",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *                         your responsibility to free the memory using\n *                         ssh_string_free_char().\n *\n * @return  SSH_OK on success, SSH_ERROR on error.\n */\nint ssh_userauth_publickey_auto_get_current_identity(ssh_session session,\n                                                     char** value)\n{\n    const char *id = NULL;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (value == NULL) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n\n    if (session->auth.auto_state != NULL &&\n        session->auth.auto_state->it != NULL) {\n        id = session->auth.auto_state->it->data;\n    }\n\n    if (id == NULL) {\n        return SSH_ERROR;\n    }\n\n    *value = strdup(id);\n    if (*value == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 1309,
      "line_end": 1340,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter: minimal logic (null checks and a strdup), no parsing of complex external input, no loops or branching complexity, and only a trivial memory copy. Low value as a fuzz target."
    },
    {
      "name": "ssh_kbdint_clean",
      "clean_name": "ssh_kbdint_clean",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "    }\n\n    SAFE_FREE(kbd);\n}\n\nvoid ssh_kbdint_clean(ssh_kbdint kbd)\n{\n    size_t i, n;\n\n    if (kbd == NULL) {\n        return;\n    }\n\n    SAFE_FREE(kbd->name);\n    SAFE_FREE(kbd->instruction);\n    SAFE_FREE(kbd->echo);\n\n    n = kbd->nprompts;\n    if (kbd->prompts) {\n        for (i = 0; i < n; i++) {\n            explicit_bzero(kbd->prompts[i], strlen(kbd->prompts[i]));\n            SAFE_FREE(kbd->prompts[i]);\n        }\n        SAFE_FREE(kbd->prompts);\n    }\n\n    n = kbd->nanswers;\n\n    if (kbd->answers) {\n        for (i = 0; i < n; i++) {\n            explicit_bzero(kbd->answers[i], strlen(kbd->answers[i]));\n            SAFE_FREE(kbd->answers[i]);\n        }\n        SAFE_FREE(kbd->answers);\n    }\n\n    kbd->nprompts = 0;\n    kbd->nanswers = 0;\n}\n",
      "line_start": 1868,
      "line_end": 1902,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 83,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a cleanup/free function that zeroes and frees fields (name, prompts, answers). It contains simple loops and null checks but no parsing of external input, no complex branching or memory-manipulation logic on untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_userauth_kbdint_getname",
      "clean_name": "ssh_userauth_kbdint_getname",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @param[in]  session  The ssh session to use.\n *\n * @returns             The name of the message block. Do not free it.\n */\nconst char *ssh_userauth_kbdint_getname(ssh_session session)\n{\n    if (session == NULL) {\n        return NULL;\n    }\n    if (session->kbdint == NULL) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n    return session->kbdint->name;\n}\n",
      "line_start": 2213,
      "line_end": 2224,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple getter with null checks: returns session->kbdint->name, no parsing or memory operations on external input, minimal logic and no complex branches \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_userauth_kbdint_getinstruction",
      "clean_name": "ssh_userauth_kbdint_getinstruction",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @param[in]  session  The ssh session to use.\n *\n * @returns             The instruction of the message block.\n */\n\nconst char *ssh_userauth_kbdint_getinstruction(ssh_session session)\n{\n    if (session == NULL)\n        return NULL;\n    if (session->kbdint == NULL) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n    return session->kbdint->instruction;\n}\n",
      "line_start": 2237,
      "line_end": 2247,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only NULL checks and returns a pointer from session->kbdint. No parsing, no memory manipulation, no input-dependent control flow, minimal logic (low fuzz value)."
    },
    {
      "name": "ssh_userauth_kbdint_getnanswers",
      "clean_name": "ssh_userauth_kbdint_getnanswers",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @param[in]  session  The ssh session to use.\n *\n * @returns             The number of answers.\n */\nint ssh_userauth_kbdint_getnanswers(ssh_session session)\n{\n    if (session == NULL || session->kbdint == NULL) {\n        return SSH_ERROR;\n    }\n    return session->kbdint->nanswers;\n}\n",
      "line_start": 2302,
      "line_end": 2309,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only null checks and returning an integer field from session->kbdint; no parsing, memory ops, or complex control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_userauth_kbdint_getanswer",
      "clean_name": "ssh_userauth_kbdint_getanswer",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " * @param[in]  i index  The number of the ith answer.\n *\n * @return              The answer string, or NULL if the answer is not\n *                      available. Do not free the string.\n */\nconst char *ssh_userauth_kbdint_getanswer(ssh_session session, unsigned int i)\n{\n    if (session == NULL || session->kbdint == NULL\n            || session->kbdint->answers == NULL) {\n        return NULL;\n    }\n    if (i >= session->kbdint->nanswers) {\n        return NULL;\n    }\n\n    return session->kbdint->answers[i];\n}\n",
      "line_start": 2320,
      "line_end": 2332,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: performs basic NULL/bounds checks and returns a pointer from an internal array. No parsing, no memory operations on untrusted data, minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "auth.c:ssh_auth_get_current_method",
      "clean_name": "ssh_auth_get_current_method",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "        default:\n            return 1;\n    }\n}\n\nstatic const char *ssh_auth_get_current_method(ssh_session session)\n{\n    const char *method = \"unknown\";\n\n    switch (session->auth.current_method) {\n    case SSH_AUTH_METHOD_NONE:\n        method = \"none\";\n        break;\n    case SSH_AUTH_METHOD_PASSWORD:\n        method = \"password\";\n        break;\n    case SSH_AUTH_METHOD_PUBLICKEY:\n        method = \"publickey\";\n        break;\n    case SSH_AUTH_METHOD_HOSTBASED:\n        method = \"hostbased\";\n        break;\n    case SSH_AUTH_METHOD_INTERACTIVE:\n        method = \"keyboard interactive\";\n        break;\n    case SSH_AUTH_METHOD_GSSAPI_MIC:\n        method = \"gssapi\";\n        break;\n    default:\n        break;\n    }\n\n    return method;\n}\n",
      "line_start": 100,
      "line_end": 129,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple accessor that maps an internal enum to constant string literals. No parsing, memory copies, or complex logic. Low cyclomatic complexity and minimal attack surface (aside from a possible null-session dereference), so low priority for fuzzing."
    },
    {
      "name": "auth.c:ssh_userauth_request_service",
      "clean_name": "ssh_userauth_request_service",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @returns SSH_OK on success, SSH_ERROR on error.\n * @returns SSH_AGAIN on nonblocking mode, if calling that function\n * again is necessary\n */\nstatic int ssh_userauth_request_service(ssh_session session)\n{\n    int rc;\n\n    rc = ssh_service_request(session, \"ssh-userauth\");\n    if ((rc != SSH_OK) && (rc != SSH_AGAIN)) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to request \\\"ssh-userauth\\\" service\");\n    }\n\n    return rc;\n}\n",
      "line_start": 68,
      "line_end": 80,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper that calls ssh_service_request with a constant service name; no parsing of external data, no memory operations on untrusted input, and minimal branching/logic. Not a useful standalone fuzz target (any issues would be in ssh_service_request)."
    },
    {
      "name": "auth.c:ssh_auth_response_termination",
      "clean_name": "ssh_auth_response_termination",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "    }\n\n    return rc;\n}\n\nstatic int ssh_auth_response_termination(void *user)\n{\n    ssh_session session = (ssh_session)user;\n    switch (session->auth.state) {\n        case SSH_AUTH_STATE_NONE:\n        case SSH_AUTH_STATE_KBDINT_SENT:\n        case SSH_AUTH_STATE_GSSAPI_REQUEST_SENT:\n        case SSH_AUTH_STATE_GSSAPI_TOKEN:\n        case SSH_AUTH_STATE_GSSAPI_MIC_SENT:\n        case SSH_AUTH_STATE_PUBKEY_AUTH_SENT:\n        case SSH_AUTH_STATE_PUBKEY_OFFER_SENT:\n        case SSH_AUTH_STATE_PASSWORD_AUTH_SENT:\n        case SSH_AUTH_STATE_AUTH_NONE_SENT:\n            return 0;\n        default:\n            return 1;\n    }\n}\n",
      "line_start": 81,
      "line_end": 99,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple switch on an internal enum field with no parsing, memory operations, or loops. Minimal logic and few code paths\u2014low value as a fuzz target (aside from potential null/dereference issues, it does not process untrusted input)."
    },
    {
      "name": "ssh_buffer_set_secure",
      "clean_name": "ssh_buffer_set_secure",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * A secure buffer will never leave cleartext data in the heap\n * after being reallocated or freed.\n *\n * @param[in] buffer buffer to set secure.\n */\nvoid ssh_buffer_set_secure(ssh_buffer buffer)\n{\n    buffer->secure = true;\n}\n",
      "line_start": 176,
      "line_end": 180,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: only sets buffer->secure = true. No parsing, no branching, no loops, no memory operations on untrusted data beyond a simple write\u2014minimal value as a fuzz target."
    },
    {
      "name": "ssh_buffer_reinit",
      "clean_name": "ssh_buffer_reinit",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  buffer   The buffer to reinitialize.\n *\n * @return              0 on success, < 0 on error.\n */\nint ssh_buffer_reinit(struct ssh_buffer_struct *buffer)\n{\n    if (buffer == NULL) {\n        return -1;\n    }\n\n    buffer_verify(buffer);\n\n    if (buffer->secure && buffer->allocated > 0) {\n        explicit_bzero(buffer->data, buffer->allocated);\n    }\n    buffer->used = 0;\n    buffer->pos = 0;\n\n    /* If the buffer is bigger then 64K, reset it to 64K */\n    if (buffer->allocated > 65536) {\n        int rc;\n\n        /* -1 for realloc_buffer magic */\n        rc = realloc_buffer(buffer, 65536 - 1);\n        if (rc != 0) {\n            return -1;\n        }\n    }\n\n    buffer_verify(buffer);\n\n    return 0;\n}\n",
      "line_start": 259,
      "line_end": 288,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple buffer reinitialization helper: checks NULL, verifies buffer, zeroes memory if marked secure, resets fields and possibly shrinks large allocations. No parsing of external formats, no complex control flow or input-dependent loops \u2014 limited value as a standalone fuzz target."
    },
    {
      "name": "ssh_buffer_allocate_size",
      "clean_name": "ssh_buffer_allocate_size",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The length to ensure as allocated.\n *\n * @return              0 on success, < 0 on error.\n */\nint ssh_buffer_allocate_size(struct ssh_buffer_struct *buffer,\n                             uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (buffer->allocated < len) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, len) < 0) {\n            return -1;\n        }\n    }\n\n    buffer_verify(buffer);\n\n    return 0;\n}\n",
      "line_start": 340,
      "line_end": 358,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small wrapper that ensures buffer size: simple branching (one if), no parsing of complex external input, no loops, and no direct memory/string operations here. The real memory work happens in buffer_shift/realloc_buffer \u2014 this function itself is low-value as a fuzz target."
    },
    {
      "name": "ssh_buffer_add_u32",
      "clean_name": "ssh_buffer_add_u32",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     The 32 bits integer to add.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_add_u32(struct ssh_buffer_struct *buffer,uint32_t data)\n{\n    int rc;\n\n    rc = ssh_buffer_add_data(buffer, &data, sizeof(data));\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 442,
      "line_end": 453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards a 32-bit value into ssh_buffer_add_data. No parsing, no branching, no loops, and minimal logic \u2014 little direct attack surface. Any real fuzz value is in the underlying buffer API rather than this thin accessor."
    },
    {
      "name": "ssh_buffer_add_u16",
      "clean_name": "ssh_buffer_add_u16",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     The 16 bits integer to add.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_add_u16(struct ssh_buffer_struct *buffer,uint16_t data)\n{\n    int rc;\n\n    rc = ssh_buffer_add_data(buffer, &data, sizeof(data));\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 465,
      "line_end": 476,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that appends a fixed-size uint16_t to a buffer with no parsing, branching, or input-dependent lengths; minimal logic \u2014 any memory/bounds risk would be in ssh_buffer_add_data, not this function."
    },
    {
      "name": "ssh_buffer_add_u64",
      "clean_name": "ssh_buffer_add_u64",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     The 64 bits integer to add.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_add_u64(struct ssh_buffer_struct *buffer, uint64_t data)\n{\n    int rc;\n\n    rc = ssh_buffer_add_data(buffer, &data, sizeof(data));\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 488,
      "line_end": 499,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: copies a fixed 8-byte integer into the buffer and returns success/failure. No parsing, branching, or input-dependent bounds here. Better fuzz targets are the underlying ssh_buffer_add_data or callers that handle untrusted data."
    },
    {
      "name": "ssh_buffer_add_u8",
      "clean_name": "ssh_buffer_add_u8",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     The 8 bits integer to add.\n *\n * @return              0 on success, -1 on error.\n */\nint ssh_buffer_add_u8(struct ssh_buffer_struct *buffer,uint8_t data)\n{\n    int rc;\n\n    rc = ssh_buffer_add_data(buffer, &data, sizeof(uint8_t));\n    if (rc < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 511,
      "line_end": 522,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards a single uint8_t to ssh_buffer_add_data; no branching, no parsing, no loops, and minimal logic. Fuzzing value is low \u2014 target the underlying buffer_add_data implementation instead."
    },
    {
      "name": "ssh_buffer_get_len",
      "clean_name": "ssh_buffer_get_len",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @return              The length of the buffer.\n *\n * @see ssh_buffer_get()\n */\nuint32_t ssh_buffer_get_len(struct ssh_buffer_struct *buffer){\n  buffer_verify(buffer);\n  return buffer->used - buffer->pos;\n}\n",
      "line_start": 614,
      "line_end": 618,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: just verifies the buffer and returns used - pos. No parsing of external input, no memory manipulation, loops, or complex branching \u2014 low-value fuzz target (simple getter)."
    },
    {
      "name": "ssh_buffer_pass_bytes_end",
      "clean_name": "ssh_buffer_pass_bytes_end",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len      The number of bytes to remove from the tail.\n *\n * @return              The new size of the buffer.\n */\nuint32_t ssh_buffer_pass_bytes_end(struct ssh_buffer_struct *buffer, uint32_t len){\n  buffer_verify(buffer);\n\n  if (buffer->used < len) {\n      return 0;\n  }\n\n  buffer->used-=len;\n  buffer_verify(buffer);\n  return len;\n}\n",
      "line_start": 660,
      "line_end": 671,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial helper that only adjusts an internal 'used' counter with a simple bounds check; no parsing, no memory copies, no loops or complex branching. Low value as a fuzz target (minimal attack surface)."
    },
    {
      "name": "ssh_buffer_get_u8",
      "clean_name": "ssh_buffer_get_u8",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     A pointer to a uint8_t where to store the data.\n *\n * @returns             0 if there is not enough data in buffer, 1 otherwise.\n */\nuint32_t ssh_buffer_get_u8(struct ssh_buffer_struct *buffer, uint8_t *data){\n    return ssh_buffer_get_data(buffer,data,sizeof(uint8_t));\n}\n",
      "line_start": 712,
      "line_end": 715,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that just calls ssh_buffer_get_data to read a single byte. No parsing, branching, loops, or direct memory manipulation here \u2014 minimal complexity; fuzz higher-level/low-level parsing or buffer-handling functions instead."
    },
    {
      "name": "ssh_buffer_get_u32",
      "clean_name": "ssh_buffer_get_u32",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     A pointer to a uint32_t where to store the data.\n *\n * @returns             0 if there is not enough data in buffer, 4 otherwise.\n */\nuint32_t ssh_buffer_get_u32(struct ssh_buffer_struct *buffer, uint32_t *data){\n    return ssh_buffer_get_data(buffer,data,sizeof(uint32_t));\n}\n",
      "line_start": 727,
      "line_end": 730,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards to ssh_buffer_get_data to read 4 bytes; no parsing, branching, loops or direct memory logic here. The real risk/complexity lies in ssh_buffer_get_data, so this function itself is a low-priority fuzz target."
    },
    {
      "name": "ssh_buffer_get_u64",
      "clean_name": "ssh_buffer_get_u64",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  data     A pointer to a uint64_t where to store the data.\n *\n * @returns             0 if there is not enough data in buffer, 8 otherwise.\n */\nuint32_t ssh_buffer_get_u64(struct ssh_buffer_struct *buffer, uint64_t *data){\n    return ssh_buffer_get_data(buffer,data,sizeof(uint64_t));\n}\n",
      "line_start": 742,
      "line_end": 745,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper that simply calls ssh_buffer_get_data to copy a fixed 8 bytes into a uint64_t. It performs a basic memory read from a buffer but has no parsing, branching, or complex logic itself. The real risk/complexity lives in ssh_buffer_get_data; this function alone is a low-value fuzz target."
    },
    {
      "name": "ssh_buffer_validate_length",
      "clean_name": "ssh_buffer_validate_length",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @param[in]  len     The length to be checked.\n *\n * @return             SSH_OK if the length is valid, SSH_ERROR otherwise.\n */\nint ssh_buffer_validate_length(struct ssh_buffer_struct *buffer, size_t len)\n{\n    if (buffer == NULL || buffer->pos + len < len ||\n        buffer->pos + len > buffer->used) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 755,
      "line_end": 764,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple bounds/overflow validation helper: checks NULL, integer-wrap and pos+len <= used. Low cyclomatic complexity, no parsing, no memory ops, no loops or security-critical logic \u2014 low standalone value as a fuzz target."
    },
    {
      "name": "ssh_channel_from_local",
      "clean_name": "ssh_channel_from_local",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "\n    return err;\n}\n\n/* return channel with corresponding local id, or NULL if not found */\nssh_channel ssh_channel_from_local(ssh_session session, uint32_t id)\n{\n    struct ssh_iterator *it = NULL;\n    ssh_channel channel = NULL;\n\n    for (it = ssh_list_get_iterator(session->channels); it != NULL;\n         it = it->next) {\n        channel = ssh_iterator_value(ssh_channel, it);\n        if (channel == NULL) {\n            continue;\n        }\n        if (channel->local_channel == id) {\n            return channel;\n        }\n    }\n\n    return NULL;\n}\n",
      "line_start": 411,
      "line_end": 429,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple linear lookup: iterates session->channels and compares channel->local_channel to id. Low cyclomatic complexity, no parsing or memory operations on untrusted data, and minimal branching \u2014 limited value as a fuzz target."
    },
    {
      "name": "ssh_channel_open_session",
      "clean_name": "ssh_channel_open_session",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @see ssh_channel_open_forward()\n * @see ssh_channel_request_env()\n * @see ssh_channel_request_shell()\n * @see ssh_channel_request_exec()\n */\nint ssh_channel_open_session(ssh_channel channel)\n{\n  if (channel == NULL) {\n      return SSH_ERROR;\n  }\n\n  return channel_open(channel,\n                      \"session\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      NULL);\n}\n",
      "line_start": 1067,
      "line_end": 1079,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: only a NULL check and a forward call with constant parameters. No parsing, no loops, no buffer/memory ops or complex branching on external data. Low value as a standalone fuzz target (fuzz channel_open instead)."
    },
    {
      "name": "ssh_channel_open_auth_agent",
      "clean_name": "ssh_channel_open_auth_agent",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n *\n * @see ssh_channel_open_forward()\n */\nint ssh_channel_open_auth_agent(ssh_channel channel)\n{\n  if (channel == NULL) {\n      return SSH_ERROR;\n  }\n\n  return channel_open(channel,\n                      \"auth-agent@openssh.com\",\n                      WINDOW_DEFAULT,\n                      CHANNEL_MAX_PACKET,\n                      NULL);\n}\n",
      "line_start": 1095,
      "line_end": 1107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: only checks channel != NULL and calls channel_open with fixed arguments. No parsing of external input, no memory operations on untrusted data, and minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_channel_do_free",
      "clean_name": "ssh_channel_do_free",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "/**\n * @internal\n * @brief Effectively free a channel, without caring about flags\n */\n\nvoid ssh_channel_do_free(ssh_channel channel)\n{\n    struct ssh_iterator *it = NULL;\n    ssh_session session = channel->session;\n\n    it = ssh_list_find(session->channels, channel);\n    if (it != NULL) {\n        ssh_list_remove(session->channels, it);\n    }\n\n    SSH_BUFFER_FREE(channel->stdout_buffer);\n    SSH_BUFFER_FREE(channel->stderr_buffer);\n\n    if (channel->callbacks != NULL) {\n        ssh_list_free(channel->callbacks);\n        channel->callbacks = NULL;\n    }\n    SAFE_FREE(channel->exit.signal);\n\n    channel->session = NULL;\n    SAFE_FREE(channel);\n}\n",
      "line_start": 1327,
      "line_end": 1349,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is essentially a cleanup/free function with simple logic and no parsing of external input or complex control flow. It only removes an item from internal lists and frees buffers/structures, so it has low value as a fuzz target. (It could still be useful in harnesses aimed at finding memory-corruption issues like double-free/use-after-free, but the function itself is trivial.)"
    },
    {
      "name": "ssh_channel_send_eof",
      "clean_name": "ssh_channel_send_eof",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @see ssh_channel_close()\n * @see ssh_channel_free()\n * @see ssh_channel_is_eof()\n */\nint ssh_channel_send_eof(ssh_channel channel)\n{\n    ssh_session session = NULL;\n    int rc = SSH_ERROR;\n    int err;\n\n    if (channel == NULL || channel->session == NULL) {\n        return rc;\n    }\n\n    /* If the EOF has already been sent we're done here. */\n    if (channel->local_eof != 0) {\n        return SSH_OK;\n    }\n\n    session = channel->session;\n\n    err = ssh_buffer_pack(session->out_buffer,\n                          \"bd\",\n                          SSH2_MSG_CHANNEL_EOF,\n                          channel->remote_channel);\n    if (err != SSH_OK) {\n        ssh_set_error_oom(session);\n        goto error;\n    }\n\n    rc = ssh_packet_send(session);\n    SSH_LOG(SSH_LOG_PACKET,\n        \"Sent a EOF on client channel (%\" PRIu32 \":%\" PRIu32 \")\",\n        channel->local_channel,\n        channel->remote_channel);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    rc = ssh_channel_flush(channel);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    channel->local_eof = 1;\n\n    return rc;\nerror:\n    ssh_buffer_reinit(session->out_buffer);\n\n    return rc;\n}\n",
      "line_start": 1378,
      "line_end": 1425,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 70,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that constructs and sends a fixed EOF packet. Minimal branching, no parsing of complex external input or loops, and no direct memory operations on attacker-controlled data in this function itself. Low value as a fuzz target."
    },
    {
      "name": "ssh_channel_flush",
      "clean_name": "ssh_channel_flush",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @param channel SSH channel\n * @return  SSH_OK On success,\n *          SSH_ERROR On error.\n *          SSH_AGAIN Timeout elapsed (or in nonblocking mode).\n */\nint ssh_channel_flush(ssh_channel channel)\n{\n    return ssh_blocking_flush(channel->session, SSH_TIMEOUT_DEFAULT);\n}\n",
      "line_start": 1528,
      "line_end": 1532,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: simply forwards to ssh_blocking_flush(channel->session, ...). No parsing of external input, no branching or memory ops, minimal logic \u2014 low value as a fuzz target (wrapper/helper)."
    },
    {
      "name": "ssh_channel_window_size",
      "clean_name": "ssh_channel_window_size",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *          packet buffer, so beware of really big window sizes.\n *\n * @warning A zero return value means ssh_channel_write (default settings)\n *          will block until the window grows back.\n */\nuint32_t ssh_channel_window_size(ssh_channel channel)\n{\n    return channel->remote_window;\n}\n",
      "line_start": 1703,
      "line_end": 1707,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor that returns channel->remote_window. No parsing, memory operations, or branching on external input \u2014 minimal value as a fuzz target (simple getter)."
    },
    {
      "name": "ssh_channel_write",
      "clean_name": "ssh_channel_write",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @return              The number of bytes written, SSH_ERROR on error.\n *\n * @see ssh_channel_read()\n */\nint ssh_channel_write(ssh_channel channel, const void *data, uint32_t len)\n{\n    return channel_write_common(channel, data, len, 0);\n}\n",
      "line_start": 1721,
      "line_end": 1725,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards to channel_write_common; contains no parsing, branching, or memory manipulation itself \u2014 the real fuzz target is channel_write_common."
    },
    {
      "name": "ssh_channel_is_open",
      "clean_name": "ssh_channel_is_open",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @return              0 if channel is closed, nonzero otherwise.\n *\n * @see ssh_channel_is_closed()\n */\nint ssh_channel_is_open(ssh_channel channel)\n{\n    if (channel == NULL) {\n        return 0;\n    }\n    return (channel->state == SSH_CHANNEL_STATE_OPEN && channel->session->alive != 0);\n}\n",
      "line_start": 1735,
      "line_end": 1742,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that checks channel and returns state/session->alive; minimal logic, no parsing or memory operations. Low fuzz value (only tiny branching and a potential session NULL deref edge case)."
    },
    {
      "name": "ssh_channel_is_eof",
      "clean_name": "ssh_channel_is_eof",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  channel  The channel to check.\n *\n * @return              0 if there is no EOF, nonzero otherwise.\n */\nint ssh_channel_is_eof(ssh_channel channel)\n{\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n    if (ssh_channel_has_unread_data(channel)) {\n        return 0;\n    }\n\n    return (channel->remote_eof != 0);\n}\n",
      "line_start": 1767,
      "line_end": 1778,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only a NULL check, one helper call and a simple flag test. No parsing of external data, no memory ops or complex branching, so low value as a fuzz target (simple logic/helper-level)."
    },
    {
      "name": "ssh_channel_set_blocking",
      "clean_name": "ssh_channel_set_blocking",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @warning    A side-effect of this is to put the whole session\n *             in non-blocking mode.\n * @see ssh_set_blocking()\n */\nvoid ssh_channel_set_blocking(ssh_channel channel, int blocking)\n{\n    if (channel == NULL) {\n        return;\n    }\n    ssh_set_blocking(channel->session, blocking);\n}\n",
      "line_start": 1790,
      "line_end": 1797,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: null-check and forward call to ssh_set_blocking; no parsing, memory ops, or input-dependent branching. Minimal fuzz value despite causing a session-mode side-effect."
    },
    {
      "name": "ssh_packet_channel_success",
      "clean_name": "ssh_packet_channel_success",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "/**\n * @internal\n *\n * @brief handle a SSH_CHANNEL_SUCCESS packet and set the channel state.\n */\nSSH_PACKET_CALLBACK(ssh_packet_channel_success)\n{\n    ssh_channel channel = NULL;\n    (void)type;\n    (void)user;\n\n    channel = channel_from_msg(session, packet);\n    if (channel == NULL) {\n        SSH_LOG(SSH_LOG_FUNCTIONS, \"%s\", ssh_get_error(session));\n        return SSH_PACKET_USED;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET,\n            \"Received SSH_CHANNEL_SUCCESS on channel (%\" PRIu32 \":%\" PRIu32 \")\",\n            channel->local_channel,\n            channel->remote_channel);\n    if (channel->request_state != SSH_CHANNEL_REQ_STATE_PENDING) {\n        SSH_LOG(SSH_LOG_RARE,\n                \"SSH_CHANNEL_SUCCESS received in incorrect state %d\",\n                channel->request_state);\n    } else {\n        channel->request_state = SSH_CHANNEL_REQ_STATE_ACCEPTED;\n\n        ssh_callbacks_execute_list(channel->callbacks,\n                                   ssh_channel_callbacks,\n                                   channel_request_response_function,\n                                   channel->session,\n                                   channel);\n    }\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 1803,
      "line_end": 1835,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 45,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small handler with minimal logic: it only looks up a channel, checks a state, sets a state, logs, and invokes callbacks. It does not parse complex external input, perform memory operations on untrusted data, or contain significant branching/loops \u2014 low value as a standalone fuzz target."
    },
    {
      "name": "ssh_channel_request_pty_size",
      "clean_name": "ssh_channel_request_pty_size",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    SSH_BUFFER_FREE(buffer);\n\n    return rc;\n}\n\nint ssh_channel_request_pty_size(ssh_channel channel, const char *terminal,\n    int col, int row)\n{\n    /* use modes from the current TTY */\n    unsigned char modes_buf[SSH_TTY_MODES_MAX_BUFSIZE];\n    int rc = encode_current_tty_opts(modes_buf, sizeof(modes_buf));\n    if (rc < 0) {\n        return rc;\n    }\n    return ssh_channel_request_pty_size_modes(channel,\n                                              terminal,\n                                              col,\n                                              row,\n                                              modes_buf,\n                                              (size_t)rc);\n}\n",
      "line_start": 2043,
      "line_end": 2059,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: collects local TTY modes into a fixed-size stack buffer and forwards to ssh_channel_request_pty_size_modes. No parsing of external input, no complex branching or loops here \u2014 low value as a direct fuzz target (real work lives in the called functions)."
    },
    {
      "name": "ssh_channel_request_pty",
      "clean_name": "ssh_channel_request_pty",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n *\n * @see ssh_channel_request_pty_size()\n */\nint ssh_channel_request_pty(ssh_channel channel)\n{\n  return ssh_channel_request_pty_size(channel, \"xterm\", 80, 24);\n}\n",
      "line_start": 2072,
      "line_end": 2076,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards to ssh_channel_request_pty_size with hardcoded arguments. Minimal logic, no parsing of external data, no memory manipulation or branching\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_channel_change_pty_size",
      "clean_name": "ssh_channel_change_pty_size",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @warning Do not call it from a signal handler if you are not sure any other\n *          libssh function using the same channel/session is running at the\n *          same time (not 100% threadsafe).\n */\nint ssh_channel_change_pty_size(ssh_channel channel, int cols, int rows)\n{\n  ssh_session session = channel->session;\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer,\n                       \"dddd\",\n                       cols,\n                       rows,\n                       0, /* pix */\n                       0 /* pix */);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(session);\n    goto error;\n  }\n\n  rc = channel_request(channel, \"window-change\", buffer, 0);\nerror:\n  SSH_BUFFER_FREE(buffer);\n\n  return rc;\n}\n",
      "line_start": 2092,
      "line_end": 2121,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Small wrapper: allocates a buffer, packs four integers (cols, rows, two zeros) and calls channel_request. Minimal branching, no parsing of complex external formats, no loops or heavy memory-manipulation on untrusted blobs \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_channel_request_shell",
      "clean_name": "ssh_channel_request_shell",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return              SSH_OK on success,\n *                      SSH_ERROR if an error occurred,\n *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n */\nint ssh_channel_request_shell(ssh_channel channel)\n{\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n\n    return channel_request(channel, \"shell\", NULL, 1);\n}\n",
      "line_start": 2132,
      "line_end": 2140,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: only a NULL check and a call to channel_request with constant arguments. No parsing, memory operations, loops, or branching on external input \u2014 low-value fuzz target (the underlying channel_request may be more interesting)."
    },
    {
      "name": "ssh_channel_request_sftp",
      "clean_name": "ssh_channel_request_sftp",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      SSH_AGAIN if in nonblocking mode and call has\n *                      to be done again.\n *\n * @note You should use sftp_new() which does this for you.\n */\nint ssh_channel_request_sftp( ssh_channel channel)\n{\n    if(channel == NULL) {\n        return SSH_ERROR;\n    }\n    return ssh_channel_request_subsystem(channel, \"sftp\");\n}\n",
      "line_start": 2205,
      "line_end": 2212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: only checks channel for NULL and delegates to ssh_channel_request_subsystem with constant \"sftp\". No parsing, memory operations, loops, or branching\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_channel_accept_x11",
      "clean_name": "ssh_channel_accept_x11",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @param[in]  timeout_ms Timeout in milliseconds.\n *\n * @return              A newly created channel, or NULL if no X11 request from\n *                      the server.\n */\nssh_channel ssh_channel_accept_x11(ssh_channel channel, int timeout_ms)\n{\n    return ssh_channel_accept(channel->session, SSH_CHANNEL_X11, timeout_ms, NULL, NULL, NULL);\n}\n",
      "line_start": 2383,
      "line_end": 2387,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards to ssh_channel_accept with no parsing, memory operations, loops, or branching. Minimal logic and no direct handling of untrusted input; low value as a standalone fuzz target (value depends on the callee)."
    },
    {
      "name": "ssh_channel_request_auth_agent",
      "clean_name": "ssh_channel_request_auth_agent",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  channel  The channel to send signal.\n *\n * @return              SSH_OK on success, SSH_ERROR if an error occurred\n */\nint ssh_channel_request_auth_agent(ssh_channel channel) {\n  if (channel == NULL) {\n    return SSH_ERROR;\n  }\n\n  return channel_request(channel, \"auth-agent-req@openssh.com\", NULL, 0);\n}\n",
      "line_start": 2399,
      "line_end": 2406,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that only null-checks the channel and forwards a constant request string (no parsing, no buffer/memory ops, minimal logic), so low value as a fuzz target."
    },
    {
      "name": "ssh_request_denied",
      "clean_name": "ssh_request_denied",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @internal\n *\n * @brief Handle a SSH_REQUEST_DENIED packet normally sent after a global\n * request.\n */\nSSH_PACKET_CALLBACK(ssh_request_denied){\n  (void)type;\n  (void)user;\n  (void)packet;\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received SSH_REQUEST_FAILURE\");\n  if(session->global_req_state != SSH_CHANNEL_REQ_STATE_PENDING){\n    SSH_LOG(SSH_LOG_RARE, \"SSH_REQUEST_DENIED received in incorrect state %d\",\n        session->global_req_state);\n  } else {\n    session->global_req_state=SSH_CHANNEL_REQ_STATE_DENIED;\n  }\n\n  return SSH_PACKET_USED;\n\n}\n",
      "line_start": 2436,
      "line_end": 2453,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very simple packet handler: ignores packet/user input, only logs and flips an internal state. No parsing, memory ops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_forward_listen",
      "clean_name": "ssh_forward_listen",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n\n/* DEPRECATED */\nint ssh_forward_listen(ssh_session session, const char *address, int port, int *bound_port)\n{\n  return ssh_channel_listen_forward(session, address, port, bound_port);\n}\n",
      "line_start": 2634,
      "line_end": 2638,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial deprecated wrapper that just forwards arguments to ssh_channel_listen_forward; no parsing, branching, or memory ops here. Low-value fuzz target \u2014 fuzz the underlying implementation instead."
    },
    {
      "name": "ssh_forward_accept",
      "clean_name": "ssh_forward_accept",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "{\n  return ssh_channel_listen_forward(session, address, port, bound_port);\n}\n\n/* DEPRECATED */\nssh_channel ssh_forward_accept(ssh_session session, int timeout_ms)\n{\n    return ssh_channel_accept(session, SSH_CHANNEL_FORWARDED_TCPIP, timeout_ms, NULL, NULL, NULL);\n}\n",
      "line_start": 2640,
      "line_end": 2644,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Deprecated thin wrapper around ssh_channel_accept with no parsing, memory operations, or branching \u2014 minimal logic and not a valuable standalone fuzz target."
    },
    {
      "name": "ssh_channel_accept_forward",
      "clean_name": "ssh_channel_accept_forward",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @param[in]  destination_port A pointer to destination port or NULL.\n *\n * @return Newly created channel, or NULL if no incoming channel request from\n *         the server\n */\nssh_channel ssh_channel_accept_forward(ssh_session session, int timeout_ms, int* destination_port) {\n  return ssh_channel_accept(session, SSH_CHANNEL_FORWARDED_TCPIP, timeout_ms, destination_port, NULL, NULL);\n}\n",
      "line_start": 2658,
      "line_end": 2661,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that simply forwards parameters to ssh_channel_accept with a fixed channel type. No parsing, memory operations, or branching here \u2014 minimal logic and low value as a direct fuzz target (wrapper around a likely more interesting target)."
    },
    {
      "name": "ssh_channel_open_forward_port",
      "clean_name": "ssh_channel_open_forward_port",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @return Newly created channel, or NULL if no incoming channel request from\n *         the server\n *\n * @see ssh_string_free_char()\n */\nssh_channel ssh_channel_open_forward_port(ssh_session session, int timeout_ms, int *destination_port, char **originator, int *originator_port) {\n  return ssh_channel_accept(session, SSH_CHANNEL_FORWARDED_TCPIP, timeout_ms, destination_port, originator, originator_port);\n}\n",
      "line_start": 2682,
      "line_end": 2685,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that just forwards parameters to ssh_channel_accept; contains no parsing, memory manipulation, branching, or validation logic itself. The real fuzzing interest is in ssh_channel_accept, not this function."
    },
    {
      "name": "ssh_forward_cancel",
      "clean_name": "ssh_forward_cancel",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n\n/* DEPRECATED */\nint ssh_forward_cancel(ssh_session session, const char *address, int port)\n{\n    return ssh_channel_cancel_forward(session, address, port);\n}\n",
      "line_start": 2733,
      "line_end": 2737,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial deprecated wrapper that just forwards to ssh_channel_cancel_forward; no parsing, no memory ops, no branching or validation\u2014minimal fuzzing value on its own."
    },
    {
      "name": "ssh_channel_request_send_break",
      "clean_name": "ssh_channel_request_send_break",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  length   The break-length in milliseconds to send.\n *\n * @return              SSH_OK on success, SSH_ERROR if an error occurred\n */\nint ssh_channel_request_send_break(ssh_channel channel, uint32_t length)\n{\n    ssh_buffer buffer = NULL;\n    int rc = SSH_ERROR;\n\n    if (channel == NULL) {\n        return SSH_ERROR;\n    }\n\n    buffer = ssh_buffer_new();\n    if (buffer == NULL) {\n        ssh_set_error_oom(channel->session);\n        goto error;\n    }\n\n    rc = ssh_buffer_pack(buffer, \"d\", length);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(channel->session);\n        goto error;\n    }\n\n    rc = channel_request(channel, \"break\", buffer, 0);\n\nerror:\n    SSH_BUFFER_FREE(buffer);\n    return rc;\n}\n",
      "line_start": 2941,
      "line_end": 2968,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: packs a single uint32 length into a buffer and forwards to channel_request. Low cyclomatic complexity, no parsing of complex external formats or byte buffers, no loops or risky memory manipulation in this function itself; limited value as a direct fuzz target."
    },
    {
      "name": "ssh_channel_read",
      "clean_name": "ssh_channel_read",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *                      timeout and SSH_ERROR on error.\n *\n * @warning This function may return less than count bytes of data, and won't\n *          block until count bytes have been read.\n */\nint ssh_channel_read(ssh_channel channel, void *dest, uint32_t count, int is_stderr)\n{\n    return ssh_channel_read_timeout(channel,\n                                    dest,\n                                    count,\n                                    is_stderr,\n                                    SSH_TIMEOUT_DEFAULT);\n}\n",
      "line_start": 3092,
      "line_end": 3100,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards to ssh_channel_read_timeout with a default timeout; contains no parsing, branching, or memory operations itself. The real fuzzing value is in the underlying ssh_channel_read_timeout implementation."
    },
    {
      "name": "ssh_channel_get_exit_status",
      "clean_name": "ssh_channel_get_exit_status",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * exit status.\n *\n * @see ssh_channel_exit_status_callback\n * @deprecated Please use ssh_channel_exit_state()\n */\nint ssh_channel_get_exit_status(ssh_channel channel)\n{\n    uint32_t exit_status = (uint32_t)-1;\n    int rc;\n\n    rc = ssh_channel_get_exit_state(channel, &exit_status, NULL, NULL);\n    if (rc != SSH_OK) {\n        return SSH_ERROR;\n    }\n\n    return exit_status;\n}\n",
      "line_start": 3524,
      "line_end": 3536,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: calls ssh_channel_get_exit_state and returns status or error. Minimal logic (single error check), no parsing of external data, no memory operations or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_channel_write_stderr",
      "clean_name": "ssh_channel_write_stderr",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @return              The number of bytes written, SSH_ERROR on error.\n *\n * @see ssh_channel_read()\n */\nint ssh_channel_write_stderr(ssh_channel channel, const void *data, uint32_t len)\n{\n    return channel_write_common(channel, data, len, 1);\n}\n",
      "line_start": 3806,
      "line_end": 3810,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that immediately forwards parameters to channel_write_common; contains no parsing, branching, memory manipulation, or validation logic itself. The underlying channel_write_common is the real fuzzing target."
    },
    {
      "name": "ssh_channel_request_send_exit_status",
      "clean_name": "ssh_channel_request_send_exit_status",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  exit_status  The exit status to send\n *\n * @return     SSH_OK on success, SSH_ERROR if an error occurred.\n */\nint ssh_channel_request_send_exit_status(ssh_channel channel, int exit_status)\n{\n  ssh_buffer buffer = NULL;\n  int rc = SSH_ERROR;\n\n  if(channel == NULL) {\n      return SSH_ERROR;\n  }\n\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = ssh_buffer_pack(buffer, \"d\", exit_status);\n  if (rc != SSH_OK) {\n    ssh_set_error_oom(channel->session);\n    goto error;\n  }\n\n  rc = channel_request(channel, \"exit-status\", buffer, 0);\nerror:\n  SSH_BUFFER_FREE(buffer);\n  return rc;\n}\n",
      "line_start": 3956,
      "line_end": 3982,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 55,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that packs an integer into a buffer and calls channel_request. Minimal logic, no parsing of complex external input, no loops or branching dependent on untrusted data, and only trivial memory allocation \u2014 low value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_has_unread_data",
      "clean_name": "ssh_channel_has_unread_data",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "                               channel);\n\n    return SSH_PACKET_USED;\n}\n\nstatic bool ssh_channel_has_unread_data(ssh_channel channel)\n{\n    if (channel == NULL) {\n        return false;\n    }\n\n    if ((channel->stdout_buffer &&\n         ssh_buffer_get_len(channel->stdout_buffer) > 0) ||\n        (channel->stderr_buffer &&\n         ssh_buffer_get_len(channel->stderr_buffer) > 0))\n    {\n        return true;\n    }\n\n    return false;\n}\n",
      "line_start": 738,
      "line_end": 754,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper/accessor: null-checks a channel and tests buffer lengths. No parsing, no memory operations on untrusted data, trivial control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_open_termination",
      "clean_name": "ssh_channel_open_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "error:\n  ssh_set_error(session, SSH_FATAL, \"Invalid packet\");\n  return SSH_PACKET_USED;\n}\n\nstatic int ssh_channel_open_termination(void *c)\n{\n  ssh_channel channel = (ssh_channel) c;\n  if (channel->state != SSH_CHANNEL_STATE_OPENING ||\n      channel->session->session_state == SSH_SESSION_STATE_ERROR)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 295,
      "line_end": 304,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple state-check helper that inspects channel/session state and returns a boolean. No parsing of external input, no memory operations or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_waitsession_unblocked",
      "clean_name": "ssh_waitsession_unblocked",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "}\n\n/* This termination function waits until the session is not in blocked status\n * anymore, e.g. because of a key re-exchange.\n */\nstatic int ssh_waitsession_unblocked(void *s)\n{\n    ssh_session session = (ssh_session)s;\n    switch (session->session_state){\n        case SSH_SESSION_STATE_DH:\n        case SSH_SESSION_STATE_INITIAL_KEX:\n        case SSH_SESSION_STATE_KEXINIT_RECEIVED:\n            return 0;\n        default:\n            return 1;\n    }\n}\n",
      "line_start": 1507,
      "line_end": 1519,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial helper that only reads an enum field and returns 0/1 via a simple switch. No parsing, memory operations, loops, or security-critical logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_waitwindow_termination",
      "clean_name": "ssh_channel_waitwindow_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "\n    return rc;\n}\n\n/* this termination function waits for a window growing condition */\nstatic int ssh_channel_waitwindow_termination(void *c)\n{\n  ssh_channel channel = (ssh_channel) c;\n  if (channel->remote_window > 0 ||\n      channel->session->session_state == SSH_SESSION_STATE_ERROR ||\n      channel->state == SSH_CHANNEL_STATE_CLOSED)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 1493,
      "line_end": 1503,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple termination predicate: just reads a few channel/session fields and returns a boolean. No parsing, no memory ops, no loops or complex branching. Low fuzz value (simple accessor-style logic)."
    },
    {
      "name": "channels.c:ssh_channel_request_termination",
      "clean_name": "ssh_channel_request_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "    }\n\n    return SSH_PACKET_USED;\n}\n\nstatic int ssh_channel_request_termination(void *c)\n{\n  ssh_channel channel = (ssh_channel)c;\n  if(channel->request_state != SSH_CHANNEL_REQ_STATE_PENDING ||\n      channel->session->session_state == SSH_SESSION_STATE_ERROR)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 1875,
      "line_end": 1884,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small accessor-like function: it only checks two struct fields and returns a boolean. No parsing, no loops, no memory/string operations, and minimal branching \u2014 low value as a fuzz target (aside from catching trivial null/invalid-pointer issues)."
    },
    {
      "name": "channels.c:ssh_global_request_termination",
      "clean_name": "ssh_global_request_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "\n  return SSH_PACKET_USED;\n\n}\n\nstatic int ssh_global_request_termination(void *s)\n{\n  ssh_session session = (ssh_session) s;\n  if (session->global_req_state != SSH_CHANNEL_REQ_STATE_PENDING ||\n      session->session_state == SSH_SESSION_STATE_ERROR)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 2454,
      "line_end": 2463,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial predicate helper that only reads two session state fields and returns a boolean. No parsing, memory manipulation, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_read_termination",
      "clean_name": "ssh_channel_read_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "struct ssh_channel_read_termination_struct {\n  ssh_channel channel;\n  ssh_buffer buffer;\n};\n\nstatic int ssh_channel_read_termination(void *s)\n{\n  struct ssh_channel_read_termination_struct *ctx = s;\n  if (ssh_buffer_get_len(ctx->buffer) >= 1 ||\n      ctx->channel->remote_eof ||\n      ctx->channel->session->session_state == SSH_SESSION_STATE_ERROR)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 3064,
      "line_end": 3074,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial predicate over state: only checks buffer length and flags. No parsing, no memory ops, no loops or complex branching. Minimal value as a fuzz target."
    },
    {
      "name": "channels.c:ssh_channel_exit_status_termination",
      "clean_name": "ssh_channel_exit_status_termination",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "  }\n\n  return channel->session;\n}\n\nstatic int ssh_channel_exit_status_termination(void *c)\n{\n    ssh_channel channel = c;\n    if (channel->exit.status ||\n        /* When a channel is closed, no exit status message can\n         * come anymore */\n        (channel->flags & SSH_CHANNEL_FLAG_CLOSED_REMOTE) ||\n        channel->session->session_state == SSH_SESSION_STATE_ERROR)\n    {\n        return 1;\n    }\n    return 0;\n}\n",
      "line_start": 3414,
      "line_end": 3427,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple predicate/helper that checks channel->exit.status, a CLOSED_REMOTE flag, and session_state. No parsing of external input, no memory operations, no loops, and very low complexity \u2014 limited value as a standalone fuzz target."
    },
    {
      "name": "channels.c:count_ptrs",
      "clean_name": "count_ptrs",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "\n    return 0;\n}\n\n/* Just count number of pointers in the array */\nstatic size_t count_ptrs(ssh_channel *ptrs)\n{\n  size_t c;\n  for (c = 0; ptrs[c] != NULL; c++)\n    ;\n\n  return c;\n}\n",
      "line_start": 3602,
      "line_end": 3610,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial helper that counts NULL-terminated pointers. No parsing, no memory writes, minimal branching or complexity. Limited value as a fuzz target (only potential crash if given a non-terminated/invalid pointer array)."
    },
    {
      "name": "ssh_get_issue_banner",
      "clean_name": "ssh_get_issue_banner",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " *\n * @param[in]  session  The SSH session to use.\n *\n * @return A newly allocated string with the banner, NULL on error.\n */\nchar *ssh_get_issue_banner(ssh_session session)\n{\n    if (session == NULL || session->banner == NULL) {\n        return NULL;\n    }\n\n    return ssh_string_to_char(session->banner);\n}\n",
      "line_start": 691,
      "line_end": 699,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: performs two null checks and delegates to ssh_string_to_char. No parsing, no loops, no memory-manipulation logic here \u2014 minimal fuzzing value (low priority)."
    },
    {
      "name": "ssh_get_openssh_version",
      "clean_name": "ssh_get_openssh_version",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * if (openssh == SSH_INT_VERSION(6, 1, 0)) {\n *     printf(\"Version match!\\m\");\n * }\n * @endcode\n */\nint ssh_get_openssh_version(ssh_session session)\n{\n    if (session == NULL) {\n        return 0;\n    }\n\n    return session->openssh;\n}\n",
      "line_start": 718,
      "line_end": 726,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: returns session->openssh with a NULL check. No parsing of external input, no memory ops, no loops or branching on untrusted data \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_request_no_more_sessions",
      "clean_name": "ssh_request_no_more_sessions",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " *\n * @returns             SSH_OK on success, SSH_ERROR on error.\n * @returns             SSH_AGAIN, if the session is in nonblocking mode,\n *                      and call must be done again.\n */\nint ssh_request_no_more_sessions(ssh_session session)\n{\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    return ssh_global_request(session, \"no-more-sessions@openssh.com\", NULL, 1);\n}\n",
      "line_start": 739,
      "line_end": 747,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that only null-checks the session and delegates to ssh_global_request with fixed parameters. No parsing of external input, no memory operations or input-dependent control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_session_set_disconnect_message",
      "clean_name": "ssh_session_set_disconnect_message",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * @param  message      The message to send after the session is disconnected.\n *                      If no message is passed then a default message i.e\n *                      \"Bye Bye\" will be sent.\n */\nint\nssh_session_set_disconnect_message(ssh_session session, const char *message)\n{\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (message == NULL || strlen(message) == 0) {\n        SAFE_FREE(session->disconnect_message);  //To free any message set earlier.\n        session->disconnect_message = strdup(\"Bye Bye\") ;\n        if (session->disconnect_message == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n        return SSH_OK;\n    }\n    SAFE_FREE(session->disconnect_message);  //To free any message set earlier.\n    session->disconnect_message = strdup(message);\n    if (session->disconnect_message == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 757,
      "line_end": 780,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 60,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that frees/strdups a provided C string. It performs basic string ops (strlen/strdup) on external input but has minimal branching or parsing and no complex memory manipulations or protocol parsing \u2014 low value as a fuzz target beyond trivial string-length/allocator issues."
    },
    {
      "name": "client.c:ssh_service_request_termination",
      "clean_name": "ssh_service_request_termination",
      "source_file": "/src/libssh/src/client.c",
      "source_code": "    }\n\n    return rc;\n}\n\nstatic int ssh_service_request_termination(void *s)\n{\n    ssh_session session = (ssh_session)s;\n\n    if (session->session_state == SSH_SESSION_STATE_ERROR ||\n        session->auth.service_state != SSH_AUTH_SERVICE_SENT)\n        return 1;\n    else\n        return 0;\n}\n",
      "line_start": 322,
      "line_end": 332,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial predicate: casts a session pointer and returns a boolean based on two field checks. No parsing, memory ops, loops, or complex branching; minimal attack surface and low value as a fuzz target."
    },
    {
      "name": "client.c:socket_callback_connected",
      "clean_name": "socket_callback_connected",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " * connection error. Changes the state of the session and updates the error\n * message.\n * @param code one of SSH_SOCKET_CONNECTED_OK or SSH_SOCKET_CONNECTED_ERROR\n * @param user is a pointer to session\n */\nstatic void socket_callback_connected(int code, int errno_code, void *user)\n{\n\tssh_session session=(ssh_session)user;\n\n\tif (session->session_state != SSH_SESSION_STATE_CONNECTING &&\n\t    session->session_state != SSH_SESSION_STATE_SOCKET_CONNECTED)\n\t{\n\t\tssh_set_error(session,SSH_FATAL, \"Wrong state in socket_callback_connected : %d\",\n\t\t\t\tsession->session_state);\n\n\t\treturn;\n\t}\n\n\tSSH_LOG(SSH_LOG_TRACE,\"Socket connection callback: %d (%d)\",code, errno_code);\n\tif(code == SSH_SOCKET_CONNECTED_OK)\n\t\tsession->session_state=SSH_SESSION_STATE_SOCKET_CONNECTED;\n\telse {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\t\tsession->session_state=SSH_SESSION_STATE_ERROR;\n\t\tssh_set_error(session,SSH_FATAL,\"%s\",\n                      ssh_strerror(errno_code, err_msg, SSH_ERRNO_MSG_MAX));\n\t}\n\tsession->ssh_connection_callback(session);\n}\n",
      "line_start": 68,
      "line_end": 92,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "This function is a thin session-state/update callback with simple branching based on two integers and a fixed-size error buffer. It does not parse complex external formats, perform unbounded memory ops, or contain loops/complex control flow. The only non-trivial actions are calling ssh_strerror and invoking a session callback (those are better fuzz targets), so this function itself provides low fuzzing value."
    },
    {
      "name": "client.c:ssh_connect_termination",
      "clean_name": "ssh_connect_termination",
      "source_file": "/src/libssh/src/client.c",
      "source_code": "}\n\n/** @internal\n * @brief describe under which conditions the ssh_connect function may stop\n */\nstatic int ssh_connect_termination(void *user)\n{\n    ssh_session session = (ssh_session)user;\n\n    switch (session->session_state) {\n    case SSH_SESSION_STATE_ERROR:\n    case SSH_SESSION_STATE_AUTHENTICATING:\n    case SSH_SESSION_STATE_DISCONNECTED:\n        return 1;\n    default:\n        return 0;\n    }\n}\n",
      "line_start": 510,
      "line_end": 523,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very simple accessor/termination check: casts a session pointer and tests session_state against three enum values, returning 1/0. No parsing, no memory ops, no loops or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "connect.c:set_tcp_nodelay",
      "clean_name": "set_tcp_nodelay",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": "    }\n\n    return getaddrinfo(host, service, &hints, ai);\n}\n\nstatic int set_tcp_nodelay(socket_t socket)\n{\n    int opt = 1;\n\n    return setsockopt(socket,\n                      IPPROTO_TCP,\n                      TCP_NODELAY,\n                      (void *)&opt,\n                      sizeof(opt));\n}\n",
      "line_start": 142,
      "line_end": 152,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper around setsockopt that simply sets TCP_NODELAY on a given socket. No parsing of external data, no branching or loops, no memory manipulation \u2014 minimal value as a fuzz target aside from invoking a syscall on a provided fd."
    },
    {
      "name": "ssh_connector_new",
      "clean_name": "ssh_connector_new",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "static ssize_t ssh_connector_fd_write(ssh_connector connector,\n                                      const void *buffer,\n                                      uint32_t len);\nstatic bool ssh_connector_fd_is_socket(socket_t socket);\n\nssh_connector ssh_connector_new(ssh_session session)\n{\n    ssh_connector connector;\n\n    connector = calloc(1, sizeof(struct ssh_connector_struct));\n    if (connector == NULL){\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n\n    connector->session = session;\n    connector->in_fd = SSH_INVALID_SOCKET;\n    connector->out_fd = SSH_INVALID_SOCKET;\n\n    connector->fd_is_socket = false;\n\n    ssh_callbacks_init(&connector->in_channel_cb);\n    ssh_callbacks_init(&connector->out_channel_cb);\n\n    connector->in_channel_cb.userdata = connector;\n    connector->in_channel_cb.channel_data_function = ssh_connector_channel_data_cb;\n\n    connector->out_channel_cb.userdata = connector;\n    connector->out_channel_cb.channel_write_wontblock_function =\n            ssh_connector_channel_write_wontblock_cb;\n\n    return connector;\n}\n",
      "line_start": 85,
      "line_end": 113,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple constructor/initializer: allocates and zeroes a struct, sets fields and callback pointers. No parsing of external data, no input-dependent branching/loops, and no memory ops on untrusted input\u2014low fuzzing value."
    },
    {
      "name": "ssh_connector_set_in_channel",
      "clean_name": "ssh_connector_set_in_channel",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    }\n\n    free(connector);\n}\n\nint ssh_connector_set_in_channel(ssh_connector connector,\n                                  ssh_channel channel,\n                                  enum ssh_connector_flags_e flags)\n{\n    connector->in_channel = channel;\n    connector->in_fd = SSH_INVALID_SOCKET;\n    connector->in_flags = flags;\n\n    /* Fallback to default value for invalid flags */\n    if (!(flags & SSH_CONNECTOR_STDOUT) && !(flags & SSH_CONNECTOR_STDERR)) {\n        connector->in_flags = SSH_CONNECTOR_STDOUT;\n    }\n\n    return ssh_add_channel_callbacks(channel, &connector->in_channel_cb);\n}\n",
      "line_start": 142,
      "line_end": 157,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter function: assigns struct fields, performs a trivial bitmask fallback, and forwards to ssh_add_channel_callbacks. No parsing of external input, no buffer/memory operations, no complex branching or loops \u2014 low value as a standalone fuzz target."
    },
    {
      "name": "ssh_connector_set_out_channel",
      "clean_name": "ssh_connector_set_out_channel",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    }\n\n    return ssh_add_channel_callbacks(channel, &connector->in_channel_cb);\n}\n\nint ssh_connector_set_out_channel(ssh_connector connector,\n                                  ssh_channel channel,\n                                  enum ssh_connector_flags_e flags)\n{\n    connector->out_channel = channel;\n    connector->out_fd = SSH_INVALID_SOCKET;\n    connector->out_flags = flags;\n\n    /* Fallback to default value for invalid flags */\n    if (!(flags & SSH_CONNECTOR_STDOUT) && !(flags & SSH_CONNECTOR_STDERR)) {\n        connector->in_flags = SSH_CONNECTOR_STDOUT;\n    }\n\n    return ssh_add_channel_callbacks(channel, &connector->out_channel_cb);\n}\n",
      "line_start": 158,
      "line_end": 173,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is effectively a simple setter/wrapper: it assigns fields and does a trivial flags fallback then delegates to ssh_add_channel_callbacks. It contains no parsing of external input, no loops, no memory-copy/string operations, and minimal branching. (There is a likely minor logic bug resetting in_flags instead of out_flags, but the function remains low-complexity and low-value as a fuzz target.)"
    },
    {
      "name": "ssh_connector_set_in_fd",
      "clean_name": "ssh_connector_set_in_fd",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    }\n\n    return ssh_add_channel_callbacks(channel, &connector->out_channel_cb);\n}\n\nvoid ssh_connector_set_in_fd(ssh_connector connector, socket_t fd)\n{\n    connector->in_fd = fd;\n    connector->fd_is_socket = ssh_connector_fd_is_socket(fd);\n    connector->in_channel = NULL;\n}\n",
      "line_start": 174,
      "line_end": 180,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: stores fd, calls a small predicate (ssh_connector_fd_is_socket) and clears a pointer. No parsing, memory manipulation, loops, or security-critical logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_connector_set_out_fd",
      "clean_name": "ssh_connector_set_out_fd",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    connector->in_fd = fd;\n    connector->fd_is_socket = ssh_connector_fd_is_socket(fd);\n    connector->in_channel = NULL;\n}\n\nvoid ssh_connector_set_out_fd(ssh_connector connector, socket_t fd)\n{\n    connector->out_fd = fd;\n    connector->fd_is_socket = ssh_connector_fd_is_socket(fd);\n    connector->out_channel = NULL;\n}\n",
      "line_start": 181,
      "line_end": 187,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: assigns fd, updates a flag via ssh_connector_fd_is_socket and clears a pointer. No parsing, memory manipulation, loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_connector_remove_event",
      "clean_name": "ssh_connector_remove_event",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "\nerror:\n    return rc;\n}\n\nint ssh_connector_remove_event(ssh_connector connector)\n{\n    ssh_session session = NULL;\n\n    if (connector->in_poll != NULL) {\n        ssh_event_remove_poll(connector->event, connector->in_poll);\n        ssh_poll_free(connector->in_poll);\n        connector->in_poll = NULL;\n    }\n\n    if (connector->out_poll != NULL) {\n        ssh_event_remove_poll(connector->event, connector->out_poll);\n        ssh_poll_free(connector->out_poll);\n        connector->out_poll = NULL;\n    }\n\n    if (connector->in_channel != NULL) {\n        session = ssh_channel_get_session(connector->in_channel);\n\n        ssh_event_remove_session(connector->event, session);\n    }\n\n    if (connector->out_channel != NULL) {\n        session = ssh_channel_get_session(connector->out_channel);\n\n        ssh_event_remove_session(connector->event, session);\n    }\n    connector->event = NULL;\n\n    return SSH_OK;\n}\n",
      "line_start": 632,
      "line_end": 663,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Low fuzz value: this is a cleanup/remove function with simple null checks and calls to other APIs. It does not parse or process external input, perform buffer/memory ops on untrusted data, or contain complex branching; only minimal control flow and pointer manipulation."
    },
    {
      "name": "connector.c:ssh_connector_reset_pollevents",
      "clean_name": "ssh_connector_reset_pollevents",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "/**\n * @internal\n *\n * @brief Reset the poll events to be followed for each file descriptor.\n */\nstatic void ssh_connector_reset_pollevents(ssh_connector connector)\n{\n    if (connector->in_fd != SSH_INVALID_SOCKET) {\n        if (connector->in_available) {\n            ssh_poll_remove_events(connector->in_poll, POLLIN);\n        } else {\n            ssh_poll_add_events(connector->in_poll, POLLIN);\n        }\n    }\n\n    if (connector->out_fd != SSH_INVALID_SOCKET) {\n        if (connector->out_wontblock) {\n            ssh_poll_remove_events(connector->out_poll, POLLOUT);\n        } else {\n            ssh_poll_add_events(connector->out_poll, POLLOUT);\n        }\n    }\n}\n",
      "line_start": 208,
      "line_end": 226,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that toggles poll events based on connector state; no parsing of external input, no memory operations, minimal branching and not security-critical \u2014 limited value as a fuzz target."
    },
    {
      "name": "connector.c:ssh_connector_fd_cb",
      "clean_name": "ssh_connector_fd_cb",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " *\n * @param[in] userdata connector\n *\n * @returns 0\n */\nstatic int ssh_connector_fd_cb(ssh_poll_handle p,\n                               socket_t fd,\n                               int revents,\n                               void *userdata)\n{\n    ssh_connector connector = userdata;\n\n    (void)p;\n\n    if (revents & POLLERR) {\n        ssh_connector_except(connector, fd);\n    } else if((revents & (POLLIN|POLLHUP)) && fd == connector->in_fd) {\n        ssh_connector_fd_in_cb(connector);\n    } else if(((revents & POLLOUT) || (revents & POLLHUP)) &&\n              fd == connector->out_fd) {\n        ssh_connector_fd_out_cb(connector);\n    }\n    ssh_connector_reset_pollevents(connector);\n\n    return 0;\n}\n",
      "line_start": 384,
      "line_end": 405,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple event-dispatch wrapper: minimal branching and no parsing or memory operations on external data. It primarily routes poll events to other handlers (which might be fuzz-worthy), but this callback itself is low-value as a fuzz target."
    },
    {
      "name": "connector.c:ssh_connector_fd_is_socket",
      "clean_name": "ssh_connector_fd_is_socket",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": " * @internal\n *\n * @brief Check the file descriptor to check if it is a Windows socket handle.\n *\n */\nstatic bool ssh_connector_fd_is_socket(socket_t s)\n{\n#ifdef _WIN32\n    struct sockaddr_storage ss;\n    int len = sizeof(struct sockaddr_storage);\n    int rc;\n\n    rc = getsockname(s, (struct sockaddr *)&ss, &len);\n    if (rc == 0) {\n        return true;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Error %i in getsockname() for fd %d\",\n            WSAGetLastError(),\n            s);\n\n    return false;\n#else\n    struct stat sb;\n    int rc;\n\n    rc = fstat(s, &sb);\n    if (rc != 0) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"error %i in fstat() for fd %d\",\n                errno,\n                s);\n        return false;\n    }\n\n    /* The descriptor is a socket */\n    if (S_ISSOCK(sb.st_mode)) {\n          return true;\n    }\n\n    return false;\n#endif /* _WIN32 */\n}\n",
      "line_start": 670,
      "line_end": 709,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that only checks a file descriptor via getsockname/fstat. It has minimal branching, no parsing of complex external input, no buffer/memory operations, and little attack surface for fuzzing beyond supplying different ints, so low priority as a fuzz target."
    },
    {
      "name": "ssh_curve25519_create_k",
      "clean_name": "ssh_curve25519_create_k",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "    .n_callbacks = 1,\n    .callbacks = dh_client_callbacks,\n    .user = NULL,\n};\n\nint ssh_curve25519_create_k(ssh_session session, ssh_curve25519_pubkey k)\n{\n    int rc;\n\n#ifdef DEBUG_CRYPTO\n    ssh_log_hexdump(\"Session server cookie\",\n                    session->next_crypto->server_kex.cookie,\n                    16);\n    ssh_log_hexdump(\"Session client cookie\",\n                    session->next_crypto->client_kex.cookie,\n                    16);\n#endif\n\n    rc = curve25519_do_create_k(session, k);\n    return rc;\n}\n",
      "line_start": 50,
      "line_end": 66,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper that simply calls curve25519_do_create_k (with optional debug hexdumps). It contains no parsing, branching, or memory manipulation of external input itself; security-critical work likely occurs in the callee, so this function alone is a low-value fuzz target."
    },
    {
      "name": "ssh_client_curve25519_init",
      "clean_name": "ssh_client_curve25519_init",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "}\n\n/** @internal\n * @brief Starts curve25519-sha256@libssh.org / curve25519-sha256 key exchange\n */\nint ssh_client_curve25519_init(ssh_session session)\n{\n    int rc;\n\n    rc = ssh_curve25519_init(session);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bdP\",\n                         SSH2_MSG_KEX_ECDH_INIT,\n                         CURVE25519_PUBKEY_SIZE,\n                         (size_t)CURVE25519_PUBKEY_SIZE,\n                         session->next_crypto->curve25519_client_pubkey);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_curve25519_client_callbacks);\n    session->dh_handshake_state = DH_STATE_INIT_SENT;\n    rc = ssh_packet_send(session);\n\n    return rc;\n}\n",
      "line_start": 70,
      "line_end": 97,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that initializes Curve25519 state, packs a client public-key packet and sends it. Minimal branching/complexity, no parsing of external/untrusted input or loop bounds; while it touches crypto, it does not process input data\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_client_curve25519_remove_callbacks",
      "clean_name": "ssh_client_curve25519_remove_callbacks",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "    rc = ssh_packet_send(session);\n\n    return rc;\n}\n\nvoid ssh_client_curve25519_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_curve25519_client_callbacks);\n}\n",
      "line_start": 98,
      "line_end": 102,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that calls ssh_packet_remove_callbacks; no parsing of external input, no memory/string operations, no complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_server_curve25519_init",
      "clean_name": "ssh_server_curve25519_init",
      "source_file": "/src/libssh/src/curve25519.c",
      "source_code": "};\n\n/** @internal\n * @brief sets up the curve25519-sha256@libssh.org kex callbacks\n */\nvoid ssh_server_curve25519_init(ssh_session session)\n{\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_curve25519_server_callbacks);\n}\n",
      "line_start": 218,
      "line_end": 223,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial initializer/wrapper that registers static callbacks; no parsing of external input, no memory operations or branching. Low-value fuzz target."
    },
    {
      "name": "ssh_client_sntrup761x25519_remove_callbacks",
      "clean_name": "ssh_client_sntrup761x25519_remove_callbacks",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "    rc = ssh_packet_send(session);\n\n    return rc;\n}\n\nvoid ssh_client_sntrup761x25519_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_sntrup761x25519_client_callbacks);\n}\n",
      "line_start": 141,
      "line_end": 145,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that removes callbacks from a session. No parsing, no memory operations on untrusted data, no loops or branching \u2014 minimal logic and low value as a fuzz target (simple API call dependent only on the session handle)."
    },
    {
      "name": "ssh_server_sntrup761x25519_init",
      "clean_name": "ssh_server_sntrup761x25519_init",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "};\n\n/** @internal\n * @brief sets up the sntrup761x25519-sha512@openssh.com kex callbacks\n */\nvoid ssh_server_sntrup761x25519_init(ssh_session session)\n{\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_sntrup761x25519_server_callbacks);\n}\n",
      "line_start": 337,
      "line_end": 342,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple initialization wrapper that only registers packet callbacks; no parsing of external input, no memory manipulation, no branching or loops\u2014minimal fuzzing value."
    },
    {
      "name": "sntrup761.c:crypto_random",
      "clean_name": "crypto_random",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "{\n    sha512(in, inlen, out);\n}\n\n#ifndef HAVE_LIBGCRYPT\nstatic void crypto_random(void *ctx, size_t length, uint8_t *dst)\n{\n    int *err = ctx;\n    *err = ssh_get_random(dst, length, 1);\n}\n",
      "line_start": 47,
      "line_end": 52,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small wrapper around ssh_get_random that only forwards a length and destination pointer and stores an error code via ctx. It does not parse complex input, perform buffer manipulation itself, or contain branching/validation logic \u2014 minimal fuzzing value (low priority)."
    },
    {
      "name": "ssh_dh_import_next_pubkey_blob",
      "clean_name": "ssh_dh_import_next_pubkey_blob",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "    bignum_safe_free(ssh_dh_group18);\n\n    dh_crypto_initialized = 0;\n}\n\nint ssh_dh_import_next_pubkey_blob(ssh_session session, ssh_string pubkey_blob)\n{\n    return ssh_pki_import_pubkey_blob(pubkey_blob,\n                                      &session->next_crypto->server_pubkey);\n\n}\n",
      "line_start": 288,
      "line_end": 294,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that just forwards pubkey_blob to ssh_pki_import_pubkey_blob and writes into session->next_crypto->server_pubkey. It contains no parsing, branching, or memory operations itself \u2014 the real surface worth fuzzing is the underlying import function."
    },
    {
      "name": "ssh_client_dh_remove_callbacks",
      "clean_name": "ssh_client_dh_remove_callbacks",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "#endif\n  ssh_dh_cleanup(crypto);\n  return SSH_ERROR;\n}\n\nvoid ssh_client_dh_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_dh_client_callbacks);\n}\n",
      "line_start": 356,
      "line_end": 360,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that calls ssh_packet_remove_callbacks with no parsing, memory operations, or branching. Minimal logic and limited exposure to untrusted input, low value as a fuzz target."
    },
    {
      "name": "ssh_server_dh_init",
      "clean_name": "ssh_server_dh_init",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "};\n\n/** @internal\n * @brief sets up the diffie-hellman-groupx kex callbacks\n */\nvoid ssh_server_dh_init(ssh_session session){\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_dh_server_callbacks);\n\n    ssh_dh_init_common(session->next_crypto);\n}\n",
      "line_start": 430,
      "line_end": 436,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple initializer/wrapper that registers callbacks and calls a common DH init. It does not parse external input, perform memory operations, or contain branching logic. The real fuzzing value lies in the callbacks or ssh_dh_init_common, not this function."
    },
    {
      "name": "ssh_dh_get_current_server_publickey",
      "clean_name": "ssh_dh_get_current_server_publickey",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "\n    SSH_LOG(SSH_LOG_TRACE, \"The received primes in FIPS are known\");\n    return true;\n}\n\nssh_key ssh_dh_get_current_server_publickey(ssh_session session)\n{\n    if (session->current_crypto == NULL) {\n        return NULL;\n    }\n\n    return session->current_crypto->server_pubkey;\n}\n",
      "line_start": 651,
      "line_end": 659,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks session->current_crypto and returns server_pubkey. No parsing, no memory operations, no branching or loops over untrusted data. Low value as a fuzz target (aside from trivial NULL-dereference if caller passes a NULL session)."
    },
    {
      "name": "ssh_dh_get_current_server_publickey_blob",
      "clean_name": "ssh_dh_get_current_server_publickey_blob",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "\n    return session->current_crypto->server_pubkey;\n}\n\n/* Caller needs to free the blob */\nint ssh_dh_get_current_server_publickey_blob(ssh_session session,\n                                     ssh_string *pubkey_blob)\n{\n    const ssh_key pubkey = ssh_dh_get_current_server_publickey(session);\n\n    return ssh_pki_export_pubkey_blob(pubkey, pubkey_blob);\n}\n",
      "line_start": 661,
      "line_end": 668,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper that retrieves a server public key and calls ssh_pki_export_pubkey_blob; it contains no parsing, loops, or memory-manipulating logic itself. The real complexity and risk would be in the underlying export/parsing code, so this function is a low-priority fuzz target."
    },
    {
      "name": "ssh_dh_get_next_server_publickey_blob",
      "clean_name": "ssh_dh_get_next_server_publickey_blob",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "{\n    return session->next_crypto->server_pubkey;\n}\n\n/* Caller needs to free the blob */\nint ssh_dh_get_next_server_publickey_blob(ssh_session session,\n                                          ssh_string *pubkey_blob)\n{\n    const ssh_key pubkey = ssh_dh_get_next_server_publickey(session);\n\n    return ssh_pki_export_pubkey_blob(pubkey, pubkey_blob);\n}\n",
      "line_start": 675,
      "line_end": 682,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: retrieves a stored key and delegates to ssh_pki_export_pubkey_blob. No parsing, no loops, minimal logic or branching; while it touches crypto objects, it does not process external input or perform memory ops itself, so low fuzzing priority."
    },
    {
      "name": "ssh_print_hash",
      "clean_name": "ssh_print_hash",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": " * @param  len          Length of the buffer to convert.\n *\n * @see ssh_get_publickey_hash()\n * @see ssh_get_fingerprint_hash()\n */\nvoid ssh_print_hash(enum ssh_publickey_hash_type type,\n                    unsigned char *hash,\n                    size_t len)\n{\n    char *fingerprint = NULL;\n\n    fingerprint = ssh_get_fingerprint_hash(type,\n                                           hash,\n                                           len);\n    if (fingerprint == NULL) {\n        return;\n    }\n\n    fprintf(stderr, \"%s\\n\", fingerprint);\n\n    SAFE_FREE(fingerprint);\n}\n",
      "line_start": 808,
      "line_end": 825,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: it delegates to ssh_get_fingerprint_hash, checks for NULL, prints with a safe \"%s\" format and frees the result. The function itself does not parse or manipulate untrusted data, has trivial control flow, and is a low-value direct fuzz target (the real risk would be in ssh_get_fingerprint_hash or upstream parsing)."
    },
    {
      "name": "dh.c:ssh_packet_server_dh_init",
      "clean_name": "ssh_packet_server_dh_init",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "\n/** @internal\n * @brief parse an incoming SSH_MSG_KEXDH_INIT packet and complete\n *        Diffie-Hellman key exchange\n **/\nstatic SSH_PACKET_CALLBACK(ssh_packet_server_dh_init){\n    (void)type;\n    (void)user;\n    SSH_LOG(SSH_LOG_DEBUG, \"Received SSH_MSG_KEXDH_INIT\");\n    ssh_packet_remove_callbacks(session, &ssh_dh_server_callbacks);\n    ssh_server_dh_process_init(session, packet);\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 571,
      "line_end": 579,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper callback: logs, removes callbacks and delegates to ssh_server_dh_process_init. It does not parse or manipulate untrusted data itself; the real DH/key-exchange work (and fuzzable logic) is in the called function, so this target has low standalone fuzzing value."
    },
    {
      "name": "_ssh_set_error_oom",
      "clean_name": "_ssh_set_error_oom",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " * @brief Registers an out of memory error\n *\n * @param  error       The place to store the error.\n *\n */\nvoid _ssh_set_error_oom(void *error, const char *function)\n{\n    struct error_struct *err = error;\n\n    snprintf(err->error_buffer, sizeof(err->error_buffer),\n            \"%s: Out of memory\", function);\n    err->error_code = SSH_FATAL;\n}\n",
      "line_start": 80,
      "line_end": 88,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that formats an OOM error into a fixed-size buffer using bounded snprintf and sets an error code. No parsing of complex input, no loops, no branching, and minimal attack surface. (A null/invalid error pointer could cause a crash, but otherwise low-value as a fuzz target.)"
    },
    {
      "name": "ssh_reset_error",
      "clean_name": "ssh_reset_error",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " *\n * @brief Reset the error code and message\n *\n * @param  error       The place to reset the error.\n */\nvoid ssh_reset_error(void *error)\n{\n    struct ssh_common_struct *err = error;\n\n    ZERO_STRUCT(err->error.error_buffer);\n    err->error.error_code = 0;\n}\n",
      "line_start": 112,
      "line_end": 119,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that zeros an error buffer and clears a code. No parsing, branching, or loops; only a straightforward write to a provided struct. Minimal value as a fuzz target (aside from obvious null/invalid-pointer crash scenarios)."
    },
    {
      "name": "ssh_get_error",
      "clean_name": "ssh_get_error",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " *\n * @param  error        An ssh_session or ssh_bind.\n *\n * @return A static string describing the error.\n */\nconst char *ssh_get_error(void *error) {\n  struct error_struct *err = error;\n\n  return err->error_buffer;\n}\n",
      "line_start": 127,
      "line_end": 132,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: it just casts a pointer and returns a buffer pointer. No parsing, no loops, no branching or memory operations on untrusted data beyond a simple dereference. Low-value fuzz target (minor NULL/invalid-pointer crash potential)."
    },
    {
      "name": "ssh_get_error_code",
      "clean_name": "ssh_get_error_code",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " *                            disconnection\\n\n *\n *         Other error codes are internal but can be considered the same as\n *         SSH_FATAL.\n */\nint ssh_get_error_code(void *error) {\n  struct error_struct *err = error;\n\n  return err->error_code;\n}\n",
      "line_start": 147,
      "line_end": 152,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter: simply casts a pointer and returns a field. No parsing, no loops, no memory manipulation or complex logic. Potential NULL/dangling pointer dereference is the only likely issue, so very low fuzzing value."
    },
    {
      "name": "kdf.c:ssh_mac_ctx_init",
      "clean_name": "ssh_mac_ctx_init",
      "source_file": "/src/libssh/src/kdf.c",
      "source_code": "        SHA384CTX sha384_ctx;\n        SHA512CTX sha512_ctx;\n    } ctx;\n};\n\nstatic ssh_mac_ctx ssh_mac_ctx_init(enum ssh_kdf_digest type)\n{\n    ssh_mac_ctx ctx = malloc(sizeof(struct ssh_mac_ctx_struct));\n    if (ctx == NULL) {\n        return NULL;\n    }\n\n    ctx->digest_type = type;\n    switch (type) {\n    case SSH_KDF_SHA1:\n        ctx->ctx.sha1_ctx = sha1_init();\n        if (ctx->ctx.sha1_ctx == NULL) {\n            goto err;\n        }\n        return ctx;\n    case SSH_KDF_SHA256:\n        ctx->ctx.sha256_ctx = sha256_init();\n        if (ctx->ctx.sha256_ctx == NULL) {\n            goto err;\n        }\n        return ctx;\n    case SSH_KDF_SHA384:\n        ctx->ctx.sha384_ctx = sha384_init();\n        if (ctx->ctx.sha384_ctx == NULL) {\n            goto err;\n        }\n        return ctx;\n    case SSH_KDF_SHA512:\n        ctx->ctx.sha512_ctx = sha512_init();\n        if (ctx->ctx.sha512_ctx == NULL) {\n            goto err;\n        }\n        return ctx;\n    }\nerr:\n    SAFE_FREE(ctx);\n    return NULL;\n}\n",
      "line_start": 52,
      "line_end": 90,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 52,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple initializer/wrapper: allocates a context, sets an enum and calls underlying sha*_init() functions. Minimal branching, no parsing of external input or unsafe buffer/memory operations \u2014 low value as a fuzz target."
    },
    {
      "name": "kdf.c:ssh_mac_ctx_free",
      "clean_name": "ssh_mac_ctx_free",
      "source_file": "/src/libssh/src/kdf.c",
      "source_code": "err:\n    SAFE_FREE(ctx);\n    return NULL;\n}\n\nstatic void ssh_mac_ctx_free(ssh_mac_ctx ctx)\n{\n    if (ctx == NULL) {\n        return;\n    }\n\n    switch (ctx->digest_type) {\n    case SSH_KDF_SHA1:\n        sha1_ctx_free(ctx->ctx.sha1_ctx);\n        break;\n    case SSH_KDF_SHA256:\n        sha256_ctx_free(ctx->ctx.sha256_ctx);\n        break;\n    case SSH_KDF_SHA384:\n        sha384_ctx_free(ctx->ctx.sha384_ctx);\n        break;\n    case SSH_KDF_SHA512:\n        sha512_ctx_free(ctx->ctx.sha512_ctx);\n        break;\n    }\n    SAFE_FREE(ctx);\n}\n",
      "line_start": 91,
      "line_end": 113,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple cleanup function: it frees sub-contexts based on a small switch and then frees the ctx. Minimal logic, no parsing of external input, no memory operations on untrusted data, and low complexity \u2014 low fuzzing value."
    },
    {
      "name": "ssh_kex_get_default_methods",
      "clean_name": "ssh_kex_get_default_methods",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "  \"languages client->server\",\n  \"languages server->client\",\n  NULL\n};\n\nconst char *ssh_kex_get_default_methods(enum ssh_kex_types_e type)\n{\n    if (type >= SSH_KEX_METHODS) {\n        return NULL;\n    }\n\n    return default_methods[type];\n}\n",
      "line_start": 277,
      "line_end": 285,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: returns a pointer from a static array with a simple bounds check. No parsing, memory manipulation, loops, or complex branching and not security-critical \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_kex_get_supported_method",
      "clean_name": "ssh_kex_get_supported_method",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "        return NULL;\n    }\n\n    return default_methods[type];\n}\nconst char *ssh_kex_get_supported_method(enum ssh_kex_types_e type)\n{\n    if (type >= SSH_KEX_METHODS) {\n        return NULL;\n    }\n\n    return supported_methods[type];\n}\n",
      "line_start": 285,
      "line_end": 293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter that returns supported_methods[type] with a single upper-bound check. No parsing, memory writes, or complex logic \u2014 minimal fuzz value. (Note: lower-bound/negative value check is not present, but overall complexity and attack surface remain very small.)"
    },
    {
      "name": "ssh_kex_get_description",
      "clean_name": "ssh_kex_get_description",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n\n    return supported_methods[type];\n}\n\nconst char *ssh_kex_get_description(enum ssh_kex_types_e type)\n{\n    if (type >= SSH_KEX_METHODS) {\n        return NULL;\n    }\n\n    return ssh_kex_descriptions[type];\n}\n",
      "line_start": 294,
      "line_end": 302,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns a string from an array after a bounds check; minimal logic, no parsing or memory manipulation, and low value as a fuzz target."
    },
    {
      "name": "ssh_kex_get_fips_methods",
      "clean_name": "ssh_kex_get_fips_methods",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n\n    return ssh_kex_descriptions[type];\n}\n\nconst char *ssh_kex_get_fips_methods(enum ssh_kex_types_e type)\n{\n    if (type >= SSH_KEX_METHODS) {\n        return NULL;\n    }\n\n    return fips_methods[type];\n}\n",
      "line_start": 303,
      "line_end": 311,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: performs a single bounds check and returns an entry from a static array. No parsing, memory manipulation, loops, or complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_get_supported_methods",
      "clean_name": "ssh_get_supported_methods",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * ...).\n *\n * @return The list of supported methods as comma-separated string, or NULL for\n * unknown type.\n */\nconst char *ssh_get_supported_methods(enum ssh_kex_types_e type)\n{\n    if (ssh_fips_mode()) {\n        return ssh_kex_get_fips_methods(type);\n    } else {\n        return ssh_kex_get_supported_method(type);\n    }\n}\n",
      "line_start": 322,
      "line_end": 330,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: selects between two getters based on ssh_fips_mode(); no parsing, memory ops, or complex branching. Minimal value as a fuzz target (simple control flow)."
    },
    {
      "name": "ssh_list_kex",
      "clean_name": "ssh_list_kex",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    session->session_state = SSH_SESSION_STATE_ERROR;\n\n    return SSH_PACKET_USED;\n}\n\nvoid ssh_list_kex(struct ssh_kex_struct *kex) {\n  int i = 0;\n\n#ifdef DEBUG_CRYPTO\n  ssh_log_hexdump(\"session cookie\", kex->cookie, 16);\n#endif\n\n  for(i = 0; i < SSH_KEX_METHODS; i++) {\n    if (kex->methods[i] == NULL) {\n      continue;\n    }\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"%s: %s\",\n        ssh_kex_descriptions[i], kex->methods[i]);\n  }\n}\n",
      "line_start": 660,
      "line_end": 675,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that logs available KEX methods (and optionally a cookie hexdump). Low cyclomatic complexity, no parsing or memory-manipulation of untrusted input, and minimal branching \u2014 limited value as a fuzz target."
    },
    {
      "name": "ssh_keep_known_algos",
      "clean_name": "ssh_keep_known_algos",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    return SSH_OK;\n}\n\n/* returns a copy of the provided list if everything is supported,\n * otherwise a new list of the supported algorithms */\nchar *ssh_keep_known_algos(enum ssh_kex_types_e algo, const char *list)\n{\n    if (algo > SSH_LANG_S_C) {\n        return NULL;\n    }\n\n    return ssh_find_all_matching(supported_methods[algo], list);\n}\n",
      "line_start": 1219,
      "line_end": 1227,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: only an enum range check and a single call to ssh_find_all_matching. No parsing, no direct memory operations, no loops or branching beyond a simple bounds test. The real surface worth fuzzing is ssh_find_all_matching; this wrapper itself is low-priority."
    },
    {
      "name": "ssh_keep_fips_algos",
      "clean_name": "ssh_keep_fips_algos",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": " * @param[in] list  The list to be filtered\n *\n * @return A newly allocated list containing only the FIPS allowed algorithms from\n * the list; NULL in case of error.\n */\nchar *ssh_keep_fips_algos(enum ssh_kex_types_e algo, const char *list)\n{\n    if (algo > SSH_LANG_S_C) {\n        return NULL;\n    }\n\n    return ssh_find_all_matching(fips_methods[algo], list);\n}\n",
      "line_start": 1240,
      "line_end": 1248,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: performs a single enum bounds check and delegates to ssh_find_all_matching. The function itself contains minimal logic, no parsing, memory ops, or complex branching \u2014 fuzzing should target the underlying parser (ssh_find_all_matching) instead."
    },
    {
      "name": "kex.c:ssh_find_aead_hmac",
      "clean_name": "ssh_find_aead_hmac",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "    }\n    pkex->methods[SSH_KEX] = kex_tmp;\n    return SSH_OK;\n}\n\nstatic const char *ssh_find_aead_hmac(const char *cipher)\n{\n    if (cipher == NULL) {\n        return NULL;\n    } else if (strcmp(cipher, \"chacha20-poly1305@openssh.com\") == 0) {\n        return \"aead-poly1305\";\n    } else if (strcmp(cipher, \"aes256-gcm@openssh.com\") == 0) {\n        return \"aead-gcm\";\n    } else if (strcmp(cipher, \"aes128-gcm@openssh.com\") == 0) {\n        return \"aead-gcm\";\n    }\n    return NULL;\n}\n",
      "line_start": 881,
      "line_end": 894,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial mapping function that only does a NULL check and a few strcmp()s against constant cipher names. No complex parsing, memory manipulation, input-dependent loops, or security-critical logic \u2014 low value as a fuzz target."
    },
    {
      "name": "kex.c:revert_kex_callbacks",
      "clean_name": "revert_kex_callbacks",
      "source_file": "/src/libssh/src/kex.c",
      "source_code": "/** @internal\n * @brief Reverts guessed callbacks set during the dh_handshake()\n * @param session session handle\n * @returns void\n */\nstatic void revert_kex_callbacks(ssh_session session)\n{\n    switch (session->next_crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA1:\n    case SSH_KEX_DH_GROUP14_SHA256:\n    case SSH_KEX_DH_GROUP16_SHA512:\n    case SSH_KEX_DH_GROUP18_SHA512:\n        ssh_client_dh_remove_callbacks(session);\n        break;\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n    case SSH_KEX_DH_GEX_SHA256:\n        ssh_client_dhgex_remove_callbacks(session);\n        break;\n#endif /* WITH_GEX */\n#ifdef HAVE_ECDH\n    case SSH_KEX_ECDH_SHA2_NISTP256:\n    case SSH_KEX_ECDH_SHA2_NISTP384:\n    case SSH_KEX_ECDH_SHA2_NISTP521:\n        ssh_client_ecdh_remove_callbacks(session);\n        break;\n#endif\n#ifdef HAVE_CURVE25519\n    case SSH_KEX_CURVE25519_SHA256:\n    case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n        ssh_client_curve25519_remove_callbacks(session);\n        break;\n#endif\n#ifdef HAVE_SNTRUP761\n    case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n        ssh_client_sntrup761x25519_remove_callbacks(session);\n        break;\n#endif\n    }\n}\n",
      "line_start": 937,
      "line_end": 973,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple dispatcher/wrapper: it switches on an internal enum (next_crypto->kex_type) and calls removal functions. There is no parsing of external input, no memory ops or complex branching, and minimal logic\u2014low value as a standalone fuzz target."
    },
    {
      "name": "ssh_session_get_known_hosts_entry",
      "clean_name": "ssh_session_get_known_hosts_entry",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *          SSH_KNOWN_HOSTS_ERROR:     There had been an error checking the host.\n *\n * @see ssh_knownhosts_entry_free()\n */\nenum ssh_known_hosts_e\nssh_session_get_known_hosts_entry(ssh_session session,\n                                  struct ssh_knownhosts_entry **pentry)\n{\n    enum ssh_known_hosts_e old_rv, rv = SSH_KNOWN_HOSTS_UNKNOWN;\n\n    if (session->opts.knownhosts == NULL) {\n        if (ssh_options_apply(session) < 0) {\n            ssh_set_error(session,\n                          SSH_REQUEST_DENIED,\n                          \"Can't find a known_hosts file\");\n\n            return SSH_KNOWN_HOSTS_NOT_FOUND;\n        }\n    }\n\n    rv = ssh_session_get_known_hosts_entry_file(session,\n                                                session->opts.knownhosts,\n                                                pentry);\n    if (rv == SSH_KNOWN_HOSTS_OK) {\n        /* We already found a match in the first file: return */\n        return rv;\n    }\n\n    old_rv = rv;\n    rv = ssh_session_get_known_hosts_entry_file(session,\n                                                session->opts.global_knownhosts,\n                                                pentry);\n\n    /* If we did not find any match at all:  we report the previous result */\n    if (rv == SSH_KNOWN_HOSTS_UNKNOWN) {\n        if (session->opts.StrictHostKeyChecking == 0) {\n            return SSH_KNOWN_HOSTS_OK;\n        }\n        return old_rv;\n    }\n\n    /* We found some match: return it */\n    return rv;\n\n}\n",
      "line_start": 1162,
      "line_end": 1202,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Wrapper/orchestration function with simple branching and no direct parsing or memory operations on untrusted data. It mainly delegates work to ssh_session_get_known_hosts_entry_file (the real parser), so it is low-value as a standalone fuzz target; fuzz the file/parsing functions instead."
    },
    {
      "name": "ssh_session_get_known_hosts_entry_file",
      "clean_name": "ssh_session_get_known_hosts_entry_file",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *          SSH_KNOWN_HOSTS_ERROR:     There had been an error checking the host.\n *\n * @see ssh_knownhosts_entry_free()\n */\nenum ssh_known_hosts_e\nssh_session_get_known_hosts_entry_file(ssh_session session,\n                                       const char *filename,\n                                       struct ssh_knownhosts_entry **pentry)\n{\n    ssh_key server_pubkey = NULL;\n    char *host_port = NULL;\n    enum ssh_known_hosts_e found = SSH_KNOWN_HOSTS_UNKNOWN;\n\n    server_pubkey = ssh_dh_get_current_server_publickey(session);\n    if (server_pubkey == NULL) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"ssh_session_is_known_host called without a \"\n                      \"server_key!\");\n\n        return SSH_KNOWN_HOSTS_ERROR;\n    }\n\n    host_port = ssh_session_get_host_port(session);\n    if (host_port == NULL) {\n        return SSH_KNOWN_HOSTS_ERROR;\n    }\n\n    found = ssh_known_hosts_check_server_key(host_port,\n                                             filename,\n                                             server_pubkey,\n                                             pentry);\n    SAFE_FREE(host_port);\n\n    return found;\n}\n",
      "line_start": 1231,
      "line_end": 1262,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: primarily retrieves server public key and host:port and delegates to ssh_known_hosts_check_server_key. The function itself has minimal logic, no parsing/memory ops or loops on untrusted data\u2014the deeper check function is the better fuzz target."
    },
    {
      "name": "ssh_session_is_known_server",
      "clean_name": "ssh_session_is_known_server",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *          SSH_KNOWN_HOSTS_NOT_FOUND: The known host file does not exist. The\n *                                     host is thus unknown. File will be\n *                                     created if host key is accepted.\\n\n *          SSH_KNOWN_HOSTS_ERROR:     There had been an error checking the host.\n */\nenum ssh_known_hosts_e ssh_session_is_known_server(ssh_session session)\n{\n    return ssh_session_get_known_hosts_entry(session, NULL);\n}\n",
      "line_start": 1287,
      "line_end": 1291,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards to ssh_session_get_known_hosts_entry(session, NULL). Contains no parsing, branching, or memory operations itself and thus has low value as a direct fuzz target; fuzz the underlying function which does the actual work."
    },
    {
      "name": "ssh_log_function",
      "clean_name": "ssh_log_function",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "\n    snprintf(buf, sizeof(buf), \"%s: %s\", function, buffer);\n    log_fn(verbosity, function, buf, ssh_get_log_userdata());\n}\n\nvoid ssh_log_function(int verbosity,\n                      const char *function,\n                      const char *buffer)\n{\n    ssh_logging_callback log_fn = ssh_get_log_callback();\n\n    if (log_fn) {\n        ssh_log_custom(log_fn, verbosity, function, buffer);\n        return;\n    }\n\n    ssh_log_stderr(verbosity, function, buffer);\n}\n",
      "line_start": 111,
      "line_end": 124,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that routes log input to either a callback or stderr. Minimal control flow (one branch), no parsing or memory manipulation of untrusted data, and no complex validation or input-dependent loops. Not a high-value fuzz target on its own (though callbacks it invokes could be)."
    },
    {
      "name": "_ssh_log",
      "clean_name": "_ssh_log",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "\n    vsnprintf(buffer, sizeof(buffer), format, *va);\n    ssh_log_function(verbosity, function, buffer);\n}\n\nvoid _ssh_log(int verbosity,\n              const char *function,\n              const char *format, ...)\n{\n    va_list va;\n\n    if (verbosity <= ssh_get_log_level()) {\n        va_start(va, format);\n        ssh_vlog(verbosity, function, format, &va);\n        va_end(va);\n    }\n}\n",
      "line_start": 136,
      "line_end": 148,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple logging wrapper with minimal logic: checks verbosity, forwards varargs to ssh_vlog. Does not parse complex external formats, perform substantial memory ops itself, or contain input-dependent loops or security-critical processing. Low value as a fuzz target (aside from trivial format-string style inputs handled by downstream code)."
    },
    {
      "name": "ssh_log",
      "clean_name": "ssh_log",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "    }\n}\n\n/* LEGACY */\n\nvoid ssh_log(ssh_session session,\n             int verbosity,\n             const char *format, ...)\n{\n  va_list va;\n\n  if (verbosity <= session->common.log_verbosity) {\n    va_start(va, format);\n    ssh_vlog(verbosity, \"\", format, &va);\n    va_end(va);\n  }\n}\n",
      "line_start": 151,
      "line_end": 163,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around ssh_vlog with a single verbosity check and va_list forwarding. It contains minimal logic, no parsing of complex external input or buffer manipulation itself \u2014 the real work is delegated to ssh_vlog \u2014 so as a standalone fuzz target it has low value."
    },
    {
      "name": "ssh_log_common",
      "clean_name": "ssh_log_common",
      "source_file": "/src/libssh/src/log.c",
      "source_code": " * @brief log a SSH event with a common pointer\n * @param common       The SSH/bind session.\n * @param verbosity     The verbosity of the event.\n * @param format        The format string of the log entry.\n */\nvoid ssh_log_common(struct ssh_common_struct *common,\n                    int verbosity,\n                    const char *function,\n                    const char *format, ...)\n{\n    va_list va;\n\n    if (verbosity <= common->log_verbosity) {\n        va_start(va, format);\n        ssh_vlog(verbosity, function, format, &va);\n        va_end(va);\n    }\n}\n",
      "line_start": 170,
      "line_end": 183,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper around ssh_vlog with a simple verbosity check and varargs forwarding. It does not parse or manipulate untrusted data, perform memory operations, or contain complex branching. Any format-string or parsing risk would reside in ssh_vlog, which is the better fuzz target."
    },
    {
      "name": "ssh_set_log_level",
      "clean_name": "ssh_set_log_level",
      "source_file": "/src/libssh/src/log.c",
      "source_code": " *\n * @param[in]  level    The level to set.\n *\n * @return              SSH_OK on success, SSH_ERROR on error.\n */\nint ssh_set_log_level(int level) {\n  if (level < 0) {\n    return SSH_ERROR;\n  }\n\n  ssh_log_level = level;\n\n  return SSH_OK;\n}\n",
      "line_start": 194,
      "line_end": 203,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter with a trivial non-negative check; no parsing, memory operations, loops, or complex branching \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_set_log_userdata",
      "clean_name": "ssh_set_log_userdata",
      "source_file": "/src/libssh/src/log.c",
      "source_code": " *\n * @param[in]  data     The userdata to set.\n *\n * @return              SSH_OK on success.\n */\nint ssh_set_log_userdata(void *data)\n{\n    ssh_log_userdata = data;\n\n    return 0;\n}\n",
      "line_start": 254,
      "line_end": 260,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter that only stores the provided pointer in a global and returns success. No parsing, no memory operations or branching on input, and no dereferencing/validation of the pointer \u2014 minimal value as a fuzz target."
    },
    {
      "name": "log.c:ssh_log_custom",
      "clean_name": "ssh_log_custom",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "    }\n\n    fprintf(stderr, \"  %s\\n\", buffer);\n}\n\nstatic void ssh_log_custom(ssh_logging_callback log_fn,\n                           int verbosity,\n                           const char *function,\n                           const char *buffer)\n{\n    char buf[LOG_SIZE + 64];\n\n    snprintf(buf, sizeof(buf), \"%s: %s\", function, buffer);\n    log_fn(verbosity, function, buf, ssh_get_log_userdata());\n}\n",
      "line_start": 100,
      "line_end": 110,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple logging helper that only composes a string with snprintf and calls a callback. Minimal logic, no parsing, no loops or complex branching; low value as a fuzz target."
    },
    {
      "name": "log.c:ssh_log_stderr",
      "clean_name": "ssh_log_stderr",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "    }\n\n    return 0;\n}\n\nstatic void ssh_log_stderr(int verbosity,\n                           const char *function,\n                           const char *buffer)\n{\n    char date[128] = {0};\n    int rc;\n\n    rc = current_timestring(1, date, sizeof(date));\n    if (rc == 0) {\n        fprintf(stderr, \"[%s, %d] %s:\", date, verbosity, function);\n    } else {\n        fprintf(stderr, \"[%d] %s\", verbosity, function);\n    }\n\n    fprintf(stderr, \"  %s\\n\", buffer);\n}\n",
      "line_start": 83,
      "line_end": 99,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple logging helper with minimal logic: formats and prints provided strings using safe %s specifiers, no parsing, no memory manipulation, no loops or complex branching. Low value as a fuzz target."
    },
    {
      "name": "log.c:current_timestring",
      "clean_name": "current_timestring",
      "source_file": "/src/libssh/src/log.c",
      "source_code": " * Logging functions for debugging and problem resolving.\n *\n * @{\n */\n\nstatic int current_timestring(int hires, char *buf, size_t len)\n{\n    char tbuf[64];\n    struct timeval tv;\n    struct tm tm, *tm_ptr = NULL;\n    time_t t;\n\n    gettimeofday(&tv, NULL);\n    t = (time_t) tv.tv_sec;\n\n    tm_ptr = localtime_r(&t, &tm);\n    if (tm_ptr == NULL) {\n        return -1;\n    }\n\n    if (hires) {\n        strftime(tbuf, sizeof(tbuf), \"%Y/%m/%d %H:%M:%S\", &tm);\n        snprintf(buf, len, \"%s.%06ld\", tbuf, (long)tv.tv_usec);\n    } else {\n        strftime(tbuf, sizeof(tbuf), \"%Y/%m/%d %H:%M:%S\", &tm);\n        snprintf(buf, len, \"%s\", tbuf);\n    }\n\n    return 0;\n}\n",
      "line_start": 57,
      "line_end": 82,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very low value as a fuzz target: the function only formats the current time into a buffer (no parsing of external/protocol data), has very low complexity and no input-dependent branching, and uses bounded snprintf/strftime. Minimal attack surface beyond a caller-supplied buffer/length (which snprintf already bounds), so not worth prioritizing for fuzzing."
    },
    {
      "name": "match_hostname",
      "clean_name": "match_hostname",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " * indicate negation).\n * Returns -1 if negation matches, 1 if there is a positive match, 0 if there\n * is no match at all.\n */\nint\nmatch_hostname(const char *host, const char *pattern, size_t len)\n{\n    return match_pattern_list(host, pattern, len, 1);\n}\n",
      "line_start": 208,
      "line_end": 212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This function is a trivial wrapper that forwards to match_pattern_list(host, pattern, len, 1) with no parsing, branching, or memory operations itself. It has minimal logic and is low-value as a direct fuzz target; fuzzing should focus on the underlying match_pattern_list implementation instead."
    },
    {
      "name": "match.c:masklen_valid",
      "clean_name": "masklen_valid",
      "source_file": "/src/libssh/src/match.c",
      "source_code": " * according to the address family (IPv4 or IPv6).\n * @return false if the mask length exceeds the maximum valid length\n * or there is no match with IPv4 or IPv6 address family.\n */\nstatic bool\nmasklen_valid(int family, unsigned int mask)\n{\n    switch (family) {\n    case AF_INET:\n        return mask <= 32;\n    case AF_INET6:\n        return mask <= 128;\n    default:\n        return false;\n    }\n}\n",
      "line_start": 304,
      "line_end": 315,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial validation: simple branch and constant comparisons for IPv4/IPv6 mask lengths. No memory ops, parsing, loops, or complex logic \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_message_get",
      "clean_name": "ssh_message_get",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *                      elapsed.\n *\n * @warning This function blocks until a message has been received. Betterset up\n *          a callback if this behavior is unwanted.\n */\nssh_message ssh_message_get(ssh_session session)\n{\n    ssh_message msg = NULL;\n    int rc;\n\n    msg = ssh_message_pop_head(session);\n    if (msg != NULL) {\n        return msg;\n    }\n    if (session->ssh_message_list == NULL) {\n        session->ssh_message_list = ssh_list_new();\n        if (session->ssh_message_list == NULL) {\n            ssh_set_error_oom(session);\n            return NULL;\n        }\n    }\n    rc = ssh_handle_packets_termination(session, SSH_TIMEOUT_USER,\n                                        ssh_message_termination, session);\n    if (rc || session->session_state == SSH_SESSION_STATE_ERROR) {\n        return NULL;\n    }\n    msg = ssh_list_pop_head(ssh_message, session->ssh_message_list);\n\n    return msg;\n}\n",
      "line_start": 590,
      "line_end": 615,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple blocking getter/dispatcher: minimal logic (pop/create list, call packet handler, return), no parsing of external input or unsafe memory ops. Better fuzz targets are the packet/termination handlers that actually parse/process network data."
    },
    {
      "name": "ssh_message_subtype",
      "clean_name": "ssh_message_subtype",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param[in] msg       The message to get the subtype from.\n *\n * @return              The message type or -1 on error.\n */\nint ssh_message_subtype(ssh_message msg) {\n  if (msg == NULL) {\n    return -1;\n  }\n\n  switch(msg->type) {\n    case SSH_REQUEST_AUTH:\n      return msg->auth_request.method;\n    case SSH_REQUEST_CHANNEL_OPEN:\n      return msg->channel_request_open.type;\n    case SSH_REQUEST_CHANNEL:\n      return msg->channel_request.type;\n    case SSH_REQUEST_GLOBAL:\n      return msg->global_request.type;\n  }\n\n  return -1;\n}\n",
      "line_start": 638,
      "line_end": 656,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns fields based on msg->type; only a null check and a small switch. No parsing, memory operations, loops, or complex branching and thus minimal attack surface \u2014 low standalone fuzzing value."
    },
    {
      "name": "ssh_message_channel_request_open_reply_accept",
      "clean_name": "ssh_message_channel_request_open_reply_accept",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @returns a valid ssh_channel handle if the request is to be allowed\n *\n * @returns NULL in case of error\n */\nssh_channel ssh_message_channel_request_open_reply_accept(ssh_message msg)\n{\n    ssh_channel chan = NULL;\n    int rc;\n\n    if (msg == NULL) {\n        return NULL;\n    }\n\n    chan = ssh_channel_new(msg->session);\n    if (chan == NULL) {\n        return NULL;\n    }\n    rc = ssh_message_channel_request_open_reply_accept_channel(msg, chan);\n    if (rc < 0) {\n        ssh_channel_free(chan);\n        chan = NULL;\n    }\n    return chan;\n}\n",
      "line_start": 1481,
      "line_end": 1501,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper: it only NULL-checks the message, allocates a channel, calls ssh_message_channel_request_open_reply_accept_channel, and frees on error. It contains minimal logic/branching and no direct parsing or memory-manipulation of untrusted data itself. The real work likely happens in the called function, so this routine is low-value as a standalone fuzz target."
    },
    {
      "name": "messages.c:ssh_message_termination",
      "clean_name": "ssh_message_termination",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    }\n    return msg;\n}\n\n/* Returns 1 if there is a message available */\nstatic int ssh_message_termination(void *s)\n{\n    ssh_session session = s;\n    struct ssh_iterator *it = NULL;\n\n    if (session->session_state == SSH_SESSION_STATE_ERROR)\n        return 1;\n\n    it = ssh_list_get_iterator(session->ssh_message_list);\n    if (!it)\n        return 0;\n    else\n        return 1;\n}\n",
      "line_start": 565,
      "line_end": 579,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very simple accessor: checks session_state and whether a message-list iterator exists. No parsing of complex external input, no buffer/memory operations, and minimal branching \u2014 low value as a fuzz target (though dereferencing a provided session pointer could still trigger crashes in unsafe contexts)."
    },
    {
      "name": "messages.c:ssh_execute_server_callbacks",
      "clean_name": "ssh_execute_server_callbacks",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "/** @internal\n * Executes the callbacks defined in session->server_callbacks, out of an ssh_message\n * I don't like ssh_message interface but it works.\n * @returns SSH_OK if the message has been handled, or SSH_AGAIN otherwise.\n */\nstatic int ssh_execute_server_callbacks(ssh_session session, ssh_message msg){\n    int rc = SSH_AGAIN;\n\n    if (session->server_callbacks != NULL){\n        rc = ssh_execute_server_request(session, msg);\n    } else if (session->common.callbacks != NULL) {\n        /* This one is in fact a client callback... */\n        rc = ssh_execute_client_request(session, msg);\n    }\n\n    return rc;\n}\n",
      "line_start": 434,
      "line_end": 446,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple dispatcher/wrapper with minimal branching and no direct parsing or memory operations on untrusted data. It only checks callback pointers and delegates work to ssh_execute_server_request/ssh_execute_client_request, so the real fuzzing value lies in those callees rather than this function."
    },
    {
      "name": "messages.c:ssh_reply_channel_open_request",
      "clean_name": "ssh_reply_channel_open_request",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": "    }\n\n    return SSH_AGAIN;\n}\n\nstatic int ssh_reply_channel_open_request(ssh_message msg, ssh_channel channel)\n{\n    if (channel != NULL) {\n        return ssh_message_channel_request_open_reply_accept_channel(msg, channel);\n    }\n\n    ssh_message_reply_default(msg);\n\n    return SSH_OK;\n}\n",
      "line_start": 381,
      "line_end": 391,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper/dispatch: no parsing or memory ops, minimal branching (single null check) and just forwards to other handlers. Low value as a fuzz target."
    },
    {
      "name": "ssh_get_user_home_dir",
      "clean_name": "ssh_get_user_home_dir",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "\n#ifndef NSS_BUFLEN_PASSWD\n#define NSS_BUFLEN_PASSWD 4096\n#endif /* NSS_BUFLEN_PASSWD */\n\nchar *ssh_get_user_home_dir(void)\n{\n    char *szPath = NULL;\n    struct passwd pwd;\n    struct passwd *pwdbuf = NULL;\n    char buf[NSS_BUFLEN_PASSWD] = {0};\n    int rc;\n\n    rc = getpwuid_r(getuid(), &pwd, buf, NSS_BUFLEN_PASSWD, &pwdbuf);\n    if (rc != 0 || pwdbuf == NULL ) {\n        szPath = getenv(\"HOME\");\n        if (szPath == NULL) {\n            return NULL;\n        }\n        snprintf(buf, sizeof(buf), \"%s\", szPath);\n\n        return strdup(buf);\n    }\n\n    szPath = strdup(pwd.pw_dir);\n\n    return szPath;\n}\n",
      "line_start": 300,
      "line_end": 323,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Low fuzz value: a small helper that either calls getpwuid_r or getenv(\"HOME\") and returns a strdup'd path. Minimal logic/branching, no parsing of complex external formats, no loops or heavy memory manipulation \u2014 only trivial string copy from an environment/system source, so low priority for fuzzing."
    },
    {
      "name": "ssh_file_readaccess_ok",
      "clean_name": "ssh_file_readaccess_ok",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "\n    return szPath;\n}\n\n/* we have read access on file */\nint ssh_file_readaccess_ok(const char *file)\n{\n    if (access(file, R_OK) < 0) {\n        return 0;\n    }\n\n    return 1;\n}\n",
      "line_start": 325,
      "line_end": 333,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around access(file, R_OK) that performs a single system call and returns a boolean. It takes external input but has no parsing, memory manipulation, loops, or branching complexity \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_dir_writeable",
      "clean_name": "ssh_dir_writeable",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @param[in] path Path to the directory to be checked\n *\n * @return Return 1 if the directory exists and is accessible; 0 otherwise\n * */\nint ssh_dir_writeable(const char *path)\n{\n    struct stat buffer;\n    int rc;\n\n    rc = stat(path, &buffer);\n    if (rc < 0) {\n        return 0;\n    }\n\n    if (S_ISDIR(buffer.st_mode) && (buffer.st_mode & S_IWRITE)) {\n        return 1;\n    }\n\n    return 0;\n}\n",
      "line_start": 342,
      "line_end": 358,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around stat() that only checks whether the given path names a directory and has write bit set. It takes external input but has minimal branching, no parsing or memory operations, no loops or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_get_local_username",
      "clean_name": "ssh_get_local_username",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n\n    return 0;\n}\n\nchar *ssh_get_local_username(void)\n{\n    struct passwd pwd;\n    struct passwd *pwdbuf = NULL;\n    char buf[NSS_BUFLEN_PASSWD];\n    char *name = NULL;\n    int rc;\n\n    rc = getpwuid_r(getuid(), &pwd, buf, NSS_BUFLEN_PASSWD, &pwdbuf);\n    if (rc != 0 || pwdbuf == NULL) {\n        return NULL;\n    }\n\n    name = strdup(pwd.pw_name);\n    rc = ssh_check_username_syntax(name);\n\n    if (rc != SSH_OK) {\n        free(name);\n        return NULL;\n    }\n\n    return name;\n}\n",
      "line_start": 359,
      "line_end": 382,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "No external input parameters and minimal logic: it reads the local passwd entry for the current uid, strdup()s the username and runs a syntax check. Low complexity and limited attack surface for a fuzzer (not driven by user-controllable input), so low fuzzing priority."
    },
    {
      "name": "ssh_is_ipaddr_v4",
      "clean_name": "ssh_is_ipaddr_v4",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n\n    return name;\n}\n\nint ssh_is_ipaddr_v4(const char *str)\n{\n    int rc = -1;\n    struct in_addr dest;\n\n    rc = inet_pton(AF_INET, str, &dest);\n    if (rc > 0) {\n        return 1;\n    }\n\n    return 0;\n}\n",
      "line_start": 383,
      "line_end": 395,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple input validation wrapper around inet_pton to check an IPv4 string. Single external input but trivial logic (success/fail), no complex parsing, memory manipulation, or multiple code paths \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_lowercase",
      "clean_name": "ssh_lowercase",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    return ssh_is_ipaddr_v4(str);\n}\n\n#endif /* _WIN32 */\n\nchar *ssh_lowercase(const char* str)\n{\n    char *new = NULL, *p = NULL;\n\n    if (str == NULL) {\n        return NULL;\n    }\n\n    new = strdup(str);\n    if (new == NULL) {\n        return NULL;\n    }\n\n    for (p = new; *p; p++) {\n        *p = tolower(*p);\n    }\n\n    return new;\n}\n",
      "line_start": 430,
      "line_end": 449,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that strdup()s and lowercases a string \u2014 minimal logic, no complex parsing or branches. It touches external input but only performs a trivial in-place lowercase loop (minor resource/locale/tolower issues possible), so low fuzzing priority."
    },
    {
      "name": "ssh_list_get_iterator",
      "clean_name": "ssh_list_get_iterator",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "        ptr = next;\n    }\n    SAFE_FREE(list);\n}\n\nstruct ssh_iterator *ssh_list_get_iterator(const struct ssh_list *list)\n{\n    if (!list)\n        return NULL;\n    return list->root;\n}\n",
      "line_start": 768,
      "line_end": 774,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: just checks for NULL and returns list->root. No parsing, memory manipulation, loops, or branching on input \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_list_find",
      "clean_name": "ssh_list_find",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    if (!list)\n        return NULL;\n    return list->root;\n}\n\nstruct ssh_iterator *ssh_list_find(const struct ssh_list *list, void *value)\n{\n    struct ssh_iterator *it = NULL;\n\n    for (it = ssh_list_get_iterator(list); it != NULL ; it = it->next)\n        if (it->data == value)\n            return it;\n    return NULL;\n}\n",
      "line_start": 775,
      "line_end": 784,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple linked-list traversal performing a pointer equality check. No parsing, no memory operations on untrusted data, minimal logic/branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_list_count",
      "clean_name": "ssh_list_count",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @param[in]  list     The list to count.\n *\n * @return The number of elements in the list.\n */\nsize_t ssh_list_count(const struct ssh_list *list)\n{\n  struct ssh_iterator *it = NULL;\n  size_t count = 0;\n\n  for (it = ssh_list_get_iterator(list); it != NULL ; it = it->next) {\n      count++;\n  }\n\n  return count;\n}\n",
      "line_start": 792,
      "line_end": 803,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that iterates a linked list and increments a counter; minimal logic and no parsing or memory operations on untrusted input. Low complexity and limited attack surface (aside from potential list corruption/cycles), so low value as a fuzz target."
    },
    {
      "name": "ssh_list_append",
      "clean_name": "ssh_list_append",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    iterator->next = NULL;\n    iterator->data = data;\n    return iterator;\n}\n\nint ssh_list_append(struct ssh_list *list,const void *data)\n{\n  struct ssh_iterator *iterator = NULL;\n\n  if (list == NULL) {\n      return SSH_ERROR;\n  }\n\n  iterator = ssh_iterator_new(data);\n  if (iterator == NULL) {\n      return SSH_ERROR;\n  }\n\n  if(!list->end){\n    /* list is empty */\n    list->root=list->end=iterator;\n  } else {\n    /* put it on end of list */\n    list->end->next=iterator;\n    list->end=iterator;\n  }\n  return SSH_OK;\n}\n",
      "line_start": 816,
      "line_end": 839,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple linked-list append: only stores a pointer, checks for NULL and allocation, minimal branching and no parsing or memory operations on untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_list_prepend",
      "clean_name": "ssh_list_prepend",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    list->end=iterator;\n  }\n  return SSH_OK;\n}\n\nint ssh_list_prepend(struct ssh_list *list, const void *data)\n{\n  struct ssh_iterator *it = NULL;\n\n  if (list == NULL) {\n      return SSH_ERROR;\n  }\n\n  it = ssh_iterator_new(data);\n  if (it == NULL) {\n    return SSH_ERROR;\n  }\n\n  if (list->end == NULL) {\n    /* list is empty */\n    list->root = list->end = it;\n  } else {\n    /* set as new root */\n    it->next = list->root;\n    list->root = it;\n  }\n\n  return SSH_OK;\n}\n",
      "line_start": 840,
      "line_end": 864,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple linked-list prepend helper: minimal branching (NULL checks), no parsing or processing of external data, no loops or memory/format operations on untrusted input. Low value as a standalone fuzz target."
    },
    {
      "name": "ssh_list_remove",
      "clean_name": "ssh_list_remove",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "  }\n\n  return SSH_OK;\n}\n\nvoid ssh_list_remove(struct ssh_list *list, struct ssh_iterator *iterator)\n{\n    struct ssh_iterator *ptr = NULL, *prev = NULL;\n\n    if (list == NULL) {\n        return;\n    }\n\n    prev = NULL;\n    ptr = list->root;\n    while (ptr && ptr != iterator) {\n        prev = ptr;\n        ptr = ptr->next;\n    }\n    if (!ptr) {\n        /* we did not find the element */\n        return;\n    }\n    /* unlink it */\n    if (prev)\n        prev->next = ptr->next;\n    /* if iterator was the head */\n    if (list->root == iterator)\n        list->root = iterator->next;\n    /* if iterator was the tail */\n    if (list->end == iterator)\n        list->end = prev;\n    SAFE_FREE(iterator);\n}\n",
      "line_start": 865,
      "line_end": 894,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 44,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple linked-list removal helper: low cyclomatic complexity, no parsing of complex external input or protocol handling. It does free memory but operates only on pointer parameters with minimal branching; limited value as a fuzz target (some risk if callers pass arbitrary pointers, but not a parser/IO-facing function)."
    },
    {
      "name": "ssh_mkdir",
      "clean_name": "ssh_mkdir",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @param[in]  mode     The permissions to use.\n *\n * @return              0 on success, < 0 on error with errno set.\n */\nint ssh_mkdir(const char *pathname, mode_t mode)\n{\n    int r;\n#ifdef _WIN32\n    r = _mkdir(pathname);\n#else\n    r = mkdir(pathname, mode);\n#endif\n\n    return r;\n}\n",
      "line_start": 1057,
      "line_end": 1068,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around mkdir/_mkdir that takes a pathname and mode. Minimal logic, no parsing, no loops, no branching \u2014 low-value fuzz target despite operating on external filesystem input."
    },
    {
      "name": "ssh_make_milliseconds",
      "clean_name": "ssh_make_milliseconds",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * into millisecond value\n * @param[in] sec number of seconds\n * @param[in] usec number of microseconds\n * @returns milliseconds, or 10000 if user supplied values are equal to zero\n */\nint ssh_make_milliseconds(unsigned long sec, unsigned long usec)\n{\n\tunsigned long res = usec ? (usec / 1000) : 0;\n\tres += (sec * 1000);\n\tif (res == 0) {\n\t\tres = 10 * 1000; /* use a reasonable default value in case\n\t\t\t\t* SSH_OPTIONS_TIMEOUT is not set in options. */\n\t}\n\n    if (res > INT_MAX) {\n        return SSH_TIMEOUT_INFINITE;\n    } else {\n        return (int)res;\n    }\n}\n",
      "line_start": 1530,
      "line_end": 1545,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple time conversion: pure arithmetic on two integer parameters with minimal branching and no parsing, memory operations, or security-critical logic. Very low cyclomatic complexity and limited attack surface (aside from a potential integer-wrap/overflow edge, which is low-impact), so it is a low-priority fuzz target."
    },
    {
      "name": "ssh_timeout_elapsed",
      "clean_name": "ssh_timeout_elapsed",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in] timeout timeout in milliseconds. Negative values mean infinite\n *                   timeout\n * @returns 1 if timeout is elapsed\n *          0 otherwise\n */\nint ssh_timeout_elapsed(struct ssh_timestamp *ts, int timeout)\n{\n    struct ssh_timestamp now;\n\n    switch(timeout) {\n        case -2: /*\n                  * -2 means user-defined timeout as available in\n                  * session->timeout, session->timeout_usec.\n                  */\n            SSH_LOG(SSH_LOG_DEBUG, \"ssh_timeout_elapsed called with -2. this needs to \"\n                            \"be fixed. please set a breakpoint on misc.c:%d and \"\n                            \"fix the caller\\n\", __LINE__);\n            return 0;\n        case -1: /* -1 means infinite timeout */\n            return 0;\n        case 0: /* 0 means no timeout */\n            return 1;\n        default:\n            break;\n    }\n\n    ssh_timestamp_init(&now);\n\n    return (ssh_timestamp_difference(ts,&now) >= timeout);\n}\n",
      "line_start": 1556,
      "line_end": 1581,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple timeout check with minimal branching and no parsing, buffer or memory operations and no complex control flow. Most work (and any risk) is delegated to ssh_timestamp_difference; low value as a standalone fuzz target."
    },
    {
      "name": "ssh_timeout_update",
      "clean_name": "ssh_timeout_update",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in] ts pointer to an existing timestamp\n * @param[in] timeout timeout in milliseconds. Negative values mean infinite\n *             timeout\n * @returns   remaining time in milliseconds, 0 if elapsed, -1 if never.\n */\nint ssh_timeout_update(struct ssh_timestamp *ts, int timeout)\n{\n  struct ssh_timestamp now;\n  int ms, ret;\n  if (timeout <= 0) {\n      return timeout;\n  }\n  ssh_timestamp_init(&now);\n  ms = ssh_timestamp_difference(ts,&now);\n  if(ms < 0)\n    ms = 0;\n  ret = timeout - ms;\n  return ret >= 0 ? ret: 0;\n}\n",
      "line_start": 1589,
      "line_end": 1603,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that computes remaining milliseconds from a timestamp and an integer timeout. No complex parsing, no memory operations or buffer manipulation, no loops, and minimal branching. Low value as a fuzz target (only potential issue would be misuse/NULL ts leading to a crash, but that is an API misuse rather than complex input processing)."
    },
    {
      "name": "burn_free",
      "clean_name": "burn_free",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in] ptr Pointer to the memory region to securely free.\n *                Can be NULL (no operation performed).\n * @param[in] len Length of the memory region in bytes.\n *\n */\nvoid burn_free(void *ptr, size_t len)\n{\n    if (ptr == NULL || len == 0) {\n        return;\n    }\n\n    explicit_bzero(ptr, len);\n    free(ptr);\n}\n",
      "line_start": 1632,
      "line_end": 1641,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: a single null/len check, then explicit_bzero() and free(). No parsing, no loops, minimal branching. While security-related (zeroing secrets), it has very low complexity and is a poor standalone fuzz target since it operates on raw pointers/lengths rather than external data formats or protocol input."
    },
    {
      "name": "ssh_strerror",
      "clean_name": "ssh_strerror",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[out] buf Pointer to a place where the string could be saved\n * @param[in] buflen The allocated size of buf\n *\n * @return error string\n */\nchar *ssh_strerror(int err_num, char *buf, size_t buflen)\n{\n#if ((defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)) && defined(_GNU_SOURCE)\n    /* GNU extension on Linux */\n    return strerror_r(err_num, buf, buflen);\n#else\n    int rv;\n\n#if defined(_WIN32)\n    rv = strerror_s(buf, buflen, err_num);\n#else\n    /* POSIX version available for example on FreeBSD or in musl libc */\n    rv = strerror_r(err_num, buf, buflen);\n#endif /* _WIN32 */\n\n    /* make sure the buffer is initialized and terminated with NULL */\n    if (-rv == ERANGE) {\n        buf[0] = '\\0';\n    }\n    return buf;\n#endif /* ((defined(__linux__) && defined(__GLIBC__)) || defined(__CYGWIN__)) && defined(_GNU_SOURCE) */\n}\n",
      "line_start": 2023,
      "line_end": 2045,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around strerror_r/strerror_s with minimal logic and branching. It delegates to libc for actual work, does trivial buffer initialization on one error case, and does not parse complex external input or perform risky memory-manipulation logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_libssh_proxy_jumps",
      "clean_name": "ssh_libssh_proxy_jumps",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @return false if OPENSSH_PROXYJUMP=1\n *         true otherwise\n */\nbool\nssh_libssh_proxy_jumps(void)\n{\n    const char *t = getenv(\"OPENSSH_PROXYJUMP\");\n\n    return !(t != NULL && t[0] == '1');\n}\n",
      "line_start": 2289,
      "line_end": 2295,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial function: reads an environment variable and checks its first character. No parsing, no memory operations, no loops or complex branching\u2014minimal value as a fuzz target."
    },
    {
      "name": "misc.c:ssh_iterator_new",
      "clean_name": "ssh_iterator_new",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "  }\n\n  return count;\n}\n\nstatic struct ssh_iterator *ssh_iterator_new(const void *data)\n{\n    struct ssh_iterator *iterator = malloc(sizeof(struct ssh_iterator));\n\n    if (iterator == NULL) {\n        return NULL;\n    }\n    iterator->next = NULL;\n    iterator->data = data;\n    return iterator;\n}\n",
      "line_start": 804,
      "line_end": 815,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple constructor/allocation: allocates an ssh_iterator and stores the provided pointer. No parsing, no copies or buffer ops on untrusted data, no branching or loops \u2014 minimal value as a fuzz target."
    },
    {
      "name": "misc.c:ssh_timestamp_difference",
      "clean_name": "ssh_timestamp_difference",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " * @param[in] new newer value\n * @returns difference in milliseconds\n */\n\nstatic int\nssh_timestamp_difference(struct ssh_timestamp *old, struct ssh_timestamp *new)\n{\n    long seconds, usecs, msecs;\n    seconds = new->seconds - old->seconds;\n    usecs = new->useconds - old->useconds;\n    if (usecs < 0){\n        seconds--;\n        usecs += 1000000;\n    }\n    msecs = seconds * 1000 + usecs/1000;\n    return msecs;\n}\n",
      "line_start": 1509,
      "line_end": 1521,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small helper that computes a millisecond difference between two timestamp structs. Only simple arithmetic and one branch, no parsing/memory ops, low cyclomatic complexity and minimal attack surface for fuzzing (aside from caller-level null-pointer or integer overflow issues)."
    },
    {
      "name": "ssh_options_get_algo",
      "clean_name": "ssh_options_get_algo",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " * This function will return NULL on error\n *\n * @param session An allocated SSH session structure.\n * @param algo One of the ssh_kex_types_e values.\n */\nchar *ssh_options_get_algo(ssh_session session,\n                           enum ssh_kex_types_e algo)\n{\n    char *value = NULL;\n\n    /* Check session and algo values are valid */\n\n    if (session == NULL) {\n        return NULL;\n    }\n\n    if (algo >= SSH_LANG_C_S) {\n        ssh_set_error_invalid(session);\n        return NULL;\n    }\n\n    /* Get the option the user has set, if there is one */\n    value = session->opts.wanted_methods[algo];\n    if (value == NULL) {\n        /* The user has not set a value, return the appropriate default */\n        if (ssh_fips_mode())\n            value = (char *)ssh_kex_get_fips_methods(algo);\n        else\n            value = (char *)ssh_kex_get_default_methods(algo);\n    }\n\n    return value;\n}\n",
      "line_start": 1378,
      "line_end": 1406,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 32,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor with minor validation. It only bounds-checks an enum, reads a pointer from session->opts and falls back to default strings; no parsing, memory copies, loops, or complex branching. Low fuzzing value on its own."
    },
    {
      "name": "options.c:ssh_bind_set_key",
      "clean_name": "ssh_bind_set_key",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "/**\n * @addtogroup libssh_server\n * @{\n */\nstatic int\nssh_bind_set_key(ssh_bind sshbind, char **key_loc, const void *value)\n{\n    if (value == NULL) {\n        ssh_set_error_invalid(sshbind);\n        return -1;\n    } else {\n        SAFE_FREE(*key_loc);\n        *key_loc = strdup(value);\n        if (*key_loc == NULL) {\n            ssh_set_error_oom(sshbind);\n            return -1;\n        }\n    }\n    return 0;\n}\n",
      "line_start": 2053,
      "line_end": 2068,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple setter that frees and strdup()s a provided pointer. Minimal branching and logic (null check + OOM check). While it performs a memory copy, it lacks parsing/validation and has low complexity \u2014 suitable as a low-priority fuzz target (small surface; potential issues only if caller supplies non-terminated or invalid pointers)."
    },
    {
      "name": "options.c:ssh_bind_set_algo",
      "clean_name": "ssh_bind_set_algo",
      "source_file": "/src/libssh/src/options.c",
      "source_code": "        }\n    }\n    return 0;\n}\n\nstatic int ssh_bind_set_algo(ssh_bind sshbind,\n                             enum ssh_kex_types_e algo,\n                             const char *list,\n                             char **place)\n{\n    /* sshbind is needed only for ssh_set_error which takes void*\n     * the typecast is only to satisfy function parameter type */\n    return ssh_options_set_algo((ssh_session)sshbind, algo, list, place);\n}\n",
      "line_start": 2069,
      "line_end": 2078,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards arguments to ssh_options_set_algo with a cast; no parsing, memory operations, branching, or security-critical logic\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_packet_get_current_crypto",
      "clean_name": "ssh_packet_get_current_crypto",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": " * During key exchange (or rekey), after one of the sides\n * sending NEWKEYS packet, this might return next_crypto for one\n * of the directions that is ahead to send already queued packets\n */\nstruct ssh_crypto_struct *\nssh_packet_get_current_crypto(ssh_session session,\n                              enum ssh_crypto_direction_e direction)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n\n    if (session == NULL) {\n        return NULL;\n    }\n\n    if (session->current_crypto != NULL &&\n        session->current_crypto->used & direction) {\n        crypto = session->current_crypto;\n    } else if (session->next_crypto != NULL &&\n               session->next_crypto->used & direction) {\n        crypto = session->next_crypto;\n    } else {\n        return NULL;\n    }\n\n    switch (direction) {\n    case SSH_DIRECTION_IN:\n        if (crypto->in_cipher != NULL) {\n            return crypto;\n        }\n        break;\n    case SSH_DIRECTION_OUT:\n        if (crypto->out_cipher != NULL) {\n            return crypto;\n        }\n        break;\n    case SSH_DIRECTION_BOTH:\n        if (crypto->in_cipher != NULL &&\n            crypto->out_cipher != NULL) {\n            return crypto;\n        }\n    }\n\n    return NULL;\n}\n",
      "line_start": 1033,
      "line_end": 1072,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 66,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/selector: it only checks the session pointer, inspects current/next crypto pointers and a bitmask, and returns a pointer based on a small switch. No parsing, no memory/IO operations, and minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_packet_register_socket_callback",
      "clean_name": "ssh_packet_register_socket_callback",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "            it = it->next;\n        }\n    }\n}\n\nvoid ssh_packet_register_socket_callback(ssh_session session, ssh_socket s)\n{\n    struct ssh_socket_callbacks_struct *callbacks = &session->socket_callbacks;\n\n    callbacks->data = ssh_packet_socket_callback;\n    callbacks->connected = NULL;\n    callbacks->controlflow = ssh_packet_socket_controlflow_callback;\n    callbacks->userdata = session;\n    ssh_socket_set_callbacks(s, callbacks);\n}\n",
      "line_start": 1545,
      "line_end": 1555,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple callback-registration wrapper: assigns callback pointers and calls ssh_socket_set_callbacks. No parsing of external input, no memory operations on untrusted data, no branching or input-dependent logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_packet_set_callbacks",
      "clean_name": "ssh_packet_set_callbacks",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "\n/** @internal\n * @brief sets the callbacks for the packet layer\n */\nvoid\nssh_packet_set_callbacks(ssh_session session, ssh_packet_callbacks callbacks)\n{\n    if (session->packet_callbacks == NULL) {\n        session->packet_callbacks = ssh_list_new();\n        if (session->packet_callbacks == NULL) {\n            ssh_set_error_oom(session);\n            return;\n        }\n    }\n    ssh_list_append(session->packet_callbacks, callbacks);\n}\n",
      "line_start": 1560,
      "line_end": 1571,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Low priority: simple setter/wrapper that only ensures a list exists and appends a callback pointer. Minimal branching, no parsing of external data, no memory operations on untrusted input, and no security-critical logic."
    },
    {
      "name": "ssh_packet_remove_callbacks",
      "clean_name": "ssh_packet_remove_callbacks",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "\n/** @internal\n * @brief remove the callbacks from the packet layer\n */\nvoid\nssh_packet_remove_callbacks(ssh_session session, ssh_packet_callbacks callbacks)\n{\n    struct ssh_iterator *it = NULL;\n\n    it = ssh_list_find(session->packet_callbacks, callbacks);\n    if (it != NULL) {\n        ssh_list_remove(session->packet_callbacks, it);\n    }\n}\n",
      "line_start": 1576,
      "line_end": 1585,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that finds and removes a callback from an internal list. Minimal logic/branching, no parsing of external input, no memory operations on untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_packet_send_newkeys",
      "clean_name": "ssh_packet_send_newkeys",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "/** @internal\n * @brief sends a SSH_MSG_NEWKEYS when enabling the new negotiated ciphers\n * @param session the SSH session\n * @return SSH_ERROR on error, else SSH_OK\n */\nint ssh_packet_send_newkeys(ssh_session session)\n{\n    int rc;\n\n    /* Send the MSG_NEWKEYS */\n    rc = ssh_buffer_add_u8(session->out_buffer, SSH2_MSG_NEWKEYS);\n    if (rc < 0) {\n        return rc;\n    }\n\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        return rc;\n    }\n    SSH_LOG(SSH_LOG_DEBUG, \"SSH_MSG_NEWKEYS sent\");\n    return rc;\n}\n",
      "line_start": 1662,
      "line_end": 1679,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that writes a single byte and calls send; no parsing of external input, minimal branching and logic. Potential issues would lie in called functions, not this function itself, so low priority as a standalone fuzz target."
    },
    {
      "name": "ssh_packet_send_unimplemented",
      "clean_name": "ssh_packet_send_unimplemented",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": " * @brief sends a SSH_MSG_UNIMPLEMENTED answer to an unhandled packet\n * @param session the SSH session\n * @param seqnum the sequence number of the unknown packet\n * @return SSH_ERROR on error, else SSH_OK\n */\nint ssh_packet_send_unimplemented(ssh_session session, uint32_t seqnum){\n    int rc;\n\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bd\",\n                         SSH2_MSG_UNIMPLEMENTED,\n                         seqnum);\n    if (rc != SSH_OK) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    rc = ssh_packet_send(session);\n\n    return rc;\n}\n",
      "line_start": 1686,
      "line_end": 1701,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: only packs a constant message type and a uint32 seqnum into session->out_buffer then calls send. Very low complexity (no parsing, no branches, no loops) and minimal attack surface \u2014 any buffer/memory risks lie in ssh_buffer_pack/ssh_packet_send, not this function itself, so it has low value as a standalone fuzz target."
    },
    {
      "name": "ssh_packet_parse_type",
      "clean_name": "ssh_packet_parse_type",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "}\n\n/** @internal\n * @parse the \"Type\" header field of a packet and updates the session\n */\nint ssh_packet_parse_type(struct ssh_session_struct *session)\n{\n    session->in_packet = (struct packet_struct) {\n        .type = 0,\n    };\n\n    if (session->in_buffer == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (ssh_buffer_get_u8(session->in_buffer, &session->in_packet.type) == 0) {\n        ssh_set_error(session, SSH_FATAL, \"Packet too short to read type\");\n        return SSH_ERROR;\n    }\n\n    session->in_packet.valid = 1;\n\n    return SSH_OK;\n}\n",
      "line_start": 1728,
      "line_end": 1747,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Only reads a single byte from an input buffer and sets a flag. Minimal logic and branching, no loops or complex parsing/transformations, limited attack surface \u2014 low-value standalone fuzz target (may be useful only as part of a larger SSH parser)."
    },
    {
      "name": "packet.c:ssh_packet_socket_controlflow_callback",
      "clean_name": "ssh_packet_socket_controlflow_callback",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "    session->session_state = SSH_SESSION_STATE_ERROR;\n    SSH_LOG(SSH_LOG_PACKET, \"Packet: processed %zu bytes\", processed);\n    return processed;\n}\n\nstatic void ssh_packet_socket_controlflow_callback(int code, void *userdata)\n{\n    ssh_session session = userdata;\n    struct ssh_iterator *it = NULL;\n    ssh_channel channel = NULL;\n\n    if (code == SSH_SOCKET_FLOW_WRITEWONTBLOCK) {\n        SSH_LOG(SSH_LOG_TRACE, \"sending channel_write_wontblock callback\");\n\n        /* the out pipe is empty so we can forward this to channels */\n        it = ssh_list_get_iterator(session->channels);\n        while (it != NULL) {\n            channel = ssh_iterator_value(ssh_channel, it);\n            ssh_callbacks_execute_list(channel->callbacks,\n                                       ssh_channel_callbacks,\n                                       channel_write_wontblock_function,\n                                       session,\n                                       channel,\n                                       channel->remote_window);\n            it = it->next;\n        }\n    }\n}\n",
      "line_start": 1521,
      "line_end": 1544,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple control-flow callback: checks a flow code and iterates over session->channels to invoke callbacks. It does not parse external input, perform memory/ buffer operations, or contain complex branching. Useful only indirectly (via callbacks it invokes), so low priority as a direct fuzz target."
    },
    {
      "name": "packet.c:ssh_packet_in_rekey",
      "clean_name": "ssh_packet_in_rekey",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "           type != SSH2_MSG_IGNORE &&\n           type != SSH2_MSG_EXT_INFO;\n}\n\nstatic bool\nssh_packet_in_rekey(ssh_session session)\n{\n    /* We know we are rekeying if we are authenticated and the DH\n     * status is not finished, but we only queue packets until we've\n     * sent our NEWKEYS.\n     */\n    return (session->flags & SSH_SESSION_FLAG_AUTHENTICATED) &&\n           (session->dh_handshake_state != DH_STATE_FINISHED) &&\n           (session->dh_handshake_state != DH_STATE_NEWKEYS_SENT);\n}\n",
      "line_start": 1922,
      "line_end": 1932,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial boolean/state-check function: only reads session fields and returns a simple conjunction. No parsing, no memory operations, low complexity \u2014 low-value as a fuzz target."
    },
    {
      "name": "packet.c:ssh_packet_is_kex",
      "clean_name": "ssh_packet_is_kex",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "error:\n    return rc; /* SSH_OK, AGAIN or ERROR */\n}\n\nstatic bool\nssh_packet_is_kex(unsigned char type)\n{\n    return type >= SSH2_MSG_DISCONNECT &&\n           type <= SSH2_MSG_KEX_DH_GEX_REQUEST &&\n           type != SSH2_MSG_SERVICE_REQUEST &&\n           type != SSH2_MSG_SERVICE_ACCEPT &&\n           type != SSH2_MSG_IGNORE &&\n           type != SSH2_MSG_EXT_INFO;\n}\n",
      "line_start": 1911,
      "line_end": 1920,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial predicate: simple range and equality checks on a single byte. No parsing, memory ops, loops, or complex branching \u2014 low-value fuzz target (simple input-dependent branch)."
    },
    {
      "name": "packet.c:ssh_packet_write",
      "clean_name": "ssh_packet_write",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "\n/*\n * This function places the outgoing packet buffer into an outgoing\n * socket buffer\n */\nstatic int ssh_packet_write(ssh_session session) {\n  int rc = SSH_ERROR;\n\n  rc=ssh_socket_write(session->socket,\n      ssh_buffer_get(session->out_buffer),\n      ssh_buffer_get_len(session->out_buffer));\n\n  return rc;\n}\n",
      "line_start": 1752,
      "line_end": 1761,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Thin wrapper that simply forwards the session socket, buffer pointer and length to ssh_socket_write. No parsing, no branching, no loops or direct memory manipulation in this function itself. Low fuzzing value \u2014 fuzz more interesting targets that build or consume the buffer (e.g., ssh_socket_write or the code that fills session->out_buffer)."
    },
    {
      "name": "ssh_packet_ignore_callback",
      "clean_name": "ssh_packet_ignore_callback",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "/**\n * @internal\n *\n * @brief Handle a SSH_IGNORE packet.\n */\nSSH_PACKET_CALLBACK(ssh_packet_ignore_callback)\n{\n    (void)session; /* unused */\n    (void)user;\n    (void)type;\n    (void)packet;\n\n    SSH_LOG(SSH_LOG_DEBUG, \"Received SSH_MSG_IGNORE packet\");\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 96,
      "line_end": 107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial ignore handler: all parameters unused, no parsing, memory ops, or branching\u2014just logs and returns a constant. Low value as a fuzz target."
    },
    {
      "name": "ssh_pcap_file_open",
      "clean_name": "ssh_pcap_file_open",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "}\n\n/**\n * @brief opens a new pcap file and creates header\n */\nint ssh_pcap_file_open(ssh_pcap_file pcap, const char *filename)\n{\n    ssh_buffer header = NULL;\n    int err;\n\n    if (pcap == NULL) {\n        return SSH_ERROR;\n    }\n    if (pcap->output) {\n        fclose(pcap->output);\n        pcap->output = NULL;\n    }\n    pcap->output = fopen(filename, \"wb\");\n    if (pcap->output == NULL) {\n        return SSH_ERROR;\n    }\n    header = ssh_buffer_new();\n    if (header == NULL) {\n        return SSH_ERROR;\n    }\n    err = ssh_buffer_allocate_size(header,\n                                   sizeof(uint32_t) * 5 +\n                                   sizeof(uint16_t) * 2);\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u32(header, htonl(PCAP_MAGIC));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u16(header, htons(PCAP_VERSION_MAJOR));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_buffer_add_u16(header, htons(PCAP_VERSION_MINOR));\n    if (err < 0) {\n        goto error;\n    }\n    /* currently hardcode GMT to 0 */\n    err = ssh_buffer_add_u32(header, htonl(0));\n    if (err < 0) {\n        goto error;\n    }\n    /* accuracy */\n    err = ssh_buffer_add_u32(header, htonl(0));\n    if (err < 0) {\n        goto error;\n    }\n    /* size of the biggest packet */\n    err = ssh_buffer_add_u32(header, htonl(MAX_PACKET_LEN));\n    if (err < 0) {\n        goto error;\n    }\n    /* we will write sort-of IP */\n    err = ssh_buffer_add_u32(header, htonl(DLT_RAW));\n    if (err < 0) {\n        goto error;\n    }\n    err = ssh_pcap_file_write(pcap,header);\nerror:\n    SSH_BUFFER_FREE(header);\n    return err;\n}\n",
      "line_start": 205,
      "line_end": 268,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 91,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Mostly a wrapper that opens a file and writes a fixed PCAP header; minimal logic and no parsing of complex external data. The only external input (filename) is used for fopen, so low value as a fuzz target."
    },
    {
      "name": "ssh_pcap_file_close",
      "clean_name": "ssh_pcap_file_close",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "error:\n    SSH_BUFFER_FREE(header);\n    return err;\n}\n\nint ssh_pcap_file_close(ssh_pcap_file pcap)\n{\n    int err;\n\n    if (pcap == NULL || pcap->output == NULL) {\n        return SSH_ERROR;\n    }\n    err = fclose(pcap->output);\n    pcap->output = NULL;\n    if (err != 0) {\n        return SSH_ERROR;\n    } else {\n        return SSH_OK;\n    }\n}\n",
      "line_start": 269,
      "line_end": 284,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple resource-cleanup wrapper: checks for NULL, calls fclose and clears pointer. Minimal logic and no parsing of external data, no loops or complex branches \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_pcap_context_new",
      "clean_name": "ssh_pcap_context_new",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "\n\n/** @internal\n * @brief allocates a new ssh_pcap_context object\n */\nssh_pcap_context ssh_pcap_context_new(ssh_session session)\n{\n    ssh_pcap_context ctx = NULL;\n\n    ctx = calloc(1, sizeof(struct ssh_pcap_context_struct));\n    if (ctx == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    ctx->session = session;\n    return ctx;\n}\n",
      "line_start": 295,
      "line_end": 307,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple allocator/initializer: just calloc and assign a session pointer with trivial error handling. No parsing of external input, no complex logic, no loops or buffer manipulation\u2014minimal value as a fuzz target."
    },
    {
      "name": "ssh_set_pcap_file",
      "clean_name": "ssh_set_pcap_file",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": " * @param current session\n * @param pcap a handler to a pcap file. A pcap file may be used in several\n * sessions.\n * @returns SSH_ERROR in case of error, SSH_OK otherwise.\n */\nint ssh_set_pcap_file(ssh_session session, ssh_pcap_file pcap)\n{\n    ssh_pcap_context ctx = ssh_pcap_context_new(session);\n    if (ctx == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    ctx->file = pcap;\n    if (session->pcap_ctx) {\n        ssh_pcap_context_free(session->pcap_ctx);\n    }\n    session->pcap_ctx = ctx;\n    return SSH_OK;\n}\n",
      "line_start": 529,
      "line_end": 543,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper: allocates a pcap context, assigns/free pointers and returns status. Minimal branching (NULL check) and no parsing or memory ops on untrusted input, so low value as a fuzz target."
    },
    {
      "name": "pcap.c:ssh_pcap_file_write",
      "clean_name": "ssh_pcap_file_write",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "}\n\n/** @internal\n * @brief writes a packet on file\n */\nstatic int ssh_pcap_file_write(ssh_pcap_file pcap, ssh_buffer packet)\n{\n    int err;\n    uint32_t len;\n    if (pcap == NULL || pcap->output == NULL) {\n        return SSH_ERROR;\n    }\n    len = ssh_buffer_get_len(packet);\n    err = fwrite(ssh_buffer_get(packet), len, 1, pcap->output);\n    if (err < 0) {\n        return SSH_ERROR;\n    } else {\n        return SSH_OK;\n    }\n}\n",
      "line_start": 139,
      "line_end": 154,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very simple wrapper that writes a buffer to a FILE*: no parsing, no loops, minimal branching and no security-critical logic. Limited value as a fuzz target (aside from exercising fwrite/file-I/O); note the incorrect fwrite error check but overall low complexity."
    },
    {
      "name": "pki_privatekey_type_from_string",
      "clean_name": "pki_privatekey_type_from_string",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "#define MAX_LINE_SIZE 4096\n#endif /* NOT MAX_LINE_SIZE */\n\n#define PKCS11_URI \"pkcs11:\"\n\nenum ssh_keytypes_e pki_privatekey_type_from_string(const char *privkey)\n{\n    char *start = NULL;\n\n    start = strstr(privkey, RSA_HEADER_BEGIN);\n    if (start != NULL) {\n        return SSH_KEYTYPE_RSA;\n    }\n\n    start = strstr(privkey, ECDSA_HEADER_BEGIN);\n    if (start != 0) {\n        /* We don't know what the curve is at this point, so we don't actually\n         * know the type. We figure out the actual curve and fix things up in\n         * pki_private_key_from_base64 */\n        return SSH_KEYTYPE_ECDSA_P256;\n    }\n\n    return SSH_KEYTYPE_UNKNOWN;\n}\n",
      "line_start": 61,
      "line_end": 80,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very low complexity string scanning: function simply calls strstr twice on the input and returns a constant enum. It does not perform memory writes, complex parsing, loops controlled by input, or crypto/auth operations. Minimal branching and logic make it a low-value fuzz target (aside from a potential NULL-input crash if caller passes NULL)."
    },
    {
      "name": "ssh_pki_key_ecdsa_name",
      "clean_name": "ssh_pki_key_ecdsa_name",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @returns the ECDSA key name (\"ecdsa-sha2-nistp256\" for example)\n *\n * @returns \"unknown\" if the ECDSA key name is not known\n */\nconst char *ssh_pki_key_ecdsa_name(const ssh_key key)\n{\n    if (key == NULL) {\n        return NULL;\n    }\n\n#ifdef HAVE_ECC /* FIXME Better ECC check needed */\n    return pki_key_ecdsa_nid_to_name(key->ecdsa_nid);\n#else\n    return NULL;\n#endif /* HAVE_ECC */\n}\n",
      "line_start": 90,
      "line_end": 102,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only a NULL check and a call to a mapping function. No parsing, memory manipulation, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_key_free",
      "clean_name": "ssh_key_free",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "\n/**\n * @brief deallocate a SSH key\n * @param[in] key ssh_key handle to free\n */\nvoid ssh_key_free (ssh_key key)\n{\n    if (key) {\n        ssh_key_clean(key);\n        SAFE_FREE(key);\n    }\n}\n",
      "line_start": 247,
      "line_end": 254,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple deallocator wrapper: checks for NULL, calls ssh_key_clean and frees the pointer. No parsing of external input, no complex branching or input-dependent loops. Minimal fuzz value (low priority)."
    },
    {
      "name": "ssh_key_signature_to_char",
      "clean_name": "ssh_key_signature_to_char",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param[in] hash_type The hash type to convert\n *\n * @return              A string for the keytype or NULL if unknown.\n */\nconst char *\nssh_key_signature_to_char(enum ssh_keytypes_e type,\n                          enum ssh_digest_e hash_type)\n{\n    switch (type) {\n    case SSH_KEYTYPE_RSA:\n        switch (hash_type) {\n        case SSH_DIGEST_SHA256:\n            return \"rsa-sha2-256\";\n        case SSH_DIGEST_SHA512:\n            return \"rsa-sha2-512\";\n        case SSH_DIGEST_SHA1:\n        case SSH_DIGEST_AUTO:\n            return \"ssh-rsa\";\n        default:\n            return NULL;\n        }\n        break;\n    case SSH_KEYTYPE_RSA_CERT01:\n        switch (hash_type) {\n        case SSH_DIGEST_SHA256:\n            return \"rsa-sha2-256-cert-v01@openssh.com\";\n        case SSH_DIGEST_SHA512:\n            return \"rsa-sha2-512-cert-v01@openssh.com\";\n        case SSH_DIGEST_SHA1:\n        case SSH_DIGEST_AUTO:\n            return \"ssh-rsa-cert-v01@openssh.com\";\n        default:\n            return NULL;\n        }\n        break;\n    default:\n        return ssh_key_type_to_char(type);\n    }\n\n    /* We should never reach this */\n    return NULL;\n}\n",
      "line_start": 284,
      "line_end": 321,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 35,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial deterministic mapping: a switch-based function returning constant strings for enum inputs. No parsing of external data, no memory or string operations on untrusted input, and only minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_key_type_to_char",
      "clean_name": "ssh_key_type_to_char",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in]  type     The type to convert.\n *\n * @return              A string for the keytype or NULL if unknown.\n */\nconst char *ssh_key_type_to_char(enum ssh_keytypes_e type) {\n  switch (type) {\n    case SSH_KEYTYPE_RSA:\n      return \"ssh-rsa\";\n    case SSH_KEYTYPE_ECDSA:\n      return \"ssh-ecdsa\"; /* deprecated. invalid value */\n    case SSH_KEYTYPE_ECDSA_P256:\n      return \"ecdsa-sha2-nistp256\";\n    case SSH_KEYTYPE_ECDSA_P384:\n      return \"ecdsa-sha2-nistp384\";\n    case SSH_KEYTYPE_ECDSA_P521:\n      return \"ecdsa-sha2-nistp521\";\n    case SSH_KEYTYPE_ED25519:\n      return \"ssh-ed25519\";\n    case SSH_KEYTYPE_RSA_CERT01:\n      return \"ssh-rsa-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n      return \"ecdsa-sha2-nistp256-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n      return \"ecdsa-sha2-nistp384-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n      return \"ecdsa-sha2-nistp521-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_ED25519_CERT01:\n      return \"ssh-ed25519-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_SK_ECDSA:\n      return \"sk-ecdsa-sha2-nistp256@openssh.com\";\n    case SSH_KEYTYPE_SK_ED25519:\n      return \"sk-ssh-ed25519@openssh.com\";\n    case SSH_KEYTYPE_SK_ECDSA_CERT01:\n      return \"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_SK_ED25519_CERT01:\n      return \"sk-ssh-ed25519-cert-v01@openssh.com\";\n    case SSH_KEYTYPE_DSS:   /* deprecated */\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_DSS_CERT01:    /* deprecated */\n    case SSH_KEYTYPE_UNKNOWN:\n      return NULL;\n  }\n\n  /* We should never reach this */\n  return NULL;\n}\n",
      "line_start": 329,
      "line_end": 371,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 41,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple enum-to-string mapping with no parsing, no memory or buffer operations, no loops and minimal branching \u2014 trivial wrapper logic and not a valuable fuzz target."
    },
    {
      "name": "ssh_key_hash_from_name",
      "clean_name": "ssh_key_hash_from_name",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "\n  /* We should never reach this */\n  return NULL;\n}\n\nenum ssh_digest_e ssh_key_hash_from_name(const char *name)\n{\n    if (name == NULL) {\n        /* TODO we should rather fail */\n        return SSH_DIGEST_AUTO;\n    }\n\n    if (strcmp(name, \"ssh-rsa\") == 0) {\n        return SSH_DIGEST_SHA1;\n    } else if (strcmp(name, \"rsa-sha2-256\") == 0) {\n        return SSH_DIGEST_SHA256;\n    } else if (strcmp(name, \"rsa-sha2-512\") == 0) {\n        return SSH_DIGEST_SHA512;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp256\") == 0) {\n        return SSH_DIGEST_SHA256;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp384\") == 0) {\n        return SSH_DIGEST_SHA384;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp521\") == 0) {\n        return SSH_DIGEST_SHA512;\n    } else if (strcmp(name, \"ssh-ed25519\") == 0) {\n        return SSH_DIGEST_AUTO;\n    } else if (strcmp(name, \"sk-ecdsa-sha2-nistp256@openssh.com\") == 0) {\n        return SSH_DIGEST_SHA256;\n    } else if (strcmp(name, \"sk-ssh-ed25519@openssh.com\") == 0) {\n        return SSH_DIGEST_AUTO;\n    }\n\n    SSH_LOG(SSH_LOG_TRACE, \"Unknown signature name %s\", name);\n\n    /* TODO we should rather fail */\n    return SSH_DIGEST_AUTO;\n}\n",
      "line_start": 372,
      "line_end": 404,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 58,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Takes a single string and performs simple strcmp checks to map names to an enum. No memory manipulation, no parsing of complex/structured input, no loops or length-dependent behavior \u2014 only a few trivial branches \u2014 so low value as a standalone fuzz target."
    },
    {
      "name": "ssh_key_size_allowed_rsa",
      "clean_name": "ssh_key_size_allowed_rsa",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "\n    SSH_LOG(SSH_LOG_DEBUG, \"Checking %s with list <%s>\", type, allowed_list);\n    return match_group(allowed_list, type);\n}\n\nbool ssh_key_size_allowed_rsa(int min_size, ssh_key key)\n{\n    int key_size = ssh_key_size(key);\n\n    if (min_size < RSA_MIN_KEY_SIZE) {\n        if (ssh_fips_mode()) {\n            min_size = 2048;\n        } else {\n            min_size = 1024;\n        }\n    }\n    return (key_size >= min_size);\n}\n",
      "line_start": 445,
      "line_end": 458,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that compares an ssh key size to a minimum (with one conditional branch and a global fips-mode check). No parsing of external input, no memory operations or complex control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_key_get_signature_algorithm",
      "clean_name": "ssh_key_get_signature_algorithm",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param[in]  type     The algorithm type to convert.\n *\n * @return              A string for the keytype or NULL if unknown.\n */\nconst char *\nssh_key_get_signature_algorithm(ssh_session session,\n                                enum ssh_keytypes_e type)\n{\n    enum ssh_digest_e hash_type;\n\n    if (type == SSH_KEYTYPE_RSA_CERT01) {\n        /* If we are talking to an old OpenSSH version which does not support\n         * rsa-sha2-{256,512}-cert-v01@openssh.com */\n        if ((session->openssh > 0) &&\n            (session->openssh < SSH_VERSION_INT(7, 8, 0)))\n        {\n            SSH_LOG(SSH_LOG_DEBUG,\n                    \"We are talking to an old OpenSSH (%x); \"\n                    \"using old cert format\",\n                    session->openssh);\n\n            return \"ssh-rsa-cert-v01@openssh.com\";\n        }\n    }\n\n    hash_type = ssh_key_type_to_hash(session, type);\n\n    return ssh_key_signature_to_char(type, hash_type);\n}\n",
      "line_start": 597,
      "line_end": 621,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper with minimal branching; no parsing of complex external input, no memory or buffer operations, and only delegates to helper functions. Low value as a standalone fuzz target."
    },
    {
      "name": "ssh_key_type_from_signature_name",
      "clean_name": "ssh_key_type_from_signature_name",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] name      The name to convert.\n *\n * @return              The enum ssh key algorithm type.\n */\nenum ssh_keytypes_e ssh_key_type_from_signature_name(const char *name) {\n    if (name == NULL) {\n        return SSH_KEYTYPE_UNKNOWN;\n    }\n\n    if ((strcmp(name, \"rsa-sha2-256\") == 0) ||\n        (strcmp(name, \"rsa-sha2-512\") == 0)) {\n        return SSH_KEYTYPE_RSA;\n    }\n\n    /* Otherwise the key type matches the signature type */\n    return ssh_key_type_from_name(name);\n}\n",
      "line_start": 629,
      "line_end": 642,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small, low-risk function: only a NULL check and two strcmp checks before delegating to ssh_key_type_from_name. No complex parsing, no memory manipulation on untrusted buffers, no loops or heavy branching. Minimal value as an isolated fuzz target."
    },
    {
      "name": "ssh_key_type_from_name",
      "clean_name": "ssh_key_type_from_name",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] name      The name to convert.\n *\n * @return              The enum ssh key type.\n */\nenum ssh_keytypes_e ssh_key_type_from_name(const char *name)\n{\n    if (name == NULL) {\n        return SSH_KEYTYPE_UNKNOWN;\n    }\n\n    if (strcmp(name, \"rsa\") == 0) {\n        return SSH_KEYTYPE_RSA;\n    } else if (strcmp(name, \"ssh-rsa\") == 0) {\n        return SSH_KEYTYPE_RSA;\n    } else if (strcmp(name, \"ssh-ecdsa\") == 0\n            || strcmp(name, \"ecdsa\") == 0\n            || strcmp(name, \"ecdsa-sha2-nistp256\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P256;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp384\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P384;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp521\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P521;\n    } else if (strcmp(name, \"ssh-ed25519\") == 0){\n        return SSH_KEYTYPE_ED25519;\n    } else if (strcmp(name, \"ssh-rsa-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_RSA_CERT01;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp256-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P256_CERT01;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp384-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P384_CERT01;\n    } else if (strcmp(name, \"ecdsa-sha2-nistp521-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_ECDSA_P521_CERT01;\n    } else if (strcmp(name, \"ssh-ed25519-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_ED25519_CERT01;\n    } else if(strcmp(name, \"sk-ecdsa-sha2-nistp256@openssh.com\") == 0) {\n        return SSH_KEYTYPE_SK_ECDSA;\n    } else if(strcmp(name, \"sk-ecdsa-sha2-nistp256-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_SK_ECDSA_CERT01;\n    } else if(strcmp(name, \"sk-ssh-ed25519@openssh.com\") == 0) {\n        return SSH_KEYTYPE_SK_ED25519;\n    } else if(strcmp(name, \"sk-ssh-ed25519-cert-v01@openssh.com\") == 0) {\n        return SSH_KEYTYPE_SK_ED25519_CERT01;\n    }\n\n    return SSH_KEYTYPE_UNKNOWN;\n}\n",
      "line_start": 650,
      "line_end": 692,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 89,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple mapping of exact string names to enums via strcmp with a NULL check. No complex parsing, no memory/buffer manipulation, no loops or conversions \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_key_type_plain",
      "clean_name": "ssh_key_type_plain",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] type   The certificate or public key type.\n *\n * @return           The matching public key type.\n */\nenum ssh_keytypes_e ssh_key_type_plain(enum ssh_keytypes_e type)\n{\n    switch (type) {\n        case SSH_KEYTYPE_RSA_CERT01:\n            return SSH_KEYTYPE_RSA;\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n            return SSH_KEYTYPE_ECDSA_P256;\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n            return SSH_KEYTYPE_ECDSA_P384;\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n            return SSH_KEYTYPE_ECDSA_P521;\n        case SSH_KEYTYPE_ED25519_CERT01:\n            return SSH_KEYTYPE_ED25519;\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n            return SSH_KEYTYPE_SK_ECDSA;\n        case SSH_KEYTYPE_SK_ED25519_CERT01:\n            return SSH_KEYTYPE_SK_ED25519;\n        default:\n            return type;\n    }\n}\n",
      "line_start": 700,
      "line_end": 721,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial enum-to-enum mapping via a simple switch. Deterministic, no parsing of external input, no memory operations or complex control flow\u2014minimal value as a fuzz target."
    },
    {
      "name": "ssh_key_is_public",
      "clean_name": "ssh_key_is_public",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] k         The key to check.\n *\n * @return              1 if it is a public key, 0 if not.\n */\nint ssh_key_is_public(const ssh_key k)\n{\n    if (k == NULL) {\n        return 0;\n    }\n\n    return (k->flags & SSH_KEY_FLAG_PUBLIC) == SSH_KEY_FLAG_PUBLIC;\n}\n",
      "line_start": 729,
      "line_end": 737,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only a NULL check and a bitmask test on an internal flags field. No parsing, memory operations, or complex control flow \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_key_is_private",
      "clean_name": "ssh_key_is_private",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param[in] k         The key to check.\n *\n * @return              1 if it is a private key, 0 if not.\n */\nint ssh_key_is_private(const ssh_key k) {\n    if (k == NULL) {\n        return 0;\n    }\n\n    return (k->flags & SSH_KEY_FLAG_PRIVATE) == SSH_KEY_FLAG_PRIVATE;\n}\n",
      "line_start": 745,
      "line_end": 752,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: just checks a flag bit on a provided pointer. No parsing, no memory operations, no complex control flow \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_pki_export_privkey_file",
      "clean_name": "ssh_pki_export_privkey_file",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @param[in]  filename  The path where to store the pem file.\n *\n * @return     SSH_OK on success, SSH_ERROR on error.\n */\nint\nssh_pki_export_privkey_file(const ssh_key privkey,\n                            const char *passphrase,\n                            ssh_auth_callback auth_fn,\n                            void *auth_data,\n                            const char *filename)\n{\n    return ssh_pki_export_privkey_file_format(privkey,\n                                              passphrase,\n                                              auth_fn,\n                                              auth_data,\n                                              filename,\n                                              SSH_FILE_FORMAT_DEFAULT);\n}\n",
      "line_start": 1295,
      "line_end": 1308,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that merely forwards arguments to ssh_pki_export_privkey_file_format; contains no parsing, memory ops, loops, or branching and thus is a low-value fuzz target."
    },
    {
      "name": "ssh_pki_convert_key_to_privatekey",
      "clean_name": "ssh_pki_convert_key_to_privatekey",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    ssh_key_free(tmp);\n\n    return pub;\n}\n\nssh_private_key ssh_pki_convert_key_to_privatekey(const ssh_key key)\n{\n    ssh_private_key privkey = NULL;\n\n    privkey = calloc(1, sizeof(struct ssh_private_key_struct));\n    if (privkey == NULL) {\n        ssh_key_free(key);\n        return NULL;\n    }\n\n    privkey->type = key->type;\n#if defined(HAVE_LIBMBEDCRYPTO)\n    privkey->rsa_priv = key->pk;\n#elif defined(HAVE_LIBCRYPTO)\n    privkey->key_priv = key->key;\n#else\n    privkey->rsa_priv = key->rsa;\n#endif /* HAVE_LIBCRYPTO */\n\n    return privkey;\n}\n",
      "line_start": 1349,
      "line_end": 1370,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple constructor-like wrapper: allocates a struct and copies pointers/type from the provided ssh_key. No parsing, no buffer/memory manipulation of untrusted data, minimal branching or loops \u2014 low fuzzing value."
    },
    {
      "name": "ssh_pki_import_cert_base64",
      "clean_name": "ssh_pki_import_cert_base64",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_cert_base64(const char *b64_cert,\n                               enum ssh_keytypes_e type,\n                               ssh_key *pkey)\n{\n    return ssh_pki_import_pubkey_base64(b64_cert, type, pkey);\n}\n",
      "line_start": 2120,
      "line_end": 2126,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that just forwards to ssh_pki_import_pubkey_base64; contains no parsing, branching, or memory operations itself. The real fuzzing value is in the underlying import function rather than this wrapper."
    },
    {
      "name": "ssh_pki_import_cert_blob",
      "clean_name": "ssh_pki_import_cert_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_cert_blob(const ssh_string cert_blob,\n                             ssh_key *pkey)\n{\n    return ssh_pki_import_pubkey_blob(cert_blob, pkey);\n}\n",
      "line_start": 2142,
      "line_end": 2147,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that immediately delegates to ssh_pki_import_pubkey_blob with no parsing, branching, or memory operations itself; the real fuzz target is the underlying import function."
    },
    {
      "name": "ssh_pki_import_cert_file",
      "clean_name": "ssh_pki_import_cert_file",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " * @returns SSH_OK on success, SSH_EOF if the file doesn't exist or permission\n *          denied, SSH_ERROR otherwise.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_import_cert_file(const char *filename, ssh_key *pkey)\n{\n    int rc;\n\n    rc = ssh_pki_import_pubkey_file(filename, pkey);\n    if (rc == SSH_OK) {\n        /* check the key is a cert type. */\n        if (!is_cert_type((*pkey)->type)) {\n            SSH_KEY_FREE(*pkey);\n            return SSH_ERROR;\n        }\n    }\n\n    return rc;\n}\n",
      "line_start": 2161,
      "line_end": 2176,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around ssh_pki_import_pubkey_file: no direct parsing of untrusted data, just a simple conditional check of the key type and a free. Minimal branching/logic makes it a low-value fuzz target (delegate does actual work)."
    },
    {
      "name": "ssh_pki_export_privkey_to_pubkey",
      "clean_name": "ssh_pki_export_privkey_to_pubkey",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_pki_export_privkey_to_pubkey(const ssh_key privkey,\n                                     ssh_key *pkey)\n{\n    ssh_key pubkey = NULL;\n\n    if (privkey == NULL || !ssh_key_is_private(privkey)) {\n        return SSH_ERROR;\n    }\n\n    pubkey = pki_key_dup(privkey, 1);\n    if (pubkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    *pkey = pubkey;\n    return SSH_OK;\n}\n",
      "line_start": 2282,
      "line_end": 2299,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/helper: only checks for NULL and private flag, calls pki_key_dup, no parsing of external input, no memory manipulation or complex branching. Low value as a fuzz target."
    },
    {
      "name": "pki_buffer_pack_sk_priv_data",
      "clean_name": "pki_buffer_pack_sk_priv_data",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_buffer_pack()\n */\nint pki_buffer_pack_sk_priv_data(ssh_buffer buffer, ssh_key key)\n{\n    return ssh_buffer_pack(buffer,\n                           \"SbSS\",\n                           key->sk_application,\n                           key->sk_flags,\n                           key->sk_key_handle,\n                           key->sk_reserved);\n}\n",
      "line_start": 2319,
      "line_end": 2328,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper that simply forwards key fields to ssh_buffer_pack; no parsing, branching, loops, or direct memory-manipulating logic in this function itself. Low fuzzing value (simple accessor/serializer call)."
    },
    {
      "name": "ssh_pki_export_pubkey_blob",
      "clean_name": "ssh_pki_export_pubkey_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR otherwise.\n *\n * @see ssh_string_free()\n */\nint ssh_pki_export_pubkey_blob(const ssh_key key,\n                               ssh_string *pblob)\n{\n    ssh_string blob = NULL;\n\n    if (key == NULL) {\n        return SSH_OK;\n    }\n\n    blob = pki_key_to_blob(key, SSH_KEY_PUBLIC);\n    if (blob == NULL) {\n        return SSH_ERROR;\n    }\n\n    *pblob = blob;\n    return SSH_OK;\n}\n",
      "line_start": 2378,
      "line_end": 2395,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper with minimal logic: checks for NULL, calls pki_key_to_blob, and assigns the result. It does not parse external input or perform memory/buffer operations itself \u2014 the real complexity is in pki_key_to_blob, which would be the appropriate fuzz target."
    },
    {
      "name": "ssh_pki_export_privkey_blob",
      "clean_name": "ssh_pki_export_privkey_blob",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR otherwise.\n *\n * @see ssh_string_free()\n */\nint ssh_pki_export_privkey_blob(const ssh_key key,\n                                ssh_string *pblob)\n{\n    ssh_string blob = NULL;\n\n    if (key == NULL) {\n        return SSH_OK;\n    }\n\n    blob = pki_key_to_blob(key, SSH_KEY_PRIVATE);\n    if (blob == NULL) {\n        return SSH_ERROR;\n    }\n\n    *pblob = blob;\n    return SSH_OK;\n}\n",
      "line_start": 2413,
      "line_end": 2430,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper with minimal logic: just a NULL check and a call to pki_key_to_blob, no parsing or memory manipulation here, no loops or branching complexity. The real work (and fuzzing value) would be in pki_key_to_blob, not this function."
    },
    {
      "name": "pki_do_sign",
      "clean_name": "pki_do_sign",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    }\n\n    return pki_verify_data_signature(sig, key, input, input_len);\n}\n\nssh_signature pki_do_sign(const ssh_key privkey,\n                          const unsigned char *input,\n                          size_t input_len,\n                          enum ssh_digest_e hash_type)\n{\n    int rc;\n\n    if (privkey == NULL || input == NULL) {\n        SSH_LOG(SSH_LOG_TRACE, \"Bad parameter provided to \"\n                               \"pki_do_sign()\");\n        return NULL;\n    }\n\n    /* Check if public key and hash type are compatible */\n    rc = pki_key_check_hash_compatible(privkey, hash_type);\n    if (rc != SSH_OK) {\n        return NULL;\n    }\n\n    return pki_sign_data(privkey, hash_type, input, input_len);\n}\n",
      "line_start": 2909,
      "line_end": 2930,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around pki_sign_data: only NULL checks and a compatibility check, no parsing or direct memory/string operations or complex branching. Delegates real work to other functions, so low fuzzing value by itself."
    },
    {
      "name": "pki.c:key_type_to_hash",
      "clean_name": "key_type_to_hash",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *          to SHA-2 with SHA-512 digest (RFC8332) instead of the default for\n *          the SSH protocol (SHA1 with RSA ; RFC 4253).\n *\n * @see     ssh_key_type_to_hash()\n */\nstatic enum ssh_digest_e key_type_to_hash(enum ssh_keytypes_e type)\n{\n    switch (type) {\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_RSA:\n        return SSH_DIGEST_SHA512;\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_SK_ECDSA:\n        return SSH_DIGEST_SHA256;\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384:\n        return SSH_DIGEST_SHA384;\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521:\n        return SSH_DIGEST_SHA512;\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_SK_ED25519:\n        return SSH_DIGEST_AUTO;\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_DSS:        /* deprecated */\n    case SSH_KEYTYPE_DSS_CERT01: /* deprecated */\n    case SSH_KEYTYPE_ECDSA:\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_WARN,\n                \"Digest algorithm to be used with key type %u \"\n                \"is not defined\",\n                type);\n    }\n\n    /* We should never reach this */\n    return SSH_DIGEST_AUTO;\n}\n",
      "line_start": 500,
      "line_end": 535,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 30,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial enum-to-enum mapping via a simple switch. No parsing of external data, no memory/string operations, no loops or complex branching; minimal attack surface and low value as a fuzz target."
    },
    {
      "name": "ssh_pki_openssh_privkey_import",
      "clean_name": "ssh_pki_openssh_privkey_import",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": "    SAFE_FREE(pubkey0);\n    SAFE_FREE(privkeys);\n    return key;\n}\n\nssh_key ssh_pki_openssh_privkey_import(const char *text_key,\n                                       const char *passphrase,\n                                       ssh_auth_callback auth_fn,\n                                       void *auth_data)\n{\n    return ssh_pki_openssh_import(text_key, passphrase, auth_fn, auth_data, true);\n}\n",
      "line_start": 382,
      "line_end": 389,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards arguments to ssh_pki_openssh_import; contains no parsing, memory operations, or branching itself. Low value as a standalone fuzz target (fuzz the underlying import function instead)."
    },
    {
      "name": "ssh_pki_openssh_pubkey_import",
      "clean_name": "ssh_pki_openssh_pubkey_import",
      "source_file": "/src/libssh/src/pki_container_openssh.c",
      "source_code": "                                       void *auth_data)\n{\n    return ssh_pki_openssh_import(text_key, passphrase, auth_fn, auth_data, true);\n}\n\nssh_key ssh_pki_openssh_pubkey_import(const char *text_key)\n{\n    return ssh_pki_openssh_import(text_key, NULL, NULL, NULL, false);\n}\n",
      "line_start": 390,
      "line_end": 394,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper functions that only forward text_key (and NULLs/flags) to ssh_pki_openssh_import; they contain no parsing, memory ops, or branching themselves so have low direct value as fuzz targets (the real work is in the callee)."
    },
    {
      "name": "ssh_poll",
      "clean_name": "ssh_poll",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": "void ssh_poll_cleanup(void)\n{\n    return;\n}\n\nint ssh_poll(ssh_pollfd_t *fds, nfds_t nfds, int timeout)\n{\n    return poll((struct pollfd *)fds, nfds, timeout);\n}\n",
      "line_start": 96,
      "line_end": 100,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper around poll with no parsing, validation, or complex logic. It merely forwards parameters to the system poll syscall; minimal attack surface and low value as a fuzz target (simple wrapper with no branching or memory manipulation)."
    },
    {
      "name": "ssh_poll_new",
      "clean_name": "ssh_poll_new",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *\n * @return                  A new poll object, NULL on error\n */\n\nssh_poll_handle\nssh_poll_new(socket_t fd, short events, ssh_poll_callback cb, void *userdata)\n{\n    ssh_poll_handle p = NULL;\n\n    p = malloc(sizeof(struct ssh_poll_handle_struct));\n    if (p == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(p);\n\n    p->x.fd = fd;\n    p->events = events;\n    p->cb = cb;\n    p->cb_data = userdata;\n\n    return p;\n}\n",
      "line_start": 360,
      "line_end": 377,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple constructor/initializer: allocates and zeroes a struct and stores caller-provided values (fd, events, callback, userdata). No parsing, no loops, no memory/IO ops on untrusted data or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_poll_free",
      "clean_name": "ssh_poll_free",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @brief  Free a poll object.\n *\n * @param  p            Pointer to an already allocated poll object.\n */\n\nvoid ssh_poll_free(ssh_poll_handle p)\n{\n    if (p->ctx != NULL) {\n        ssh_poll_ctx_remove(p->ctx, p);\n        p->ctx = NULL;\n    }\n    SAFE_FREE(p);\n}\n",
      "line_start": 384,
      "line_end": 392,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial cleanup/wrapper function with minimal branching. It only conditionally calls a context-remove helper and frees memory; no parsing, no loops, no complex logic or handling of untrusted external input \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_poll_get_ctx",
      "clean_name": "ssh_poll_get_ctx",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *\n * @param  p            Pointer to an already allocated poll object.\n *\n * @return              Poll context or NULL if the poll object isn't attached.\n */\nssh_poll_ctx ssh_poll_get_ctx(ssh_poll_handle p)\n{\n    return p->ctx;\n}\n",
      "line_start": 400,
      "line_end": 404,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns p->ctx; no parsing, allocation, or memory operations on untrusted input, no branching \u2014 trivial getter and low-value fuzz target."
    },
    {
      "name": "ssh_poll_get_events",
      "clean_name": "ssh_poll_get_events",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *\n * @param  p            Pointer to an already allocated poll object.\n *\n * @return              Poll events.\n */\nshort ssh_poll_get_events(ssh_poll_handle p)\n{\n    return p->events;\n}\n",
      "line_start": 412,
      "line_end": 416,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns p->events with no parsing, branching, or memory manipulation. Minimal surface for fuzzing beyond null/dereference crashes; low priority as a fuzz target."
    },
    {
      "name": "ssh_poll_set_events",
      "clean_name": "ssh_poll_set_events",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *         only the POLLOUT can be set.\n *\n * @param  p            Pointer to an already allocated poll object.\n * @param  events       Poll events.\n */\nvoid ssh_poll_set_events(ssh_poll_handle p, short events)\n{\n    p->events = events;\n    if (p->ctx != NULL) {\n        if (!ssh_poll_is_locked(p)) {\n            p->ctx->pollfds[p->x.idx].events = events;\n        } else if (!(p->ctx->pollfds[p->x.idx].events & POLLOUT)) {\n            /* if locked, allow only setting POLLOUT to prevent recursive\n             * callbacks */\n            p->ctx->pollfds[p->x.idx].events = events & POLLOUT;\n        }\n    }\n}\n",
      "line_start": 425,
      "line_end": 438,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter with minimal branching: it assigns an events field and conditionally updates a pollfd entry. It does not parse complex external input, perform memory/raw buffer ops, or contain loops/complex parsing. While it indexes into an array (potential OOB risk if surrounding invariants are violated), the function itself is low-value as a fuzz target."
    },
    {
      "name": "ssh_poll_set_fd",
      "clean_name": "ssh_poll_set_fd",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * propagated to an associated poll context.\n *\n * @param  p            Pointer to an already allocated poll object.\n * @param  fd       New file descriptor.\n */\nvoid ssh_poll_set_fd(ssh_poll_handle p, socket_t fd)\n{\n    if (p->ctx != NULL) {\n        p->ctx->pollfds[p->x.idx].fd = fd;\n    } else {\n        p->x.fd = fd;\n    }\n}\n",
      "line_start": 446,
      "line_end": 454,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper with minimal logic: only a single conditional and direct assignment of an fd. No parsing, no memory operations on untrusted data, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_poll_add_events",
      "clean_name": "ssh_poll_add_events",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *         The events will also be propagated to an associated poll context.\n *\n * @param  p            Pointer to an already allocated poll object.\n * @param  events       Poll events.\n */\nvoid ssh_poll_add_events(ssh_poll_handle p, short events)\n{\n    ssh_poll_set_events(p, ssh_poll_get_events(p) | events);\n}\n",
      "line_start": 462,
      "line_end": 466,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that ORs an events flag into the poll handle via getters/setters. No parsing of external data, no memory/size operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_poll_remove_events",
      "clean_name": "ssh_poll_remove_events",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *         The events will also be propagated to an associated poll context.\n *\n * @param  p            Pointer to an already allocated poll object.\n * @param  events       Poll events.\n */\nvoid ssh_poll_remove_events(ssh_poll_handle p, short events)\n{\n    ssh_poll_set_events(p, ssh_poll_get_events(p) & ~events);\n}\n",
      "line_start": 474,
      "line_end": 478,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that clears flag bits: reads current events, performs a simple bitwise AND-NOT with the supplied short, and writes back. No parsing, no memory operations, no loops or complex branching \u2014 minimal fuzz value."
    },
    {
      "name": "ssh_poll_get_fd",
      "clean_name": "ssh_poll_get_fd",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  p            Pointer to an already allocated poll object.\n *\n * @return              Raw socket.\n */\n\nsocket_t ssh_poll_get_fd(ssh_poll_handle p)\n{\n    if (p->ctx != NULL) {\n        return p->ctx->pollfds[p->x.idx].fd;\n    }\n\n    return p->x.fd;\n}\n",
      "line_start": 487,
      "line_end": 495,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns a socket field with one small branch. No parsing, no loops, no memory/string ops, and minimal logic. While it does dereference an index and pointer, it is essentially a getter and offers low value as a fuzz target."
    },
    {
      "name": "ssh_poll_set_callback",
      "clean_name": "ssh_poll_set_callback",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  p            Pointer to an already allocated poll object.\n * @param  cb           Function to be called if any of the events are set.\n * @param  userdata     Userdata to be passed to the callback function. NULL if\n *                      not needed.\n */\nvoid ssh_poll_set_callback(ssh_poll_handle p,\n                           ssh_poll_callback cb,\n                           void *userdata)\n{\n    if (cb != NULL) {\n        p->cb = cb;\n        p->cb_data = userdata;\n    }\n}\n",
      "line_start": 503,
      "line_end": 512,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that assigns a callback and userdata if cb is non-NULL; no parsing, memory operations, loops, or branching logic of interest \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_poll_ctx_new",
      "clean_name": "ssh_poll_ctx_new",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *                      more memory is needed. This is for efficiency reasons,\n *                      i.e. don't allocate memory for each new poll object, but\n *                      for the next 5. Set it to 0 if you want to use the\n *                      library's default value.\n */\nssh_poll_ctx ssh_poll_ctx_new(size_t chunk_size)\n{\n    ssh_poll_ctx ctx;\n\n    ctx = malloc(sizeof(struct ssh_poll_ctx_struct));\n    if (ctx == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(ctx);\n\n    if (chunk_size == 0) {\n        chunk_size = SSH_POLL_CTX_CHUNK;\n    }\n\n    ctx->chunk_size = chunk_size;\n\n    return ctx;\n}\n",
      "line_start": 524,
      "line_end": 542,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple constructor/allocator: allocates and zeroes a struct and sets a default chunk_size if 0. Minimal logic, no parsing, complex branching, or unsafe operations on untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_poll_ctx_free",
      "clean_name": "ssh_poll_ctx_free",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": "/**\n * @brief  Free a poll context.\n *\n * @param  ctx          Pointer to an already allocated poll context.\n */\nvoid ssh_poll_ctx_free(ssh_poll_ctx ctx)\n{\n    if (ctx->polls_allocated > 0) {\n        while (ctx->polls_used > 0) {\n            ssh_poll_handle p = ctx->pollptrs[0];\n            /*\n             * The free function calls ssh_poll_ctx_remove() and decrements\n             * ctx->polls_used\n             */\n            ssh_poll_free(p);\n        }\n\n        SAFE_FREE(ctx->pollptrs);\n        SAFE_FREE(ctx->pollfds);\n    }\n\n    SAFE_FREE(ctx);\n}\n",
      "line_start": 548,
      "line_end": 566,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 34,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple resource cleanup: frees poll context and associated arrays and iteratively calls ssh_poll_free. Minimal branching and no parsing or handling of external input; mostly memory deallocation helper logic. Not a high-value fuzz target (only potential issues arise if supplied an already-corrupted ctx, but the function itself contains no complex input-driven logic)."
    },
    {
      "name": "ssh_poll_ctx_add_socket",
      "clean_name": "ssh_poll_ctx_add_socket",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param  ctx          Pointer to an already allocated poll context.\n * @param  s            A SSH socket handle\n *\n * @return              0 on success, < 0 on error\n */\nint ssh_poll_ctx_add_socket(ssh_poll_ctx ctx, ssh_socket s)\n{\n    ssh_poll_handle p = NULL;\n\n    p = ssh_socket_get_poll_handle(s);\n    if (p == NULL) {\n        return -1;\n    }\n    return ssh_poll_ctx_add(ctx, p);\n}\n",
      "line_start": 644,
      "line_end": 654,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Wrapper/adapter with minimal logic: it just retrieves a poll handle from the socket and delegates to ssh_poll_ctx_add. No parsing, memory operations, loops, or branching on untrusted data beyond a NULL check \u2014 low value as a direct fuzz target (the underlying functions may be higher priority)."
    },
    {
      "name": "ssh_poll_get_default_ctx",
      "clean_name": "ssh_poll_get_default_ctx",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @brief gets the default poll structure for the current session,\n * when used in blocking mode.\n * @param session SSH session\n * @returns the default ssh_poll_ctx\n */\nssh_poll_ctx ssh_poll_get_default_ctx(ssh_session session)\n{\n    if (session->default_poll_ctx != NULL) {\n        return session->default_poll_ctx;\n    }\n    /* 2 is enough for the default one */\n    session->default_poll_ctx = ssh_poll_ctx_new(2);\n    return session->default_poll_ctx;\n}\n",
      "line_start": 798,
      "line_end": 807,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/initializer: returns or lazily creates a default poll context with a fixed size. Minimal branching, no parsing of external input, no loops or memory operations on untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_event_add_fd",
      "clean_name": "ssh_event_add_fd",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *                      not needed.\n *\n * @returns SSH_OK      on success\n *          SSH_ERROR   on failure\n */\nint ssh_event_add_fd(ssh_event event,\n                     socket_t fd,\n                     short events,\n                     ssh_event_callback cb,\n                     void *userdata)\n{\n    ssh_poll_handle p = NULL;\n    struct ssh_event_fd_wrapper *pw = NULL;\n    int rc;\n\n    if (event == NULL || event->ctx == NULL || cb == NULL ||\n        fd == SSH_INVALID_SOCKET) {\n        return SSH_ERROR;\n    }\n    pw = malloc(sizeof(struct ssh_event_fd_wrapper));\n    if (pw == NULL) {\n        return SSH_ERROR;\n    }\n\n    pw->cb = cb;\n    pw->userdata = userdata;\n\n    /* pw is freed by ssh_event_remove_fd */\n    p = ssh_poll_new(fd, events, ssh_event_fd_wrapper_callback, pw);\n    if (p == NULL) {\n        free(pw);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_poll_ctx_add(event->ctx, p);\n    if (rc < 0) {\n        free(pw);\n        ssh_poll_free(p);\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 889,
      "line_end": 926,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: basic parameter validation, a single malloc, and delegation to ssh_poll_* functions. No parsing of external data, no buffer/string/memory manipulation on untrusted input, and minimal branching \u2014 low value as a direct fuzz target (fuzz ssh_poll_* or callers instead)."
    },
    {
      "name": "ssh_event_add_poll",
      "clean_name": "ssh_event_add_poll",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param   p         the poll handle\n *\n * @returns SSH_OK    on success\n *          SSH_ERROR on failure\n */\nint ssh_event_add_poll(ssh_event event, ssh_poll_handle p)\n{\n    return ssh_poll_ctx_add(event->ctx, p);\n}\n",
      "line_start": 937,
      "line_end": 941,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that just forwards to ssh_poll_ctx_add(event->ctx, p). No parsing of external input, no memory ops or branching here; minimal logic. The underlying ssh_poll_ctx_add implementation would be a more appropriate fuzz target."
    },
    {
      "name": "ssh_event_remove_poll",
      "clean_name": "ssh_event_remove_poll",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *\n * @param   event     the ssh_event\n *\n * @param   p         the poll handle\n */\nvoid ssh_event_remove_poll(ssh_event event, ssh_poll_handle p)\n{\n    ssh_poll_ctx_remove(event->ctx, p);\n}\n",
      "line_start": 949,
      "line_end": 953,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards event->ctx and p to ssh_poll_ctx_remove. No parsing, no branching, no memory operations or loops \u2014 minimal fuzz value (aside from potential null-dereference if event is invalid)."
    },
    {
      "name": "ssh_event_add_connector",
      "clean_name": "ssh_event_add_connector",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *\n * @return SSH_OK\n *\n * @return SSH_ERROR in case of error\n */\nint ssh_event_add_connector(ssh_event event, ssh_connector connector)\n{\n    return ssh_connector_set_event(connector, event);\n}\n",
      "line_start": 1021,
      "line_end": 1025,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards to ssh_connector_set_event; no parsing, no branching, no memory or buffer operations on untrusted data. Minimal value as a fuzz target \u2014 fuzz the underlying connector/event handling instead."
    },
    {
      "name": "ssh_event_dopoll",
      "clean_name": "ssh_event_dopoll",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @returns SSH_OK      on success.\n *          SSH_ERROR   Error happened during the poll. Check errno to get more\n *                      details about why it failed.\n *          SSH_AGAIN   Timeout occurred\n */\nint ssh_event_dopoll(ssh_event event, int timeout)\n{\n    int rc;\n\n    if (event == NULL || event->ctx == NULL) {\n        return SSH_ERROR;\n    }\n    rc = ssh_poll_ctx_dopoll(event->ctx, timeout);\n    return rc;\n}\n",
      "line_start": 1046,
      "line_end": 1056,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: only a NULL check and a direct call to ssh_poll_ctx_dopoll. No parsing, memory operations, or complex branching\u2014minimal value as a standalone fuzz target."
    },
    {
      "name": "ssh_event_remove_connector",
      "clean_name": "ssh_event_remove_connector",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @param[in] event The ssh_event object.\n * @param[in] connector connector object to remove\n * @return SSH_OK on success\n * @return SSH_ERROR on failure\n */\nint ssh_event_remove_connector(ssh_event event, ssh_connector connector)\n{\n    (void)event;\n    return ssh_connector_remove_event(connector);\n}\n",
      "line_start": 1170,
      "line_end": 1175,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper with no parsing or logic: it ignores the event parameter and simply forwards the connector to ssh_connector_remove_event. No branching, memory operations, or input-dependent loops \u2014 low value as a standalone fuzz target (may be covered by fuzzing the underlying remove function)."
    },
    {
      "name": "poll.c:ssh_event_fd_wrapper_callback",
      "clean_name": "ssh_event_fd_wrapper_callback",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": "#endif\n\n    return event;\n}\n\nstatic int ssh_event_fd_wrapper_callback(ssh_poll_handle p,\n                                         socket_t fd,\n                                         int revents,\n                                         void *userdata)\n{\n    struct ssh_event_fd_wrapper *pw = (struct ssh_event_fd_wrapper *)userdata;\n\n    (void)p;\n    if (pw->cb != NULL) {\n        return pw->cb(fd, revents, pw->userdata);\n    }\n    return 0;\n}\n",
      "line_start": 858,
      "line_end": 871,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Thin wrapper that merely forwards fd and revents to a user-provided callback. No parsing, memory manipulation, loops, or complex branching in this function itself; minimal value as a standalone fuzz target (only indirect value if the delegated callback is targeted)."
    },
    {
      "name": "ssh_get_serverbanner",
      "clean_name": "ssh_get_serverbanner",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session   The SSH session\n *\n * @return Returns the server banner string or NULL.\n */\nconst char* ssh_get_serverbanner(ssh_session session) {\n    if (!session) {\n        return NULL;\n    }\n    return session->serverbanner;\n}\n",
      "line_start": 414,
      "line_end": 420,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: returns session->serverbanner or NULL. No parsing, memory manipulation, loops, or complex logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_get_kex_algo",
      "clean_name": "ssh_get_kex_algo",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session   The SSH session\n *\n * @return Returns the key exchange algorithm string or NULL.\n */\nconst char* ssh_get_kex_algo(ssh_session session) {\n    if ((session == NULL) ||\n        (session->current_crypto == NULL)) {\n        return NULL;\n    }\n\n    switch (session->current_crypto->kex_type) {\n    case SSH_KEX_DH_GROUP1_SHA1:\n        return \"diffie-hellman-group1-sha1\";\n    case SSH_KEX_DH_GROUP14_SHA1:\n        return \"diffie-hellman-group14-sha1\";\n    case SSH_KEX_DH_GROUP14_SHA256:\n        return \"diffie-hellman-group14-sha256\";\n    case SSH_KEX_DH_GROUP16_SHA512:\n        return \"diffie-hellman-group16-sha512\";\n    case SSH_KEX_DH_GROUP18_SHA512:\n        return \"diffie-hellman-group18-sha512\";\n    case SSH_KEX_ECDH_SHA2_NISTP256:\n        return \"ecdh-sha2-nistp256\";\n    case SSH_KEX_ECDH_SHA2_NISTP384:\n        return \"ecdh-sha2-nistp384\";\n    case SSH_KEX_ECDH_SHA2_NISTP521:\n        return \"ecdh-sha2-nistp521\";\n    case SSH_KEX_CURVE25519_SHA256:\n        return \"curve25519-sha256\";\n    case SSH_KEX_CURVE25519_SHA256_LIBSSH_ORG:\n        return \"curve25519-sha256@libssh.org\";\n    case SSH_KEX_SNTRUP761X25519_SHA512_OPENSSH_COM:\n        return \"sntrup761x25519-sha512@openssh.com\";\n#ifdef WITH_GEX\n    case SSH_KEX_DH_GEX_SHA1:\n        return \"diffie-hellman-group-exchange-sha1\";\n    case SSH_KEX_DH_GEX_SHA256:\n        return \"diffie-hellman-group-exchange-sha256\";\n#endif /* WITH_GEX */\n    }\n\n    return NULL;\n}\n",
      "line_start": 428,
      "line_end": 467,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: maps an internal enum to constant strings with a null check. No parsing of external input, no memory operations on untrusted data, no loops or complex branching\u2014low-value fuzz target."
    },
    {
      "name": "ssh_get_cipher_in",
      "clean_name": "ssh_get_cipher_in",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session The SSH session.\n *\n * @return Returns cipher name or NULL.\n */\nconst char* ssh_get_cipher_in(ssh_session session) {\n    if ((session != NULL) &&\n        (session->current_crypto != NULL) &&\n        (session->current_crypto->in_cipher != NULL)) {\n        return session->current_crypto->in_cipher->name;\n    }\n    return NULL;\n}\n",
      "line_start": 475,
      "line_end": 483,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: performs simple NULL checks and returns a nested field (cipher name). No parsing, no memory manipulation, no loops or branching complexity \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_get_cipher_out",
      "clean_name": "ssh_get_cipher_out",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session The SSH session.\n *\n * @return Returns cipher name or NULL.\n */\nconst char* ssh_get_cipher_out(ssh_session session) {\n    if ((session != NULL) &&\n        (session->current_crypto != NULL) &&\n        (session->current_crypto->out_cipher != NULL)) {\n        return session->current_crypto->out_cipher->name;\n    }\n    return NULL;\n}\n",
      "line_start": 491,
      "line_end": 499,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 16,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks pointers and returns a name string. No parsing, no memory operations on untrusted data, no branching complexity or loops, and not security-critical \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_get_hmac_in",
      "clean_name": "ssh_get_hmac_in",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session The SSH session.\n *\n * @return Returns HMAC algorithm name or NULL if unknown.\n */\nconst char* ssh_get_hmac_in(ssh_session session) {\n    if ((session != NULL) &&\n        (session->current_crypto != NULL)) {\n        return ssh_hmac_type_to_string(session->current_crypto->in_hmac, session->current_crypto->in_hmac_etm);\n    }\n    return NULL;\n}\n",
      "line_start": 507,
      "line_end": 514,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: it only checks for NULL and delegates to ssh_hmac_type_to_string to return a name. No parsing, memory manipulation, loops, or complex control flow; minimal value as a fuzz target."
    },
    {
      "name": "ssh_get_hmac_out",
      "clean_name": "ssh_get_hmac_out",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session The SSH session.\n *\n * @return Returns HMAC algorithm name or NULL if unknown.\n */\nconst char* ssh_get_hmac_out(ssh_session session) {\n    if ((session != NULL) &&\n        (session->current_crypto != NULL)) {\n        return ssh_hmac_type_to_string(session->current_crypto->out_hmac, session->current_crypto->out_hmac_etm);\n    }\n    return NULL;\n}\n",
      "line_start": 522,
      "line_end": 529,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: performs null checks and returns a string derived from internal fields (out_hmac/out_hmac_etm). No parsing, no memory ops on untrusted data, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_session_socket_close",
      "clean_name": "ssh_session_socket_close",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @internal\n * @brief Close the connection socket if it is a socket created by us.\n * Does not close the sockets provided by the user through options API.\n */\nvoid\nssh_session_socket_close(ssh_session session)\n{\n    if (session->opts.fd == SSH_INVALID_SOCKET) {\n        ssh_socket_close(session->socket);\n    }\n    session->alive = 0;\n    session->session_state = SSH_SESSION_STATE_ERROR;\n}\n",
      "line_start": 536,
      "line_end": 544,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small wrapper that closes a socket and updates session state. No parsing of external input, no complex branching or memory/string operations; limited attack surface beyond the side-effect of closing a socket, so low fuzz priority."
    },
    {
      "name": "ssh_silent_disconnect",
      "clean_name": "ssh_silent_disconnect",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * Suitable if you forked and want to destroy this session.\n *\n * @param[in]  session  The SSH session to disconnect.\n */\nvoid\nssh_silent_disconnect(ssh_session session)\n{\n    if (session == NULL) {\n        return;\n    }\n\n    ssh_session_socket_close(session);\n    ssh_disconnect(session);\n}\n",
      "line_start": 553,
      "line_end": 562,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that only checks for NULL and calls session cleanup functions (socket close and disconnect). No parsing, no memory/string operations on untrusted data, and minimal control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_set_blocking",
      "clean_name": "ssh_set_blocking",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in]  session  The ssh session to change.\n *\n * @param[in]  blocking Zero for nonblocking mode.\n */\nvoid ssh_set_blocking(ssh_session session, int blocking)\n{\n    if (session == NULL) {\n        return;\n    }\n    session->flags &= ~SSH_SESSION_FLAG_BLOCKING;\n    session->flags |= blocking ? SSH_SESSION_FLAG_BLOCKING : 0;\n}\n",
      "line_start": 570,
      "line_end": 578,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that toggles a session flag. Minimal logic (null check + bit ops), no parsing of external complex input, no memory operations, loops, or security-critical processing \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_is_blocking",
      "clean_name": "ssh_is_blocking",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @brief Return the blocking mode of libssh\n * @param[in] session The SSH session\n * @returns 0 if the session is nonblocking,\n * @returns 1 if the functions may block.\n */\nint ssh_is_blocking(ssh_session session)\n{\n    return (session->flags & SSH_SESSION_FLAG_BLOCKING) ? 1 : 0;\n}\n",
      "line_start": 585,
      "line_end": 589,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: reads a single flag bit from the session and returns 0/1. No parsing of external input, no memory operations, and minimal control flow \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_blocking_flush",
      "clean_name": "ssh_blocking_flush",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *                    the poll() function.\n * @returns           SSH_OK on success, SSH_AGAIN if timeout occurred,\n *                    SSH_ERROR otherwise.\n */\n\nint ssh_blocking_flush(ssh_session session, int timeout){\n    int rc;\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    rc = ssh_handle_packets_termination(session, timeout,\n            ssh_flush_termination, session);\n    if (rc == SSH_ERROR) {\n        return rc;\n    }\n    if (!ssh_flush_termination(session)) {\n        rc = SSH_AGAIN;\n    }\n\n    return rc;\n}\n",
      "line_start": 611,
      "line_end": 628,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper with minimal logic: just a NULL check, a call-through to ssh_handle_packets_termination and a boolean check of ssh_flush_termination. No parsing of external input, no memory/string operations, low cyclomatic complexity. The real fuzzing value is in the called functions rather than this wrapper."
    },
    {
      "name": "ssh_get_fd",
      "clean_name": "ssh_get_fd",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @param[in] session   The ssh session to use.\n *\n * @return              The file descriptor of the connection, or -1 if it is\n *                      not connected\n */\nsocket_t ssh_get_fd(ssh_session session) {\n  if (session == NULL) {\n    return -1;\n  }\n\n  return ssh_socket_get_fd(session->socket);\n}\n",
      "line_start": 654,
      "line_end": 661,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor wrapper that returns a file descriptor with a single NULL check; no parsing, no memory operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_set_fd_toread",
      "clean_name": "ssh_set_fd_toread",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @brief Tell the session it has data to read on the file descriptor without\n * blocking.\n *\n * @param[in] session   The ssh session to use.\n */\nvoid ssh_set_fd_toread(ssh_session session) {\n  if (session == NULL) {\n    return;\n  }\n\n  ssh_socket_set_read_wontblock(session->socket);\n}\n",
      "line_start": 668,
      "line_end": 675,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: performs a NULL check then forwards session->socket to ssh_socket_set_read_wontblock. No parsing, no buffer/memory ops, no input-dependent branching or loops \u2014 minimal fuzzing value."
    },
    {
      "name": "ssh_set_fd_towrite",
      "clean_name": "ssh_set_fd_towrite",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "/**\n * @brief Tell the session it may write to the file descriptor without blocking.\n *\n * @param[in] session   The ssh session to use.\n */\nvoid ssh_set_fd_towrite(ssh_session session) {\n  if (session == NULL) {\n    return;\n  }\n\n  ssh_socket_set_write_wontblock(session->socket);\n}\n",
      "line_start": 681,
      "line_end": 688,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: only a NULL check and a call to ssh_socket_set_write_wontblock. No parsing, no memory or buffer operations, minimal control flow\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_set_fd_except",
      "clean_name": "ssh_set_fd_except",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "/**\n * @brief Tell the session it has an exception to catch on the file descriptor.\n *\n * \\param[in] session   The ssh session to use.\n */\nvoid ssh_set_fd_except(ssh_session session) {\n  if (session == NULL) {\n    return;\n  }\n\n  ssh_socket_set_except(session->socket);\n}\n",
      "line_start": 694,
      "line_end": 701,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that only checks for NULL and forwards session->socket to ssh_socket_set_except; no parsing, no memory operations, no branching on input \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_handle_packets",
      "clean_name": "ssh_handle_packets",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *                      specified in options. 0 means poll will return immediately.\n *                      This parameter is passed to the poll() function.\n *\n * @return              SSH_OK on success, SSH_ERROR otherwise.\n */\nint ssh_handle_packets(ssh_session session, int timeout)\n{\n    ssh_poll_handle spoll = NULL;\n    ssh_poll_ctx ctx = NULL;\n    int tm = timeout;\n    int rc;\n\n    if (session == NULL || session->socket == NULL) {\n        return SSH_ERROR;\n    }\n\n    spoll = ssh_socket_get_poll_handle(session->socket);\n    if (spoll == NULL) {\n        ssh_set_error_oom(session);\n        return SSH_ERROR;\n    }\n    ssh_poll_add_events(spoll, POLLIN);\n    ctx = ssh_poll_get_ctx(spoll);\n\n    if (ctx == NULL) {\n        ctx = ssh_poll_get_default_ctx(session);\n        if (ctx == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n        rc = ssh_poll_ctx_add(ctx, spoll);\n        if (rc != SSH_OK) {\n            return SSH_ERROR;\n        }\n    }\n\n    if (timeout == SSH_TIMEOUT_USER) {\n        if (ssh_is_blocking(session)) {\n            tm = ssh_make_milliseconds(session->opts.timeout,\n                                       session->opts.timeout_usec);\n        } else {\n            tm = 0;\n        }\n    }\n    rc = ssh_poll_ctx_dopoll(ctx, tm);\n    if (rc == SSH_ERROR) {\n        session->session_state = SSH_SESSION_STATE_ERROR;\n    }\n\n    return rc;\n}\n",
      "line_start": 721,
      "line_end": 767,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 70,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Mostly a thin orchestration/wrapper around poll/context APIs: checks pointers, sets events, chooses a timeout, and calls ssh_poll_ctx_dopoll. It has low cyclomatic complexity, no direct parsing or memory operations on untrusted data, and no crypto/auth logic. Better fuzz targets are the lower-level packet parsing or I/O handlers this function invokes."
    },
    {
      "name": "ssh_get_status",
      "clean_name": "ssh_get_status",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @returns A bitmask including SSH_CLOSED, SSH_READ_PENDING, SSH_WRITE_PENDING\n *          or SSH_CLOSED_ERROR which respectively means the session is closed,\n *          has data to read on the connection socket and session was closed\n *          due to an error.\n */\nint ssh_get_status(ssh_session session) {\n  int socketstate;\n  int r = 0;\n\n  if (session == NULL) {\n    return 0;\n  }\n\n  socketstate = ssh_socket_get_status(session->socket);\n\n  if (session->session_state == SSH_SESSION_STATE_DISCONNECTED) {\n    r |= SSH_CLOSED;\n  }\n  if (socketstate & SSH_READ_PENDING) {\n    r |= SSH_READ_PENDING;\n  }\n  if (socketstate & SSH_WRITE_PENDING) {\n      r |= SSH_WRITE_PENDING;\n  }\n  if ((session->session_state == SSH_SESSION_STATE_DISCONNECTED &&\n       (socketstate & SSH_CLOSED_ERROR)) ||\n      session->session_state == SSH_SESSION_STATE_ERROR) {\n    r |= SSH_CLOSED_ERROR;\n  }\n\n  return r;\n}\n",
      "line_start": 854,
      "line_end": 881,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 43,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor-style function that composes status flags: only a NULL check, small number of conditional flag checks, and a call to ssh_socket_get_status. No parsing of external input, no memory operations, no loops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_get_poll_flags",
      "clean_name": "ssh_get_poll_flags",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @returns A bitmask including SSH_READ_PENDING or SSH_WRITE_PENDING.\n *          For SSH_READ_PENDING, your invocation of poll() should include\n *          POLLIN.  For SSH_WRITE_PENDING, your invocation of poll() should\n *          include POLLOUT.\n */\nint ssh_get_poll_flags(ssh_session session)\n{\n  if (session == NULL) {\n    return 0;\n  }\n\n  return ssh_socket_get_poll_flags (session->socket);\n}\n",
      "line_start": 892,
      "line_end": 900,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/getter: only does a NULL check and delegates to ssh_socket_get_poll_flags. No parsing, memory operations, loops, or complex branching \u2014 low value as a standalone fuzz target."
    },
    {
      "name": "ssh_get_disconnect_message",
      "clean_name": "ssh_get_disconnect_message",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *                      disconnect, or NULL in which case the reason of the\n *                      disconnect may be found with ssh_get_error.\n *\n * @see ssh_get_error()\n */\nconst char *ssh_get_disconnect_message(ssh_session session) {\n  if (session == NULL) {\n    return NULL;\n  }\n\n  if (session->session_state != SSH_SESSION_STATE_DISCONNECTED) {\n    ssh_set_error(session, SSH_REQUEST_DENIED,\n        \"Connection not closed yet\");\n  } else if(!session->peer_discon_msg) {\n    ssh_set_error(session, SSH_FATAL,\n        \"Connection correctly closed but no disconnect message\");\n  } else {\n    return session->peer_discon_msg;\n  }\n\n  return NULL;\n}\n",
      "line_start": 912,
      "line_end": 929,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor-style function: it only validates the session pointer and state, possibly calls ssh_set_error, and returns an existing string pointer. No parsing, no memory operations on untrusted data, and minimal branching\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_get_version",
      "clean_name": "ssh_get_version",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param session       The ssh session to use.\n *\n * @return The SSH version as integer, < 0 on error.\n */\nint ssh_get_version(ssh_session session) {\n    if (session == NULL) {\n        return -1;\n    }\n\n    return 2;\n}\n",
      "line_start": 937,
      "line_end": 944,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor-style function: only a NULL check and returning a constant (2). No parsing, memory operations, or complex branching based on external input, so low value as a fuzz target."
    },
    {
      "name": "ssh_socket_exception_callback",
      "clean_name": "ssh_socket_exception_callback",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "/**\n * @internal\n * @brief Callback to be called when the socket received an exception code.\n * @param user is a pointer to session\n */\nvoid ssh_socket_exception_callback(int code, int errno_code, void *user){\n    ssh_session session = (ssh_session)user;\n\n    SSH_LOG(SSH_LOG_RARE,\n            \"Socket exception callback: %d (%d)\",\n            code,\n            errno_code);\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    if (errno_code == 0 && code == SSH_SOCKET_EXCEPTION_EOF) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: disconnected\");\n#ifdef _WIN32\n    } else if (errno_code == WSAENETDOWN) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: network down\");\n    } else if (errno_code == WSAENETUNREACH) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: network unreachable\");\n    } else if (errno_code == WSAENETRESET) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: network reset\");\n    } else if (errno_code == WSAECONNABORTED) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: connection aborted\");\n    } else if (errno_code == WSAECONNRESET) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Socket error: connection reset by peer\");\n    } else if (errno_code == WSAETIMEDOUT) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: connection timed out\");\n    } else if (errno_code == WSAECONNREFUSED) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: connection refused\");\n    } else if (errno_code == WSAEHOSTUNREACH) {\n        ssh_set_error(session, SSH_FATAL, \"Socket error: host unreachable\");\n#endif\n    } else {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Socket error: %s\",\n                      ssh_strerror(errno_code, err_msg, SSH_ERRNO_MSG_MAX));\n    }\n\n    session->ssh_connection_callback(session);\n}\n",
      "line_start": 950,
      "line_end": 990,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Low-value fuzz target: this is a simple socket-exception handler that only inspects integer codes, sets session state and error strings, and dispatches an existing callback. There is minimal branching, no parsing of complex external input, no loops or risky memory manipulation. (Only marginal interest is the indirect call to session->ssh_connection_callback if an attacker can supply a corrupted session pointer, but the function itself offers little surface for fuzzing.)"
    },
    {
      "name": "ssh_set_counters",
      "clean_name": "ssh_set_counters",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " * @param[in] scounter  Counter for byte data handled by the session sockets.\n *\n * @param[in] rcounter  Counter for byte and packet data handled by the session,\n *                      prior compression and SSH overhead.\n */\nvoid ssh_set_counters(ssh_session session, ssh_counter scounter,\n                              ssh_counter rcounter) {\n    if (session != NULL) {\n        session->socket_counter = scounter;\n        session->raw_counter = rcounter;\n    }\n}\n",
      "line_start": 1090,
      "line_end": 1097,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: it only assigns two counter values to a session if non-null. No parsing, no memory/buffer operations, no complex control flow or security-critical logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_get_server_publickey",
      "clean_name": "ssh_get_server_publickey",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @return              SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_key_free()\n */\nint ssh_get_server_publickey(ssh_session session, ssh_key *key)\n{\n    ssh_key pubkey = NULL;\n\n    if (session == NULL ||\n        session->current_crypto == NULL ||\n        session->current_crypto->server_pubkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    pubkey = ssh_key_dup(session->current_crypto->server_pubkey);\n    if (pubkey == NULL) {\n        return SSH_ERROR;\n    }\n\n    *key = pubkey;\n    return SSH_OK;\n}\n",
      "line_start": 1202,
      "line_end": 1220,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter: only null checks and a key duplication call. No parsing of external data, no complex branching or loops, minimal surface for fuzzing (low value as a fuzz target)."
    },
    {
      "name": "session.c:ssh_flush_termination",
      "clean_name": "ssh_flush_termination",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "{\n    return (session->flags & SSH_SESSION_FLAG_BLOCKING) ? 1 : 0;\n}\n\n/* Waits until the output socket is empty */\nstatic int ssh_flush_termination(void *c){\n  ssh_session session = c;\n  if (ssh_socket_buffered_write_bytes(session->socket) == 0 ||\n      session->session_state == SSH_SESSION_STATE_ERROR)\n    return 1;\n  else\n    return 0;\n}\n",
      "line_start": 591,
      "line_end": 599,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple predicate function: checks whether the output socket buffer is empty or the session is in an error state and returns 1/0. Minimal logic and branching, no parsing of external input, no memory or buffer manipulation, not suitable as a high-value fuzz target."
    },
    {
      "name": "ssh_string_new",
      "clean_name": "ssh_string_new",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param[in] size       The size of the string.\n *\n * @return               The newly allocated string, NULL on error.\n */\nstruct ssh_string_struct *ssh_string_new(size_t size)\n{\n    struct ssh_string_struct *str = NULL;\n\n    if (size > STRING_SIZE_MAX) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    str = malloc(sizeof(struct ssh_string_struct) + size);\n    if (str == NULL) {\n        return NULL;\n    }\n\n    str->size = htonl((uint32_t)size);\n    str->data[0] = 0;\n\n    return str;\n}\n",
      "line_start": 55,
      "line_end": 74,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple allocator/constructor: accepts a size, checks against STRING_SIZE_MAX, mallocs, sets a length field and a null byte. Minimal logic, no parsing of external data, no loops or complex branching and no memory operations on untrusted buffers \u2014 low fuzz value beyond trivial size-bound checks."
    },
    {
      "name": "ssh_string_len",
      "clean_name": "ssh_string_len",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param[in] s         The input SSH string.\n *\n * @return The size of the content of the string, 0 on error.\n */\nsize_t ssh_string_len(struct ssh_string_struct *s)\n{\n    size_t size;\n\n    if (s == NULL) {\n        return 0;\n    }\n\n    size = ntohl(s->size);\n    if (size > 0 && size <= STRING_SIZE_MAX) {\n        return size;\n    }\n\n    return 0;\n}\n",
      "line_start": 137,
      "line_end": 152,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/validator: it just reads a length field, applies ntohl, and checks bounds. Minimal logic and no parsing, memory ops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_string_copy",
      "clean_name": "ssh_string_copy",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param[in] s         String to copy.\n *\n * @return              Newly allocated copy of the string, NULL on error.\n */\nstruct ssh_string_struct *ssh_string_copy(struct ssh_string_struct *s)\n{\n    struct ssh_string_struct *new = NULL;\n    size_t len;\n\n    if (s == NULL) {\n        return NULL;\n    }\n\n    len = ssh_string_len(s);\n\n    new = ssh_string_new(len);\n    if (new == NULL) {\n        return NULL;\n    }\n\n    memcpy(new->data, s->data, len);\n\n    return new;\n}\n",
      "line_start": 225,
      "line_end": 245,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 21,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small helper: only a NULL check, length retrieval, allocation and memcpy. No parsing, no loops, no branching or crypto. Fuzzing value is low \u2014 any real issues would stem from ssh_string_len/ssh_string_new or corrupted invariants rather than this function itself."
    },
    {
      "name": "ssh_string_burn",
      "clean_name": "ssh_string_burn",
      "source_file": "/src/libssh/src/string.c",
      "source_code": "/**\n * @brief Destroy the data in a string so it couldn't appear in a core dump.\n *\n * @param[in] s         The string to burn.\n */\nvoid ssh_string_burn(struct ssh_string_struct *s)\n{\n    if (s == NULL || s->size == 0) {\n        return;\n    }\n\n    explicit_bzero(s->data, ssh_string_len(s));\n}\n",
      "line_start": 301,
      "line_end": 309,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that zeroes memory: trivial null/size check and a single explicit_bzero call. It does not parse or validate complex external input, has minimal branching and no input-dependent control flow, so it offers little value as a standalone fuzz target despite being security-related."
    },
    {
      "name": "ssh_string_data",
      "clean_name": "ssh_string_data",
      "source_file": "/src/libssh/src/string.c",
      "source_code": " *\n * @param s             The string to get the data from.\n *\n * @return              Return the data of the string or NULL on error.\n */\nvoid *ssh_string_data(struct ssh_string_struct *s)\n{\n    if (s == NULL) {\n        return NULL;\n    }\n\n    return s->data;\n}\n",
      "line_start": 317,
      "line_end": 325,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only a NULL check and return of an internal pointer. No parsing, memory operations, branching, or input-dependent logic \u2014 low value as a fuzz target."
    },
    {
      "name": "encode_current_tty_opts",
      "clean_name": "encode_current_tty_opts",
      "source_file": "/src/libssh/src/ttyopts.c",
      "source_code": " * @param[in]  buflen   The length of the buffer.\n *\n * @return              number of bytes in the buffer on success, -1 on error.\n */\nint\nencode_current_tty_opts(unsigned char *buf, size_t buflen)\n{\n#ifdef HAVE_TERMIOS_H\n    struct termios attr;\n    ZERO_STRUCT(attr);\n\n    if (isatty(STDIN_FILENO)) {\n        /* get local terminal attributes */\n        if (tcgetattr(STDIN_FILENO, &attr) < 0) {\n            perror(\"tcgetattr\");\n            return -1;\n        }\n        return encode_termios_opts(&attr, buf, buflen);\n    }\n#endif\n\n    /* use \"sane\" default attributes */\n    return encode_default_opts(buf, buflen);\n}\n",
      "line_start": 435,
      "line_end": 454,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: selects between live termios (via tcgetattr) or sane defaults and delegates to encode_termios_opts/encode_default_opts. Minimal logic, no parsing of untrusted input, no loops or complex branching. The real fuzz value is in the encoder functions called, not this wrapper."
    },
    {
      "name": "ttyopts.c:encode_termios_opt",
      "clean_name": "encode_termios_opt",
      "source_file": "/src/libssh/src/ttyopts.c",
      "source_code": " *\n * @return              number of bytes written to the buffer on success, -1 on\n * error.\n */\nstatic int\nencode_termios_opt(unsigned char opcode,\n                   uint32_t value,\n                   unsigned char *buf,\n                   size_t buflen)\n{\n    int offset = 0;\n\n    /* always need 5 bytes */\n    if (buflen < 5) {\n        return -1;\n    }\n\n    /* 1 byte opcode */\n    buf[offset++] = opcode;\n\n    /* 4 bytes value (big endian) */\n    value = htonl(value);\n    memcpy(buf + offset, &value, sizeof(value));\n    offset += sizeof(value);\n\n    return offset;\n}\n",
      "line_start": 112,
      "line_end": 134,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial fixed-size encoder: writes a 1-byte opcode + 4-byte htonl(value). Very low complexity (no parsing, no loops, minimal branching), memcpy copies from a local uint32, and output size is constant and checked. Minimal attack surface and low value as a fuzz target."
    },
    {
      "name": "ttyopts.c:encode_default_opts",
      "clean_name": "encode_default_opts",
      "source_file": "/src/libssh/src/ttyopts.c",
      "source_code": " * @param[in]  buflen   The length of the buffer.\n *\n * @return              number of bytes in the buffer on success, -1 on error.\n */\nstatic int\nencode_default_opts(unsigned char *buf, size_t buflen)\n{\n    unsigned int offset = 0;\n    int rc;\n\n#define SSH_ENCODE_OPT(code, value)                                      \\\n    rc = encode_termios_opt(code, value, buf + offset, buflen - offset); \\\n    if (rc < 0) {                                                        \\\n        return rc;                                                       \\\n    } else {                                                             \\\n        offset += rc;                                                    \\\n    }\n\n    SSH_ENCODE_OPT(TTY_OP_VINTR, 003)\n    SSH_ENCODE_OPT(TTY_OP_VQUIT, 034)\n    SSH_ENCODE_OPT(TTY_OP_VERASE, 0177)\n    SSH_ENCODE_OPT(TTY_OP_VKILL, 025)\n    SSH_ENCODE_OPT(TTY_OP_VEOF, 004)\n    SSH_ENCODE_OPT(TTY_OP_VEOL, 0)\n    SSH_ENCODE_OPT(TTY_OP_VEOL2, 0)\n    SSH_ENCODE_OPT(TTY_OP_VSTART, 021)\n    SSH_ENCODE_OPT(TTY_OP_VSTOP, 023)\n    SSH_ENCODE_OPT(TTY_OP_VSUSP, 032)\n    SSH_ENCODE_OPT(TTY_OP_VDSUSP, 031)\n    SSH_ENCODE_OPT(TTY_OP_VREPRINT, 022)\n    SSH_ENCODE_OPT(TTY_OP_VWERASE, 027)\n    SSH_ENCODE_OPT(TTY_OP_VLNEXT, 026)\n    SSH_ENCODE_OPT(TTY_OP_VDISCARD, 017)\n    SSH_ENCODE_OPT(TTY_OP_IGNPAR, 0)\n    SSH_ENCODE_OPT(TTY_OP_PARMRK, 0)\n    SSH_ENCODE_OPT(TTY_OP_INPCK, 0)\n    SSH_ENCODE_OPT(TTY_OP_ISTRIP, 0)\n    SSH_ENCODE_OPT(TTY_OP_INLCR, 0)\n    SSH_ENCODE_OPT(TTY_OP_IGNCR, 0)\n    SSH_ENCODE_OPT(TTY_OP_ICRNL, 1)\n    SSH_ENCODE_OPT(TTY_OP_IUCLC, 0)\n    SSH_ENCODE_OPT(TTY_OP_IXON, 1)\n    SSH_ENCODE_OPT(TTY_OP_IXANY, 0)\n    SSH_ENCODE_OPT(TTY_OP_IXOFF, 0)\n    SSH_ENCODE_OPT(TTY_OP_IMAXBEL, 0)\n    SSH_ENCODE_OPT(TTY_OP_IUTF8, 1)\n    SSH_ENCODE_OPT(TTY_OP_ISIG, 1)\n    SSH_ENCODE_OPT(TTY_OP_ICANON, 1)\n    SSH_ENCODE_OPT(TTY_OP_XCASE, 0)\n    SSH_ENCODE_OPT(TTY_OP_ECHO, 1)\n    SSH_ENCODE_OPT(TTY_OP_ECHOE, 1)\n    SSH_ENCODE_OPT(TTY_OP_ECHOK, 1)\n    SSH_ENCODE_OPT(TTY_OP_ECHONL, 0)\n    SSH_ENCODE_OPT(TTY_OP_NOFLSH, 0)\n    SSH_ENCODE_OPT(TTY_OP_TOSTOP, 0)\n    SSH_ENCODE_OPT(TTY_OP_IEXTEN, 1)\n    SSH_ENCODE_OPT(TTY_OP_ECHOCTL, 1)\n    SSH_ENCODE_OPT(TTY_OP_ECHOKE, 1)\n    SSH_ENCODE_OPT(TTY_OP_PENDIN, 0)\n    SSH_ENCODE_OPT(TTY_OP_OPOST, 1)\n    SSH_ENCODE_OPT(TTY_OP_OLCUC, 0)\n    SSH_ENCODE_OPT(TTY_OP_ONLCR, 1)\n    SSH_ENCODE_OPT(TTY_OP_OCRNL, 0)\n    SSH_ENCODE_OPT(TTY_OP_ONOCR, 0)\n    SSH_ENCODE_OPT(TTY_OP_ONLRET, 0)\n    SSH_ENCODE_OPT(TTY_OP_CS7, 1)\n    SSH_ENCODE_OPT(TTY_OP_CS8, 1)\n    SSH_ENCODE_OPT(TTY_OP_PARENB, 0)\n    SSH_ENCODE_OPT(TTY_OP_PARODD, 0)\n    SSH_ENCODE_OPT(TTY_OP_ISPEED, 38400);\n    SSH_ENCODE_OPT(TTY_OP_OSPEED, 38400);\n\n#undef SSH_ENCODE_OPT\n\n    /* end of options */\n    if (buflen > offset) {\n        buf[offset++] = TTY_OP_END;\n    } else {\n        return -1;\n    }\n\n    return (int)offset;\n}\n",
      "line_start": 330,
      "line_end": 408,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 382,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Deterministic encoder that writes fixed option values into a provided buffer. It does not parse or validate external structured input, has no input-dependent branching or loops, and only performs bounded writes (via encode_termios_opt). Limited attack surface beyond buffer-size checking, so low fuzzing value."
    },
    {
      "name": "ssh_hmac_type_to_string",
      "clean_name": "ssh_hmac_type_to_string",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "    default:\n      return 0;\n  }\n}\n\nconst char *ssh_hmac_type_to_string(enum ssh_hmac_e hmac_type, bool etm)\n{\n  int i = 0;\n  struct ssh_hmac_struct *ssh_hmactab = ssh_get_hmactab();\n  while (ssh_hmactab[i].name &&\n         ((ssh_hmactab[i].hmac_type != hmac_type) ||\n          (ssh_hmactab[i].etm != etm))) {\n    i++;\n  }\n  return ssh_hmactab[i].name;\n}\n",
      "line_start": 94,
      "line_end": 105,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple lookup/accessor: maps an enum and bool to a string by scanning a static table. Minimal logic and branching, no parsing, memory manipulation, or external input processing \u2014 low fuzzing value (small attack surface). Possible minor robustness issue if the table is malformed, but still low priority."
    },
    {
      "name": "ssh_cipher_clear",
      "clean_name": "ssh_cipher_clear",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "  memcpy(cipher, &ssh_get_ciphertab()[offset], sizeof(*cipher));\n\n  return cipher;\n}\n\nvoid ssh_cipher_clear(struct ssh_cipher_struct *cipher){\n#ifdef HAVE_LIBGCRYPT\n    unsigned int i;\n#endif\n\n    if (cipher == NULL) {\n        return;\n    }\n\n#ifdef HAVE_LIBGCRYPT\n    if (cipher->key) {\n        for (i = 0; i < (cipher->keylen / sizeof(gcry_cipher_hd_t)); i++) {\n            gcry_cipher_close(cipher->key[i]);\n        }\n        SAFE_FREE(cipher->key);\n    }\n#endif\n\n    if (cipher->cleanup != NULL) {\n        cipher->cleanup(cipher);\n    }\n}\n",
      "line_start": 121,
      "line_end": 143,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a cleanup/free function with minimal logic: null check, optional loop to close/free keys (loop bound comes from an internal keylen), and an optional callback invocation. It does not parse complex external input or perform buffer/format parsing; aside from the callback and the loop over an internal length, it presents low value as a fuzz target."
    },
    {
      "name": "crypt_set_algorithms_client",
      "clean_name": "crypt_set_algorithms_client",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "    }\n\n    return SSH_OK;\n}\n\nint crypt_set_algorithms_client(ssh_session session)\n{\n    return crypt_set_algorithms2(session);\n}\n",
      "line_start": 409,
      "line_end": 413,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards the session to crypt_set_algorithms2 with no parsing, memory operations, or branching; minimal value as a fuzz target."
    },
    {
      "name": "wrapper.c:cipher_free",
      "clean_name": "cipher_free",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "    if (cipher->cleanup != NULL) {\n        cipher->cleanup(cipher);\n    }\n}\n\nstatic void cipher_free(struct ssh_cipher_struct *cipher) {\n  ssh_cipher_clear(cipher);\n  SAFE_FREE(cipher);\n}\n",
      "line_start": 144,
      "line_end": 148,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple cleanup/free function: it calls ssh_cipher_clear and frees the struct. No parsing of external input, no complex logic, no loops or memory operations on untrusted data. Slightly security-relevant only because it frees/clears cipher state, but not a high-value fuzz target."
    },
    {
      "name": "wrapper.c:cipher_new",
      "clean_name": "cipher_new",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "  }\n  return ssh_hmactab[i].name;\n}\n\n/* it allocates a new cipher structure based on its offset into the global table */\nstatic struct ssh_cipher_struct *cipher_new(uint8_t offset) {\n  struct ssh_cipher_struct *cipher = NULL;\n\n  cipher = malloc(sizeof(struct ssh_cipher_struct));\n  if (cipher == NULL) {\n    return NULL;\n  }\n\n  /* note the memcpy will copy the pointers : so, you shouldn't free them */\n  memcpy(cipher, &ssh_get_ciphertab()[offset], sizeof(*cipher));\n\n  return cipher;\n}\n",
      "line_start": 107,
      "line_end": 120,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very simple allocator/wrapper: malloc + memcpy from a global table based on a single uint8_t offset. Low cyclomatic complexity and no parsing or complex logic. Lacks bounds checking on the offset (minor OOB/read risk), but overall not a high-value fuzz target."
    },
    {
      "name": "wrapper.c:compression_enable",
      "clean_name": "compression_enable",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "\n    SAFE_FREE(crypto);\n}\n\nstatic void\ncompression_enable(ssh_session session,\n                   enum ssh_crypto_direction_e direction,\n                   bool delayed)\n{\n    /* The delayed compression is turned on AFTER authentication. This means\n     * that we need to turn it on immediately in case of rekeying */\n    if (delayed && !(session->flags & SSH_SESSION_FLAG_AUTHENTICATED)) {\n        if (direction == SSH_DIRECTION_IN) {\n            session->next_crypto->delayed_compress_in = 1;\n        } else { /* SSH_DIRECTION_OUT */\n            session->next_crypto->delayed_compress_out = 1;\n        }\n    } else {\n        if (direction == SSH_DIRECTION_IN) {\n            session->next_crypto->do_compress_in = 1;\n        } else { /* SSH_DIRECTION_OUT */\n            session->next_crypto->do_compress_out = 1;\n        }\n    }\n}\n",
      "line_start": 234,
      "line_end": 254,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that just sets flag fields based on a direction and delayed boolean. Minimal logic and no parsing, memory operations, or external-input-driven control flow \u2014 low fuzzing value."
    },
    {
      "name": "ssh_config_get_cmd",
      "clean_name": "ssh_config_get_cmd",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "/* Returns the original string after skipping the leading whitespace\n * until finding LF.\n * This is useful in case we need to get the rest of the line (for example\n * external command).\n */\nchar *ssh_config_get_cmd(char **str)\n{\n    register char *c = NULL;\n    char *r = NULL;\n\n    /* Ignore leading spaces */\n    for (c = *str; *c; c++) {\n        if (! isblank(*c)) {\n            break;\n        }\n    }\n\n    for (r = c; *c; c++) {\n        if (*c == '\\n') {\n            *c = '\\0';\n            goto out;\n        }\n    }\n\nout:\n    *str = c + 1;\n\n    return r;\n}\n",
      "line_start": 39,
      "line_end": 63,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small, simple line parser: skips leading blanks, scans to newline and replaces it with '\\0'. Minimal branching and complexity, no complex parsing, no memory copies or security-critical ops \u2014 low priority for fuzzing."
    },
    {
      "name": "ssh_config_get_str_tok",
      "clean_name": "ssh_config_get_str_tok",
      "source_file": "/src/libssh/src/config_parser.c",
      "source_code": "    }\n\n    return notfound;\n}\n\nconst char *ssh_config_get_str_tok(char **str, const char *def)\n{\n    char *p = NULL;\n\n    p = ssh_config_get_token(str);\n    if (p && *p) {\n        return p;\n    }\n\n    return def;\n}\n",
      "line_start": 140,
      "line_end": 151,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 12,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper around ssh_config_get_token: returns a non-empty token or a default. Minimal logic (single branch), no parsing, loops, or direct memory manipulation. The interesting behavior is in ssh_config_get_token, not this function."
    },
    {
      "name": "ssh_tokens_free",
      "clean_name": "ssh_tokens_free",
      "source_file": "/src/libssh/src/token.c",
      "source_code": " * @brief Free the given tokens list structure. The used buffer is overwritten\n * with zeroes before freed.\n *\n * @param[in] tokens    The pointer to a structure to be freed;\n */\nvoid ssh_tokens_free(struct ssh_tokens_st *tokens)\n{\n    int i;\n    if (tokens == NULL) {\n        return;\n    }\n\n    if (tokens->tokens != NULL) {\n        for (i = 0; tokens->tokens[i] != NULL; i++) {\n            explicit_bzero(tokens->tokens[i], strlen(tokens->tokens[i]));\n        }\n    }\n\n    SAFE_FREE(tokens->buffer);\n    SAFE_FREE(tokens->tokens);\n    SAFE_FREE(tokens);\n}\n",
      "line_start": 41,
      "line_end": 58,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a simple cleanup/free routine (destructor-like) with minimal control flow. It does perform memory operations (explicit_bzero and frees) and a loop over tokens, but it does not parse complex external input or implement parsing/validation logic. While using strlen on token pointers could expose crashes with malformed data, overall it is a low-value standalone fuzz target compared to parsers/protocol handlers."
    },
    {
      "name": "pki_key_ecdsa_nid_to_name",
      "clean_name": "pki_key_ecdsa_nid_to_name",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "        default:\n            return SSH_KEYTYPE_UNKNOWN;\n    }\n}\n\nconst char *pki_key_ecdsa_nid_to_name(int nid)\n{\n    switch (nid) {\n        case NID_X9_62_prime256v1:\n            return \"ecdsa-sha2-nistp256\";\n        case NID_secp384r1:\n            return \"ecdsa-sha2-nistp384\";\n        case NID_secp521r1:\n            return \"ecdsa-sha2-nistp521\";\n        default:\n            break;\n    }\n\n    return \"unknown\";\n}\n",
      "line_start": 160,
      "line_end": 175,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial mapping function: takes an int and returns static string literals based on a small switch. No parsing, memory manipulation, or complex control flow \u2014 minimal value as a fuzz target."
    },
    {
      "name": "pki_key_ecdsa_nid_from_name",
      "clean_name": "pki_key_ecdsa_nid_from_name",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return \"unknown\";\n}\n\nint pki_key_ecdsa_nid_from_name(const char *name)\n{\n    if (strcmp(name, \"nistp256\") == 0) {\n        return NID_X9_62_prime256v1;\n    } else if (strcmp(name, \"nistp384\") == 0) {\n        return NID_secp384r1;\n    } else if (strcmp(name, \"nistp521\") == 0) {\n        return NID_secp521r1;\n    }\n\n    return -1;\n}\n",
      "line_start": 192,
      "line_end": 204,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial mapping: performs a few strcmp checks against three fixed strings and returns constants. Minimal branching, no parsing, no memory manipulation, and no security-critical or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "pki_privkey_build_ed25519",
      "clean_name": "pki_privkey_build_ed25519",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    return -1;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n#endif /* HAVE_OPENSSL_ECC */\n\nint pki_privkey_build_ed25519(ssh_key key,\n                              ssh_string pubkey,\n                              ssh_string privkey)\n{\n    EVP_PKEY *pkey = NULL;\n\n    if (ssh_string_len(pubkey) != ED25519_KEY_LEN ||\n        ssh_string_len(privkey) != (2 * ED25519_KEY_LEN)) {\n        SSH_LOG(SSH_LOG_TRACE, \"Invalid ed25519 key len\");\n        return SSH_ERROR;\n    }\n\n    pkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_ED25519,\n                                        NULL,\n                                        (const uint8_t *)ssh_string_data(privkey),\n                                        ED25519_KEY_LEN);\n    if (pkey == NULL) {\n        SSH_LOG(SSH_LOG_TRACE,\n                \"Failed to create ed25519 EVP_PKEY: %s\",\n                ERR_error_string(ERR_get_error(), NULL));\n        return SSH_ERROR;\n    }\n\n    key->key = pkey;\n\n    return SSH_OK;\n}\n",
      "line_start": 414,
      "line_end": 441,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper: only basic length checks and a single call to EVP_PKEY_new_raw_private_key. Minimal branching, no complex parsing, no loops or buffer manipulation in this function itself; low-value fuzz target (OpenSSL internals may be higher risk)."
    },
    {
      "name": "pki_signature_to_blob",
      "clean_name": "pki_signature_to_blob",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    ECDSA_SIG_free(ecdsa_sig);\n    SSH_BUFFER_FREE(buf);\n    return NULL;\n}\n\nssh_string pki_signature_to_blob(const ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n\n    switch(sig->type) {\n        case SSH_KEYTYPE_RSA:\n        case SSH_KEYTYPE_RSA1:\n            sig_blob = ssh_string_copy(sig->raw_sig);\n            break;\n        case SSH_KEYTYPE_ED25519:\n            sig_blob = pki_ed25519_signature_to_blob(sig);\n            break;\n        case SSH_KEYTYPE_ECDSA_P256:\n        case SSH_KEYTYPE_ECDSA_P384:\n        case SSH_KEYTYPE_ECDSA_P521:\n#ifdef HAVE_OPENSSL_ECC\n            sig_blob = pki_ecdsa_signature_to_blob(sig);\n            break;\n#endif /* HAVE_OPENSSL_ECC */\n        case SSH_KEYTYPE_SK_ECDSA:\n        case SSH_KEYTYPE_SK_ED25519:\n            /* For SK keys, signature data is already in raw_sig */\n            sig_blob = ssh_string_copy(sig->raw_sig);\n            break;\n        default:\n        case SSH_KEYTYPE_UNKNOWN:\n            SSH_LOG(SSH_LOG_TRACE, \"Unknown signature key type: %s\", sig->type_c);\n            return NULL;\n    }\n\n    return sig_blob;\n}\n",
      "line_start": 2121,
      "line_end": 2153,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple dispatcher that selects how to return an existing signature blob (copy or delegate). Minimal branching and no parsing, loops, or direct complex memory manipulation \u2014 the real attack surface is in the delegated pki_* functions, which are higher-value fuzz targets."
    },
    {
      "name": "pki_crypto.c:pki_key_ecdsa_to_key_type",
      "clean_name": "pki_key_ecdsa_to_key_type",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "#endif /* OPENSSL_VERSION_NUMBER */\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\nstatic enum ssh_keytypes_e pki_key_ecdsa_to_key_type(EC_KEY *k)\n#else\nstatic enum ssh_keytypes_e pki_key_ecdsa_to_key_type(EVP_PKEY *k)\n#endif /* OPENSSL_VERSION_NUMBER */\n{\n    int nid;\n\n    nid = pki_key_ecdsa_to_nid(k);\n\n    switch (nid) {\n        case NID_X9_62_prime256v1:\n            return SSH_KEYTYPE_ECDSA_P256;\n        case NID_secp384r1:\n            return SSH_KEYTYPE_ECDSA_P384;\n        case NID_secp521r1:\n            return SSH_KEYTYPE_ECDSA_P521;\n        default:\n            return SSH_KEYTYPE_UNKNOWN;\n    }\n}\n",
      "line_start": 141,
      "line_end": 159,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small helper that maps an ECDSA key NID to an enum via a simple switch. No parsing, no memory operations on untrusted data, no loops or complex branching. Fuzzing here offers little value \u2014 any issues are more likely in pki_key_ecdsa_to_nid or upstream key parsing."
    },
    {
      "name": "pki_crypto.c:pki_key_ecdsa_to_nid",
      "clean_name": "pki_key_ecdsa_to_nid",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    key->key = NULL;\n}\n\n#ifdef HAVE_OPENSSL_ECC\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\nstatic int pki_key_ecdsa_to_nid(EC_KEY *k)\n{\n    const EC_GROUP *g = EC_KEY_get0_group(k);\n    int nid;\n\n    if (g == NULL) {\n        return -1;\n    }\n    nid = EC_GROUP_get_curve_name(g);\n    if (nid) {\n        return nid;\n    }\n\n    return -1;\n}\n",
      "line_start": 104,
      "line_end": 119,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small wrapper/utility: it only queries an EC_KEY for its EC_GROUP and returns the curve NID or -1. No parsing of external data, no memory manipulation, minimal control flow \u2014 low fuzzing value."
    },
    {
      "name": "pki_crypto.c:pki_key_ecdsa_nid_to_char",
      "clean_name": "pki_key_ecdsa_nid_to_char",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return \"unknown\";\n}\n\nstatic const char *pki_key_ecdsa_nid_to_char(int nid)\n{\n    switch (nid) {\n        case NID_X9_62_prime256v1:\n            return \"nistp256\";\n        case NID_secp384r1:\n            return \"nistp384\";\n        case NID_secp521r1:\n            return \"nistp521\";\n        default:\n            break;\n    }\n\n    return \"unknown\";\n}\n",
      "line_start": 176,
      "line_end": 191,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple deterministic mapping from an integer to constant strings with no parsing, memory manipulation, or complex control flow. Minimal attack surface and low value as a fuzz target."
    },
    {
      "name": "pki_crypto.c:pki_digest_to_md",
      "clean_name": "pki_digest_to_md",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "error:\n    ssh_signature_free(sig);\n    return NULL;\n}\n\nstatic const EVP_MD *pki_digest_to_md(enum ssh_digest_e hash_type)\n{\n    const EVP_MD *md = NULL;\n\n    switch (hash_type) {\n    case SSH_DIGEST_SHA256:\n        md = EVP_sha256();\n        break;\n    case SSH_DIGEST_SHA384:\n        md = EVP_sha384();\n        break;\n    case SSH_DIGEST_SHA512:\n        md = EVP_sha512();\n        break;\n    case SSH_DIGEST_SHA1:\n        md = EVP_sha1();\n        break;\n    case SSH_DIGEST_AUTO:\n        md = NULL;\n        break;\n    default:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown hash algorithm for type: %d\",\n                hash_type);\n        return NULL;\n    }\n\n    return md;\n}\n",
      "line_start": 2443,
      "line_end": 2471,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 22,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple mapping from an enum to EVP digest functions with minimal branching. No parsing of external input, no memory/buffer operations, no loops, and no security-critical processing \u2014 low-value fuzz target."
    },
    {
      "name": "pki_crypto.c:pki_key_to_pkey",
      "clean_name": "pki_key_to_pkey",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return md;\n}\n\nstatic EVP_PKEY *pki_key_to_pkey(ssh_key key)\n{\n    EVP_PKEY *pkey = NULL;\n    int rc = 0;\n\n    switch (key->type) {\n    case SSH_KEYTYPE_RSA:\n    case SSH_KEYTYPE_RSA1:\n    case SSH_KEYTYPE_RSA_CERT01:\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n    case SSH_KEYTYPE_ECDSA_P256_CERT01:\n    case SSH_KEYTYPE_ECDSA_P384_CERT01:\n    case SSH_KEYTYPE_ECDSA_P521_CERT01:\n    case SSH_KEYTYPE_SK_ECDSA:\n    case SSH_KEYTYPE_SK_ECDSA_CERT01:\n    case SSH_KEYTYPE_ED25519:\n    case SSH_KEYTYPE_ED25519_CERT01:\n    case SSH_KEYTYPE_SK_ED25519:\n    case SSH_KEYTYPE_SK_ED25519_CERT01:\n        if (key->key == NULL) {\n            SSH_LOG(SSH_LOG_TRACE, \"NULL key->key\");\n            goto error;\n        }\n        rc = EVP_PKEY_up_ref(key->key);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE, \"Failed to reference EVP_PKEY\");\n            return NULL;\n        }\n        pkey = key->key;\n        break;\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_TRACE, \"Unknown private key algorithm for type: %d\",\n                key->type);\n        goto error;\n    }\n\n    return pkey;\n\nerror:\n    EVP_PKEY_free(pkey);\n    return NULL;\n}\n",
      "line_start": 2472,
      "line_end": 2517,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 47,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple accessor/wrapper: it switches on an enum, checks key->key, increments EVP_PKEY refcount and returns it. No parsing, no buffer or string operations, minimal branching. Only minor crash surface if caller supplies a NULL/malformed ssh_key, so low value as a fuzz target."
    },
    {
      "name": "ecdh_crypto.c:ecdh_kex_type_to_curve",
      "clean_name": "ecdh_kex_type_to_curve",
      "source_file": "/src/libssh/src/ecdh_crypto.c",
      "source_code": "\n/** @internal\n * @brief Map the given key exchange enum value to its curve name.\n */\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\nstatic int ecdh_kex_type_to_curve(enum ssh_key_exchange_e kex_type) {\n#else\nstatic const char *ecdh_kex_type_to_curve(enum ssh_key_exchange_e kex_type) {\n#endif /* OPENSSL_VERSION_NUMBER */\n    if (kex_type == SSH_KEX_ECDH_SHA2_NISTP256) {\n        return NISTP256;\n    } else if (kex_type == SSH_KEX_ECDH_SHA2_NISTP384) {\n        return NISTP384;\n    } else if (kex_type == SSH_KEX_ECDH_SHA2_NISTP521) {\n        return NISTP521;\n    }\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    return SSH_ERROR;\n#else\n    return NULL;\n#endif\n}\n",
      "line_start": 49,
      "line_end": 66,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial enum-to-constant mapping with simple if/else branches. No parsing of external input, no memory operations, no complex control flow \u2014 a low-value fuzz target (simple wrapper/lookup)."
    },
    {
      "name": "ssh_get_random",
      "clean_name": "ssh_get_random",
      "source_file": "/src/libssh/src/getrandom_crypto.c",
      "source_code": " * @param[in]  strong   Use a strong or private RNG source.\n *\n * @return 1 on success, 0 on error.\n */\nint\nssh_get_random(void *where, int len, int strong)\n{\n#ifdef HAVE_OPENSSL_RAND_PRIV_BYTES\n    if (strong) {\n        /* Returns -1 when not supported, 0 on error, 1 on success */\n        return !!RAND_priv_bytes(where, len);\n    }\n#else\n    (void)strong;\n#endif /* HAVE_RAND_PRIV_BYTES */\n\n    /* Returns -1 when not supported, 0 on error, 1 on success */\n    return !!RAND_bytes(where, len);\n}\n",
      "line_start": 46,
      "line_end": 60,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around OpenSSL RAND_bytes/RAND_priv_bytes with minimal branching and no parsing of external structured input. It performs no input-dependent memory parsing or loops; mostly a trivial wrapper/crypto helper \u2014 low value as a standalone fuzz target (could be exercised indirectly as part of larger targets)."
    },
    {
      "name": "sha1_final",
      "clean_name": "sha1_final",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha1_final(unsigned char *md, SHACTX c)\n{\n    unsigned int mdlen = 0;\n    int rc = EVP_DigestFinal(c, md, &mdlen);\n\n    EVP_MD_CTX_free(c);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 65,
      "line_end": 76,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper around EVP_DigestFinal and EVP_MD_CTX_free with minimal logic and a single return-path check. No parsing of external input, no complex branching or input-dependent memory operations\u2014low value as a fuzz target."
    },
    {
      "name": "sha256_ctx_free",
      "clean_name": "sha256_ctx_free",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return c;\n}\n\nvoid\nsha256_ctx_free(SHA256CTX c)\n{\n    EVP_MD_CTX_free(c);\n}\n",
      "line_start": 111,
      "line_end": 115,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that frees an EVP_MD_CTX. No parsing, branching, or processing of untrusted input; minimal logic. Not a valuable primary fuzz target (might be exercised indirectly)."
    },
    {
      "name": "sha384_final",
      "clean_name": "sha384_final",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nsha384_final(unsigned char *md, SHA384CTX c)\n{\n    unsigned int mdlen = 0;\n    int rc = EVP_DigestFinal(c, md, &mdlen);\n\n    EVP_MD_CTX_free(c);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 189,
      "line_end": 200,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around EVP_DigestFinal/EVP_MD_CTX_free with minimal logic and no parsing of external structured input. No loops/branching or complex processing; small risk only from caller-provided buffer size but overall low fuzz value."
    },
    {
      "name": "md5_ctx_free",
      "clean_name": "md5_ctx_free",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return c;\n}\n\nvoid\nmd5_ctx_free(MD5CTX c)\n{\n    EVP_MD_CTX_free(c);\n}\n",
      "line_start": 297,
      "line_end": 301,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper around EVP_MD_CTX_free; no parsing, branching, or input-dependent logic. Limited fuzzing value (simple memory free), though minor potential for memory-management issues (double-free/null) exists."
    },
    {
      "name": "md5_final",
      "clean_name": "md5_final",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return SSH_OK;\n}\n\nint\nmd5_final(unsigned char *md, MD5CTX c)\n{\n    unsigned int mdlen = 0;\n    int rc = EVP_DigestFinal(c, md, &mdlen);\n\n    EVP_MD_CTX_free(c);\n    if (rc != 1) {\n        return SSH_ERROR;\n    }\n    return SSH_OK;\n}\n",
      "line_start": 313,
      "line_end": 324,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper around EVP_DigestFinal: no parsing of complex external input, no loops or branching, minimal logic (calls library, frees context). Limited fuzzing value beyond checking misuse/null pointers or upstream context issues."
    },
    {
      "name": "ssh_dh_debug_crypto",
      "clean_name": "ssh_dh_debug_crypto",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "#else\n    EVP_PKEY *keypair[2];\n#endif /* OPENSSL_VERSION_NUMBER */\n};\n\nvoid ssh_dh_debug_crypto(struct ssh_crypto_struct *c)\n{\n#ifdef DEBUG_CRYPTO\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    const_bignum x = NULL, y = NULL, e = NULL, f = NULL;\n#else\n    bignum x = NULL, y = NULL, e = NULL, f = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    ssh_dh_keypair_get_keys(c->dh_ctx, DH_CLIENT_KEYPAIR, &x, &e);\n    ssh_dh_keypair_get_keys(c->dh_ctx, DH_SERVER_KEYPAIR, &y, &f);\n    ssh_print_bignum(\"x\", x);\n    ssh_print_bignum(\"y\", y);\n    ssh_print_bignum(\"e\", e);\n    ssh_print_bignum(\"f\", f);\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n    bignum_safe_free(x);\n    bignum_safe_free(y);\n    bignum_safe_free(e);\n    bignum_safe_free(f);\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    ssh_log_hexdump(\"Session server cookie\", c->server_kex.cookie, 16);\n    ssh_log_hexdump(\"Session client cookie\", c->client_kex.cookie, 16);\n    ssh_print_bignum(\"k\", c->shared_secret);\n\n#else\n    (void)c; /* UNUSED_PARAM */\n#endif /* DEBUG_CRYPTO */\n}\n",
      "line_start": 54,
      "line_end": 84,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Debug-only helper that just prints DH bignums and hexdumps from an internal struct. No parsing of external/complex input, no loops or branching on user data, and minimal logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_dh_keypair_get_keys",
      "clean_name": "ssh_dh_keypair_get_keys",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "    (void)c; /* UNUSED_PARAM */\n#endif /* DEBUG_CRYPTO */\n}\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\nint ssh_dh_keypair_get_keys(struct dh_ctx *ctx, int peer,\n                            const_bignum *priv, const_bignum *pub)\n{\n    if (((peer != DH_CLIENT_KEYPAIR) && (peer != DH_SERVER_KEYPAIR)) ||\n        ((priv == NULL) && (pub == NULL)) || (ctx == NULL) ||\n        (ctx->keypair[peer] == NULL)) {\n        return SSH_ERROR;\n    }\n\n    DH_get0_key(ctx->keypair[peer], pub, priv);\n\n    if (priv && (*priv == NULL || bignum_num_bits(*priv) == 0)) {\n        return SSH_ERROR;\n    }\n    if (pub && (*pub == NULL || bignum_num_bits(*pub) == 0)) {\n        return SSH_ERROR;\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 86,
      "line_end": 106,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 70,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/getter: only validates arguments and forwards to DH_get0_key, with trivial branching and no parsing, memory manipulation, or complex control flow \u2014 low value as a fuzz target despite being crypto-related."
    },
    {
      "name": "ssh_dh_get_parameters",
      "clean_name": "ssh_dh_get_parameters",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "    return rc;\n#endif /* OPENSSL_VERSION_NUMBER */\n}\n\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\nint ssh_dh_get_parameters(struct dh_ctx *ctx,\n                          const_bignum *modulus, const_bignum *generator)\n{\n    if (ctx == NULL || ctx->keypair[0] == NULL) {\n        return SSH_ERROR;\n    }\n    DH_get0_pqg(ctx->keypair[0], modulus, NULL, generator);\n    return SSH_OK;\n}\n",
      "line_start": 250,
      "line_end": 259,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/wrapper: only a null check and a call to DH_get0_pqg to return DH parameters. No parsing of external input, no memory manipulation on untrusted data, and minimal control flow \u2014 low priority for fuzzing."
    },
    {
      "name": "ssh_dh_cleanup",
      "clean_name": "ssh_dh_cleanup",
      "source_file": "/src/libssh/src/dh_crypto.c",
      "source_code": "        ssh_dh_cleanup(crypto);\n    }\n    return rc;\n}\n\nvoid ssh_dh_cleanup(struct ssh_crypto_struct *crypto)\n{\n    if (crypto->dh_ctx != NULL) {\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        DH_free(crypto->dh_ctx->keypair[0]);\n        DH_free(crypto->dh_ctx->keypair[1]);\n#else\n        EVP_PKEY_free(crypto->dh_ctx->keypair[0]);\n        EVP_PKEY_free(crypto->dh_ctx->keypair[1]);\n#endif /* OPENSSL_VERSION_NUMBER */\n        free(crypto->dh_ctx);\n        crypto->dh_ctx = NULL;\n    }\n}\n",
      "line_start": 445,
      "line_end": 459,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple resource cleanup: frees DH/EVP_PKEY and dh_ctx and sets pointer to NULL. No parsing of external input, no complex branching or loops, and no security-critical processing. Limited value as a fuzz target aside from trivially provoking invalid-free/null-deref crashes if given a malformed struct pointer."
    },
    {
      "name": "ssh_packet_kexdh_init",
      "clean_name": "ssh_packet_kexdh_init",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    ssh_buffer_reinit(session->out_buffer);\n\n    return -1;\n}\n\nSSH_PACKET_CALLBACK(ssh_packet_kexdh_init){\n  (void)packet;\n  (void)type;\n  (void)user;\n\n  SSH_LOG(SSH_LOG_PACKET,\"Received SSH_MSG_KEXDH_INIT\");\n  if(session->dh_handshake_state != DH_STATE_INIT){\n    SSH_LOG(SSH_LOG_RARE,\"Invalid state for SSH_MSG_KEXDH_INIT\");\n    session->session_state = SSH_SESSION_STATE_ERROR;\n    return SSH_PACKET_USED;\n  }\n\n  /* If first_kex_packet_follows guess was wrong, ignore this message. */\n  if (session->first_kex_follows_guess_wrong != 0) {\n    SSH_LOG(SSH_LOG_RARE, \"first_kex_packet_follows guess was wrong, \"\n                          \"ignoring first SSH_MSG_KEXDH_INIT message\");\n    session->first_kex_follows_guess_wrong = 0;\n\n    return SSH_PACKET_USED;\n  }\n  SSH_LOG(SSH_LOG_DEBUG, \"Calling next KEXDH handler\");\n  return SSH_PACKET_NOT_USED;\n}\n",
      "line_start": 254,
      "line_end": 277,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This callback performs only simple state checks and control-flow handling (logs, flag checks, returns). It does not parse or operate on untrusted packet data, perform memory/string ops, or complex logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_set_auth_methods",
      "clean_name": "ssh_set_auth_methods",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  else\n    return 1;\n}\n\n/* FIXME: auth_methods should be unsigned */\nvoid ssh_set_auth_methods(ssh_session session, int auth_methods)\n{\n    /* accept only methods in range */\n    session->auth.supported_methods = (uint32_t)auth_methods & 0x3fU;\n}\n",
      "line_start": 535,
      "line_end": 540,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial setter: masks and stores a 6-bit value into a session field. No parsing, no loops, no memory or complex branching \u2014 minimal fuzz value (simple state update)."
    },
    {
      "name": "ssh_message_reply_default",
      "clean_name": "ssh_message_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    return SSH_OK;\nerror:\n    return SSH_ERROR;\n}\n\nint ssh_message_reply_default(ssh_message msg) {\n  if (msg == NULL) {\n    return -1;\n  }\n\n  switch(msg->type) {\n    case SSH_REQUEST_AUTH:\n      return ssh_auth_reply_default(msg->session, 0);\n    case SSH_REQUEST_CHANNEL_OPEN:\n      return ssh_message_channel_request_open_reply_default(msg);\n    case SSH_REQUEST_CHANNEL:\n      return ssh_message_channel_request_reply_default(msg);\n    case SSH_REQUEST_SERVICE:\n      return ssh_message_service_request_reply_default(msg);\n    case SSH_REQUEST_GLOBAL:\n      return ssh_message_global_request_reply_default(msg);\n    default:\n      SSH_LOG(SSH_LOG_PACKET,\n          \"Don't know what to default reply to %d type\",\n          msg->type);\n      break;\n  }\n\n  return -1;\n}\n",
      "line_start": 812,
      "line_end": 837,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple dispatcher/wrapper: only a NULL check and a switch on msg->type that delegates to other handlers. No parsing of complex external input, no memory operations, no loops or heavy branching in this function itself. The real complexity (and fuzzing value) would be in the called handlers, not here."
    },
    {
      "name": "ssh_message_auth_user",
      "clean_name": "ssh_message_auth_user",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    return NULL;\n  }\n  return msg->service_request.service;\n}\n\nconst char *ssh_message_auth_user(ssh_message msg) {\n  if (msg == NULL) {\n    return NULL;\n  }\n\n  return msg->auth_request.username;\n}\n",
      "line_start": 852,
      "line_end": 859,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: only a NULL check and returns msg->auth_request.username. No parsing, no memory operations, no complex logic or branches \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_message_auth_password",
      "clean_name": "ssh_message_auth_password",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  }\n\n  return msg->auth_request.username;\n}\n\nconst char *ssh_message_auth_password(ssh_message msg){\n  if (msg == NULL) {\n    return NULL;\n  }\n\n  return msg->auth_request.password;\n}\n",
      "line_start": 860,
      "line_end": 867,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter: only checks msg for NULL and returns msg->auth_request.password. No parsing, memory operations, or complex logic. While it exposes sensitive data, the function itself is low-value as a fuzz target."
    },
    {
      "name": "ssh_message_auth_pubkey",
      "clean_name": "ssh_message_auth_pubkey",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  }\n\n  return msg->auth_request.password;\n}\n\nssh_key ssh_message_auth_pubkey(ssh_message msg) {\n  if (msg == NULL) {\n    return NULL;\n  }\n\n  return msg->auth_request.pubkey;\n}\n",
      "line_start": 868,
      "line_end": 875,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: only checks NULL and returns msg->auth_request.pubkey. No parsing, memory manipulation, loops, or security-sensitive logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_message_auth_publickey",
      "clean_name": "ssh_message_auth_publickey",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  }\n\n  return msg->auth_request.pubkey;\n}\n\nssh_public_key ssh_message_auth_publickey(ssh_message msg){\n  if (msg == NULL) {\n    return NULL;\n  }\n\n  return ssh_pki_convert_key_to_publickey(msg->auth_request.pubkey);\n}\n",
      "line_start": 876,
      "line_end": 883,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper with a NULL check that just forwards msg->auth_request.pubkey to ssh_pki_convert_key_to_publickey; minimal branching and no parsing or memory manipulation here \u2014 low-value fuzz target (the conversion routine itself would be higher priority)."
    },
    {
      "name": "ssh_message_auth_publickey_state",
      "clean_name": "ssh_message_auth_publickey_state",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  }\n\n  return ssh_pki_convert_key_to_publickey(msg->auth_request.pubkey);\n}\n\nenum ssh_publickey_state_e ssh_message_auth_publickey_state(ssh_message msg){\n\tif (msg == NULL) {\n\t    return -1;\n\t  }\n\t  return msg->auth_request.signature_state;\n}\n",
      "line_start": 884,
      "line_end": 890,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter: only checks for NULL and returns a field from msg->auth_request. No parsing, memory ops, loops, or complex branching. Minor note: returns -1 on NULL (potentially out-of-enum), but overall not a valuable fuzz target."
    },
    {
      "name": "ssh_message_auth_kbdint_is_response",
      "clean_name": "ssh_message_auth_kbdint_is_response",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n *  @param msg The message to check\n *\n *  @returns 1 if the message is a response, otherwise 0\n */\nint ssh_message_auth_kbdint_is_response(ssh_message msg) {\n  if (msg == NULL) {\n    return -1;\n  }\n\n  return msg->auth_request.kbdint_response != 0;\n}\n",
      "line_start": 898,
      "line_end": 905,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor with a trivial NULL check; only reads a single struct field and returns a boolean. No parsing, memory operations, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_message_auth_set_methods",
      "clean_name": "ssh_message_auth_set_methods",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " * The supported methods are listed in ssh_set_auth_methods\n * @see ssh_set_auth_methods\n *\n * @returns 0 on success, otherwise -1\n */\nint ssh_message_auth_set_methods(ssh_message msg, int methods) {\n  if (msg == NULL || msg->session == NULL) {\n    return -1;\n  }\n\n  if (methods < 0) {\n      return -1;\n  }\n\n  msg->session->auth.supported_methods = (uint32_t)methods;\n\n  return 0;\n}\n",
      "line_start": 918,
      "line_end": 931,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: only null and non-negative checks and an integer-to-uint32_t assignment. No parsing, memory manipulation, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_message_auth_reply_success",
      "clean_name": "ssh_message_auth_reply_success",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "        crypto->do_compress_in = 1;\n    }\n    return r;\n}\n\nint ssh_message_auth_reply_success(ssh_message msg, int partial) {\n\tif(msg == NULL)\n\t\treturn SSH_ERROR;\n\treturn ssh_auth_reply_success(msg->session, partial);\n}\n",
      "line_start": 1091,
      "line_end": 1096,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple thin wrapper: only checks msg for NULL and forwards msg->session and partial to ssh_auth_reply_success. No parsing, memory manipulation, or complex control flow here \u2014 low value as a direct fuzz target (the callee may be more interesting)."
    },
    {
      "name": "ssh_message_channel_request_open_originator",
      "clean_name": "ssh_message_channel_request_open_originator",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\n    return ret;\n}\n\n\nconst char *ssh_message_channel_request_open_originator(ssh_message msg){\n    return msg->channel_request_open.originator;\n}\n",
      "line_start": 1161,
      "line_end": 1164,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter: returns an internal char* field from the message with no parsing, memory operations, loops, or branching. Low value as a fuzz target (simple accessor)."
    },
    {
      "name": "ssh_message_channel_request_open_originator_port",
      "clean_name": "ssh_message_channel_request_open_originator_port",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_open_originator(ssh_message msg){\n    return msg->channel_request_open.originator;\n}\n\nint ssh_message_channel_request_open_originator_port(ssh_message msg){\n    return msg->channel_request_open.originator_port;\n}\n",
      "line_start": 1165,
      "line_end": 1168,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns an int field from the ssh_message structure. No parsing, no branching, no memory operations on untrusted data. Minimal value as a fuzz target (aside from a potential NULL-deref crash if msg is invalid)."
    },
    {
      "name": "ssh_message_channel_request_open_destination",
      "clean_name": "ssh_message_channel_request_open_destination",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_open_originator_port(ssh_message msg){\n    return msg->channel_request_open.originator_port;\n}\n\nconst char *ssh_message_channel_request_open_destination(ssh_message msg){\n    return msg->channel_request_open.destination;\n}\n",
      "line_start": 1169,
      "line_end": 1172,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor functions that just return fields from the ssh_message struct. No parsing, no bounds checks, no branching, no memory manipulation \u2014 minimal fuzz value."
    },
    {
      "name": "ssh_message_channel_request_open_destination_port",
      "clean_name": "ssh_message_channel_request_open_destination_port",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_open_destination(ssh_message msg){\n    return msg->channel_request_open.destination;\n}\n\nint ssh_message_channel_request_open_destination_port(ssh_message msg){\n    return msg->channel_request_open.destination_port;\n}\n",
      "line_start": 1173,
      "line_end": 1176,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "These are trivial accessor functions that just return struct fields (a string pointer and an int). They perform no parsing, memory operations, validation, or branching, so they are low-value fuzz targets."
    },
    {
      "name": "ssh_message_channel_request_channel",
      "clean_name": "ssh_message_channel_request_channel",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_open_destination_port(ssh_message msg){\n    return msg->channel_request_open.destination_port;\n}\n\nssh_channel ssh_message_channel_request_channel(ssh_message msg){\n    return msg->channel_request.channel;\n}\n",
      "line_start": 1177,
      "line_end": 1180,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns a field (msg->channel_request.channel). No parsing, memory operations, loops, or input-dependent branching \u2014 low fuzzing value."
    },
    {
      "name": "ssh_message_channel_request_pty_term",
      "clean_name": "ssh_message_channel_request_pty_term",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nssh_channel ssh_message_channel_request_channel(ssh_message msg){\n    return msg->channel_request.channel;\n}\n\nconst char *ssh_message_channel_request_pty_term(ssh_message msg){\n    return msg->channel_request.TERM;\n}\n",
      "line_start": 1181,
      "line_end": 1184,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor functions that just return fields from msg (getters). No parsing, no branching, no memory manipulation or loops \u2014 minimal value as fuzz targets aside from obvious NULL-deref checks."
    },
    {
      "name": "ssh_message_channel_request_pty_width",
      "clean_name": "ssh_message_channel_request_pty_width",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_pty_term(ssh_message msg){\n    return msg->channel_request.TERM;\n}\n\nint ssh_message_channel_request_pty_width(ssh_message msg){\n    return msg->channel_request.width;\n}\n",
      "line_start": 1185,
      "line_end": 1188,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "These are trivial accessors that just return fields from the ssh_message struct (a const char* and an int). No parsing, no memory operations, no loops or branching, and no validation \u2014 minimal value as a fuzz target beyond exercising call/site coverage."
    },
    {
      "name": "ssh_message_channel_request_pty_height",
      "clean_name": "ssh_message_channel_request_pty_height",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_pty_width(ssh_message msg){\n    return msg->channel_request.width;\n}\n\nint ssh_message_channel_request_pty_height(ssh_message msg){\n    return msg->channel_request.height;\n}\n",
      "line_start": 1189,
      "line_end": 1192,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns a struct field (msg->channel_request.height). No parsing, branching, loops, or memory manipulation. Minimal value as a fuzz target (low priority); at best a null-pointer check could be relevant but otherwise not fuzz-worthy."
    },
    {
      "name": "ssh_message_channel_request_pty_pxwidth",
      "clean_name": "ssh_message_channel_request_pty_pxwidth",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_pty_height(ssh_message msg){\n    return msg->channel_request.height;\n}\n\nint ssh_message_channel_request_pty_pxwidth(ssh_message msg){\n    return msg->channel_request.pxwidth;\n}\n",
      "line_start": 1193,
      "line_end": 1196,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor/getter returning a struct field with no parsing, branching, loops, or memory operations on untrusted data. Low-value fuzz target (minor risk like possible NULL deref but no complex logic)."
    },
    {
      "name": "ssh_message_channel_request_pty_pxheight",
      "clean_name": "ssh_message_channel_request_pty_pxheight",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_pty_pxwidth(ssh_message msg){\n    return msg->channel_request.pxwidth;\n}\n\nint ssh_message_channel_request_pty_pxheight(ssh_message msg){\n    return msg->channel_request.pxheight;\n}\n",
      "line_start": 1197,
      "line_end": 1200,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor: just returns a struct field (pxheight) with no parsing, memory ops, loops, or branching. Minimal fuzz value \u2014 trivial getter; low risk and low complexity (possible null-deref if msg is invalid, but still low priority)."
    },
    {
      "name": "ssh_message_channel_request_env_name",
      "clean_name": "ssh_message_channel_request_env_name",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_pty_pxheight(ssh_message msg){\n    return msg->channel_request.pxheight;\n}\n\nconst char *ssh_message_channel_request_env_name(ssh_message msg){\n    return msg->channel_request.var_name;\n}\n",
      "line_start": 1201,
      "line_end": 1204,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter that just returns msg->channel_request.var_name. No parsing, no memory ops, no branching or input-dependent logic \u2014 minimal value as a standalone fuzz target (could only be useful indirectly as part of larger code)."
    },
    {
      "name": "ssh_message_channel_request_command",
      "clean_name": "ssh_message_channel_request_command",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_env_value(ssh_message msg){\n    return msg->channel_request.var_value;\n}\n\nconst char *ssh_message_channel_request_command(ssh_message msg){\n    return msg->channel_request.command;\n}\n",
      "line_start": 1209,
      "line_end": 1212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor functions that just return struct fields. No parsing, memory operations, loops, or branching \u2014 low value as fuzz targets (simple getters)."
    },
    {
      "name": "ssh_message_channel_request_x11_single_connection",
      "clean_name": "ssh_message_channel_request_x11_single_connection",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_subsystem(ssh_message msg){\n    return msg->channel_request.subsystem;\n}\n\nint ssh_message_channel_request_x11_single_connection(ssh_message msg){\n    return msg->channel_request.x11_single_connection ? 1 : 0;\n}\n",
      "line_start": 1217,
      "line_end": 1220,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple accessor that returns a single boolean flag from msg->channel_request. No parsing, memory operations, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_message_channel_request_x11_auth_protocol",
      "clean_name": "ssh_message_channel_request_x11_auth_protocol",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_x11_single_connection(ssh_message msg){\n    return msg->channel_request.x11_single_connection ? 1 : 0;\n}\n\nconst char *ssh_message_channel_request_x11_auth_protocol(ssh_message msg){\n    return msg->channel_request.x11_auth_protocol;\n}\n",
      "line_start": 1221,
      "line_end": 1224,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "These are trivial accessor functions that simply return fields from ssh_message with no parsing, memory manipulation, loops, or branching. They do not process or transform untrusted input and thus are low-value fuzz targets (though callers using the returned pointer may warrant testing)."
    },
    {
      "name": "ssh_message_channel_request_x11_screen_number",
      "clean_name": "ssh_message_channel_request_x11_screen_number",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_x11_auth_cookie(ssh_message msg){\n    return msg->channel_request.x11_auth_cookie;\n}\n\nint ssh_message_channel_request_x11_screen_number(ssh_message msg){\n    return msg->channel_request.x11_screen_number;\n}\n",
      "line_start": 1229,
      "line_end": 1232,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessor: simply returns an int field from the ssh_message struct. No parsing, memory operations, loops, branching, or security-sensitive logic \u2014 minimal value as a fuzz target (aside from a potential null-pointer dereference if msg is uncontrolled)."
    },
    {
      "name": "ssh_message_global_request_address",
      "clean_name": "ssh_message_global_request_address",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nint ssh_message_channel_request_x11_screen_number(ssh_message msg){\n    return msg->channel_request.x11_screen_number;\n}\n\nconst char *ssh_message_global_request_address(ssh_message msg){\n    return msg->global_request.bind_address;\n}\n",
      "line_start": 1233,
      "line_end": 1236,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial getter that returns msg->global_request.bind_address. No parsing, no memory ops, no branching or loops. Minimal value as a fuzz target (low priority); only minor risk if msg is NULL or attacker-controlled pointer causing a crash."
    },
    {
      "name": "ssh_message_global_request_port",
      "clean_name": "ssh_message_global_request_port",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_global_request_address(ssh_message msg){\n    return msg->global_request.bind_address;\n}\n\nint ssh_message_global_request_port(ssh_message msg){\n    return msg->global_request.bind_port;\n}\n",
      "line_start": 1237,
      "line_end": 1240,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial accessors that just return fields from the ssh_message struct. No parsing, no memory ops or branching; very low fuzz value. (Only minor issue: they dereference msg without checks, so a null-pointer input could cause a simple crash.)"
    },
    {
      "name": "ssh_set_message_callback",
      "clean_name": "ssh_set_message_callback",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " * current ssh session and received message as parameters. the function returns\n * 0 if the message has been parsed and treated successfully, 1 otherwise (libssh\n * must take care of the response).\n * @param[in] data void pointer to be passed to callback functions\n */\nvoid ssh_set_message_callback(ssh_session session,\n        int(*ssh_bind_message_callback)(ssh_session session, ssh_message msg, void *data),\n        void *data) {\n  session->ssh_message_callback = ssh_bind_message_callback;\n  session->ssh_message_callback_data = data;\n}\n",
      "line_start": 1249,
      "line_end": 1255,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter that stores a callback pointer and data into the session struct; no parsing of external input, no memory operations or branching, and minimal attack surface\u2014low value as a fuzz target."
    },
    {
      "name": "server.c:ssh_server_kex_termination",
      "clean_name": "ssh_server_kex_termination",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\n    return processed;\n}\n\n/* returns 0 until the key exchange is not finished */\nstatic int ssh_server_kex_termination(void *s){\n  ssh_session session = s;\n  if (session->session_state != SSH_SESSION_STATE_ERROR &&\n      session->session_state != SSH_SESSION_STATE_AUTHENTICATING &&\n      session->session_state != SSH_SESSION_STATE_AUTHENTICATED &&\n      session->session_state != SSH_SESSION_STATE_DISCONNECTED)\n    return 0;\n  else\n    return 1;\n}\n",
      "line_start": 523,
      "line_end": 533,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small helper that only checks session->session_state against a few constants and returns 0/1. No parsing, no memory ops, no loops, and minimal branching (low cyclomatic complexity). Only potential fuzz interest is a trivial null/invalid-pointer dereference, so overall low value as a fuzz target."
    },
    {
      "name": "server.c:ssh_message_channel_request_open_reply_default",
      "clean_name": "ssh_message_channel_request_open_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "  }\n  rc = ssh_packet_send(session);\n  return rc;\n}\n\nstatic int ssh_message_channel_request_open_reply_default(ssh_message msg) {\n    int rc;\n\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"Refusing a channel\");\n\n    rc = ssh_buffer_pack(msg->session->out_buffer,\n                         \"bdddd\",\n                         SSH2_MSG_CHANNEL_OPEN_FAILURE,\n                         msg->channel_request_open.sender,\n                         SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED,\n                         0,    /* reason is empty string */\n                         0);   /* language string */\n    if (rc != SSH_OK){\n        ssh_set_error_oom(msg->session);\n        return SSH_ERROR;\n    }\n\n    rc = ssh_packet_send(msg->session);\n    return rc;\n}\n",
      "line_start": 666,
      "line_end": 686,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple handler that builds and sends a fixed failure reply. It only reads a single field (sender id) from the message, packs fixed-format integers/zeros, does no parsing of complex external formats, has no loops or branching on input, and performs no direct untrusted memory/string operations \u2014 low value as a fuzz target."
    },
    {
      "name": "server.c:ssh_message_service_request_reply_default",
      "clean_name": "ssh_message_service_request_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "      \"The client doesn't want to know the request failed!\");\n\n  return SSH_OK;\n}\n\nstatic int ssh_message_service_request_reply_default(ssh_message msg) {\n  /* The only return code accepted by specifications are success or disconnect */\n  return ssh_message_service_reply_success(msg);\n}\n",
      "line_start": 714,
      "line_end": 718,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper that immediately forwards to ssh_message_service_reply_success(msg). No parsing, memory operations, or branching; minimal value as a fuzz target (fuzz the underlying handler instead)."
    },
    {
      "name": "server.c:ssh_message_global_request_reply_default",
      "clean_name": "ssh_message_global_request_reply_default",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "    return SSH_OK;\nerror:\n    return SSH_ERROR;\n}\n\nstatic int ssh_message_global_request_reply_default(ssh_message msg) {\n    SSH_LOG(SSH_LOG_FUNCTIONS, \"Refusing a global request\");\n\n    if (msg->global_request.want_reply) {\n        if (ssh_buffer_add_u8(msg->session->out_buffer\n                    , SSH2_MSG_REQUEST_FAILURE) < 0) {\n            goto error;\n        }\n        return ssh_packet_send(msg->session);\n    }\n    SSH_LOG(SSH_LOG_PACKET,\n            \"The client doesn't want to know the request failed!\");\n\n    return SSH_OK;\nerror:\n    return SSH_ERROR;\n}\n",
      "line_start": 794,
      "line_end": 811,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very simple control flow: checks a want_reply flag, writes a single byte to an output buffer and calls packet_send. No parsing of complex external input, no input-dependent loops or heavy memory manipulation, and low cyclomatic complexity \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_client_dhgex_init",
      "clean_name": "ssh_client_dhgex_init",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "};\n\n/** @internal\n * @brief initiates a diffie-hellman-group-exchange kex\n */\nint ssh_client_dhgex_init(ssh_session session)\n{\n    int rc;\n\n    rc = ssh_dh_init_common(session->next_crypto);\n    if (rc != SSH_OK){\n        goto error;\n    }\n\n    session->next_crypto->dh_pmin = DH_PMIN;\n    session->next_crypto->dh_pn = DH_PREQ;\n    session->next_crypto->dh_pmax = DH_PMAX;\n    /* Minimum group size, preferred group size, maximum group size */\n    rc = ssh_buffer_pack(session->out_buffer,\n                         \"bddd\",\n                         SSH2_MSG_KEX_DH_GEX_REQUEST,\n                         session->next_crypto->dh_pmin,\n                         session->next_crypto->dh_pn,\n                         session->next_crypto->dh_pmax);\n    if (rc != SSH_OK) {\n        goto error;\n    }\n\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_dhgex_client_callbacks);\n    session->dh_handshake_state = DH_STATE_REQUEST_SENT;\n    rc = ssh_packet_send(session);\n    if (rc == SSH_ERROR) {\n        goto error;\n    }\n    return rc;\nerror:\n    ssh_dh_cleanup(session->next_crypto);\n    return SSH_ERROR;\n}\n",
      "line_start": 63,
      "line_end": 98,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Initialization helper that sets DH parameters and sends a packet; it contains minimal branching, no loops, and does not parse or manipulate untrusted external input or perform risky memory operations. Low value as a direct fuzz target (could be useful only as part of larger protocol/stateful harness)."
    },
    {
      "name": "ssh_server_dhgex_init",
      "clean_name": "ssh_server_dhgex_init",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "};\n\n/** @internal\n * @brief sets up the diffie-hellman-groupx kex callbacks\n */\nvoid ssh_server_dhgex_init(ssh_session session){\n    /* register the packet callbacks */\n    ssh_packet_set_callbacks(session, &ssh_dhgex_server_callbacks);\n    ssh_dh_init_common(session->next_crypto);\n    session->dh_handshake_state = DH_STATE_INIT;\n}\n",
      "line_start": 598,
      "line_end": 604,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple initializer: registers callbacks and calls ssh_dh_init_common, sets a state. No parsing of external input, no loops, no memory/string ops or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "dh-gex.c:ssh_packet_server_dhgex_init",
      "clean_name": "ssh_packet_server_dhgex_init",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "\n/** @internal\n * @brief parse an incoming SSH_MSG_KEX_DH_GEX_INIT packet and complete\n *        Diffie-Hellman key exchange\n **/\nstatic SSH_PACKET_CALLBACK(ssh_packet_server_dhgex_init){\n    (void) type;\n    (void) user;\n    SSH_LOG(SSH_LOG_DEBUG, \"Received SSH_MSG_KEX_DHGEX_INIT\");\n    ssh_packet_remove_callbacks(session, &ssh_dhgex_server_callbacks);\n    ssh_server_dh_process_init(session, packet);\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 704,
      "line_end": 712,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Thin wrapper/callback handler with no parsing or complex logic: it logs, removes callbacks and delegates to ssh_server_dh_process_init. The real parsing and risky operations occur in the called function, so this specific function is low-value as a direct fuzz target."
    },
    {
      "name": "ssh_agent_new",
      "clean_name": "ssh_agent_new",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "        }\n        return pos;\n    }\n}\n\nssh_agent ssh_agent_new(struct ssh_session_struct *session)\n{\n    ssh_agent agent = NULL;\n\n    agent = calloc(1, sizeof(struct ssh_agent_struct));\n    if (agent == NULL) {\n        return NULL;\n    }\n\n    agent->count = 0;\n    agent->sock = ssh_socket_new(session);\n    if (agent->sock == NULL) {\n        SAFE_FREE(agent);\n        return NULL;\n    }\n    agent->channel = NULL;\n    return agent;\n}\n",
      "line_start": 134,
      "line_end": 152,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple constructor/factory: allocates and initializes an agent struct and delegates socket creation to ssh_socket_new. No parsing of external input, no complex branching or loop logic, and no direct memory manipulation of untrusted data\u2014low priority as a fuzz target."
    },
    {
      "name": "ssh_set_agent_channel",
      "clean_name": "ssh_set_agent_channel",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": " * @param[in] channel a SSH channel from another session.\n *\n * @returns SSH_OK in case of success\n *          SSH_ERROR in case of an error\n */\nint ssh_set_agent_channel(ssh_session session, ssh_channel channel)\n{\n    if (!session) {\n        return SSH_ERROR;\n    }\n    if (!session->agent) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Session has no active agent\");\n        return SSH_ERROR;\n    }\n    agent_set_channel(session->agent, channel);\n    return SSH_OK;\n}\n",
      "line_start": 177,
      "line_end": 191,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/setter: performs null checks and delegates to agent_set_channel. No parsing, no memory operations on untrusted data, minimal branching and logic. Low value as a fuzz target (fuzz agent_set_channel or callers handling external input instead)."
    },
    {
      "name": "ssh_set_agent_socket",
      "clean_name": "ssh_set_agent_socket",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": " * is responsible for connecting to the socket prior to calling\n * this function.\n * @returns SSH_OK in case of success\n *          SSH_ERROR in case of an error\n */\nint ssh_set_agent_socket(ssh_session session, socket_t fd)\n{\n    if (!session) {\n        return SSH_ERROR;\n    }\n    if (!session->agent) {\n        ssh_set_error(session,\n                      SSH_REQUEST_DENIED,\n                      \"Session has no active agent\");\n        return SSH_ERROR;\n    }\n\n    return ssh_socket_set_fd(session->agent->sock, fd);\n}\n",
      "line_start": 200,
      "line_end": 214,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Thin wrapper: only null checks and an error set before delegating to ssh_socket_set_fd. No parsing, no loops, no memory operations or complex branching \u2014 low value as a standalone fuzz target (fuzz the underlying socket handling instead)."
    },
    {
      "name": "ssh_agent_close",
      "clean_name": "ssh_agent_close",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "\n/**\n * @}\n */\n\nvoid ssh_agent_close(struct ssh_agent_struct *agent)\n{\n    if (agent == NULL) {\n        return;\n    }\n\n    ssh_socket_close(agent->sock);\n}\n",
      "line_start": 219,
      "line_end": 227,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper/cleanup function: checks for NULL then closes a socket. Minimal logic, no parsing of external input, no memory operations or complex control flow \u2014 low priority as a fuzz target."
    },
    {
      "name": "ssh_agent_free",
      "clean_name": "ssh_agent_free",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "    }\n\n    ssh_socket_close(agent->sock);\n}\n\nvoid ssh_agent_free(ssh_agent agent)\n{\n    if (agent) {\n        if (agent->ident) {\n            SSH_BUFFER_FREE(agent->ident);\n        }\n        if (agent->sock) {\n            ssh_agent_close(agent);\n            ssh_socket_free(agent->sock);\n        }\n        SAFE_FREE(agent);\n    }\n}\n",
      "line_start": 228,
      "line_end": 241,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple resource cleanup: only checks for null, frees buffers/sockets and calls close/free helpers. No parsing of external input, no loops, little branching and no complex validation \u2014 low-value fuzz target (useful mainly for detecting trivial memory-management bugs)."
    },
    {
      "name": "ssh_agent_get_first_ident",
      "clean_name": "ssh_agent_get_first_ident",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "\n    return session->agent->count;\n}\n\n/* caller has to free comment */\nssh_key ssh_agent_get_first_ident(struct ssh_session_struct *session,\n                              char **comment) {\n    if (ssh_agent_get_ident_count(session) > 0) {\n        return ssh_agent_get_next_ident(session, comment);\n    }\n\n    return NULL;\n}\n",
      "line_start": 436,
      "line_end": 444,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper: checks agent ident count and calls ssh_agent_get_next_ident. Minimal logic, no parsing of external input, no direct memory/IO operations or complex branching \u2014 low value as a standalone fuzz target."
    },
    {
      "name": "agent.c:agent_set_channel",
      "clean_name": "agent_set_channel",
      "source_file": "/src/libssh/src/agent.c",
      "source_code": "    }\n    agent->channel = NULL;\n    return agent;\n}\n\nstatic void agent_set_channel(struct ssh_agent_struct *agent,\n                              ssh_channel channel)\n{\n    agent->channel = channel;\n}\n",
      "line_start": 153,
      "line_end": 158,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial setter: simply assigns a pointer (agent->channel = channel) with no parsing, bounds checks, memory ops, loops, or branching. Minimal value as a fuzz target."
    },
    {
      "name": "ssh_make_bignum_string",
      "clean_name": "ssh_make_bignum_string",
      "source_file": "/src/libssh/src/bignum.c",
      "source_code": "    bignum_bn2bin(num, len, ptr->data + pad);\n\n    return ptr;\n}\n\nssh_string ssh_make_bignum_string(bignum num)\n{\n    return make_bignum_string(num, 0);\n}\n",
      "line_start": 67,
      "line_end": 71,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that just forwards its bignum argument to make_bignum_string(num, 0). No parsing, no memory manipulation or branching in this function itself \u2014 low value as a fuzz target (delegate may be more interesting)."
    },
    {
      "name": "ssh_make_padded_bignum_string",
      "clean_name": "ssh_make_padded_bignum_string",
      "source_file": "/src/libssh/src/bignum.c",
      "source_code": "ssh_string ssh_make_bignum_string(bignum num)\n{\n    return make_bignum_string(num, 0);\n}\n\nssh_string ssh_make_padded_bignum_string(bignum num, size_t pad_len)\n{\n    return make_bignum_string(num, pad_len);\n}\n",
      "line_start": 72,
      "line_end": 76,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "These are trivial wrapper functions that simply forward a bignum and optional pad length to make_bignum_string. They contain no parsing, branching, or direct memory manipulation themselves, so they are low-priority fuzz targets (any substantive logic would be in make_bignum_string)."
    },
    {
      "name": "ssh_print_bignum",
      "clean_name": "ssh_print_bignum",
      "source_file": "/src/libssh/src/bignum.c",
      "source_code": "\n    return bn;\n}\n\n/* prints the bignum on stderr */\nvoid ssh_print_bignum(const char *name, const_bignum num)\n{\n    unsigned char *hex = NULL;\n    if (num != NULL) {\n        bignum_bn2hex(num, &hex);\n    }\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"%s value: %s\",\n            name,\n            (hex == NULL) ? \"(null)\" : (char *)hex);\n    ssh_crypto_free(hex);\n}\n",
      "line_start": 95,
      "line_end": 107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 20,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple helper that formats and logs a bignum: calls bn-to-hex, prints and frees. Minimal logic/branching, no complex parsing or memory-manipulating loops\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_set_callbacks",
      "clean_name": "ssh_set_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "        _ssh_reset_log_cb();\n        ssh_set_log_userdata(NULL);\n    }\n}\n\nint ssh_set_callbacks(ssh_session session, ssh_callbacks cb)\n{\n    if (session == NULL || cb == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (!is_callback_valid(session, cb)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid callback passed in (badly initialized)\");\n        return SSH_ERROR;\n    };\n    session->common.callbacks = cb;\n\n    /* LEGACY */\n    if (ssh_get_log_callback() == NULL && cb->log_function) {\n        ssh_set_log_callback(ssh_legacy_log_callback);\n        ssh_set_log_userdata(session);\n    }\n\n    return 0;\n}\n",
      "line_start": 55,
      "line_end": 77,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 37,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter/wrapper: performs NULL checks and a callback-structure validity check, then assigns pointers and configures legacy logging. No parsing of complex external input, no memory/byte operations, minimal control flow \u2014 low fuzzing value."
    },
    {
      "name": "ssh_set_channel_callbacks",
      "clean_name": "ssh_set_channel_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "    }\n\n    return rc;\n}\n\nint ssh_set_channel_callbacks(ssh_channel channel, ssh_channel_callbacks cb)\n{\n    return ssh_add_set_channel_callbacks(channel, cb, 1);\n}\n",
      "line_start": 112,
      "line_end": 116,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that delegates to ssh_add_set_channel_callbacks with no parsing, memory ops, or branching. Minimal logic and no direct processing of external data, so low fuzzing priority."
    },
    {
      "name": "ssh_add_channel_callbacks",
      "clean_name": "ssh_add_channel_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "int ssh_set_channel_callbacks(ssh_channel channel, ssh_channel_callbacks cb)\n{\n    return ssh_add_set_channel_callbacks(channel, cb, 1);\n}\n\nint ssh_add_channel_callbacks(ssh_channel channel, ssh_channel_callbacks cb)\n{\n    return ssh_add_set_channel_callbacks(channel, cb, 0);\n}\n",
      "line_start": 117,
      "line_end": 121,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that forwards parameters to ssh_add_set_channel_callbacks; no parsing, no memory operations, no branching or loops and no direct handling of untrusted data \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_remove_channel_callbacks",
      "clean_name": "ssh_remove_channel_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "int ssh_add_channel_callbacks(ssh_channel channel, ssh_channel_callbacks cb)\n{\n    return ssh_add_set_channel_callbacks(channel, cb, 0);\n}\n\nint ssh_remove_channel_callbacks(ssh_channel channel, ssh_channel_callbacks cb)\n{\n    struct ssh_iterator *it = NULL;\n\n    if (channel == NULL || channel->callbacks == NULL) {\n        return SSH_ERROR;\n    }\n\n    it = ssh_list_find(channel->callbacks, cb);\n    if (it == NULL) {\n        return SSH_ERROR;\n    }\n\n    ssh_list_remove(channel->callbacks, it);\n\n    return SSH_OK;\n}\n",
      "line_start": 122,
      "line_end": 139,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 29,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Very small helper: does null checks, a list lookup and remove. Low cyclomatic complexity, no parsing of external input, no loops or pointer arithmetic here \u2014 minimal attack surface and limited value as a fuzz target."
    },
    {
      "name": "ssh_set_server_callbacks",
      "clean_name": "ssh_set_server_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "    ssh_list_remove(channel->callbacks, it);\n\n    return SSH_OK;\n}\n\nint ssh_set_server_callbacks(ssh_session session, ssh_server_callbacks cb)\n{\n    if (session == NULL || cb == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (!is_callback_valid(session, cb)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid callback passed in (badly initialized)\");\n        return SSH_ERROR;\n    };\n    session->server_callbacks = cb;\n\n    return 0;\n}\n",
      "line_start": 140,
      "line_end": 156,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 28,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple setter: only NULL checks and a callback-validity check, then assigns a pointer. No parsing or memory operations on untrusted data, minimal branching \u2014 low-value fuzz target."
    },
    {
      "name": "callbacks.c:ssh_legacy_log_callback",
      "clean_name": "ssh_legacy_log_callback",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "\n#define is_callback_valid(session, cb) \\\n    (cb->size > 0 || cb->size <= 1024 * sizeof(void *))\n\n/* LEGACY */\nstatic void ssh_legacy_log_callback(int priority,\n                                    const char *function,\n                                    const char *buffer,\n                                    void *userdata)\n{\n    ssh_session session = (ssh_session)userdata;\n    ssh_log_callback log_fn = session->common.callbacks->log_function;\n    void *log_data = session->common.callbacks->userdata;\n\n    (void)function; /* unused */\n\n    log_fn(session, priority, buffer, log_data);\n}\n",
      "line_start": 33,
      "line_end": 46,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial wrapper that simply forwards parameters to a stored callback. No parsing, memory operations, loops, or branching; the only risk is whatever the callback does, so this function itself is low-value as a direct fuzz target."
    },
    {
      "name": "callbacks.c:ssh_add_set_channel_callbacks",
      "clean_name": "ssh_add_set_channel_callbacks",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "    }\n\n    return 0;\n}\n\nstatic int ssh_add_set_channel_callbacks(ssh_channel channel,\n                                         ssh_channel_callbacks cb,\n                                         int prepend)\n{\n    ssh_session session = NULL;\n    int rc;\n\n    if (channel == NULL || cb == NULL) {\n        return SSH_ERROR;\n    }\n    session = channel->session;\n\n    if (!is_callback_valid(session, cb)) {\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Invalid callback passed in (badly initialized)\");\n        return SSH_ERROR;\n    };\n    if (channel->callbacks == NULL) {\n        channel->callbacks = ssh_list_new();\n        if (channel->callbacks == NULL) {\n            ssh_set_error_oom(session);\n            return SSH_ERROR;\n        }\n    }\n    if (prepend) {\n        rc = ssh_list_prepend(channel->callbacks, cb);\n    } else {\n        rc = ssh_list_append(channel->callbacks, cb);\n    }\n\n    return rc;\n}\n",
      "line_start": 78,
      "line_end": 111,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 49,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Thin wrapper that validates pointers and manages an internal list (append/prepend). Low cyclomatic complexity, no parsing of external data, no memory/string ops on untrusted input and no security-critical logic \u2014 limited value as a standalone fuzz target."
    },
    {
      "name": "ssh_config_parse_file",
      "clean_name": "ssh_config_parse_file",
      "source_file": "/src/libssh/src/config.c",
      "source_code": " * @params[in] session   The ssh session\n * @params[in] filename  The path to the ssh configuration file\n *\n * @returns    0 on successful parsing the configuration file, -1 on error\n */\nint ssh_config_parse_file(ssh_session session, const char *filename)\n{\n    FILE *fp = NULL;\n    int rv;\n    bool global = 0;\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        return 0;\n    }\n\n    rv = strcmp(filename, GLOBAL_CLIENT_CONFIG);\n#ifdef USR_GLOBAL_CLIENT_CONFIG\n    if (rv != 0) {\n        rv = strcmp(filename, USR_GLOBAL_CLIENT_CONFIG);\n    }\n#endif\n\n    if (rv == 0) {\n        global = true;\n    }\n\n    SSH_LOG(SSH_LOG_PACKET, \"Reading configuration data from %s\", filename);\n\n    rv = ssh_config_parse(session, fp, global);\n\n    fclose(fp);\n    return rv;\n}\n",
      "line_start": 1486,
      "line_end": 1515,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 23,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "This is a thin wrapper: it opens a file, does simple strcmp checks and forwards the FILE* to ssh_config_parse. It contains minimal logic/branching and no parsing/memory operations itself, so it's low-value as a primary fuzz target (the real parsing happens in ssh_config_parse)."
    },
    {
      "name": "config.c:ssh_config_get_match_opcode",
      "clean_name": "ssh_config_get_match_opcode",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "    globfree(&globbuf);\n}\n#endif /* HAVE_GLOB HAVE_GLOB_GL_FLAGS_MEMBER */\n\nstatic enum ssh_config_match_e\nssh_config_get_match_opcode(const char *keyword)\n{\n    size_t i;\n\n    for (i = 0; ssh_config_match_keyword_table[i].name != NULL; i++) {\n        if (strcasecmp(keyword, ssh_config_match_keyword_table[i].name) == 0) {\n            return ssh_config_match_keyword_table[i].opcode;\n        }\n    }\n\n    return MATCH_UNKNOWN;\n}\n",
      "line_start": 279,
      "line_end": 291,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple lookup: iterates a static table and does a strcasecmp on the input string. Low cyclomatic complexity, no parsing, no memory writes or buffer manipulation. The only rough edge is lack of a NULL check on keyword (could crash if NULL), but otherwise this is a low-value fuzz target."
    },
    {
      "name": "ssh_client_ecdh_remove_callbacks",
      "clean_name": "ssh_client_ecdh_remove_callbacks",
      "source_file": "/src/libssh/src/ecdh.c",
      "source_code": "    .n_callbacks = 1,\n    .callbacks = ecdh_client_callbacks,\n    .user = NULL\n};\n\nvoid ssh_client_ecdh_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_ecdh_client_callbacks);\n}\n",
      "line_start": 45,
      "line_end": 49,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that only calls ssh_packet_remove_callbacks(session, &ssh_ecdh_client_callbacks). No parsing, memory ops, loops, or branching on external input \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_server_ecdh_init",
      "clean_name": "ssh_server_ecdh_init",
      "source_file": "/src/libssh/src/ecdh.c",
      "source_code": "};\n\n/** @internal\n * @brief sets up the ecdh kex callbacks\n */\nvoid ssh_server_ecdh_init(ssh_session session){\n    ssh_packet_set_callbacks(session, &ssh_ecdh_server_callbacks);\n}\n",
      "line_start": 124,
      "line_end": 127,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Trivial wrapper that only registers callbacks with no parsing, memory ops, branching, or input-dependent logic. Minimal value as a direct fuzz target; better to fuzz the registered callbacks or functions they invoke."
    },
    {
      "name": "gzip.c:initcompress",
      "clean_name": "initcompress",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "#ifndef BLOCKSIZE\n#define BLOCKSIZE 4092\n#endif\n\nstatic z_stream *\ninitcompress(ssh_session session, int level)\n{\n    z_stream *stream = NULL;\n    int status;\n\n    stream = calloc(1, sizeof(z_stream));\n    if (stream == NULL) {\n        return NULL;\n    }\n\n    status = deflateInit(stream, level);\n    if (status != Z_OK) {\n        deflateEnd(stream);\n        SAFE_FREE(stream);\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"status %d initialising zlib deflate\",\n                      status);\n        return NULL;\n    }\n\n    return stream;\n}\n",
      "line_start": 42,
      "line_end": 65,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper that allocates a z_stream and calls deflateInit with an integer 'level'. Minimal logic and branching (only error path), no parsing of complex input, no buffer/string operations or loops\u2014limited fuzzing value beyond passing invalid levels to zlib."
    },
    {
      "name": "gzip.c:initdecompress",
      "clean_name": "initdecompress",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "}\n\n/* decompression */\n\nstatic z_stream *\ninitdecompress(ssh_session session)\n{\n    z_stream *stream = NULL;\n    int status;\n\n    stream = calloc(1, sizeof(z_stream));\n    if (stream == NULL) {\n        return NULL;\n    }\n\n    status = inflateInit(stream);\n    if (status != Z_OK) {\n        inflateEnd(stream);\n        SAFE_FREE(stream);\n        ssh_set_error(session,\n                      SSH_FATAL,\n                      \"Status = %d initiating inflate context!\",\n                      status);\n        return NULL;\n    }\n\n    return stream;\n}\n",
      "line_start": 151,
      "line_end": 174,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple helper that allocates and initializes a zlib inflate stream; contains minimal logic and error handling but does not parse or operate on external/untrusted data directly. Useful only indirectly as part of actual decompression paths, so low standalone fuzzing value."
    },
    {
      "name": "pki_ed25519_signature_to_blob",
      "clean_name": "pki_ed25519_signature_to_blob",
      "source_file": "/src/libssh/src/pki_ed25519_common.c",
      "source_code": " *\n * @param[in] sig signature to convert\n *\n * @return Signature blob in SSH string, or NULL on error\n */\nssh_string pki_ed25519_signature_to_blob(ssh_signature sig)\n{\n    ssh_string sig_blob = NULL;\n    int rc;\n\n#ifdef HAVE_LIBCRYPTO\n    /* When using the OpenSSL implementation, the signature is stored in raw_sig\n     * which is shared by all algorithms.*/\n    if (sig->raw_sig == NULL) {\n        return NULL;\n    }\n#else\n    /* When using the internal implementation, the signature is stored in an\n     * algorithm specific field. */\n    if (sig->ed25519_sig == NULL) {\n        return NULL;\n    }\n#endif\n\n    sig_blob = ssh_string_new(ED25519_SIG_LEN);\n    if (sig_blob == NULL) {\n        return NULL;\n    }\n\n#ifdef HAVE_LIBCRYPTO\n    rc = ssh_string_fill(sig_blob, ssh_string_data(sig->raw_sig),\n                         ssh_string_len(sig->raw_sig));\n#else\n    rc = ssh_string_fill(sig_blob, sig->ed25519_sig, ED25519_SIG_LEN);\n#endif\n    if (rc < 0) {\n        SSH_STRING_FREE(sig_blob);\n        return NULL;\n    }\n\n    return sig_blob;\n}\n",
      "line_start": 38,
      "line_end": 75,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 38,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 2.0,
      "reason": "Simple wrapper that copies a fixed-size Ed25519 signature into an ssh_string with minimal branching and no parsing, loops, or complex validation. Limited attack surface for fuzzing beyond checking for NULL and a single fixed-length memory copy."
    },
    {
      "name": "ssh_client_fuzzer.c:auth_callback",
      "clean_name": "auth_callback",
      "source_file": "/src/libssh/tests/fuzz/ssh_client_fuzzer.c",
      "source_code": "\n#define LIBSSH_STATIC 1\n#include <libssh/libssh.h>\n#include <libssh/callbacks.h>\n\nstatic int auth_callback(const char *prompt,\n                         char *buf,\n                         size_t len,\n                         int echo,\n                         int verify,\n                         void *userdata)\n{\n    (void)prompt;   /* unused */\n    (void)echo;     /* unused */\n    (void)verify;   /* unused */\n    (void)userdata; /* unused */\n\n    snprintf(buf, len, \"secret\");\n\n    return 0;\n}\n",
      "line_start": 26,
      "line_end": 42,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Trivial auth callback that unconditionally writes the constant \"secret\" into the provided buffer via snprintf. No parsing of external input, no branching or complex logic, and no meaningful input-dependent memory manipulation. Low fuzzing value (minor edge-case around len==0 or NULL buf only)."
    },
    {
      "name": "ssh_known_hosts_fuzzer.c:ssh_known_host_sigs_from_hostkey_type",
      "clean_name": "ssh_known_host_sigs_from_hostkey_type",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * given key type can generate.\n *\n * @returns A static cstring containing the signature types the key is able to\n * generate separated by commas; NULL in case of error\n */\nstatic const char *ssh_known_host_sigs_from_hostkey_type(enum ssh_keytypes_e type)\n{\n    switch (type) {\n    case SSH_KEYTYPE_RSA:\n        return \"rsa-sha2-512,rsa-sha2-256,ssh-rsa\";\n    case SSH_KEYTYPE_ED25519:\n        return \"ssh-ed25519\";\n    case SSH_KEYTYPE_SK_ED25519:\n        return \"sk-ssh-ed25519@openssh.com\";\n#ifdef HAVE_ECC\n    case SSH_KEYTYPE_ECDSA_P256:\n        return \"ecdsa-sha2-nistp256\";\n    case SSH_KEYTYPE_ECDSA_P384:\n        return \"ecdsa-sha2-nistp384\";\n    case SSH_KEYTYPE_ECDSA_P521:\n        return \"ecdsa-sha2-nistp521\";\n    case SSH_KEYTYPE_SK_ECDSA:\n        return \"sk-ecdsa-sha2-nistp256@openssh.com\";\n#else\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n        SSH_LOG(SSH_LOG_WARN, \"ECDSA keys are not supported by this build\");\n        break;\n#endif\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_TRACE,\n                \"The given type %d is not a base private key type \"\n                \"or is unsupported\",\n                type);\n    }\n\n    return NULL;\n}\n",
      "line_start": 475,
      "line_end": 510,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple deterministic mapping from an enum to static strings with minimal branching and no parsing, memory operations, loops, or input-dependent complexity \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_server_fuzzer.c:auth_none",
      "clean_name": "auth_none",
      "source_file": "/src/libssh/tests/fuzz/ssh_server_fuzzer.c",
      "source_code": "    ssh_channel channel;\n    size_t auth_attempts;\n    bool authenticated;\n};\n\nstatic int auth_none(ssh_session session, const char *user, void *userdata)\n{\n    struct session_data_struct *sdata =\n        (struct session_data_struct *)userdata;\n\n    (void)session;\n    (void)user;\n\n    if (sdata->auth_attempts > 0) {\n        sdata->authenticated = true;\n    }\n    sdata->auth_attempts++;\n\n    if (!sdata->authenticated) {\n        return SSH_AUTH_PARTIAL;\n    }\n\n    return SSH_AUTH_SUCCESS;\n}\n",
      "line_start": 70,
      "line_end": 89,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 14,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Very small, simple authentication helper: ignores session/user, only toggles and increments fields in userdata. No parsing, no memory operations on untrusted data, minimal branching. Low fuzzing value (aside from trivial null-pointer or state-corruption checks)."
    },
    {
      "name": "ssh_server_fuzzer.c:channel_open",
      "clean_name": "channel_open",
      "source_file": "/src/libssh/tests/fuzz/ssh_server_fuzzer.c",
      "source_code": "    }\n\n    return SSH_AUTH_SUCCESS;\n}\n\nstatic ssh_channel channel_open(ssh_session session, void *userdata)\n{\n    struct session_data_struct *sdata =\n        (struct session_data_struct *)userdata;\n\n    sdata->channel = ssh_channel_new(session);\n\n    return sdata->channel;\n}\n",
      "line_start": 90,
      "line_end": 99,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Simple wrapper that allocates/returns a channel and stores it in userdata; no parsing, no branching, no buffer or string operations on untrusted data \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_server_fuzzer.c:write_rsa_hostkey",
      "clean_name": "write_rsa_hostkey",
      "source_file": "/src/libssh/tests/fuzz/ssh_server_fuzzer.c",
      "source_code": "    sdata->channel = ssh_channel_new(session);\n\n    return sdata->channel;\n}\n\nstatic int write_rsa_hostkey(const char *rsakey_path)\n{\n    FILE *fp = NULL;\n    size_t nwritten;\n\n    fp = fopen(rsakey_path, \"wb\");\n    if (fp == NULL) {\n        return -1;\n    }\n\n    nwritten = fwrite(kRSAPrivateKeyPEM, 1, strlen(kRSAPrivateKeyPEM), fp);\n    fclose(fp);\n\n    if (nwritten != strlen(kRSAPrivateKeyPEM)) {\n        return -1;\n    }\n\n    return 0;\n}\n",
      "line_start": 100,
      "line_end": 119,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 2.0,
      "reason": "Takes an external file path but performs trivial I/O: fopen/fwrite of a constant blob and a simple fwrite length check. No parsing of complex input, no memory operations on untrusted data, minimal branching \u2014 low value as a fuzz target."
    },
    {
      "name": "is_ssh_initialized",
      "clean_name": "is_ssh_initialized",
      "source_file": "/src/libssh/src/init.c",
      "source_code": " *\n * @returns true if the library is initialized; false otherwise.\n *\n * @see ssh_init()\n */\nbool is_ssh_initialized(void) {\n\n    bool is_initialized = false;\n\n    ssh_mutex_lock(&ssh_init_mutex);\n    is_initialized = _ssh_initialized > 0;\n    ssh_mutex_unlock(&ssh_init_mutex);\n\n    return is_initialized;\n}\n",
      "line_start": 283,
      "line_end": 293,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor with no external input or parsing; just reads a global flag under a mutex. No memory ops, branching, or external-data-dependent behavior, so not a useful fuzz target."
    },
    {
      "name": "ssh_socket_get_poll_handle",
      "clean_name": "ssh_socket_get_poll_handle",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "/** @internal\n * @brief returns the poll handle corresponding to the socket,\n * creates it if it does not exist.\n * @returns allocated and initialized ssh_poll_handle object\n */\nssh_poll_handle ssh_socket_get_poll_handle(ssh_socket s)\n{\n    if (s->poll_handle) {\n        return s->poll_handle;\n    }\n    s->poll_handle = ssh_poll_new(s->fd, 0, ssh_socket_pollcallback, s);\n    return s->poll_handle;\n}\n",
      "line_start": 409,
      "line_end": 417,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor/wrapper: simply returns or lazily creates a poll handle. Very low complexity, no parsing of external input, no buffer/memory operations on untrusted data, and no security-critical logic \u2014 not a meaningful fuzz target."
    },
    {
      "name": "ssh_socket_get_fd",
      "clean_name": "ssh_socket_get_fd",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief returns the input file descriptor of the socket\n */\nsocket_t ssh_socket_get_fd(ssh_socket s)\n{\n    return s->fd;\n}\n",
      "line_start": 550,
      "line_end": 554,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor that returns a struct field. No parsing, branching, memory operations, or input-dependent logic \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_socket_is_open",
      "clean_name": "ssh_socket_is_open",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/** \\internal\n * \\brief returns nonzero if the socket is open\n */\nint ssh_socket_is_open(ssh_socket s)\n{\n    return s->fd != SSH_INVALID_SOCKET;\n}\n",
      "line_start": 558,
      "line_end": 562,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 3,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor that only checks a socket file descriptor against a constant; no parsing, memory operations, loops, or complex branching and thus low value as a fuzz target."
    },
    {
      "name": "ssh_socket_data_available",
      "clean_name": "ssh_socket_data_available",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "void ssh_socket_set_except(ssh_socket s)\n{\n    s->data_except = 1;\n}\n\nint ssh_socket_data_available(ssh_socket s)\n{\n    return s->read_wontblock;\n}\n",
      "line_start": 784,
      "line_end": 788,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: ssh_socket_data_available simply returns a struct field (s->read_wontblock). No parsing, no memory ops, no control flow dependent on external input \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_socket_data_writable",
      "clean_name": "ssh_socket_data_writable",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "int ssh_socket_data_available(ssh_socket s)\n{\n    return s->read_wontblock;\n}\n\nint ssh_socket_data_writable(ssh_socket s)\n{\n    return s->write_wontblock;\n}\n",
      "line_start": 789,
      "line_end": 793,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: simply returns boolean flags (read_wontblock/write_wontblock) from the socket struct. No parsing, memory ops, branching, or external-input-dependent logic\u2014poor fuzz target."
    },
    {
      "name": "ssh_threads_get_pthread",
      "clean_name": "ssh_threads_get_pthread",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "{\n    return &ssh_threads_pthread;\n}\n#endif\n\nstruct ssh_threads_callbacks_struct *ssh_threads_get_pthread(void)\n{\n    return &ssh_threads_pthread;\n}\n",
      "line_start": 136,
      "line_end": 140,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: returns address of a static callbacks struct with no external input, no parsing, no branching, and no memory operations \u2014 minimal value as a fuzz target."
    },
    {
      "name": "libcrypto.c:evp_cipher_cleanup",
      "clean_name": "evp_cipher_cleanup",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "                len);\n        return;\n    }\n}\n\nstatic void evp_cipher_cleanup(struct ssh_cipher_struct *cipher) {\n    if (cipher->ctx != NULL) {\n        EVP_CIPHER_CTX_free(cipher->ctx);\n    }\n}\n",
      "line_start": 568,
      "line_end": 573,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Trivial cleanup wrapper: only checks a pointer and calls EVP_CIPHER_CTX_free. No parsing of external input, no branching or loop complexity, and no memory operations on untrusted data \u2014 low fuzzing value."
    },
    {
      "name": "ssh_userauth_kbdint_getnprompts",
      "clean_name": "ssh_userauth_kbdint_getnprompts",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": " *\n * @param[in]  session  The ssh session to use.\n *\n * @returns             The number of prompts.\n */\nint ssh_userauth_kbdint_getnprompts(ssh_session session)\n{\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n    if (session->kbdint == NULL) {\n        ssh_set_error_invalid(session);\n        return SSH_ERROR;\n    }\n    return session->kbdint->nprompts;\n}\n",
      "line_start": 2190,
      "line_end": 2201,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 19,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor/getter with only null checks and a direct field return; no parsing, memory ops, loops, or complex branches \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_buffer_get",
      "clean_name": "ssh_buffer_get",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " *\n * @return              A pointer to the data from current position.\n *\n * @see ssh_buffer_get_len()\n */\nvoid *ssh_buffer_get(struct ssh_buffer_struct *buffer){\n    return buffer->data + buffer->pos;\n}\n",
      "line_start": 601,
      "line_end": 604,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: just returns buffer->data + buffer->pos with no parsing, branching, or memory operations on untrusted input. Minimal logic makes it a poor standalone fuzz target."
    },
    {
      "name": "_ssh_buffer_unpack",
      "clean_name": "_ssh_buffer_unpack",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": " * @returns             SSH_OK on success\n *                      SSH_ERROR on error\n * @warning             when using 'P' with a constant size (e.g. 8), do not\n *                      forget to cast to (size_t).\n */\nint _ssh_buffer_unpack(struct ssh_buffer_struct *buffer,\n                       const char *format,\n                       size_t argc,\n                       ...)\n{\n    va_list ap;\n    int rc;\n\n    va_start(ap, argc);\n    rc = ssh_buffer_unpack_va(buffer, format, argc, ap);\n    va_end(ap);\n    return rc;\n}\n",
      "line_start": 1388,
      "line_end": 1401,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial variadic wrapper: only sets up a va_list and forwards to ssh_buffer_unpack_va. Contains no parsing, memory ops, or branching itself; fuzzing this wrapper adds little value (fuzz the underlying ssh_buffer_unpack_va instead)."
    },
    {
      "name": "ssh_channel_is_closed",
      "clean_name": "ssh_channel_is_closed",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @return              0 if channel is opened, nonzero otherwise.\n *\n * @see ssh_channel_is_open()\n */\nint ssh_channel_is_closed(ssh_channel channel)\n{\n    if (channel == NULL || channel->session == NULL) {\n        return SSH_ERROR;\n    }\n    return (channel->state != SSH_CHANNEL_STATE_OPEN || channel->session->alive == 0);\n}\n",
      "line_start": 1752,
      "line_end": 1759,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 17,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: performs simple null checks and a boolean/state return. No parsing, memory operations, loops, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_request_success",
      "clean_name": "ssh_request_success",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " * @internal\n *\n * @brief Handle a SSH_REQUEST_SUCCESS packet normally sent after a global\n * request.\n */\nSSH_PACKET_CALLBACK(ssh_request_success){\n  (void)type;\n  (void)user;\n  (void)packet;\n\n  SSH_LOG(SSH_LOG_PACKET,\n      \"Received SSH_REQUEST_SUCCESS\");\n  if(session->global_req_state != SSH_CHANNEL_REQ_STATE_PENDING){\n    SSH_LOG(SSH_LOG_RARE, \"SSH_REQUEST_SUCCESS received in incorrect state %d\",\n        session->global_req_state);\n  } else {\n    session->global_req_state=SSH_CHANNEL_REQ_STATE_ACCEPTED;\n  }\n\n  return SSH_PACKET_USED;\n}\n",
      "line_start": 2413,
      "line_end": 2429,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial packet handler: ignores packet input, performs only a simple state check/log and a state assignment. No parsing, memory operations, or complex branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_channel_get_session",
      "clean_name": "ssh_channel_get_session",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  channel  The channel to recover the session from.\n *\n * @return              The session pointer.\n */\nssh_session ssh_channel_get_session(ssh_channel channel)\n{\n  if (channel == NULL) {\n      return NULL;\n  }\n\n  return channel->session;\n}\n",
      "line_start": 3405,
      "line_end": 3413,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: only a NULL check and returns channel->session. No parsing, no memory manipulation, no branching or input-dependent logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_channel_set_counter",
      "clean_name": "ssh_channel_set_counter",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in] channel The SSH channel.\n *\n * @param[in] counter Counter for bytes handled by the channel.\n */\nvoid ssh_channel_set_counter(ssh_channel channel,\n                             ssh_counter counter)\n{\n    if (channel != NULL) {\n        channel->counter = counter;\n    }\n}\n",
      "line_start": 3785,
      "line_end": 3792,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: checks for NULL and assigns a value. No parsing, memory ops, loops, or security-critical logic \u2014 minimal fuzz value."
    },
    {
      "name": "connect.c:ssh_connect_socket_close",
      "clean_name": "ssh_connect_socket_close",
      "source_file": "/src/libssh/src/connect.c",
      "source_code": "    return buf;\n}\n#endif /* gai_strerror */\n#endif /* _WIN32 */\n\nstatic int ssh_connect_socket_close(socket_t s)\n{\n#ifdef _WIN32\n    return closesocket(s);\n#else\n    return close(s);\n#endif\n}\n",
      "line_start": 102,
      "line_end": 110,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Trivial wrapper around close()/closesocket() with no parsing, memory operations, or input-dependent logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "connector.c:ssh_connector_except",
      "clean_name": "ssh_connector_except",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    connector->fd_is_socket = ssh_connector_fd_is_socket(fd);\n    connector->out_channel = NULL;\n}\n\n/* TODO */\nstatic void ssh_connector_except(ssh_connector connector, socket_t fd)\n{\n    (void) connector;\n    (void) fd;\n}\n",
      "line_start": 189,
      "line_end": 194,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Function is a no-op stub that ignores its parameters; it performs no parsing, memory ops, branching, or security-critical work, so it has minimal value as a fuzz target."
    },
    {
      "name": "ssh_dh_get_next_server_publickey",
      "clean_name": "ssh_dh_get_next_server_publickey",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "    const ssh_key pubkey = ssh_dh_get_current_server_publickey(session);\n\n    return ssh_pki_export_pubkey_blob(pubkey, pubkey_blob);\n}\n\nssh_key ssh_dh_get_next_server_publickey(ssh_session session)\n{\n    return session->next_crypto->server_pubkey;\n}\n",
      "line_start": 669,
      "line_end": 673,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: simply returns session->next_crypto->server_pubkey. No parsing, no memory ops, no branching or input-dependent behavior \u2014 minimal value as a fuzz target."
    },
    {
      "name": "_ssh_set_error_invalid",
      "clean_name": "_ssh_set_error_invalid",
      "source_file": "/src/libssh/src/error.c",
      "source_code": " * @param  error       The place to store the error.\n *\n * @param  function    The function the error happened in.\n *\n */\nvoid _ssh_set_error_invalid(void *error, const char *function)\n{\n    _ssh_set_error(error, SSH_FATAL, function,\n                   \"Invalid argument in %s\", function);\n}\n",
      "line_start": 99,
      "line_end": 104,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple wrapper that sets an error string; no parsing of external input, no buffer manipulation, no loops or branching. It only forwards the function name into a safe \"%s\" format and thus has minimal value as a fuzz target."
    },
    {
      "name": "ssh_knownhosts_entry_free",
      "clean_name": "ssh_knownhosts_entry_free",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " *\n * Use SSH_KNOWNHOSTS_ENTRY_FREE() to set the pointer to NULL.\n *\n * @param[in]  entry     The entry to free.\n */\nvoid ssh_knownhosts_entry_free(struct ssh_knownhosts_entry *entry)\n{\n    if (entry == NULL) {\n        return;\n    }\n\n    SAFE_FREE(entry->hostname);\n    SAFE_FREE(entry->unparsed);\n    ssh_key_free(entry->publickey);\n    SAFE_FREE(entry->comment);\n    SAFE_FREE(entry);\n}\n",
      "line_start": 154,
      "line_end": 166,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 40,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "This is a simple destructor/cleanup routine that frees struct fields (and guards NULL). It doesn't parse or process external input, has minimal logic, and offers little value as a fuzz target."
    },
    {
      "name": "knownhosts.c:ssh_known_host_sigs_from_hostkey_type",
      "clean_name": "ssh_known_host_sigs_from_hostkey_type",
      "source_file": "/src/libssh/src/knownhosts.c",
      "source_code": " * given key type can generate.\n *\n * @returns A static cstring containing the signature types the key is able to\n * generate separated by commas; NULL in case of error\n */\nstatic const char *ssh_known_host_sigs_from_hostkey_type(enum ssh_keytypes_e type)\n{\n    switch (type) {\n    case SSH_KEYTYPE_RSA:\n        return \"rsa-sha2-512,rsa-sha2-256,ssh-rsa\";\n    case SSH_KEYTYPE_ED25519:\n        return \"ssh-ed25519\";\n    case SSH_KEYTYPE_SK_ED25519:\n        return \"sk-ssh-ed25519@openssh.com\";\n#ifdef HAVE_ECC\n    case SSH_KEYTYPE_ECDSA_P256:\n        return \"ecdsa-sha2-nistp256\";\n    case SSH_KEYTYPE_ECDSA_P384:\n        return \"ecdsa-sha2-nistp384\";\n    case SSH_KEYTYPE_ECDSA_P521:\n        return \"ecdsa-sha2-nistp521\";\n    case SSH_KEYTYPE_SK_ECDSA:\n        return \"sk-ecdsa-sha2-nistp256@openssh.com\";\n#else\n    case SSH_KEYTYPE_ECDSA_P256:\n    case SSH_KEYTYPE_ECDSA_P384:\n    case SSH_KEYTYPE_ECDSA_P521:\n        SSH_LOG(SSH_LOG_WARN, \"ECDSA keys are not supported by this build\");\n        break;\n#endif\n    case SSH_KEYTYPE_UNKNOWN:\n    default:\n        SSH_LOG(SSH_LOG_TRACE,\n                \"The given type %d is not a base private key type \"\n                \"or is unsupported\",\n                type);\n    }\n\n    return NULL;\n}\n",
      "line_start": 475,
      "line_end": 510,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Trivial mapping from an enum to static strings with no parsing of external input, no memory or buffer operations, and minimal branching (only a simple switch and logging). Not a valuable fuzz target."
    },
    {
      "name": "ssh_get_log_level",
      "clean_name": "ssh_get_log_level",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "/**\n * @brief Get the log level of the library.\n *\n * @return    The value of the log level.\n */\nint ssh_get_log_level(void) {\n  return ssh_log_level;\n}\n",
      "line_start": 209,
      "line_end": 212,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple getter that returns a global log level; no external input, no parsing or memory operations, and trivial logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_set_log_callback",
      "clean_name": "ssh_set_log_callback",
      "source_file": "/src/libssh/src/log.c",
      "source_code": " */\nint ssh_get_log_level(void) {\n  return ssh_log_level;\n}\n\nint ssh_set_log_callback(ssh_logging_callback cb) {\n  if (cb == NULL) {\n    return SSH_ERROR;\n  }\n\n  ssh_log_cb = cb;\n\n  return SSH_OK;\n}\n",
      "line_start": 213,
      "line_end": 222,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: only checks for NULL and assigns a callback pointer. No parsing, memory manipulation, loops, or security-critical logic \u2014 very low value as a fuzz target."
    },
    {
      "name": "ssh_get_log_callback",
      "clean_name": "ssh_get_log_callback",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "_ssh_reset_log_cb(void)\n{\n    ssh_log_cb = NULL;\n}\n\nssh_logging_callback ssh_get_log_callback(void) {\n  return ssh_log_cb;\n}\n",
      "line_start": 229,
      "line_end": 232,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple getter/accessor returning a global callback pointer with no external input, parsing, memory ops, or complex logic \u2014 very low-value fuzz target."
    },
    {
      "name": "ssh_message_type",
      "clean_name": "ssh_message_type",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param[in] msg       The message to get the type from.\n *\n * @return              The message type or -1 on error.\n */\nint ssh_message_type(ssh_message msg) {\n  if (msg == NULL) {\n    return -1;\n  }\n\n  return msg->type;\n}\n",
      "line_start": 623,
      "line_end": 630,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial getter: only checks for NULL and returns a field. No parsing, memory operations, loops, or input-dependent control flow \u2014 minimal fuzz value."
    },
    {
      "name": "ssh_version",
      "clean_name": "ssh_version",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *  if (debug) {\n *    printf(\"libssh %s\\n\", ssh_version(0));\n *  }\n * @endcode\n */\nconst char *ssh_version(int req_version)\n{\n    if (req_version <= LIBSSH_VERSION_INT) {\n        return SSH_STRINGIFY(LIBSSH_VERSION) GCRYPT_STRING CRYPTO_STRING\n               MBED_STRING ZLIB_STRING;\n    }\n\n    return NULL;\n}\n",
      "line_start": 734,
      "line_end": 743,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple version-string accessor: trivial conditional on an integer with no parsing, memory operations, or complex logic. Minimal attack surface and not a meaningful fuzz target."
    },
    {
      "name": "ssh_list_free",
      "clean_name": "ssh_list_free",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n    ret->root = ret->end = NULL;\n    return ret;\n}\n\nvoid ssh_list_free(struct ssh_list *list)\n{\n    struct ssh_iterator *ptr = NULL, *next = NULL;\n    if (!list)\n        return;\n    ptr = list->root;\n    while (ptr) {\n        next = ptr->next;\n        SAFE_FREE(ptr);\n        ptr = next;\n    }\n    SAFE_FREE(list);\n}\n",
      "line_start": 754,
      "line_end": 767,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple deallocation helper: no external input parsing, minimal control flow, just iterates and frees nodes. Trivial logic and not a meaningful fuzz target."
    },
    {
      "name": "ssh_options_get_port",
      "clean_name": "ssh_options_get_port",
      "source_file": "/src/libssh/src/options.c",
      "source_code": " *         port will be set from the ssh session.\n *\n * @return       0 on success, < 0 on error.\n *\n */\nint ssh_options_get_port(ssh_session session, unsigned int* port_target) {\n    if (session == NULL) {\n        return -1;\n    }\n\n    if (session->opts.port == 0) {\n        *port_target = 22;\n        return 0;\n    }\n\n    *port_target = session->opts.port;\n\n    return 0;\n}\n",
      "line_start": 1422,
      "line_end": 1436,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: only checks for NULL, returns a default port or stored value. No parsing, memory operations, loops, or complex branching \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_packet_set_default_callbacks",
      "clean_name": "ssh_packet_set_default_callbacks",
      "source_file": "/src/libssh/src/packet.c",
      "source_code": "}\n\n/** @internal\n * @brief sets the default packet handlers\n */\nvoid ssh_packet_set_default_callbacks(ssh_session session)\n{\n    struct ssh_packet_callbacks_struct *c = &session->default_packet_callbacks;\n\n    c->start = 1;\n    c->n_callbacks = sizeof(default_packet_handlers) / sizeof(ssh_packet_callback);\n    c->user = session;\n    c->callbacks = default_packet_handlers;\n    ssh_packet_set_callbacks(session, c);\n}\n",
      "line_start": 1589,
      "line_end": 1599,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: simply initializes a callback struct and forwards it to ssh_packet_set_callbacks. No parsing of external input, no loops, no memory operations on untrusted data, and minimal logic\u2014low value as a fuzz target."
    },
    {
      "name": "ssh_packet_service_accept",
      "clean_name": "ssh_packet_service_accept",
      "source_file": "/src/libssh/src/packet_cb.c",
      "source_code": "/**\n * @internal\n * @brief handles a SSH_SERVICE_ACCEPT packet\n *\n */\nSSH_PACKET_CALLBACK(ssh_packet_service_accept)\n{\n    (void)packet;\n    (void)type;\n    (void)user;\n\n    session->auth.service_state = SSH_AUTH_SERVICE_ACCEPTED;\n    SSH_LOG(SSH_LOG_PACKET, \"Received SSH_MSG_SERVICE_ACCEPT\");\n\n    return SSH_PACKET_USED;\n}\n",
      "line_start": 248,
      "line_end": 259,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial handler: ignores packet input and only sets session->auth.service_state and logs a message. No parsing, memory ops, branches, or input-dependent logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_pcap_context_set_file",
      "clean_name": "ssh_pcap_context_set_file",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "void ssh_pcap_context_free(ssh_pcap_context ctx)\n{\n    SAFE_FREE(ctx);\n}\n\nvoid ssh_pcap_context_set_file(ssh_pcap_context ctx, ssh_pcap_file pcap)\n{\n    ctx->file = pcap;\n}\n",
      "line_start": 313,
      "line_end": 317,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial setter: just assigns ctx->file = pcap. No parsing, no loops, no memory operations on untrusted data, minimal logic \u2014 very low value as a fuzz target."
    },
    {
      "name": "ssh_key_dup",
      "clean_name": "ssh_key_dup",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @param key An ssh_key to duplicate\n *\n * @return A duplicated ssh_key key\n */\nssh_key ssh_key_dup(const ssh_key key)\n{\n    if (key == NULL) {\n        return NULL;\n    }\n\n    return pki_key_dup(key, 0);\n}\n",
      "line_start": 197,
      "line_end": 205,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple wrapper that only NULL-checks and delegates to pki_key_dup; no parsing or manipulation of external data and minimal logic \u2014 low value as a fuzz target."
    },
    {
      "name": "ssh_key_type",
      "clean_name": "ssh_key_type",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *          SSH_KEYTYPE_RSA_CERT01, SSH_KEYTYPE_ECDSA_P256_CERT01,\n *          SSH_KEYTYPE_ECDSA_P384_CERT01, SSH_KEYTYPE_ECDSA_P521_CERT01, or\n *          SSH_KEYTYPE_ED25519_CERT01.\n * @returns SSH_KEYTYPE_UNKNOWN if the type is unknown\n */\nenum ssh_keytypes_e ssh_key_type(const ssh_key key)\n{\n    if (key == NULL) {\n        return SSH_KEYTYPE_UNKNOWN;\n    }\n    return key->type;\n}\n",
      "line_start": 266,
      "line_end": 273,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: returns key->type or UNKNOWN on NULL. No parsing, memory ops, loops, or security-critical logic \u2014 very low-value fuzz target."
    },
    {
      "name": "ssh_pki_export_privkey_base64",
      "clean_name": "ssh_pki_export_privkey_base64",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": " *\n * @return     SSH_OK on success, SSH_ERROR on error.\n *\n * @see ssh_string_free_char()\n */\nint ssh_pki_export_privkey_base64(const ssh_key privkey,\n                                  const char *passphrase,\n                                  ssh_auth_callback auth_fn,\n                                  void *auth_data,\n                                  char **b64_key)\n{\n    return ssh_pki_export_privkey_base64_format(privkey,\n                                                passphrase,\n                                                auth_fn,\n                                                auth_data,\n                                                b64_key,\n                                                SSH_FILE_FORMAT_DEFAULT);\n}\n",
      "line_start": 1062,
      "line_end": 1075,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial wrapper that just forwards arguments to ssh_pki_export_privkey_base64_format; contains no parsing, branching, or memory operations itself and therefore is a low-value fuzz target."
    },
    {
      "name": "ssh_poll_is_locked",
      "clean_name": "ssh_poll_is_locked",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " * @brief  Returns if a poll object is locked.\n *\n * @param  p            Pointer to an already allocated poll object.\n * @returns true if the poll object is locked; false otherwise.\n */\nbool ssh_poll_is_locked(ssh_poll_handle p)\n{\n    if (p == NULL) {\n        return false;\n    }\n    return p->lock_cnt > 0;\n}\n",
      "line_start": 690,
      "line_end": 697,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: checks for NULL and returns p->lock_cnt > 0. No parsing or memory ops, minimal logic and branching\u2014not a meaningful fuzz target."
    },
    {
      "name": "ssh_get_clientbanner",
      "clean_name": "ssh_get_clientbanner",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] session   The SSH session\n *\n * @return Returns the client banner string or NULL.\n */\nconst char* ssh_get_clientbanner(ssh_session session) {\n    if (session == NULL) {\n        return NULL;\n    }\n\n    return session->clientbanner;\n}\n",
      "line_start": 399,
      "line_end": 406,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: only a NULL check and return of session->clientbanner. No parsing, memory manipulation, loops, or branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_is_connected",
      "clean_name": "ssh_is_connected",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in]  session  The session to check if it is connected.\n *\n * @return              1 if we are connected, 0 if not.\n */\nint ssh_is_connected(ssh_session session) {\n    if (session == NULL) {\n        return 0;\n    }\n\n    return session->alive;\n}\n",
      "line_start": 636,
      "line_end": 643,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor: only checks for NULL and returns a field. No parsing, memory ops, or complex logic \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_get_publickey",
      "clean_name": "ssh_get_publickey",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "}\n\n/**\n * @deprecated Use ssh_get_server_publickey()\n */\nint ssh_get_publickey(ssh_session session, ssh_key *key)\n{\n    return ssh_get_server_publickey(session, key);\n}\n",
      "line_start": 1224,
      "line_end": 1228,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial deprecated wrapper that just forwards to ssh_get_server_publickey; no parsing, no memory ops, no branching or input handling \u2014 not a useful fuzz target."
    },
    {
      "name": "ttyopts.c:baud2speed",
      "clean_name": "baud2speed",
      "source_file": "/src/libssh/src/ttyopts.c",
      "source_code": "}\n\n#ifdef HAVE_TERMIOS_H\n/** Converts a baudrate constant (Bxxxx) to a numeric value. */\nstatic int\nbaud2speed(int baudrate)\n{\n    switch (baudrate) {\n    default:\n    case B0:\n        return 0;\n    case B50:\n        return 50;\n    case B75:\n        return 75;\n    case B110:\n        return 110;\n    case B134:\n        return 134;\n    case B150:\n        return 150;\n    case B200:\n        return 200;\n    case B300:\n        return 300;\n    case B600:\n        return 600;\n    case B1200:\n        return 1200;\n    case B1800:\n        return 1800;\n    case B2400:\n        return 2400;\n    case B4800:\n        return 4800;\n    case B9600:\n        return 9600;\n    case B19200:\n        return 19200;\n    case B38400:\n        return 38400;\n    case B57600:\n        return 57600;\n    case B115200:\n        return 115200;\n    case B230400:\n        return 230400;\n    }\n}\n",
      "line_start": 138,
      "line_end": 182,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 59,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "Trivial switch mapping of an integer constant to a numeric baud value; no parsing, no memory operations, no loops or complex branching and not security-critical \u2014 minimal value as a fuzz target."
    },
    {
      "name": "ssh_get_hmactab",
      "clean_name": "ssh_get_hmactab",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "  { \"none\",                          SSH_HMAC_NONE,          false },\n#endif /* WITH_INSECURE_NONE */\n  { NULL,                            0,                      false }\n};\n\nstruct ssh_hmac_struct *ssh_get_hmactab(void) {\n  return ssh_hmac_tab;\n}\n",
      "line_start": 71,
      "line_end": 74,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor returning an internal hmac table pointer; no external input, no parsing, no memory operations or branching \u2014 minimal value as a fuzz target."
    },
    {
      "name": "hmac_digest_len",
      "clean_name": "hmac_digest_len",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "\nstruct ssh_hmac_struct *ssh_get_hmactab(void) {\n  return ssh_hmac_tab;\n}\n\nsize_t hmac_digest_len(enum ssh_hmac_e type) {\n  switch(type) {\n    case SSH_HMAC_SHA1:\n      return SHA_DIGEST_LEN;\n    case SSH_HMAC_SHA256:\n      return SHA256_DIGEST_LEN;\n    case SSH_HMAC_SHA512:\n      return SHA512_DIGEST_LEN;\n    case SSH_HMAC_MD5:\n      return MD5_DIGEST_LEN;\n    case SSH_HMAC_AEAD_POLY1305:\n      return POLY1305_TAGLEN;\n    case SSH_HMAC_AEAD_GCM:\n      return AES_GCM_TAGLEN;\n    default:\n      return 0;\n  }\n}\n",
      "line_start": 75,
      "line_end": 93,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 31,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial enum-to-constant mapping with no parsing, memory operations, or complex control flow. No use as a fuzz target beyond basic input range checks; minimal security impact."
    },
    {
      "name": "sha512_ctx_free",
      "clean_name": "sha512_ctx_free",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return c;\n}\n\nvoid\nsha512_ctx_free(SHA512CTX c)\n{\n    EVP_MD_CTX_free(c);\n}\n",
      "line_start": 235,
      "line_end": 239,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple wrapper that only calls EVP_MD_CTX_free on the provided context; no parsing/validation, no branching or loops, minimal logic \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_message_service_service",
      "clean_name": "ssh_message_service_service",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param msg The service request message\n *\n * @returns the service name from the message\n */\nconst char *ssh_message_service_service(ssh_message msg){\n  if (msg == NULL) {\n    return NULL;\n  }\n  return msg->service_request.service;\n}\n",
      "line_start": 845,
      "line_end": 851,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor that returns a field from the message struct with only a NULL check; no parsing, memory operations, loops, or branching on untrusted data \u2014 low-value fuzz target."
    },
    {
      "name": "ssh_message_channel_request_env_value",
      "clean_name": "ssh_message_channel_request_env_value",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_env_name(ssh_message msg){\n    return msg->channel_request.var_name;\n}\n\nconst char *ssh_message_channel_request_env_value(ssh_message msg){\n    return msg->channel_request.var_value;\n}\n",
      "line_start": 1205,
      "line_end": 1208,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple accessor functions that only return fields from ssh_message (var_name, var_value). No parsing, memory operations, branching, or input-dependent logic \u2014 minimal value as fuzz targets."
    },
    {
      "name": "ssh_message_channel_request_subsystem",
      "clean_name": "ssh_message_channel_request_subsystem",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_command(ssh_message msg){\n    return msg->channel_request.command;\n}\n\nconst char *ssh_message_channel_request_subsystem(ssh_message msg){\n    return msg->channel_request.subsystem;\n}\n",
      "line_start": 1213,
      "line_end": 1216,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial accessor functions that simply return a pointer to a field in the message struct. They perform no parsing, memory manipulation, or control flow and thus have minimal value as standalone fuzz targets."
    },
    {
      "name": "ssh_message_channel_request_x11_auth_cookie",
      "clean_name": "ssh_message_channel_request_x11_auth_cookie",
      "source_file": "/src/libssh/src/server.c",
      "source_code": "\nconst char *ssh_message_channel_request_x11_auth_protocol(ssh_message msg){\n    return msg->channel_request.x11_auth_protocol;\n}\n\nconst char *ssh_message_channel_request_x11_auth_cookie(ssh_message msg){\n    return msg->channel_request.x11_auth_cookie;\n}\n",
      "line_start": 1225,
      "line_end": 1228,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Trivial getter that simply returns a pointer to a field (x11 auth cookie) with no parsing, memory manipulation, branching, or input-dependent control flow \u2014 low value as a direct fuzz target."
    },
    {
      "name": "ssh_client_dhgex_remove_callbacks",
      "clean_name": "ssh_client_dhgex_remove_callbacks",
      "source_file": "/src/libssh/src/dh-gex.c",
      "source_code": "    session->session_state = SSH_SESSION_STATE_ERROR;\n\n    return SSH_PACKET_USED;\n}\n\nvoid ssh_client_dhgex_remove_callbacks(ssh_session session)\n{\n    ssh_packet_remove_callbacks(session, &ssh_dhgex_client_callbacks);\n}\n",
      "line_start": 250,
      "line_end": 254,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 1.0,
      "reason": "Simple wrapper that removes callbacks; no parsing of external input, no memory ops or branching, minimal logic and not a useful fuzzing target."
    },
    {
      "name": "config.c:ssh_match_exec",
      "clean_name": "ssh_match_exec",
      "source_file": "/src/libssh/src/config.c",
      "source_code": "    free(cmd);\n    return result;\n}\n#else\nstatic int\nssh_match_exec(ssh_session session, const char *command, bool negate)\n{\n    (void)session;\n    (void)command;\n    (void)negate;\n\n    SSH_LOG(SSH_LOG_TRACE,\n            \"Unsupported 'exec' command on Windows '%s'\",\n            command);\n    return 0;\n}\n",
      "line_start": 425,
      "line_end": 436,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 4,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 1.0,
      "reason": "This Windows stub only logs the provided command and returns 0; it performs no parsing, memory manipulation, or branching on external input, so it is a trivial/low-value fuzz target."
    },
    {
      "name": "libssh_destructor",
      "clean_name": "libssh_destructor",
      "source_file": "/src/libssh/src/init.c",
      "source_code": " * @brief Finalize and clean up all libssh and cryptographic data structures.\n *\n * This function is automatically called when the library is unloaded.\n *\n */\nvoid libssh_destructor(void)\n{\n    int rc;\n\n    rc = _ssh_finalize(1);\n\n    if (rc < 0) {\n        fprintf(stderr, \"Error in libssh_destructor()\\n\");\n    }\n}\n",
      "line_start": 208,
      "line_end": 218,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 7,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Destructor with no external input or parsing; simply calls internal _ssh_finalize and logs an error. Not a suitable fuzz target."
    },
    {
      "name": "ssh_socket_cleanup",
      "clean_name": "ssh_socket_cleanup",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "}\n\n/**\n * @brief Cleanup the socket system.\n */\nvoid ssh_socket_cleanup(void)\n{\n    if (sockets_initialized == 1) {\n        ssh_poll_cleanup();\n#ifdef _WIN32\n        WSACleanup();\n#endif\n        sockets_initialized = 0;\n    }\n}\n",
      "line_start": 139,
      "line_end": 149,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or user-controllable data; a simple cleanup routine that manipulates internal global state and calls system cleanup functions. Not suitable as a fuzz target."
    },
    {
      "name": "ssh_socket_new",
      "clean_name": "ssh_socket_new",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n/**\n * \\internal\n * \\brief creates a new Socket object\n */\nssh_socket ssh_socket_new(ssh_session session)\n{\n    ssh_socket s;\n\n    s = calloc(1, sizeof(struct ssh_socket_struct));\n    if (s == NULL) {\n        ssh_set_error_oom(session);\n        return NULL;\n    }\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    s->session = session;\n    s->in_buffer = ssh_buffer_new();\n    if (s->in_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->out_buffer=ssh_buffer_new();\n    if (s->out_buffer == NULL) {\n        ssh_set_error_oom(session);\n        SSH_BUFFER_FREE(s->in_buffer);\n        SAFE_FREE(s);\n        return NULL;\n    }\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    s->poll_handle = NULL;\n    s->state=SSH_SOCKET_NONE;\n    return s;\n}\n",
      "line_start": 155,
      "line_end": 188,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 56,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Allocator/constructor that only allocates and initializes structures; no parsing of external input, no untrusted memory ops, no branching/loops \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_socket_reset",
      "clean_name": "ssh_socket_reset",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "/**\n * @internal\n * @brief Reset the state of a socket so it looks brand-new\n * @param[in] s socket to rest\n */\nvoid ssh_socket_reset(ssh_socket s)\n{\n    s->fd = SSH_INVALID_SOCKET;\n    s->last_errno = -1;\n    s->fd_is_socket = 1;\n    ssh_buffer_reinit(s->in_buffer);\n    ssh_buffer_reinit(s->out_buffer);\n    s->read_wontblock = 0;\n    s->write_wontblock = 0;\n    s->data_except = 0;\n    if (s->poll_handle != NULL) {\n        ssh_poll_free(s->poll_handle);\n        s->poll_handle = NULL;\n    }\n    s->state=SSH_SOCKET_NONE;\n#ifndef _WIN32\n    s->proxy_pid = 0;\n#endif\n}\n",
      "line_start": 194,
      "line_end": 213,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Not suitable: this is an internal reset/initializer that simply sets fields and calls reinit/free helpers. It does not parse or validate external input, perform memory ops on untrusted data, or contain complex branching \u2014 no meaningful fuzzing surface."
    },
    {
      "name": "ssh_socket_set_read_wontblock",
      "clean_name": "ssh_socket_set_read_wontblock",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "void ssh_socket_set_write_wontblock(ssh_socket s)\n{\n    s->write_wontblock = 1;\n}\n\nvoid ssh_socket_set_read_wontblock(ssh_socket s)\n{\n    s->read_wontblock = 1;\n}\n",
      "line_start": 774,
      "line_end": 778,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial setter: simply sets a flag on a socket structure with no parsing, branching, or use of external/untrusted input \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_socket_connect_proxyjump",
      "clean_name": "ssh_socket_connect_proxyjump",
      "source_file": "/src/libssh/src/socket.c",
      "source_code": "\n    pthread_exit(NULL);\n}\n\nint\nssh_socket_connect_proxyjump(ssh_socket s)\n{\n    ssh_poll_handle h = NULL;\n    int rc;\n    pthread_t jump_thread;\n    struct jump_thread_data_struct *jump_thread_data = NULL;\n    socket_t pair[2];\n\n    if (s->state != SSH_SOCKET_NONE) {\n        ssh_set_error(\n            s->session,\n            SSH_FATAL,\n            \"ssh_socket_connect_proxyjump called on socket not unconnected\");\n        return SSH_ERROR;\n    }\n\n    jump_thread_data = calloc(1, sizeof(struct jump_thread_data_struct));\n    if (jump_thread_data == NULL) {\n        ssh_set_error_oom(s->session);\n        return SSH_ERROR;\n    }\n\n    rc = socketpair(PF_UNIX, SOCK_STREAM, 0, pair);\n    if (rc == -1) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n        ssh_set_error(s->session,\n                      SSH_FATAL,\n                      \"Creating socket pair failed: %s\",\n                      ssh_strerror(errno, err_msg, SSH_ERRNO_MSG_MAX));\n        SAFE_FREE(jump_thread_data);\n        return SSH_ERROR;\n    }\n\n    jump_thread_data->session = s->session;\n    jump_thread_data->fd = pair[0];\n\n    rc = pthread_create(&jump_thread, NULL, jump_thread_func, jump_thread_data);\n    if (rc != 0) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n        ssh_set_error(s->session,\n                      SSH_FATAL,\n                      \"Creating new thread failed: %s\",\n                      ssh_strerror(rc, err_msg, SSH_ERRNO_MSG_MAX));\n        SAFE_FREE(jump_thread_data);\n        return SSH_ERROR;\n    }\n    rc = pthread_detach(jump_thread);\n    if (rc != 0) {\n        char err_msg[SSH_ERRNO_MSG_MAX] = {0};\n\n        ssh_set_error(s->session,\n                      SSH_FATAL,\n                      \"Failed to detach thread: %s\",\n                      ssh_strerror(rc, err_msg, SSH_ERRNO_MSG_MAX));\n        SAFE_FREE(jump_thread_data);\n        return SSH_ERROR;\n    }\n\n    SSH_LOG(SSH_LOG_DEBUG,\n            \"ProxyJump connection pipe: [%d,%d]\",\n            pair[0],\n            pair[1]);\n\n    rc = ssh_socket_set_fd(s, pair[1]);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    s->fd_is_socket = 1;\n    h = ssh_socket_get_poll_handle(s);\n    if (h == NULL) {\n        return SSH_ERROR;\n    }\n    ssh_socket_set_connected(s, h);\n    if (s->callbacks && s->callbacks->connected) {\n        s->callbacks->connected(SSH_SOCKET_CONNECTED_OK,\n                                0,\n                                s->callbacks->userdata);\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 1223,
      "line_end": 1307,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 116,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Not suitable: takes an internal ssh_socket context (no external data parsing), performs resource/thread setup and state changes but no parsing, memory ops on untrusted input, or input-dependent control flow to make a good fuzz target."
    },
    {
      "name": "ssh_threads_finalize",
      "clean_name": "ssh_threads_finalize",
      "source_file": "/src/libssh/src/threads.c",
      "source_code": "        threads_initialized = 1;\n    }\n    return rc;\n}\n\nvoid ssh_threads_finalize(void)\n{\n    crypto_thread_finalize();\n}\n",
      "line_start": 65,
      "line_end": 69,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing: this is an internal cleanup wrapper that just calls crypto_thread_finalize(), so not a suitable fuzz target."
    },
    {
      "name": "pthread.c:ssh_pthread_thread_id",
      "clean_name": "ssh_pthread_thread_id",
      "source_file": "/src/libssh/src/threads/pthread.c",
      "source_code": "static int ssh_pthread_mutex_unlock (void **mutex)\n{\n    return pthread_mutex_unlock((pthread_mutex_t *)*mutex);\n}\n\nstatic unsigned long ssh_pthread_thread_id (void)\n{\n#if defined(_WIN32) && !defined(__WINPTHREADS_VERSION)\n    return (unsigned long) pthread_self().p;\n#else\n    return (unsigned long) pthread_self();\n#endif\n}\n",
      "line_start": 78,
      "line_end": 86,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "Not suitable for fuzzing: purely returns the current thread ID (cast to unsigned long), no external input, no parsing, no memory operations or branches."
    },
    {
      "name": "crypto_thread_finalize",
      "clean_name": "crypto_thread_finalize",
      "source_file": "/src/libssh/src/threads/libcrypto.c",
      "source_code": "{\n    (void) cb;\n    return SSH_OK;\n}\n\nvoid crypto_thread_finalize(void)\n{\n    return;\n}\n",
      "line_start": 32,
      "line_end": 36,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Function takes no external input and is a no-op (just returns). It performs no parsing, memory operations, or branching, so it is not a suitable fuzzing target."
    },
    {
      "name": "ssh_reseed",
      "clean_name": "ssh_reseed",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "#include \"libssh/crypto.h\"\n\nstatic int libcrypto_initialized = 0;\n\n\nvoid ssh_reseed(void){\n#ifndef _WIN32\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    RAND_add(&tv, sizeof(tv), 0.0);\n#endif\n}\n",
      "line_start": 91,
      "line_end": 98,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Takes no external/user input and only seeds PRNG from current time via gettimeofday; no parsing, memory ops on untrusted data, or input-dependent logic \u2014 not a good fuzz target."
    },
    {
      "name": "ssh_get_ciphertab",
      "clean_name": "ssh_get_ciphertab",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "  {\n    .name = NULL\n  }\n};\n\nstruct ssh_cipher_struct *ssh_get_ciphertab(void)\n{\n  return ssh_ciphertab;\n}\n",
      "line_start": 1362,
      "line_end": 1366,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial getter with no external input or processing \u2014 simply returns a global pointer (ssh_ciphertab). Not suitable as a fuzz target."
    },
    {
      "name": "ssh_crypto_finalize",
      "clean_name": "ssh_crypto_finalize",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "\n/**\n * @internal\n * @brief Finalize libcrypto's subsystem\n */\nvoid ssh_crypto_finalize(void)\n{\n    if (!libcrypto_initialized) {\n        return;\n    }\n\n/* TODO this should finalize engine if it was started, but during atexit calls,\n * we are crashing. AFAIK this is related to the dlopened pkcs11 modules calling\n * the crypto cleanups earlier. */\n#if 0\n    if (engine != NULL) {\n        ENGINE_finish(engine);\n        ENGINE_free(engine);\n        engine = NULL;\n    }\n#endif\n#if defined(WITH_PKCS11_URI)\n#if defined(WITH_PKCS11_PROVIDER)\n    if (provider != NULL) {\n        OSSL_PROVIDER_unload(provider);\n        provider = NULL;\n    }\n#endif /* WITH_PKCS11_PROVIDER */\n#endif /* WITH_PKCS11_URI */\n\n    libcrypto_initialized = 0;\n}\n",
      "line_start": 1422,
      "line_end": 1449,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; trivial cleanup of global state with simple conditional checks. No memory ops, branching on untrusted data, or complex logic \u2014 not suitable as a fuzz target."
    },
    {
      "name": "libcrypto.c:chacha20_poly1305_cleanup",
      "clean_name": "chacha20_poly1305_cleanup",
      "source_file": "/src/libssh/src/libcrypto.c",
      "source_code": "    EVP_MAC_CTX *mctx;\n#endif /* OPENSSL_VERSION_NUMBER */\n};\n\nstatic void\nchacha20_poly1305_cleanup(struct ssh_cipher_struct *cipher)\n{\n    struct chacha20_poly1305_keysched *ctx = NULL;\n\n    if (cipher->chacha20_schedule == NULL) {\n        return;\n    }\n\n    ctx = cipher->chacha20_schedule;\n\n    EVP_CIPHER_CTX_free(ctx->main_evp);\n    ctx->main_evp  = NULL;\n    EVP_CIPHER_CTX_free(ctx->header_evp);\n    ctx->header_evp = NULL;\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n    /* ctx->pctx is freed as part of MD context */\n    EVP_PKEY_free(ctx->key);\n    ctx->key = NULL;\n    EVP_MD_CTX_free(ctx->mctx);\n    ctx->mctx = NULL;\n#else\n    EVP_MAC_CTX_free(ctx->mctx);\n    ctx->mctx = NULL;\n#endif /* OPENSSL_VERSION_NUMBER */\n\n    SAFE_FREE(cipher->chacha20_schedule);\n}\n",
      "line_start": 765,
      "line_end": 792,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 25,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "This is a cleanup/destructor that frees OpenSSL contexts and NULLs pointers. It performs no parsing, no processing of external/untrusted input, and contains only trivial logic, so it is not a useful fuzz target."
    },
    {
      "name": "ssh_bind_new",
      "clean_name": "ssh_bind_new",
      "source_file": "/src/libssh/src/bind.c",
      "source_code": "\n    freeaddrinfo (ai);\n    return s;\n}\n\nssh_bind ssh_bind_new(void)\n{\n    ssh_bind ptr = NULL;\n\n    ptr = calloc(1, sizeof(struct ssh_bind_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ptr->bindfd = SSH_INVALID_SOCKET;\n    ptr->bindport = 22;\n    ptr->common.log_verbosity = 0;\n\n    return ptr;\n}\n",
      "line_start": 134,
      "line_end": 148,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple allocator/initializer with no external input, parsing, or branching. Acts as a constructor setting fixed defaults\u2014no user-controllable data or security-relevant logic, so not a fuzz target."
    },
    {
      "name": "ssh_agent_state_free",
      "clean_name": "ssh_agent_state_free",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "    ssh_key pubkey;\n    char *comment;\n};\n\n/* Internal function */\nvoid ssh_agent_state_free(void *data)\n{\n    struct ssh_agent_state_struct *state = data;\n\n    if (state) {\n        SSH_STRING_FREE_CHAR(state->comment);\n        ssh_key_free(state->pubkey);\n        free(state);\n    }\n}\n",
      "line_start": 977,
      "line_end": 987,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Pure cleanup/destructor: frees members and the struct, no parsing or logic on external input. No input-dependent control flow or complex operations \u2014 not a useful standalone fuzz target."
    },
    {
      "name": "ssh_kbdint_new",
      "clean_name": "ssh_kbdint_new",
      "source_file": "/src/libssh/src/auth.c",
      "source_code": "    ssh_key_free(key);\n\n    return rc;\n}\n\nssh_kbdint ssh_kbdint_new(void)\n{\n    ssh_kbdint kbd;\n\n    kbd = calloc(1, sizeof(struct ssh_kbdint_struct));\n    if (kbd == NULL) {\n        return NULL;\n    }\n\n    return kbd;\n}\n",
      "line_start": 1818,
      "line_end": 1829,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simply allocates/zeroes an internal struct and returns it. Pure constructor-style function with no branches or memory ops on untrusted data \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_buffer_new",
      "clean_name": "ssh_buffer_new",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": "/**\n * @brief Create a new SSH buffer.\n *\n * @return A newly initialized SSH buffer, NULL on error.\n */\nstruct ssh_buffer_struct *ssh_buffer_new(void)\n{\n    struct ssh_buffer_struct *buf = NULL;\n    int rc;\n\n    buf = calloc(1, sizeof(struct ssh_buffer_struct));\n    if (buf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * Always preallocate 64 bytes.\n     *\n     * -1 for realloc_buffer magic.\n     */\n    rc = ssh_buffer_allocate_size(buf, 64 - 1);\n    if (rc != 0) {\n        SAFE_FREE(buf);\n        return NULL;\n    }\n    buffer_verify(buf);\n\n    return buf;\n}\n",
      "line_start": 119,
      "line_end": 143,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input parameters and only performs internal memory allocation/initialization; does not parse or process untrusted data, so it is not a useful fuzz target."
    },
    {
      "name": "ssh_buffer_free",
      "clean_name": "ssh_buffer_free",
      "source_file": "/src/libssh/src/buffer.c",
      "source_code": "/**\n * @brief Deallocate a SSH buffer.\n *\n * \\param[in]  buffer   The buffer to free.\n */\nvoid ssh_buffer_free(struct ssh_buffer_struct *buffer)\n{\n    if (buffer == NULL) {\n        return;\n    }\n    buffer_verify(buffer);\n\n    if (buffer->secure && buffer->allocated > 0) {\n        /* burn the data */\n        explicit_bzero(buffer->data, buffer->allocated);\n        SAFE_FREE(buffer->data);\n\n        explicit_bzero(buffer, sizeof(struct ssh_buffer_struct));\n    } else {\n        SAFE_FREE(buffer->data);\n    }\n    SAFE_FREE(buffer);\n}\n",
      "line_start": 149,
      "line_end": 167,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 42,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Not a good fuzz target: this function only deallocates an ssh_buffer_struct and zeroes memory. It does not parse or validate external input or implement complex branching\u2014it's internal cleanup. Any issues would stem from callers passing invalid pointers, so the function itself offers little value for fuzzing."
    },
    {
      "name": "ssh_channel_new_id",
      "clean_name": "ssh_channel_new_id",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": " *\n * @param[in]  session  The SSH session to use.\n *\n * @return              The new channel identifier.\n */\nuint32_t ssh_channel_new_id(ssh_session session)\n{\n    return ++(session->maxchannel);\n}\n",
      "line_start": 156,
      "line_end": 160,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial internal state update: simply increments session->maxchannel and returns it. No parsing of external input, no branching, no memory operations or complex logic \u2014 not useful as a fuzz target."
    },
    {
      "name": "channels.c:generate_cookie",
      "clean_name": "generate_cookie",
      "source_file": "/src/libssh/src/channels.c",
      "source_code": "        return SSH_ERROR;\n    }\n    return ssh_channel_request_subsystem(channel, \"sftp\");\n}\n\nstatic char *generate_cookie(void)\n{\n  static const char *hex = \"0123456789abcdef\";\n  char s[36];\n  unsigned char rnd[16];\n  int ok;\n  int i;\n\n  ok = ssh_get_random(rnd, sizeof(rnd), 0);\n  if (!ok) {\n      return NULL;\n  }\n\n  for (i = 0; i < 16; i++) {\n    s[i*2] = hex[rnd[i] & 0x0f];\n    s[i*2+1] = hex[rnd[i] >> 4];\n  }\n  s[32] = '\\0';\n  return strdup(s);\n}\n",
      "line_start": 2213,
      "line_end": 2233,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "No external/untrusted input: function generates a random cookie from internal RNG, performs trivial deterministic formatting and returns a strdup'ed string. Contains no parsing, branching, or user-controlled memory operations, so not a useful fuzz target."
    },
    {
      "name": "ssh_copyright",
      "clean_name": "ssh_copyright",
      "source_file": "/src/libssh/src/client.c",
      "source_code": " *\n * Returns copyright information\n *\n * @returns SSH_STRING copyright\n */\nconst char *ssh_copyright(void)\n{\n    return SSH_STRINGIFY(LIBSSH_VERSION) \" (c) 2003-2025 \"\n           \"Aris Adamantiadis, Andreas Schneider \"\n           \"and libssh contributors. \"\n           \"Distributed under the LGPL, please refer to COPYING \"\n           \"file for information about your rights\";\n}\n",
      "line_start": 903,
      "line_end": 911,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Returns a static constant string with no external inputs or branching. Pure accessor; no parsing, memory ops, or input-dependent behavior \u2014 not a suitable fuzz target."
    },
    {
      "name": "ssh_connector_free",
      "clean_name": "ssh_connector_free",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "            ssh_connector_channel_write_wontblock_cb;\n\n    return connector;\n}\n\nvoid ssh_connector_free (ssh_connector connector)\n{\n    if (connector->in_channel != NULL) {\n        ssh_remove_channel_callbacks(connector->in_channel,\n                                     &connector->in_channel_cb);\n    }\n    if (connector->out_channel != NULL) {\n        ssh_remove_channel_callbacks(connector->out_channel,\n                                     &connector->out_channel_cb);\n    }\n\n    if (connector->event != NULL){\n        ssh_connector_remove_event(connector);\n    }\n\n    if (connector->in_poll != NULL) {\n        ssh_poll_free(connector->in_poll);\n        connector->in_poll = NULL;\n    }\n\n    if (connector->out_poll != NULL) {\n        ssh_poll_free(connector->out_poll);\n        connector->out_poll = NULL;\n    }\n\n    free(connector);\n}\n",
      "line_start": 114,
      "line_end": 141,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 26,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Cleanup function that frees internal resources; no parsing or processing of external/untrusted input, no complex logic or memory operations on user data \u2014 not a suitable fuzz target."
    },
    {
      "name": "connector.c:ssh_connector_except_channel",
      "clean_name": "ssh_connector_except_channel",
      "source_file": "/src/libssh/src/connector.c",
      "source_code": "    (void) connector;\n    (void) fd;\n}\n\n/* TODO */\nstatic void ssh_connector_except_channel(ssh_connector connector,\n                                         ssh_channel channel)\n{\n    (void) connector;\n    (void) channel;\n}\n",
      "line_start": 196,
      "line_end": 202,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "Empty stub: parameters are unused and there is no parsing, memory manipulation, or control flow. Not suitable as a fuzz target."
    },
    {
      "name": "sntrup761.c:ssh_sntrup761x25519_init",
      "clean_name": "ssh_sntrup761x25519_init",
      "source_file": "/src/libssh/src/sntrup761.c",
      "source_code": "        .n_callbacks = 1,\n        .callbacks = dh_client_callbacks,\n        .user = NULL,\n};\n\nstatic int ssh_sntrup761x25519_init(ssh_session session)\n{\n    int rc;\n\n    rc = ssh_curve25519_init(session);\n    if (rc != SSH_OK) {\n        return rc;\n    }\n\n    if (!session->server) {\n#ifdef HAVE_LIBGCRYPT\n        gcry_error_t err;\n\n        err = gcry_kem_keypair(GCRY_KEM_SNTRUP761,\n                               session->next_crypto->sntrup761_client_pubkey,\n                               SNTRUP761_PUBLICKEY_SIZE,\n                               session->next_crypto->sntrup761_privkey,\n                               SNTRUP761_SECRETKEY_SIZE);\n        if (err) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to generate sntrup761 key: %s\",\n                    gpg_strerror(err));\n            return SSH_ERROR;\n        }\n#else\n        sntrup761_keypair(session->next_crypto->sntrup761_client_pubkey,\n                          session->next_crypto->sntrup761_privkey,\n                          &rc,\n                          crypto_random);\n        if (rc != 1) {\n            SSH_LOG(SSH_LOG_TRACE,\n                    \"Failed to generate sntrup761 key: PRNG failure\");\n            return SSH_ERROR;\n        }\n#endif /* HAVE_LIBGCRYPT */\n    }\n\n    return SSH_OK;\n}\n",
      "line_start": 68,
      "line_end": 107,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 27,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "Initialization function that generates keys and calls crypto libs; it does not parse or process external/untrusted input or perform risky memory ops. It's essentially setup/constructor logic, so not a good fuzz target."
    },
    {
      "name": "ssh_dh_finalize",
      "clean_name": "ssh_dh_finalize",
      "source_file": "/src/libssh/src/dh.c",
      "source_code": "\n/**\n * @internal\n * @brief Finalize and free global constants used in DH key agreement\n */\nvoid ssh_dh_finalize(void)\n{\n    if (!dh_crypto_initialized) {\n        return;\n    }\n\n    bignum_safe_free(ssh_dh_generator);\n    bignum_safe_free(ssh_dh_group1);\n    bignum_safe_free(ssh_dh_group14);\n    bignum_safe_free(ssh_dh_group16);\n    bignum_safe_free(ssh_dh_group18);\n\n    dh_crypto_initialized = 0;\n}\n",
      "line_start": 273,
      "line_end": 287,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 48,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simple cleanup of global resources (freeing bignums and resetting a flag). Internal destructor-like function with no input-dependent logic, not suitable as a fuzz target."
    },
    {
      "name": "_ssh_reset_log_cb",
      "clean_name": "_ssh_reset_log_cb",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "\n  return SSH_OK;\n}\n\nvoid\n_ssh_reset_log_cb(void)\n{\n    ssh_log_cb = NULL;\n}\n",
      "line_start": 224,
      "line_end": 228,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 2,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial internal function that just clears a global callback (ssh_log_cb = NULL); no external input, no parsing or memory ops \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_get_log_userdata",
      "clean_name": "ssh_get_log_userdata",
      "source_file": "/src/libssh/src/log.c",
      "source_code": "/**\n * @brief Get the userdata of the logging function.\n *\n * @return    The userdata if set or NULL.\n */\nvoid *ssh_get_log_userdata(void)\n{\n    if (ssh_log_userdata == NULL) {\n        return NULL;\n    }\n\n    return ssh_log_userdata;\n}\n",
      "line_start": 238,
      "line_end": 246,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial accessor with no external input or complex logic; simply returns a global pointer or NULL, so not a useful fuzz target."
    },
    {
      "name": "ssh_message_pop_head",
      "clean_name": "ssh_message_pop_head",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " *\n * @param[in]  session  The SSH session to pop the message.\n *\n * @returns             The head message or NULL if it doesn't exist.\n */\nssh_message ssh_message_pop_head(ssh_session session)\n{\n    ssh_message msg = NULL;\n    struct ssh_iterator *i = NULL;\n\n    if (session->ssh_message_list == NULL)\n        return NULL;\n\n    i = ssh_list_get_iterator(session->ssh_message_list);\n    if (i != NULL) {\n        msg = ssh_iterator_value(ssh_message, i);\n        ssh_list_remove(session->ssh_message_list, i);\n    }\n    return msg;\n}\n",
      "line_start": 548,
      "line_end": 563,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 18,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial internal accessor: pops a message from an internal list with no parsing of external input, no complex logic, no memory/IO operations on untrusted data \u2014 not a worthwhile fuzz target."
    },
    {
      "name": "messages.c:ssh_message_new",
      "clean_name": "ssh_message_new",
      "source_file": "/src/libssh/src/messages.c",
      "source_code": " * if you don't know what to do).\n *\n * @{\n */\n\nstatic ssh_message ssh_message_new(ssh_session session)\n{\n    ssh_message msg = calloc(1, sizeof(struct ssh_message_struct));\n    if (msg == NULL) {\n        return NULL;\n    }\n    msg->session = session;\n\n    /* Set states explicitly */\n    msg->auth_request.signature_state = SSH_PUBLICKEY_STATE_NONE;\n\n    return msg;\n}\n",
      "line_start": 65,
      "line_end": 78,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": true,
      "score": 0.0,
      "reason": "Simple constructor: allocates and initializes a message struct with no parsing or operations on external/untrusted data. No complex logic, branching, or memory manipulation of user input \u2014 not suitable as a fuzz target."
    },
    {
      "name": "ssh_list_new",
      "clean_name": "ssh_list_new",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "    }\n\n    return NULL;\n}\n\nstruct ssh_list *ssh_list_new(void)\n{\n    struct ssh_list *ret = malloc(sizeof(struct ssh_list));\n    if (ret == NULL) {\n        return NULL;\n    }\n    ret->root = ret->end = NULL;\n    return ret;\n}\n",
      "line_start": 744,
      "line_end": 753,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Allocates and initializes a simple list struct with no external input or parsing; trivial constructor/allocator with no security-relevant logic."
    },
    {
      "name": "ssh_timestamp_init",
      "clean_name": "ssh_timestamp_init",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": "/**\n * @internal\n * @brief initializes a timestamp to the current time\n * @param[out] ts pointer to an allocated ssh_timestamp structure\n */\nvoid ssh_timestamp_init(struct ssh_timestamp *ts)\n{\n#ifdef HAVE_CLOCK_GETTIME\n  struct timespec tp;\n  clock_gettime(CLOCK, &tp);\n  ts->useconds = tp.tv_nsec / 1000;\n#else\n  struct timeval tp;\n  gettimeofday(&tp, NULL);\n  ts->useconds = tp.tv_usec;\n#endif\n  ts->seconds = tp.tv_sec;\n}\n",
      "line_start": 1484,
      "line_end": 1497,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external/untrusted input is processed \u2014 it simply reads system time and writes to the provided struct. No parsing, memory ops on attacker data, or complex logic; not a useful fuzz target."
    },
    {
      "name": "ssh_proxyjumps_free",
      "clean_name": "ssh_proxyjumps_free",
      "source_file": "/src/libssh/src/misc.c",
      "source_code": " *\n * @param proxy_jump_list\n *\n */\nvoid\nssh_proxyjumps_free(struct ssh_list *proxy_jump_list)\n{\n    struct ssh_jump_info_struct *jump = NULL;\n\n    for (jump =\n             ssh_list_pop_head(struct ssh_jump_info_struct *, proxy_jump_list);\n         jump != NULL;\n         jump = ssh_list_pop_head(struct ssh_jump_info_struct *,\n                                  proxy_jump_list)) {\n        SAFE_FREE(jump->hostname);\n        SAFE_FREE(jump->username);\n        SAFE_FREE(jump);\n    }\n}\n",
      "line_start": 2264,
      "line_end": 2278,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 36,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simply frees list nodes and associated strings; no parsing of external input, no branching or input-dependent logic, and no security-critical operations \u2014 not a useful standalone fuzz target."
    },
    {
      "name": "ssh_pcap_file_new",
      "clean_name": "ssh_pcap_file_new",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "};\n\n/**\n * @brief create a new ssh_pcap_file object\n */\nssh_pcap_file ssh_pcap_file_new(void)\n{\n    struct ssh_pcap_file_struct *pcap = NULL;\n\n    pcap = calloc(1, sizeof(struct ssh_pcap_file_struct));\n    if (pcap == NULL) {\n        return NULL;\n    }\n\n    return pcap;\n}\n",
      "line_start": 124,
      "line_end": 135,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simply allocates and zeros a struct. Pure allocator/constructor with trivial logic \u2014 not suitable as a fuzz target."
    },
    {
      "name": "ssh_pcap_file_free",
      "clean_name": "ssh_pcap_file_free",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "    } else {\n        return SSH_OK;\n    }\n}\n\nvoid ssh_pcap_file_free(ssh_pcap_file pcap)\n{\n    ssh_pcap_file_close(pcap);\n    SAFE_FREE(pcap);\n}\n",
      "line_start": 285,
      "line_end": 290,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Cleanup/free function: trivial wrapper that calls ssh_pcap_file_close and SAFE_FREE, no parsing or processing of external input and no complex logic \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_pcap_context_free",
      "clean_name": "ssh_pcap_context_free",
      "source_file": "/src/libssh/src/pcap.c",
      "source_code": "    }\n    ctx->session = session;\n    return ctx;\n}\n\nvoid ssh_pcap_context_free(ssh_pcap_context ctx)\n{\n    SAFE_FREE(ctx);\n}\n",
      "line_start": 308,
      "line_end": 312,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial free/destructor: simply frees the ctx pointer via SAFE_FREE with no parsing, branching, or processing of external data. Not a useful standalone fuzz target."
    },
    {
      "name": "ssh_key_new",
      "clean_name": "ssh_key_new",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "/**\n * @brief creates a new empty SSH key\n *\n * @returns an empty ssh_key handle, or NULL on error.\n */\nssh_key ssh_key_new (void)\n{\n    ssh_key ptr = malloc (sizeof (struct ssh_key_struct));\n    if (ptr == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(ptr);\n    return ptr;\n}\n",
      "line_start": 108,
      "line_end": 117,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 15,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simple constructor that allocates and zeroes a struct with no branching or input-dependent behavior \u2014 not suitable as a fuzz target."
    },
    {
      "name": "ssh_signature_new",
      "clean_name": "ssh_signature_new",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "#endif\n\n    return pki_key_compare(k1, k2, what);\n}\n\nssh_signature ssh_signature_new(void)\n{\n    struct ssh_signature_struct *sig = NULL;\n\n    sig = calloc(1, sizeof(struct ssh_signature_struct));\n    if (sig == NULL) {\n        return NULL;\n    }\n\n    return sig;\n}\n",
      "line_start": 831,
      "line_end": 842,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 11,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple constructor/allocator with no external input or parsing and minimal logic (calloc + NULL check). Not a meaningful fuzz target."
    },
    {
      "name": "ssh_signature_free",
      "clean_name": "ssh_signature_free",
      "source_file": "/src/libssh/src/pki.c",
      "source_code": "    }\n\n    return sig;\n}\n\nvoid ssh_signature_free(ssh_signature sig)\n{\n    if (sig == NULL) {\n        return;\n    }\n\n    switch(sig->type) {\n        case SSH_KEYTYPE_RSA:\n#ifdef HAVE_LIBGCRYPT\n            gcry_sexp_release(sig->rsa_sig);\n#elif defined HAVE_LIBMBEDCRYPTO\n            SAFE_FREE(sig->rsa_sig);\n#endif /* HAVE_LIBGCRYPT */\n            break;\n        case SSH_KEYTYPE_ECDSA_P256:\n        case SSH_KEYTYPE_ECDSA_P384:\n        case SSH_KEYTYPE_ECDSA_P521:\n        case SSH_KEYTYPE_SK_ECDSA:\n#ifdef HAVE_GCRYPT_ECC\n            gcry_sexp_release(sig->ecdsa_sig);\n#elif defined HAVE_LIBMBEDCRYPTO\n            bignum_safe_free(sig->ecdsa_sig.r);\n            bignum_safe_free(sig->ecdsa_sig.s);\n#endif /* HAVE_GCRYPT_ECC */\n            break;\n        case SSH_KEYTYPE_ED25519:\n        case SSH_KEYTYPE_SK_ED25519:\n#ifndef HAVE_LIBCRYPTO\n            /* When using OpenSSL, the signature is stored in sig->raw_sig */\n            SAFE_FREE(sig->ed25519_sig);\n#endif /* HAVE_LIBCRYPTO */\n            break;\n        case SSH_KEYTYPE_DSS:   /* deprecated */\n        case SSH_KEYTYPE_DSS_CERT01:    /* deprecated */\n        case SSH_KEYTYPE_RSA_CERT01:\n        case SSH_KEYTYPE_ECDSA_P256_CERT01:\n        case SSH_KEYTYPE_ECDSA_P384_CERT01:\n        case SSH_KEYTYPE_ECDSA_P521_CERT01:\n        case SSH_KEYTYPE_ED25519_CERT01:\n        case SSH_KEYTYPE_SK_ECDSA_CERT01:\n        case SSH_KEYTYPE_SK_ED25519_CERT01:\n        case SSH_KEYTYPE_RSA1:\n        case SSH_KEYTYPE_ECDSA:\n        case SSH_KEYTYPE_UNKNOWN:\n            break;\n    }\n\n    /* Explicitly zero the signature content before free */\n    ssh_string_burn(sig->raw_sig);\n    SSH_STRING_FREE(sig->raw_sig);\n    SAFE_FREE(sig);\n}\n",
      "line_start": 843,
      "line_end": 895,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Destructor/cleanup function that frees internal structures based on type; contains only simple conditional frees and zeroing, no parsing of external input, no complex control flow, and thus is not a useful fuzz target."
    },
    {
      "name": "ssh_poll_cleanup",
      "clean_name": "ssh_poll_cleanup",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": "void ssh_poll_init(void)\n{\n    return;\n}\n\nvoid ssh_poll_cleanup(void)\n{\n    return;\n}\n",
      "line_start": 91,
      "line_end": 95,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Function is an empty cleanup with no parameters or logic, no parsing or memory operations and no external input\u2014unsuitable as a fuzz target."
    },
    {
      "name": "ssh_event_new",
      "clean_name": "ssh_event_new",
      "source_file": "/src/libssh/src/poll.c",
      "source_code": " *         same time as the event context. You would need a single event context\n *         per thread.\n *\n * @return  The ssh_event object on success, NULL on failure.\n */\nssh_event ssh_event_new(void)\n{\n    ssh_event event;\n\n    event = malloc(sizeof(struct ssh_event_struct));\n    if (event == NULL) {\n        return NULL;\n    }\n    ZERO_STRUCTP(event);\n\n    event->ctx = ssh_poll_ctx_new(2);\n    if (event->ctx == NULL) {\n        free(event);\n        return NULL;\n    }\n\n#ifdef WITH_SERVER\n    event->sessions = ssh_list_new();\n    if (event->sessions == NULL) {\n        ssh_poll_ctx_free(event->ctx);\n        free(event);\n        return NULL;\n    }\n#endif\n\n    return event;\n}\n",
      "line_start": 830,
      "line_end": 857,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 33,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input parameters and only performs allocation/initialization and internal constructor calls; contains no parsing, I/O, or operations on untrusted data\u2014unsuitable as a fuzz target."
    },
    {
      "name": "ssh_new",
      "clean_name": "ssh_new",
      "source_file": "/src/libssh/src/session.c",
      "source_code": "/**\n * @brief Create a new ssh session.\n *\n * @returns             A new ssh_session pointer, NULL on error.\n */\nssh_session ssh_new(void)\n{\n    ssh_session session = NULL;\n    char *id = NULL;\n    int rc;\n\n    session = calloc(1, sizeof (struct ssh_session_struct));\n    if (session == NULL) {\n        return NULL;\n    }\n\n    session->next_crypto = crypto_new();\n    if (session->next_crypto == NULL) {\n        goto err;\n    }\n\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n        goto err;\n    }\n\n    session->out_buffer = ssh_buffer_new();\n    if (session->out_buffer == NULL) {\n        goto err;\n    }\n\n    session->in_buffer = ssh_buffer_new();\n    if (session->in_buffer == NULL) {\n        goto err;\n    }\n\n    session->out_queue = ssh_list_new();\n    if (session->out_queue == NULL) {\n        goto err;\n    }\n\n    session->alive = 0;\n    session->auth.supported_methods = 0;\n    ssh_set_blocking(session, 1);\n    session->maxchannel = FIRST_CHANNEL;\n    session->proxy_root = true;\n\n    session->agent = ssh_agent_new(session);\n    if (session->agent == NULL) {\n        goto err;\n    }\n\n    /* OPTIONS */\n    session->opts.StrictHostKeyChecking = 1;\n    session->opts.port = 22;\n    session->opts.fd = -1;\n    session->opts.compressionlevel = 7;\n    session->opts.nodelay = 0;\n    session->opts.identities_only = false;\n    session->opts.control_master = SSH_CONTROL_MASTER_NO;\n\n    session->opts.flags = SSH_OPT_FLAG_PASSWORD_AUTH |\n                          SSH_OPT_FLAG_PUBKEY_AUTH |\n                          SSH_OPT_FLAG_KBDINT_AUTH |\n                          SSH_OPT_FLAG_GSSAPI_AUTH;\n\n    session->opts.exp_flags = 0;\n\n    session->opts.identity = ssh_list_new();\n    if (session->opts.identity == NULL) {\n        goto err;\n    }\n    session->opts.identity_non_exp = ssh_list_new();\n    if (session->opts.identity_non_exp == NULL) {\n        goto err;\n    }\n\n    session->opts.certificate = ssh_list_new();\n    if (session->opts.certificate == NULL) {\n        goto err;\n    }\n    session->opts.certificate_non_exp = ssh_list_new();\n    if (session->opts.certificate_non_exp == NULL) {\n        goto err;\n    }\n    /* the default certificates are loaded automatically from the default\n     * identities later */\n\n    session->opts.proxy_jumps = ssh_list_new();\n    if (session->opts.proxy_jumps == NULL) {\n        goto err;\n    }\n\n    session->opts.proxy_jumps_user_cb = ssh_list_new();\n    if (session->opts.proxy_jumps_user_cb == NULL) {\n        goto err;\n    }\n\n    id = strdup(\"%d/id_ed25519\");\n    if (id == NULL) {\n        goto err;\n    }\n\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n#ifdef HAVE_ECC\n    id = strdup(\"%d/id_ecdsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n#endif\n\n    id = strdup(\"%d/id_rsa\");\n    if (id == NULL) {\n        goto err;\n    }\n    rc = ssh_list_append(session->opts.identity_non_exp, id);\n    if (rc == SSH_ERROR) {\n        goto err;\n    }\n\n    /* Explicitly initialize states */\n    session->session_state = SSH_SESSION_STATE_NONE;\n    session->pending_call_state = SSH_PENDING_CALL_NONE;\n    session->packet_state = PACKET_STATE_INIT;\n    session->dh_handshake_state = DH_STATE_INIT;\n    session->global_req_state = SSH_CHANNEL_REQ_STATE_NONE;\n\n    session->auth.state = SSH_AUTH_STATE_NONE;\n    session->auth.service_state = SSH_AUTH_SERVICE_NONE;\n\n    return session;\n\nerr:\n    free(id);\n    ssh_free(session);\n    return NULL;\n}\n",
      "line_start": 63,
      "line_end": 203,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 159,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Constructor/initializer with no external input or parsing; only allocates and sets defaults (no untrusted data handling), so not a useful fuzz target."
    },
    {
      "name": "ssh_clean_pubkey_hash",
      "clean_name": "ssh_clean_pubkey_hash",
      "source_file": "/src/libssh/src/session.c",
      "source_code": " *\n * @param[in] hash      The buffer to deallocate.\n *\n * @see ssh_get_pubkey_hash()\n */\nvoid ssh_clean_pubkey_hash(unsigned char **hash)\n{\n    SAFE_FREE(*hash);\n}\n",
      "line_start": 1185,
      "line_end": 1189,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple cleanup wrapper that just frees a buffer (SAFE_FREE). No parsing, no branching, no processing of external input \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_string_free_char",
      "clean_name": "ssh_string_free_char",
      "source_file": "/src/libssh/src/string.c",
      "source_code": "/**\n * @brief Deallocate a char string object.\n *\n * @param[in] s         The string to delete.\n */\nvoid ssh_string_free_char(char *s)\n{\n    SAFE_FREE(s);\n}\n",
      "line_start": 212,
      "line_end": 216,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial deallocator wrapper with no parsing, branching, or processing of external data; a destructor-style function not suitable as a fuzz target."
    },
    {
      "name": "ssh_string_free",
      "clean_name": "ssh_string_free",
      "source_file": "/src/libssh/src/string.c",
      "source_code": "/**\n * @brief Deallocate a SSH string object.\n *\n * \\param[in] s         The SSH string to delete.\n */\nvoid ssh_string_free(struct ssh_string_struct *s)\n{\n    SAFE_FREE(s);\n}\n",
      "line_start": 331,
      "line_end": 335,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 9,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple deallocator: just frees a struct (SAFE_FREE), no parsing or handling of external input, no control flow \u2014 not a useful fuzz target."
    },
    {
      "name": "crypto_new",
      "clean_name": "crypto_new",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "static void cipher_free(struct ssh_cipher_struct *cipher) {\n  ssh_cipher_clear(cipher);\n  SAFE_FREE(cipher);\n}\n\nstruct ssh_crypto_struct *crypto_new(void)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n\n    crypto = calloc(1, sizeof(struct ssh_crypto_struct));\n    if (crypto == NULL) {\n        return NULL;\n    }\n    return crypto;\n}\n",
      "line_start": 149,
      "line_end": 159,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 10,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Constructor-like allocator with no external input or parsing; trivial allocation/zeroing and no complex logic or untrusted-data handling, not a useful fuzz target."
    },
    {
      "name": "crypto_free",
      "clean_name": "crypto_free",
      "source_file": "/src/libssh/src/wrapper.c",
      "source_code": "        return NULL;\n    }\n    return crypto;\n}\n\nvoid crypto_free(struct ssh_crypto_struct *crypto)\n{\n    size_t i;\n\n    if (crypto == NULL) {\n        return;\n    }\n\n    ssh_key_free(crypto->server_pubkey);\n\n    ssh_dh_cleanup(crypto);\n    bignum_safe_free(crypto->shared_secret);\n#ifdef HAVE_ECDH\n    SAFE_FREE(crypto->ecdh_client_pubkey);\n    SAFE_FREE(crypto->ecdh_server_pubkey);\n    if (crypto->ecdh_privkey != NULL) {\n#ifdef HAVE_OPENSSL_ECC\n#if OPENSSL_VERSION_NUMBER < 0x30000000L\n        EC_KEY_free(crypto->ecdh_privkey);\n#else\n        EVP_PKEY_free(crypto->ecdh_privkey);\n#endif /* OPENSSL_VERSION_NUMBER */\n#elif defined HAVE_GCRYPT_ECC\n        gcry_sexp_release(crypto->ecdh_privkey);\n#elif defined HAVE_LIBMBEDCRYPTO\n        mbedtls_ecp_keypair_free(crypto->ecdh_privkey);\n        SAFE_FREE(crypto->ecdh_privkey);\n#endif /* HAVE_LIBGCRYPT */\n        crypto->ecdh_privkey = NULL;\n    }\n#endif\n#ifdef HAVE_LIBCRYPTO\n    EVP_PKEY_free(crypto->curve25519_privkey);\n#elif defined(HAVE_GCRYPT_CURVE25519)\n    gcry_sexp_release(crypto->curve25519_privkey);\n#endif\n    SAFE_FREE(crypto->dh_server_signature);\n    if (crypto->session_id != NULL) {\n        explicit_bzero(crypto->session_id, crypto->session_id_len);\n        SAFE_FREE(crypto->session_id);\n    }\n    if (crypto->secret_hash != NULL) {\n        explicit_bzero(crypto->secret_hash, crypto->digest_len);\n        SAFE_FREE(crypto->secret_hash);\n    }\n    compress_cleanup(crypto);\n    SAFE_FREE(crypto->encryptIV);\n    SAFE_FREE(crypto->decryptIV);\n    SAFE_FREE(crypto->encryptMAC);\n    SAFE_FREE(crypto->decryptMAC);\n    if (crypto->encryptkey != NULL) {\n        explicit_bzero(crypto->encryptkey, crypto->out_cipher->keysize / 8);\n        SAFE_FREE(crypto->encryptkey);\n    }\n    if (crypto->decryptkey != NULL) {\n        explicit_bzero(crypto->decryptkey, crypto->in_cipher->keysize / 8);\n        SAFE_FREE(crypto->decryptkey);\n    }\n\n    cipher_free(crypto->in_cipher);\n    cipher_free(crypto->out_cipher);\n\n    for (i = 0; i < SSH_KEX_METHODS; i++) {\n        SAFE_FREE(crypto->client_kex.methods[i]);\n        SAFE_FREE(crypto->server_kex.methods[i]);\n        SAFE_FREE(crypto->kex_methods[i]);\n    }\n\n    explicit_bzero(crypto, sizeof(struct ssh_crypto_struct));\n\n    SAFE_FREE(crypto);\n}\n",
      "line_start": 160,
      "line_end": 232,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 172,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "This is a destructor/cleanup function that frees and zeroes fields of an ssh_crypto_struct. It does not parse or validate external input, has minimal control flow, and mostly calls free/cleanup helpers\u2014low value as a fuzz target."
    },
    {
      "name": "pki_key_clean",
      "clean_name": "pki_key_clean",
      "source_file": "/src/libssh/src/pki_crypto.c",
      "source_code": "    }\n\n    return 0;\n}\n\nvoid pki_key_clean(ssh_key key)\n{\n    if (key == NULL)\n        return;\n    EVP_PKEY_free(key->key);\n    key->key = NULL;\n}\n",
      "line_start": 94,
      "line_end": 101,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 8,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple cleanup function: checks for NULL, frees an EVP_PKEY and clears the pointer. No parsing of external input, no branching or complex logic, not a meaningful fuzz target."
    },
    {
      "name": "sha1_init",
      "clean_name": "sha1_init",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "#include <openssl/evp.h>\n#include <openssl/md5.h>\n#include <openssl/sha.h>\n\nSHACTX\nsha1_init(void)\n{\n    int rc;\n    SHACTX c = EVP_MD_CTX_new();\n    if (c == NULL) {\n        return NULL;\n    }\n    rc = EVP_DigestInit_ex(c, EVP_sha1(), NULL);\n    if (rc == 0) {\n        EVP_MD_CTX_free(c);\n        c = NULL;\n    }\n    return c;\n}\n",
      "line_start": 33,
      "line_end": 47,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input \u2014 simple allocator/initializer for a SHA1 context with only null checks and cleanup. Does not parse or process untrusted data, so not a useful fuzz target."
    },
    {
      "name": "sha1_ctx_free",
      "clean_name": "sha1_ctx_free",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return c;\n}\n\nvoid\nsha1_ctx_free(SHACTX c)\n{\n    EVP_MD_CTX_free(c);\n}\n",
      "line_start": 49,
      "line_end": 53,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial wrapper/destructor that frees an EVP_MD_CTX; no parsing or processing of external input, no branches or loops, and no security-critical logic\u2014unsuitable as a fuzz target."
    },
    {
      "name": "sha256_init",
      "clean_name": "sha256_init",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return sha1_final(hash, c);\n}\n\nSHA256CTX\nsha256_init(void)\n{\n    int rc;\n    SHA256CTX c = EVP_MD_CTX_new();\n    if (c == NULL) {\n        return NULL;\n    }\n    rc = EVP_DigestInit_ex(c, EVP_sha256(), NULL);\n    if (rc == 0) {\n        EVP_MD_CTX_free(c);\n        c = NULL;\n    }\n    return c;\n}\n",
      "line_start": 95,
      "line_end": 109,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple initializer wrapper that allocates and initializes an OpenSSL EVP_SHA256 context; takes no external input and has trivial control flow, so it is not a useful fuzz target."
    },
    {
      "name": "sha384_init",
      "clean_name": "sha384_init",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return sha256_final(hash, c);\n}\n\nSHA384CTX\nsha384_init(void)\n{\n    int rc;\n    SHA384CTX c = EVP_MD_CTX_new();\n    if (c == NULL) {\n        return NULL;\n    }\n    rc = EVP_DigestInit_ex(c, EVP_sha384(), NULL);\n    if (rc == 0) {\n        EVP_MD_CTX_free(c);\n        c = NULL;\n    }\n    return c;\n}\n",
      "line_start": 157,
      "line_end": 171,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Wrapper/initializer with no external input \u2014 just allocates and initializes an OpenSSL SHA-384 context. No parsing, no input-dependent logic or memory operations on untrusted data, so not a useful fuzz target."
    },
    {
      "name": "sha384_ctx_free",
      "clean_name": "sha384_ctx_free",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return c;\n}\n\nvoid\nsha384_ctx_free(SHA384CTX c)\n{\n    EVP_MD_CTX_free(c);\n}\n",
      "line_start": 173,
      "line_end": 177,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 1,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Simple wrapper/destructor that only calls EVP_MD_CTX_free on the provided context; no parsing, no input-dependent logic, and not suitable as a fuzz target."
    },
    {
      "name": "sha512_init",
      "clean_name": "sha512_init",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return sha384_final(hash, c);\n}\n\nSHA512CTX\nsha512_init(void)\n{\n    int rc = 0;\n    SHA512CTX c = EVP_MD_CTX_new();\n    if (c == NULL) {\n        return NULL;\n    }\n    rc = EVP_DigestInit_ex(c, EVP_sha512(), NULL);\n    if (rc == 0) {\n        EVP_MD_CTX_free(c);\n        c = NULL;\n    }\n    return c;\n}\n",
      "line_start": 219,
      "line_end": 233,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simple wrapper that allocates and initializes an OpenSSL SHA-512 context. No branching on untrusted data, memory ops on user data, or security-critical logic dependent on input \u2014 not a useful fuzz target."
    },
    {
      "name": "md5_init",
      "clean_name": "md5_init",
      "source_file": "/src/libssh/src/md_crypto.c",
      "source_code": "    }\n    return sha512_final(hash, c);\n}\n\nMD5CTX\nmd5_init(void)\n{\n    int rc;\n    MD5CTX c = EVP_MD_CTX_new();\n    if (c == NULL) {\n        return NULL;\n    }\n    rc = EVP_DigestInit_ex(c, EVP_md5(), NULL);\n    if (rc == 0) {\n        EVP_MD_CTX_free(c);\n        c = NULL;\n    }\n    return c;\n}\n",
      "line_start": 281,
      "line_end": 295,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 13,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing: simple allocator/initializer wrapper around OpenSSL EVP calls that creates and returns an MD5 context. No processing of untrusted data or complex logic, so not a useful fuzz target."
    },
    {
      "name": "ssh_auth_reply_success",
      "clean_name": "ssh_auth_reply_success",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " * @param partial Denotes if the authentication process was partially completed\n * (unsuccessful)\n *\n * @returns SSH_OK on success, otherwise SSH_ERROR\n */\nint ssh_auth_reply_success(ssh_session session, int partial)\n{\n    struct ssh_crypto_struct *crypto = NULL;\n    int r;\n\n    if (session == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (partial) {\n        return ssh_auth_reply_default(session, partial);\n    }\n\n    r = ssh_buffer_add_u8(session->out_buffer,SSH2_MSG_USERAUTH_SUCCESS);\n    if (r < 0) {\n        return SSH_ERROR;\n    }\n\n    r = ssh_packet_send(session);\n\n    /*\n     * Consider the session as having been authenticated only after sending\n     * the USERAUTH_SUCCESS message.  Setting these flags after ssh_packet_send\n     * ensures that a rekey is not triggered prematurely, causing the message\n     * to be queued.\n     */\n    session->session_state = SSH_SESSION_STATE_AUTHENTICATED;\n    session->flags |= SSH_SESSION_FLAG_AUTHENTICATED;\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_OUT);\n    if (crypto != NULL && crypto->delayed_compress_out) {\n        SSH_LOG(SSH_LOG_DEBUG, \"Enabling delayed compression OUT\");\n        crypto->do_compress_out = 1;\n    }\n\n    crypto = ssh_packet_get_current_crypto(session, SSH_DIRECTION_IN);\n    if (crypto != NULL && crypto->delayed_compress_in) {\n        SSH_LOG(SSH_LOG_DEBUG, \"Enabling delayed compression IN\");\n        crypto->do_compress_in = 1;\n    }\n    return r;\n}\n",
      "line_start": 1048,
      "line_end": 1090,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 53,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Does not parse or process external attacker-controlled input: it writes a fixed byte, sends a packet, and flips session flags. Minimal branching/logic and no untrusted memory operations \u2014 not a useful fuzz target."
    },
    {
      "name": "ssh_send_keepalive",
      "clean_name": "ssh_send_keepalive",
      "source_file": "/src/libssh/src/server.c",
      "source_code": " *\n * @param session   The session to send the message to\n *\n * @returns SSH_OK\n */\nint ssh_send_keepalive(ssh_session session)\n{\n    /* Client denies the request, so the error code is not meaningful */\n    (void)ssh_global_request(session, \"keepalive@openssh.com\", NULL, 1);\n\n    return SSH_OK;\n}\n",
      "line_start": 1293,
      "line_end": 1300,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 6,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Trivial wrapper: no parsing or processing of external data (passes a constant string and NULL), returns a constant. Not suitable as a fuzz target."
    },
    {
      "name": "_ssh_remove_legacy_log_cb",
      "clean_name": "_ssh_remove_legacy_log_cb",
      "source_file": "/src/libssh/src/callbacks.c",
      "source_code": "    (void)function; /* unused */\n\n    log_fn(session, priority, buffer, log_data);\n}\n\nvoid _ssh_remove_legacy_log_cb(void)\n{\n    if (ssh_get_log_callback() == ssh_legacy_log_callback) {\n        _ssh_reset_log_cb();\n        ssh_set_log_userdata(NULL);\n    }\n}\n",
      "line_start": 47,
      "line_end": 54,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 5,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simple internal logging housekeeping that checks and resets callbacks. Pure internal state management with trivial logic \u2014 not a useful fuzz target."
    },
    {
      "name": "compress_cleanup",
      "clean_name": "compress_cleanup",
      "source_file": "/src/libssh/src/gzip.c",
      "source_code": "    SSH_BUFFER_FREE(dest);\n    return 0;\n}\n\nvoid\ncompress_cleanup(struct ssh_crypto_struct *crypto)\n{\n    if (crypto->compress_out_ctx) {\n        deflateEnd(crypto->compress_out_ctx);\n    }\n    SAFE_FREE(crypto->compress_out_ctx);\n\n    if (crypto->compress_in_ctx) {\n        inflateEnd(crypto->compress_in_ctx);\n    }\n    SAFE_FREE(crypto->compress_in_ctx);\n}\n",
      "line_start": 266,
      "line_end": 278,
      "execution_count": 0,
      "covered_regions": 0,
      "total_regions": 24,
      "coverage_percent": 0.0,
      "is_covered": false,
      "is_static": false,
      "score": 0.0,
      "reason": "Cleanup function that releases compression contexts (deflateEnd/inflateEnd and frees memory). No external/untrusted input, no parsing or branching based on input\u2014internal resource cleanup only, not suitable as a fuzz target."
    },
    {
      "name": "libssh_constructor",
      "clean_name": "libssh_constructor",
      "source_file": "/src/libssh/src/init.c",
      "source_code": " * @brief Initialize global cryptographic data structures.\n *\n * This function is automatically called when the library is loaded.\n *\n */\nvoid libssh_constructor(void)\n{\n\n    int rc;\n\n    rc = _ssh_init(1);\n\n    if (rc < 0) {\n        fprintf(stderr, \"Error in auto_init()\\n\");\n    }\n\n    return;\n}\n",
      "line_start": 112,
      "line_end": 125,
      "execution_count": 8,
      "covered_regions": 2,
      "total_regions": 9,
      "coverage_percent": 22.22,
      "is_covered": true,
      "is_static": false,
      "score": 0.0,
      "reason": "No external input or parsing; simply calls internal _ssh_init(1) during library load and prints an error on failure. No branching on untrusted data or memory ops, so not suitable as a fuzz target."
    },
    {
      "name": "init.c:_ssh_finalize",
      "clean_name": "_ssh_finalize",
      "source_file": "/src/libssh/src/init.c",
      "source_code": " */\nint ssh_init(void) {\n    return _ssh_init(0);\n}\n\nstatic int _ssh_finalize(unsigned destructor) {\n\n    if (!destructor) {\n        ssh_mutex_lock(&ssh_init_mutex);\n\n        if (_ssh_initialized > 1) {\n            _ssh_initialized--;\n            ssh_mutex_unlock(&ssh_init_mutex);\n            return 0;\n        }\n\n        if (_ssh_initialized == 1) {\n            if (_ssh_init_ret < 0) {\n                ssh_mutex_unlock(&ssh_init_mutex);\n                return 0;\n            }\n        }\n    }\n\n    /* If the counter reaches zero or it is the destructor calling, finalize */\n    ssh_dh_finalize();\n    ssh_crypto_finalize();\n    ssh_socket_cleanup();\n    /* It is important to finalize threading after CRYPTO because\n     * it still depends on it */\n    ssh_threads_finalize();\n\n    _ssh_initialized = 0;\n\n    if (!destructor) {\n        ssh_mutex_unlock(&ssh_init_mutex);\n    }\n\n#if (defined(_WIN32) && !defined(HAVE_PTHREAD))\n    if (ssh_init_mutex != NULL) {\n        DeleteCriticalSection(ssh_init_mutex);\n        SAFE_FREE(ssh_init_mutex);\n    }\n#endif\n\n    return 0;\n}\n",
      "line_start": 159,
      "line_end": 201,
      "execution_count": 1,
      "covered_regions": 7,
      "total_regions": 29,
      "coverage_percent": 24.14,
      "is_covered": true,
      "is_static": true,
      "score": 0.0,
      "reason": "Teardown/finalizer routine with no parsing of external input or untrusted data, minimal branching and no memory/string operations on user-controlled data \u2014 not a suitable fuzz target."
    },
    {
      "name": "LLVMFuzzerInitialize",
      "clean_name": "LLVMFuzzerInitialize",
      "source_file": "/src/libssh/tests/fuzz/ssh_sshsig_fuzzer.c",
      "source_code": "static void _fuzz_finalize(void)\n{\n    ssh_finalize();\n}\n\nint LLVMFuzzerInitialize(int *argc, char ***argv)\n{\n    (void)argc;\n    (void)argv;\n\n    ssh_init();\n\n    atexit(_fuzz_finalize);\n\n    return 0;\n}\n",
      "line_start": 28,
      "line_end": 39,
      "execution_count": 1,
      "covered_regions": 1,
      "total_regions": 4,
      "coverage_percent": 25.0,
      "is_covered": true,
      "is_static": false,
      "score": 0.0,
      "reason": "Initialization function with no external input or parsing; it only calls ssh_init and registers ssh_finalize via atexit. No input-dependent logic, memory ops, or branching, so not a fuzz target."
    }
  ],
  "batch_id": "batch_692a7b5b69f081908fe3bcd59c51ad6b"
}